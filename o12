
 specfile :: synth_tests/eff12.specres : int;



c2 : State  {\(h : heap). sel (h, res) > 4} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == sel (h, res) + 10};


c2' : State  {\(h : heap). not (sel (h, res) > 20)} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == sel (h, res)};


bar : State  {\(h : heap). sel (h, res) == 5} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == sel (h, res) + 2};

foo : State  {\(h : heap). sel (h, res) == 0} 
	v : { v : int |  [v=5]} 
	{\(h : heap), (v : int), (h' : heap).  sel (h', res) == v /\ [v=5]};

foo' : State  {\(h : heap). not (sel (h, res) > 20)} 
	v : { v : int |  [v=20]} 
	{\(h : heap), (v : int), (h' : heap). sel (h', res) == v /\ [v=20]};



c4 : State  {\(h : heap). not (sel (h, res) > 30)} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == sel (h, res) + 6};


c41: State  {\(h : heap). (sel (h, res) == 6)} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == sel (h, res) + 4};


c5 : State  {\(h : heap). sel (h, res) == 7} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == sel (h, res) + 5};


baz : State  {\(h : heap). sel (h, res) == 7} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == sel (h, res) + 3};

c3' : State  {\(h : heap). not (sel (h, res) > 8)} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == sel (h, res) + 3};



goal : State  
        {\(h : heap). sel (h, res) == 0} 
		
		v : { v : int | true} 
		
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == 10};

var: res
whitespace colon
whitespace var: int
semicolon
var: c2
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace lessthanopwhitespace int: 4
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 10
rcurly
semicolon
var: c2'
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace notwhitespace lparen
var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace lessthanopwhitespace int: 20
rparen
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
rcurly
semicolon
var: bar
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 5
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 2
rcurly
semicolon
var: foo
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 0
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace lbrace
var: v
equalopint: 5
rbrace
rcurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace conjwhitespace lbrace
var: v
equalopint: 5
rbrace
rcurly
semicolon
var: foo'
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace notwhitespace lparen
var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace lessthanopwhitespace int: 20
rparen
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace lbrace
var: v
equalopint: 20
rbrace
rcurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace conjwhitespace lbrace
var: v
equalopint: 20
rbrace
rcurly
semicolon
var: c4
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace notwhitespace lparen
var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace lessthanopwhitespace int: 30
rparen
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 6
rcurly
semicolon
var: c41
colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace lparen
var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 6
rparen
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 4
rcurly
semicolon
var: c5
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 7
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 5
rcurly
semicolon
var: baz
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 7
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 3
rcurly
semicolon
var: c3'
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace notwhitespace lparen
var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace lessthanopwhitespace int: 8
rparen
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 3
rcurly
semicolon
var: goal
whitespace colon
whitespace var: State
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 0
rcurly
whitespace whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 10
rcurly
semicolon
RelSpec {  SRs ;  PRs ;  TSs  
 Assume false
 name res : 
 params :
 Type Base {var_v0:Ty_int | true} 
 Assume false
 name c2 : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 ) 
 Assume false
 name c2' : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) } 
 } 
 ) 
 Assume false
 name bar : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 ) 
 Assume false
 name foo : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 ) 
 Assume false
 name foo' : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 20} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 ) 
 Assume false
 name c4 : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (30) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (6)) } 
 } 
 ) 
 Assume false
 name c41 : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 ) 
 Assume false
 name c5 : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 ) 
 Assume false
 name baz : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 ) 
 Assume false
 name c3' : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (8) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 ) 
 Assume false
 name goal : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 );  Formulas  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
c3'
baz
c5
c41
c4
foo'
foo
bar
c2'
c2
 *********************Enumeration Iteration*****************0
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (8) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1 --->  Ty_heap  
 var__temp_v2 --->  Ty_int  
 var__temp_h'3 --->  Ty_heap  
 var__temp_v_err4 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h1, res ) > (8) AND 
 	 Rel (sel)( , var__temp_h1, res ) > (8) => 
 	 Rel (sel)( , var__temp_h'3, res ) ==((sel)( , var__temp_h1, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'3, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h1 T0)
(declare-const var__temp_v2 Int)
(declare-const |var__temp_h'3| T0)
(declare-const var__temp_v_err4 T1)
(declare-const err T14)

solver 
 (declare-sort T0)
(declare-fun sel (T0 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'3| () T0)
(declare-fun var__temp_h1 () T0)
(assert true)
(assert (let ((a!1 (=> (= (sel var__temp_h1 res) 0) (not (> (sel var__temp_h1 res) 8))))
      (a!2 (=> (= (sel |var__temp_h'3| res) (+ (sel var__temp_h1 res) 3))
               (= (sel |var__temp_h'3| res) 10))))
(let ((a!3 (=> (not (> (sel var__temp_h1 res) 8)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************c3'
 *********************Enumeration Iteration*****************1
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h5 --->  Ty_heap  
 var__temp_v6 --->  Ty_int  
 var__temp_h'7 --->  Ty_heap  
 var__temp_v_err8 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h5, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h5, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h5, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'7, res ) ==((sel)( , var__temp_h5, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'7, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h5 T17)
(declare-const var__temp_v6 Int)
(declare-const |var__temp_h'7| T17)
(declare-const var__temp_v_err8 T18)
(declare-const err T31)

solver 
 (declare-sort T17)
(declare-fun sel (T17 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'7| () T17)
(declare-fun var__temp_h5 () T17)
(assert true)
(assert (let ((a!1 (=> (= (sel |var__temp_h'7| res) (+ (sel var__temp_h5 res) 3))
               (= (sel |var__temp_h'7| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h5 res) 0) (= (sel var__temp_h5 res) 7))
                (=> (= (sel var__temp_h5 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************2
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h9 --->  Ty_heap  
 var__temp_v10 --->  Ty_int  
 var__temp_h'11 --->  Ty_heap  
 var__temp_v_err12 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h9, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h9, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h9, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'11, res ) ==((sel)( , var__temp_h9, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'11, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h9 T34)
(declare-const var__temp_v10 Int)
(declare-const |var__temp_h'11| T34)
(declare-const var__temp_v_err12 T35)
(declare-const err T48)

solver 
 (declare-sort T34)
(declare-fun sel (T34 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'11| () T34)
(declare-fun var__temp_h9 () T34)
(assert true)
(assert (let ((a!1 (=> (= (sel |var__temp_h'11| res) (+ (sel var__temp_h9 res) 5))
               (= (sel |var__temp_h'11| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h9 res) 0) (= (sel var__temp_h9 res) 7))
                (=> (= (sel var__temp_h9 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************3
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h13 --->  Ty_heap  
 var__temp_v14 --->  Ty_int  
 var__temp_h'15 --->  Ty_heap  
 var__temp_v_err16 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h13, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h13, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h13, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'15, res ) ==((sel)( , var__temp_h13, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'15, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h13 T51)
(declare-const var__temp_v14 Int)
(declare-const |var__temp_h'15| T51)
(declare-const var__temp_v_err16 T52)
(declare-const err T65)

solver 
 (declare-sort T51)
(declare-fun sel (T51 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'15| () T51)
(declare-fun var__temp_h13 () T51)
(assert true)
(assert (let ((a!1 (=> (= (sel |var__temp_h'15| res) (+ (sel var__temp_h13 res) 4))
               (= (sel |var__temp_h'15| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h13 res) 0) (= (sel var__temp_h13 res) 6))
                (=> (= (sel var__temp_h13 res) 6) a!1))))
  (not a!2))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************4
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (30) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (6)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (6)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h17 --->  Ty_heap  
 var__temp_v18 --->  Ty_int  
 var__temp_h'19 --->  Ty_heap  
 var__temp_v_err20 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h17, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h17, res ) > (30) AND 
 	 Rel (sel)( , var__temp_h17, res ) > (30) => 
 	 Rel (sel)( , var__temp_h'19, res ) ==((sel)( , var__temp_h17, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h'19, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h17 T68)
(declare-const var__temp_v18 Int)
(declare-const |var__temp_h'19| T68)
(declare-const var__temp_v_err20 T69)
(declare-const err T82)

solver 
 (declare-sort T68)
(declare-fun sel (T68 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'19| () T68)
(declare-fun var__temp_h17 () T68)
(assert true)
(assert (let ((a!1 (=> (= (sel var__temp_h17 res) 0)
               (not (> (sel var__temp_h17 res) 30))))
      (a!2 (=> (= (sel |var__temp_h'19| res) (+ (sel var__temp_h17 res) 6))
               (= (sel |var__temp_h'19| res) 10))))
(let ((a!3 (=> (not (> (sel var__temp_h17 res) 30)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************5
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 20} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h21 --->  Ty_heap  
 var__temp_v22 --->  Ty_int  
 var__temp_h'23 --->  Ty_heap  
 var__temp_v_err24 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h21, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h21, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h21, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'23, res ) ==(var__temp_v22) AND 
 	 Base var__temp_v22 = 20 => 
 	 Rel (sel)( , var__temp_h'23, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h21 T85)
(declare-const var__temp_v22 Int)
(declare-const |var__temp_h'23| T85)
(declare-const var__temp_v_err24 T86)
(declare-const err T99)
    (declare-const |20| Int)
  
solver 
 (declare-sort T85)
(declare-fun |20| () Int)
(declare-fun sel (T85 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'23| () T85)
(declare-fun var__temp_v22 () Int)
(declare-fun var__temp_h21 () T85)
(assert true)
(assert (= |20| 20))
(assert (let ((a!1 (=> (= (sel var__temp_h21 res) 0)
               (not (> (sel var__temp_h21 res) 20))))
      (a!2 (=> (and (= (sel |var__temp_h'23| res) var__temp_v22)
                    (= var__temp_v22 |20|))
               (= (sel |var__temp_h'23| res) 10))))
(let ((a!3 (=> (not (> (sel var__temp_h21 res) 20)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************foo'
 *********************Enumeration Iteration*****************6
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h25 --->  Ty_heap  
 var__temp_v26 --->  Ty_int  
 var__temp_h'27 --->  Ty_heap  
 var__temp_v_err28 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h25, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h25, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h25, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'27, res ) ==(var__temp_v26) AND 
 	 Base var__temp_v26 = 5 => 
 	 Rel (sel)( , var__temp_h'27, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h25 T102)
(declare-const var__temp_v26 Int)
(declare-const |var__temp_h'27| T102)
(declare-const var__temp_v_err28 T103)
(declare-const err T116)
    (declare-const |5| Int)
  
solver 
 (declare-sort T102)
(declare-fun |5| () Int)
(declare-fun sel (T102 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'27| () T102)
(declare-fun var__temp_v26 () Int)
(declare-fun var__temp_h25 () T102)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel |var__temp_h'27| res) var__temp_v26)
                    (= var__temp_v26 |5|))
               (= (sel |var__temp_h'27| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h25 res) 0) (= (sel var__temp_h25 res) 0))
                (=> (= (sel var__temp_h25 res) 0) a!1))))
  (not a!2))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************7
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h29 --->  Ty_heap  
 var__temp_v30 --->  Ty_int  
 var__temp_h'31 --->  Ty_heap  
 var__temp_v_err32 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h29, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h29, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h29, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'31, res ) ==((sel)( , var__temp_h29, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'31, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h29 T119)
(declare-const var__temp_v30 Int)
(declare-const |var__temp_h'31| T119)
(declare-const var__temp_v_err32 T120)
(declare-const err T133)

solver 
 (declare-sort T119)
(declare-fun sel (T119 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'31| () T119)
(declare-fun var__temp_h29 () T119)
(assert true)
(assert (let ((a!1 (=> (= (sel |var__temp_h'31| res) (+ (sel var__temp_h29 res) 2))
               (= (sel |var__temp_h'31| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h29 res) 0) (= (sel var__temp_h29 res) 5))
                (=> (= (sel var__temp_h29 res) 5) a!1))))
  (not a!2))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************8
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h33 --->  Ty_heap  
 var__temp_v34 --->  Ty_int  
 var__temp_h'35 --->  Ty_heap  
 var__temp_v_err36 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h33, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h33, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h33, res ) > (20) => 
 	 Rel (sel)( , var__temp_h'35, res ) ==(sel)( , var__temp_h33, res ) => 
 	 Rel (sel)( , var__temp_h'35, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h33 T136)
(declare-const var__temp_v34 Int)
(declare-const |var__temp_h'35| T136)
(declare-const var__temp_v_err36 T137)
(declare-const err T150)

solver 
 (declare-sort T136)
(declare-fun sel (T136 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'35| () T136)
(declare-fun var__temp_h33 () T136)
(assert true)
(assert (let ((a!1 (=> (= (sel var__temp_h33 res) 0)
               (not (> (sel var__temp_h33 res) 20))))
      (a!2 (=> (not (> (sel var__temp_h33 res) 20))
               (=> (= (sel |var__temp_h'35| res) (sel var__temp_h33 res))
                   (= (sel |var__temp_h'35| res) 10)))))
  (not (and a!1 a!2))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************9
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h37 --->  Ty_heap  
 var__temp_v38 --->  Ty_int  
 var__temp_h'39 --->  Ty_heap  
 var__temp_v_err40 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h37, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h37, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h37, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'39, res ) ==((sel)( , var__temp_h37, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h'39, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h37 T153)
(declare-const var__temp_v38 Int)
(declare-const |var__temp_h'39| T153)
(declare-const var__temp_v_err40 T154)
(declare-const err T167)

solver 
 (declare-sort T153)
(declare-fun sel (T153 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'39| () T153)
(declare-fun var__temp_h37 () T153)
(assert true)
(assert (let ((a!1 (=> (= (sel |var__temp_h'39| res) (+ (sel var__temp_h37 res) 10))
               (= (sel |var__temp_h'39| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h37 res) 0) (> (sel var__temp_h37 res) 4))
                (=> (> (sel var__temp_h37 res) 4) a!1))))
  (not a!2))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************10
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {v:Ty_int | true}
isynthesizeConstApp
Spec Base {v:Ty_int | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Terms
esynthesizeBind
PARTIAL PATH
SUB 
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {var_v41:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c3'
baz
c5
c41
c4
foo'
foo
bar
c2'
c2
 *********************Enumeration Iteration*****************11
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (8) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {var_v41:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h42 --->  Ty_heap  
 var__temp_v43 --->  Ty_int  
 var__temp_h'44 --->  Ty_heap  
 var__temp_v_err45 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h42, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h42, res ) > (8) AND 
 	 Rel (sel)( , var__temp_h42, res ) > (8) => 
 	 Rel (sel)( , var__temp_h'44, res ) ==((sel)( , var__temp_h42, res ) + (3)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h42 T170)
(declare-const var__temp_v43 Int)
(declare-const |var__temp_h'44| T170)
(declare-const var__temp_v_err45 T171)
(declare-const err T184)

solver 
 (declare-sort T170)
(declare-fun sel (T170 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h42 () T170)
(declare-fun |var__temp_h'44| () T170)
(assert true)
(assert (let ((a!1 (=> (= (sel var__temp_h42 res) 0)
               (not (> (sel var__temp_h42 res) 8))))
      (a!2 (=> (= (sel |var__temp_h'44| res) (+ (sel var__temp_h42 res) 3))
               true)))
(let ((a!3 (=> (not (> (sel var__temp_h42 res) 8)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Successful************c3'
PARTIAL PATH NEW
NEW 	 --c3'
post_substituted Forall 
 	 
 Key =var_h_i47 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v48:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i47 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
c4
foo'
foo
bar
c2'
c2
 *********************Enumeration Iteration*****************12
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v48:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i47 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h49 --->  Ty_heap  
 var__temp_v50 --->  Ty_int  
 var__temp_h'51 --->  Ty_heap  
 var__temp_v_err52 --->  error  
 var_h46 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h49, res ) ==((sel)( , var_h46, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h49, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h49, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'51, res ) ==((sel)( , var__temp_h49, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'51, res ) ==(10)
 
VC_END(declare-const var_h_i47 T187)
(declare-const var_h46 T187)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h49 T187)
(declare-const var__temp_v50 Int)
(declare-const |var__temp_h'51| T187)
(declare-const var__temp_v_err52 T188)
(declare-const var_h46 T187)
(declare-const err T201)

solver 
 (declare-sort T187)
(declare-fun sel (T187 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T187)
(declare-fun |var__temp_h'51| () T187)
(declare-fun var__temp_h49 () T187)
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h49 res) (+ (sel var_h46 res) 3))
               (= (sel var__temp_h49 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'51| res) (+ (sel var__temp_h49 res) 3))
               (= (sel |var__temp_h'51| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h49 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************13
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v48:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i47 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h53 --->  Ty_heap  
 var__temp_v54 --->  Ty_int  
 var__temp_h'55 --->  Ty_heap  
 var__temp_v_err56 --->  error  
 var_h46 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h53, res ) ==((sel)( , var_h46, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h53, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h53, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'55, res ) ==((sel)( , var__temp_h53, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'55, res ) ==(10)
 
VC_END(declare-const var_h_i47 T204)
(declare-const var_h46 T204)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h53 T204)
(declare-const var__temp_v54 Int)
(declare-const |var__temp_h'55| T204)
(declare-const var__temp_v_err56 T205)
(declare-const var_h46 T204)
(declare-const err T218)

solver 
 (declare-sort T204)
(declare-fun sel (T204 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T204)
(declare-fun |var__temp_h'55| () T204)
(declare-fun var__temp_h53 () T204)
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h53 res) (+ (sel var_h46 res) 3))
               (= (sel var__temp_h53 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'55| res) (+ (sel var__temp_h53 res) 5))
               (= (sel |var__temp_h'55| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h53 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************14
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v48:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i47 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h57 --->  Ty_heap  
 var__temp_v58 --->  Ty_int  
 var__temp_h'59 --->  Ty_heap  
 var__temp_v_err60 --->  error  
 var_h46 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h57, res ) ==((sel)( , var_h46, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h57, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h57, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'59, res ) ==((sel)( , var__temp_h57, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'59, res ) ==(10)
 
VC_END(declare-const var_h_i47 T221)
(declare-const var_h46 T221)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h57 T221)
(declare-const var__temp_v58 Int)
(declare-const |var__temp_h'59| T221)
(declare-const var__temp_v_err60 T222)
(declare-const var_h46 T221)
(declare-const err T235)

solver 
 (declare-sort T221)
(declare-fun sel (T221 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T221)
(declare-fun |var__temp_h'59| () T221)
(declare-fun var__temp_h57 () T221)
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h57 res) (+ (sel var_h46 res) 3))
               (= (sel var__temp_h57 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'59| res) (+ (sel var__temp_h57 res) 4))
               (= (sel |var__temp_h'59| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h57 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************15
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (30) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (6)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v48:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i47 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (6)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h61 --->  Ty_heap  
 var__temp_v62 --->  Ty_int  
 var__temp_h'63 --->  Ty_heap  
 var__temp_v_err64 --->  error  
 var_h46 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h61, res ) ==((sel)( , var_h46, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h61, res ) > (30) AND 
 	 Rel (sel)( , var__temp_h61, res ) > (30) => 
 	 Rel (sel)( , var__temp_h'63, res ) ==((sel)( , var__temp_h61, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h'63, res ) ==(10)
 
VC_END(declare-const var_h_i47 T238)
(declare-const var_h46 T238)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h61 T238)
(declare-const var__temp_v62 Int)
(declare-const |var__temp_h'63| T238)
(declare-const var__temp_v_err64 T239)
(declare-const var_h46 T238)
(declare-const err T252)

solver 
 (declare-sort T238)
(declare-fun sel (T238 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T238)
(declare-fun |var__temp_h'63| () T238)
(declare-fun var__temp_h61 () T238)
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h61 res) (+ (sel var_h46 res) 3))
               (not (> (sel var__temp_h61 res) 30))))
      (a!2 (=> (= (sel |var__temp_h'63| res) (+ (sel var__temp_h61 res) 6))
               (= (sel |var__temp_h'63| res) 10))))
(let ((a!3 (=> (not (> (sel var__temp_h61 res) 30)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************16
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 20} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v48:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i47 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h65 --->  Ty_heap  
 var__temp_v66 --->  Ty_int  
 var__temp_h'67 --->  Ty_heap  
 var__temp_v_err68 --->  error  
 var_h46 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h65, res ) ==((sel)( , var_h46, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h65, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h65, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'67, res ) ==(var__temp_v66) AND 
 	 Base var__temp_v66 = 20 => 
 	 Rel (sel)( , var__temp_h'67, res ) ==(10)
 
VC_END(declare-const var_h_i47 T255)
(declare-const var_h46 T255)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h65 T255)
(declare-const var__temp_v66 Int)
(declare-const |var__temp_h'67| T255)
(declare-const var__temp_v_err68 T256)
(declare-const var_h46 T255)
(declare-const err T269)
    (declare-const |20| Int)
  
solver 
 (declare-sort T255)
(declare-fun sel (T255 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T255)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'67| () T255)
(declare-fun var__temp_v66 () Int)
(declare-fun var__temp_h65 () T255)
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (= (sel var__temp_h65 res) (+ (sel var_h46 res) 3))
               (not (> (sel var__temp_h65 res) 20))))
      (a!2 (=> (and (= (sel |var__temp_h'67| res) var__temp_v66)
                    (= var__temp_v66 |20|))
               (= (sel |var__temp_h'67| res) 10))))
(let ((a!3 (=> (not (> (sel var__temp_h65 res) 20)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************foo'
 *********************Enumeration Iteration*****************17
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v48:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i47 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h69 --->  Ty_heap  
 var__temp_v70 --->  Ty_int  
 var__temp_h'71 --->  Ty_heap  
 var__temp_v_err72 --->  error  
 var_h46 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h69, res ) ==((sel)( , var_h46, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h69, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h69, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'71, res ) ==(var__temp_v70) AND 
 	 Base var__temp_v70 = 5 => 
 	 Rel (sel)( , var__temp_h'71, res ) ==(10)
 
VC_END(declare-const var_h_i47 T272)
(declare-const var_h46 T272)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h69 T272)
(declare-const var__temp_v70 Int)
(declare-const |var__temp_h'71| T272)
(declare-const var__temp_v_err72 T273)
(declare-const var_h46 T272)
(declare-const err T286)
    (declare-const |5| Int)
  
solver 
 (declare-sort T272)
(declare-fun sel (T272 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T272)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'71| () T272)
(declare-fun var__temp_v70 () Int)
(declare-fun var__temp_h69 () T272)
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h69 res) (+ (sel var_h46 res) 3))
               (= (sel var__temp_h69 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'71| res) var__temp_v70)
                    (= var__temp_v70 |5|))
               (= (sel |var__temp_h'71| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h69 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************18
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v48:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i47 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h73 --->  Ty_heap  
 var__temp_v74 --->  Ty_int  
 var__temp_h'75 --->  Ty_heap  
 var__temp_v_err76 --->  error  
 var_h46 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h73, res ) ==((sel)( , var_h46, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h73, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h73, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'75, res ) ==((sel)( , var__temp_h73, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'75, res ) ==(10)
 
VC_END(declare-const var_h_i47 T289)
(declare-const var_h46 T289)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h73 T289)
(declare-const var__temp_v74 Int)
(declare-const |var__temp_h'75| T289)
(declare-const var__temp_v_err76 T290)
(declare-const var_h46 T289)
(declare-const err T303)

solver 
 (declare-sort T289)
(declare-fun sel (T289 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T289)
(declare-fun |var__temp_h'75| () T289)
(declare-fun var__temp_h73 () T289)
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h73 res) (+ (sel var_h46 res) 3))
               (= (sel var__temp_h73 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'75| res) (+ (sel var__temp_h73 res) 2))
               (= (sel |var__temp_h'75| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h73 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************19
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v48:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i47 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h77 --->  Ty_heap  
 var__temp_v78 --->  Ty_int  
 var__temp_h'79 --->  Ty_heap  
 var__temp_v_err80 --->  error  
 var_h46 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h77, res ) ==((sel)( , var_h46, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h77, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h77, res ) > (20) => 
 	 Rel (sel)( , var__temp_h'79, res ) ==(sel)( , var__temp_h77, res ) => 
 	 Rel (sel)( , var__temp_h'79, res ) ==(10)
 
VC_END(declare-const var_h_i47 T306)
(declare-const var_h46 T306)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h77 T306)
(declare-const var__temp_v78 Int)
(declare-const |var__temp_h'79| T306)
(declare-const var__temp_v_err80 T307)
(declare-const var_h46 T306)
(declare-const err T320)

solver 
 (declare-sort T306)
(declare-fun sel (T306 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T306)
(declare-fun |var__temp_h'79| () T306)
(declare-fun var__temp_h77 () T306)
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h77 res) (+ (sel var_h46 res) 3))
               (not (> (sel var__temp_h77 res) 20))))
      (a!2 (=> (not (> (sel var__temp_h77 res) 20))
               (=> (= (sel |var__temp_h'79| res) (sel var__temp_h77 res))
                   (= (sel |var__temp_h'79| res) 10)))))
  (not (and a!1 a!2))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************20
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v48:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i47 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h81 --->  Ty_heap  
 var__temp_v82 --->  Ty_int  
 var__temp_h'83 --->  Ty_heap  
 var__temp_v_err84 --->  error  
 var_h46 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h81, res ) ==((sel)( , var_h46, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h81, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h81, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'83, res ) ==((sel)( , var__temp_h81, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h'83, res ) ==(10)
 
VC_END(declare-const var_h_i47 T323)
(declare-const var_h46 T323)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h81 T323)
(declare-const var__temp_v82 Int)
(declare-const |var__temp_h'83| T323)
(declare-const var__temp_v_err84 T324)
(declare-const var_h46 T323)
(declare-const err T337)

solver 
 (declare-sort T323)
(declare-fun sel (T323 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T323)
(declare-fun |var__temp_h'83| () T323)
(declare-fun var__temp_h81 () T323)
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h81 res) (+ (sel var_h46 res) 3))
               (> (sel var__temp_h81 res) 4)))
      (a!2 (=> (= (sel |var__temp_h'83| res) (+ (sel var__temp_h81 res) 10))
               (= (sel |var__temp_h'83| res) 10))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h81 res) 4) a!2))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************21
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v48:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v48:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v85:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
c4
foo'
foo
bar
c2'
c2
 *********************Enumeration Iteration*****************22
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v85:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h86 --->  Ty_heap  
 var__temp_v87 --->  Ty_int  
 var__temp_h'88 --->  Ty_heap  
 var__temp_v_err89 --->  error  
 var_h46 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h86, res ) ==((sel)( , var_h46, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h86, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h86, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'88, res ) ==((sel)( , var__temp_h86, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i47 T340)
(declare-const var_h46 T340)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h86 T340)
(declare-const var__temp_v87 Int)
(declare-const |var__temp_h'88| T340)
(declare-const var__temp_v_err89 T341)
(declare-const var_h46 T340)
(declare-const err T354)

solver 
 (declare-sort T340)
(declare-fun sel (T340 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T340)
(declare-fun var__temp_h86 () T340)
(declare-fun |var__temp_h'88| () T340)
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h86 res) (+ (sel var_h46 res) 3))
               (= (sel var__temp_h86 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'88| res) (+ (sel var__temp_h86 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h86 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************23
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v85:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h90 --->  Ty_heap  
 var__temp_v91 --->  Ty_int  
 var__temp_h'92 --->  Ty_heap  
 var__temp_v_err93 --->  error  
 var_h46 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h90, res ) ==((sel)( , var_h46, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h90, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h90, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'92, res ) ==((sel)( , var__temp_h90, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i47 T357)
(declare-const var_h46 T357)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h90 T357)
(declare-const var__temp_v91 Int)
(declare-const |var__temp_h'92| T357)
(declare-const var__temp_v_err93 T358)
(declare-const var_h46 T357)
(declare-const err T371)

solver 
 (declare-sort T357)
(declare-fun sel (T357 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T357)
(declare-fun var__temp_h90 () T357)
(declare-fun |var__temp_h'92| () T357)
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h90 res) (+ (sel var_h46 res) 3))
               (= (sel var__temp_h90 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'92| res) (+ (sel var__temp_h90 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h90 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************24
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v85:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h94 --->  Ty_heap  
 var__temp_v95 --->  Ty_int  
 var__temp_h'96 --->  Ty_heap  
 var__temp_v_err97 --->  error  
 var_h46 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h94, res ) ==((sel)( , var_h46, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h94, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h94, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'96, res ) ==((sel)( , var__temp_h94, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i47 T374)
(declare-const var_h46 T374)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h94 T374)
(declare-const var__temp_v95 Int)
(declare-const |var__temp_h'96| T374)
(declare-const var__temp_v_err97 T375)
(declare-const var_h46 T374)
(declare-const err T388)

solver 
 (declare-sort T374)
(declare-fun sel (T374 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T374)
(declare-fun var__temp_h94 () T374)
(declare-fun |var__temp_h'96| () T374)
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h94 res) (+ (sel var_h46 res) 3))
               (= (sel var__temp_h94 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'96| res) (+ (sel var__temp_h94 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h94 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************25
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (30) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (6)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v85:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (6)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h98 --->  Ty_heap  
 var__temp_v99 --->  Ty_int  
 var__temp_h'100 --->  Ty_heap  
 var__temp_v_err101 --->  error  
 var_h46 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h98, res ) ==((sel)( , var_h46, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h98, res ) > (30) AND 
 	 Rel (sel)( , var__temp_h98, res ) > (30) => 
 	 Rel (sel)( , var__temp_h'100, res ) ==((sel)( , var__temp_h98, res ) + (6)) => 
 	 True
 
VC_END(declare-const var_h_i47 T391)
(declare-const var_h46 T391)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h98 T391)
(declare-const var__temp_v99 Int)
(declare-const |var__temp_h'100| T391)
(declare-const var__temp_v_err101 T392)
(declare-const var_h46 T391)
(declare-const err T405)

solver 
 (declare-sort T391)
(declare-fun sel (T391 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T391)
(declare-fun var__temp_h98 () T391)
(declare-fun |var__temp_h'100| () T391)
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h98 res) (+ (sel var_h46 res) 3))
               (not (> (sel var__temp_h98 res) 30))))
      (a!2 (=> (= (sel |var__temp_h'100| res) (+ (sel var__temp_h98 res) 6))
               true)))
(let ((a!3 (=> (not (> (sel var__temp_h98 res) 30)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Successful************c4
PARTIAL PATH NEW
NEW 	 --c3'	 --c4
post_substituted Forall 
 	 
 Key =var_h_i103 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v104:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i103 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo'
foo
bar
c2'
c2
 *********************Enumeration Iteration*****************26
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v104:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i103 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h105 --->  Ty_heap  
 var__temp_v106 --->  Ty_int  
 var__temp_h'107 --->  Ty_heap  
 var__temp_v_err108 --->  error  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h105, res ) ==((sel)( , var_h102, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h105, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h105, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'107, res ) ==((sel)( , var__temp_h105, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'107, res ) ==(10)
 
VC_END(declare-const var_h_i103 T408)
(declare-const var_h102 T408)
(declare-const v Int)
(declare-const var_h_i47 T408)
(declare-const var_h46 T408)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h105 T408)
(declare-const var__temp_v106 Int)
(declare-const |var__temp_h'107| T408)
(declare-const var__temp_v_err108 T409)
(declare-const var_h102 T408)
(declare-const var_h46 T408)
(declare-const err T422)

solver 
 (declare-sort T408)
(declare-fun sel (T408 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T408)
(declare-fun var_h102 () T408)
(declare-fun |var__temp_h'107| () T408)
(declare-fun var__temp_h105 () T408)
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h105 res) (+ (sel var_h102 res) 6))
               (= (sel var__temp_h105 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'107| res) (+ (sel var__temp_h105 res) 3))
               (= (sel |var__temp_h'107| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h105 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************27
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v104:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i103 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h109 --->  Ty_heap  
 var__temp_v110 --->  Ty_int  
 var__temp_h'111 --->  Ty_heap  
 var__temp_v_err112 --->  error  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h109, res ) ==((sel)( , var_h102, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h109, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h109, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'111, res ) ==((sel)( , var__temp_h109, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'111, res ) ==(10)
 
VC_END(declare-const var_h_i103 T425)
(declare-const var_h102 T425)
(declare-const v Int)
(declare-const var_h_i47 T425)
(declare-const var_h46 T425)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h109 T425)
(declare-const var__temp_v110 Int)
(declare-const |var__temp_h'111| T425)
(declare-const var__temp_v_err112 T426)
(declare-const var_h102 T425)
(declare-const var_h46 T425)
(declare-const err T439)

solver 
 (declare-sort T425)
(declare-fun sel (T425 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T425)
(declare-fun var_h102 () T425)
(declare-fun |var__temp_h'111| () T425)
(declare-fun var__temp_h109 () T425)
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h109 res) (+ (sel var_h102 res) 6))
               (= (sel var__temp_h109 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'111| res) (+ (sel var__temp_h109 res) 5))
               (= (sel |var__temp_h'111| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h109 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************28
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v104:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i103 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h113 --->  Ty_heap  
 var__temp_v114 --->  Ty_int  
 var__temp_h'115 --->  Ty_heap  
 var__temp_v_err116 --->  error  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h113, res ) ==((sel)( , var_h102, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h113, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h113, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'115, res ) ==((sel)( , var__temp_h113, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'115, res ) ==(10)
 
VC_END(declare-const var_h_i103 T442)
(declare-const var_h102 T442)
(declare-const v Int)
(declare-const var_h_i47 T442)
(declare-const var_h46 T442)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h113 T442)
(declare-const var__temp_v114 Int)
(declare-const |var__temp_h'115| T442)
(declare-const var__temp_v_err116 T443)
(declare-const var_h102 T442)
(declare-const var_h46 T442)
(declare-const err T456)

solver 
 (declare-sort T442)
(declare-fun sel (T442 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T442)
(declare-fun var_h102 () T442)
(declare-fun |var__temp_h'115| () T442)
(declare-fun var__temp_h113 () T442)
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h113 res) (+ (sel var_h102 res) 6))
               (= (sel var__temp_h113 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'115| res) (+ (sel var__temp_h113 res) 4))
               (= (sel |var__temp_h'115| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h113 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************29
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 20} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v104:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i103 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h117 --->  Ty_heap  
 var__temp_v118 --->  Ty_int  
 var__temp_h'119 --->  Ty_heap  
 var__temp_v_err120 --->  error  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h117, res ) ==((sel)( , var_h102, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h117, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h117, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'119, res ) ==(var__temp_v118) AND 
 	 Base var__temp_v118 = 20 => 
 	 Rel (sel)( , var__temp_h'119, res ) ==(10)
 
VC_END(declare-const var_h_i103 T459)
(declare-const var_h102 T459)
(declare-const v Int)
(declare-const var_h_i47 T459)
(declare-const var_h46 T459)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h117 T459)
(declare-const var__temp_v118 Int)
(declare-const |var__temp_h'119| T459)
(declare-const var__temp_v_err120 T460)
(declare-const var_h102 T459)
(declare-const var_h46 T459)
(declare-const err T473)
    (declare-const |20| Int)
  
solver 
 (declare-sort T459)
(declare-fun sel (T459 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T459)
(declare-fun var_h102 () T459)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'119| () T459)
(declare-fun var__temp_v118 () Int)
(declare-fun var__temp_h117 () T459)
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (= (sel var__temp_h117 res) (+ (sel var_h102 res) 6))
               (not (> (sel var__temp_h117 res) 20))))
      (a!2 (=> (and (= (sel |var__temp_h'119| res) var__temp_v118)
                    (= var__temp_v118 |20|))
               (= (sel |var__temp_h'119| res) 10))))
(let ((a!3 (=> (not (> (sel var__temp_h117 res) 20)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************foo'
 *********************Enumeration Iteration*****************30
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v104:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i103 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h121 --->  Ty_heap  
 var__temp_v122 --->  Ty_int  
 var__temp_h'123 --->  Ty_heap  
 var__temp_v_err124 --->  error  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h121, res ) ==((sel)( , var_h102, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h121, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h121, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'123, res ) ==(var__temp_v122) AND 
 	 Base var__temp_v122 = 5 => 
 	 Rel (sel)( , var__temp_h'123, res ) ==(10)
 
VC_END(declare-const var_h_i103 T476)
(declare-const var_h102 T476)
(declare-const v Int)
(declare-const var_h_i47 T476)
(declare-const var_h46 T476)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h121 T476)
(declare-const var__temp_v122 Int)
(declare-const |var__temp_h'123| T476)
(declare-const var__temp_v_err124 T477)
(declare-const var_h102 T476)
(declare-const var_h46 T476)
(declare-const err T490)
    (declare-const |5| Int)
  
solver 
 (declare-sort T476)
(declare-fun sel (T476 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T476)
(declare-fun var_h102 () T476)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'123| () T476)
(declare-fun var__temp_v122 () Int)
(declare-fun var__temp_h121 () T476)
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h121 res) (+ (sel var_h102 res) 6))
               (= (sel var__temp_h121 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'123| res) var__temp_v122)
                    (= var__temp_v122 |5|))
               (= (sel |var__temp_h'123| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h121 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************31
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v104:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i103 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h125 --->  Ty_heap  
 var__temp_v126 --->  Ty_int  
 var__temp_h'127 --->  Ty_heap  
 var__temp_v_err128 --->  error  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h125, res ) ==((sel)( , var_h102, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h125, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h125, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'127, res ) ==((sel)( , var__temp_h125, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'127, res ) ==(10)
 
VC_END(declare-const var_h_i103 T493)
(declare-const var_h102 T493)
(declare-const v Int)
(declare-const var_h_i47 T493)
(declare-const var_h46 T493)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h125 T493)
(declare-const var__temp_v126 Int)
(declare-const |var__temp_h'127| T493)
(declare-const var__temp_v_err128 T494)
(declare-const var_h102 T493)
(declare-const var_h46 T493)
(declare-const err T507)

solver 
 (declare-sort T493)
(declare-fun sel (T493 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T493)
(declare-fun var_h102 () T493)
(declare-fun |var__temp_h'127| () T493)
(declare-fun var__temp_h125 () T493)
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h125 res) (+ (sel var_h102 res) 6))
               (= (sel var__temp_h125 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'127| res) (+ (sel var__temp_h125 res) 2))
               (= (sel |var__temp_h'127| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h125 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************32
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v104:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i103 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h129 --->  Ty_heap  
 var__temp_v130 --->  Ty_int  
 var__temp_h'131 --->  Ty_heap  
 var__temp_v_err132 --->  error  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h129, res ) ==((sel)( , var_h102, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h129, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h129, res ) > (20) => 
 	 Rel (sel)( , var__temp_h'131, res ) ==(sel)( , var__temp_h129, res ) => 
 	 Rel (sel)( , var__temp_h'131, res ) ==(10)
 
VC_END(declare-const var_h_i103 T510)
(declare-const var_h102 T510)
(declare-const v Int)
(declare-const var_h_i47 T510)
(declare-const var_h46 T510)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h129 T510)
(declare-const var__temp_v130 Int)
(declare-const |var__temp_h'131| T510)
(declare-const var__temp_v_err132 T511)
(declare-const var_h102 T510)
(declare-const var_h46 T510)
(declare-const err T524)

solver 
 (declare-sort T510)
(declare-fun sel (T510 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T510)
(declare-fun var_h102 () T510)
(declare-fun |var__temp_h'131| () T510)
(declare-fun var__temp_h129 () T510)
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h129 res) (+ (sel var_h102 res) 6))
               (not (> (sel var__temp_h129 res) 20))))
      (a!2 (=> (not (> (sel var__temp_h129 res) 20))
               (=> (= (sel |var__temp_h'131| res) (sel var__temp_h129 res))
                   (= (sel |var__temp_h'131| res) 10)))))
  (not (and a!1 a!2))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************33
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v104:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i103 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h133 --->  Ty_heap  
 var__temp_v134 --->  Ty_int  
 var__temp_h'135 --->  Ty_heap  
 var__temp_v_err136 --->  error  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h133, res ) ==((sel)( , var_h102, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h133, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h133, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'135, res ) ==((sel)( , var__temp_h133, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h'135, res ) ==(10)
 
VC_END(declare-const var_h_i103 T527)
(declare-const var_h102 T527)
(declare-const v Int)
(declare-const var_h_i47 T527)
(declare-const var_h46 T527)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h133 T527)
(declare-const var__temp_v134 Int)
(declare-const |var__temp_h'135| T527)
(declare-const var__temp_v_err136 T528)
(declare-const var_h102 T527)
(declare-const var_h46 T527)
(declare-const err T541)

solver 
 (declare-sort T527)
(declare-fun sel (T527 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T527)
(declare-fun var_h102 () T527)
(declare-fun |var__temp_h'135| () T527)
(declare-fun var__temp_h133 () T527)
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h133 res) (+ (sel var_h102 res) 6))
               (> (sel var__temp_h133 res) 4)))
      (a!2 (=> (= (sel |var__temp_h'135| res) (+ (sel var__temp_h133 res) 10))
               (= (sel |var__temp_h'135| res) 10))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h133 res) 4) a!2))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************34
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v104:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v104:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v137:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo'
foo
bar
c2'
c2
 *********************Enumeration Iteration*****************35
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v137:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h138 --->  Ty_heap  
 var__temp_v139 --->  Ty_int  
 var__temp_h'140 --->  Ty_heap  
 var__temp_v_err141 --->  error  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h138, res ) ==((sel)( , var_h102, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h138, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h138, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'140, res ) ==((sel)( , var__temp_h138, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i103 T544)
(declare-const var_h102 T544)
(declare-const v Int)
(declare-const var_h_i47 T544)
(declare-const var_h46 T544)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h138 T544)
(declare-const var__temp_v139 Int)
(declare-const |var__temp_h'140| T544)
(declare-const var__temp_v_err141 T545)
(declare-const var_h102 T544)
(declare-const var_h46 T544)
(declare-const err T558)

solver 
 (declare-sort T544)
(declare-fun sel (T544 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T544)
(declare-fun var_h102 () T544)
(declare-fun var__temp_h138 () T544)
(declare-fun |var__temp_h'140| () T544)
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h138 res) (+ (sel var_h102 res) 6))
               (= (sel var__temp_h138 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'140| res) (+ (sel var__temp_h138 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h138 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************36
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v137:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h142 --->  Ty_heap  
 var__temp_v143 --->  Ty_int  
 var__temp_h'144 --->  Ty_heap  
 var__temp_v_err145 --->  error  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h142, res ) ==((sel)( , var_h102, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h142, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h142, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'144, res ) ==((sel)( , var__temp_h142, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i103 T561)
(declare-const var_h102 T561)
(declare-const v Int)
(declare-const var_h_i47 T561)
(declare-const var_h46 T561)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h142 T561)
(declare-const var__temp_v143 Int)
(declare-const |var__temp_h'144| T561)
(declare-const var__temp_v_err145 T562)
(declare-const var_h102 T561)
(declare-const var_h46 T561)
(declare-const err T575)

solver 
 (declare-sort T561)
(declare-fun sel (T561 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T561)
(declare-fun var_h102 () T561)
(declare-fun var__temp_h142 () T561)
(declare-fun |var__temp_h'144| () T561)
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h142 res) (+ (sel var_h102 res) 6))
               (= (sel var__temp_h142 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'144| res) (+ (sel var__temp_h142 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h142 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************37
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v137:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h146 --->  Ty_heap  
 var__temp_v147 --->  Ty_int  
 var__temp_h'148 --->  Ty_heap  
 var__temp_v_err149 --->  error  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h146, res ) ==((sel)( , var_h102, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h146, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h146, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'148, res ) ==((sel)( , var__temp_h146, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i103 T578)
(declare-const var_h102 T578)
(declare-const v Int)
(declare-const var_h_i47 T578)
(declare-const var_h46 T578)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h146 T578)
(declare-const var__temp_v147 Int)
(declare-const |var__temp_h'148| T578)
(declare-const var__temp_v_err149 T579)
(declare-const var_h102 T578)
(declare-const var_h46 T578)
(declare-const err T592)

solver 
 (declare-sort T578)
(declare-fun sel (T578 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T578)
(declare-fun var_h102 () T578)
(declare-fun var__temp_h146 () T578)
(declare-fun |var__temp_h'148| () T578)
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h146 res) (+ (sel var_h102 res) 6))
               (= (sel var__temp_h146 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'148| res) (+ (sel var__temp_h146 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h146 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************38
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 20} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v137:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h150 --->  Ty_heap  
 var__temp_v151 --->  Ty_int  
 var__temp_h'152 --->  Ty_heap  
 var__temp_v_err153 --->  error  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h150, res ) ==((sel)( , var_h102, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h150, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h150, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'152, res ) ==(var__temp_v151) AND 
 	 Base var__temp_v151 = 20 => 
 	 True
 
VC_END(declare-const var_h_i103 T595)
(declare-const var_h102 T595)
(declare-const v Int)
(declare-const var_h_i47 T595)
(declare-const var_h46 T595)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h150 T595)
(declare-const var__temp_v151 Int)
(declare-const |var__temp_h'152| T595)
(declare-const var__temp_v_err153 T596)
(declare-const var_h102 T595)
(declare-const var_h46 T595)
(declare-const err T609)
    (declare-const |20| Int)
  
solver 
 (declare-sort T595)
(declare-fun sel (T595 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T595)
(declare-fun var_h102 () T595)
(declare-fun |20| () Int)
(declare-fun var__temp_v151 () Int)
(declare-fun |var__temp_h'152| () T595)
(declare-fun var__temp_h150 () T595)
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (= (sel var__temp_h150 res) (+ (sel var_h102 res) 6))
               (not (> (sel var__temp_h150 res) 20))))
      (a!2 (=> (and (= (sel |var__temp_h'152| res) var__temp_v151)
                    (= var__temp_v151 |20|))
               true)))
(let ((a!3 (=> (not (> (sel var__temp_h150 res) 20)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Successful************foo'
PARTIAL PATH NEW
NEW 	 --c3'	 --c4	 --foo'
post_substituted Forall 
 	 
 Key =var_h_i155 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i155 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i155, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v156:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i155 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
c2'
c2
 *********************Enumeration Iteration*****************39
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i155 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i155, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v156:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i155 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h157 --->  Ty_heap  
 var__temp_v158 --->  Ty_int  
 var__temp_h'159 --->  Ty_heap  
 var__temp_v_err160 --->  error  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h157, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h157, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h157, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'159, res ) ==((sel)( , var__temp_h157, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'159, res ) ==(10)
 
VC_END(declare-const var_h_i155 T612)
(declare-const var_h154 T612)
(declare-const v Int)
(declare-const var_h_i103 T612)
(declare-const var_h102 T612)
(declare-const v Int)
(declare-const var_h_i47 T612)
(declare-const var_h46 T612)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h157 T612)
(declare-const var__temp_v158 Int)
(declare-const |var__temp_h'159| T612)
(declare-const var__temp_v_err160 T613)
(declare-const var_h154 T612)
(declare-const var_h102 T612)
(declare-const var_h46 T612)
(declare-const err T626)
    (declare-const |20| Int)
  
solver 
 (declare-sort T612)
(declare-fun sel (T612 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T612)
(declare-fun var_h154 () T612)
(declare-fun var_h46 () T612)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'159| () T612)
(declare-fun var__temp_h157 () T612)
(declare-fun v () Int)
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h157 res) v) (= v |20|))
               (= (sel var__temp_h157 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'159| res) (+ (sel var__temp_h157 res) 3))
               (= (sel |var__temp_h'159| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h157 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************40
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i155 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i155, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v156:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i155 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h161 --->  Ty_heap  
 var__temp_v162 --->  Ty_int  
 var__temp_h'163 --->  Ty_heap  
 var__temp_v_err164 --->  error  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h161, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h161, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h161, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'163, res ) ==((sel)( , var__temp_h161, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'163, res ) ==(10)
 
VC_END(declare-const var_h_i155 T629)
(declare-const var_h154 T629)
(declare-const v Int)
(declare-const var_h_i103 T629)
(declare-const var_h102 T629)
(declare-const v Int)
(declare-const var_h_i47 T629)
(declare-const var_h46 T629)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h161 T629)
(declare-const var__temp_v162 Int)
(declare-const |var__temp_h'163| T629)
(declare-const var__temp_v_err164 T630)
(declare-const var_h154 T629)
(declare-const var_h102 T629)
(declare-const var_h46 T629)
(declare-const err T643)
    (declare-const |20| Int)
  
solver 
 (declare-sort T629)
(declare-fun sel (T629 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T629)
(declare-fun var_h154 () T629)
(declare-fun var_h46 () T629)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'163| () T629)
(declare-fun var__temp_h161 () T629)
(declare-fun v () Int)
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h161 res) v) (= v |20|))
               (= (sel var__temp_h161 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'163| res) (+ (sel var__temp_h161 res) 5))
               (= (sel |var__temp_h'163| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h161 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************41
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i155 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i155, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v156:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i155 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h165 --->  Ty_heap  
 var__temp_v166 --->  Ty_int  
 var__temp_h'167 --->  Ty_heap  
 var__temp_v_err168 --->  error  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h165, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h165, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h165, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'167, res ) ==((sel)( , var__temp_h165, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'167, res ) ==(10)
 
VC_END(declare-const var_h_i155 T646)
(declare-const var_h154 T646)
(declare-const v Int)
(declare-const var_h_i103 T646)
(declare-const var_h102 T646)
(declare-const v Int)
(declare-const var_h_i47 T646)
(declare-const var_h46 T646)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h165 T646)
(declare-const var__temp_v166 Int)
(declare-const |var__temp_h'167| T646)
(declare-const var__temp_v_err168 T647)
(declare-const var_h154 T646)
(declare-const var_h102 T646)
(declare-const var_h46 T646)
(declare-const err T660)
    (declare-const |20| Int)
  
solver 
 (declare-sort T646)
(declare-fun sel (T646 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T646)
(declare-fun var_h154 () T646)
(declare-fun var_h46 () T646)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'167| () T646)
(declare-fun var__temp_h165 () T646)
(declare-fun v () Int)
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h165 res) v) (= v |20|))
               (= (sel var__temp_h165 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'167| res) (+ (sel var__temp_h165 res) 4))
               (= (sel |var__temp_h'167| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h165 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************42
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i155 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i155, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v156:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i155 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h169 --->  Ty_heap  
 var__temp_v170 --->  Ty_int  
 var__temp_h'171 --->  Ty_heap  
 var__temp_v_err172 --->  error  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h169, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h169, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h169, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'171, res ) ==(var__temp_v170) AND 
 	 Base var__temp_v170 = 5 => 
 	 Rel (sel)( , var__temp_h'171, res ) ==(10)
 
VC_END(declare-const var_h_i155 T663)
(declare-const var_h154 T663)
(declare-const v Int)
(declare-const var_h_i103 T663)
(declare-const var_h102 T663)
(declare-const v Int)
(declare-const var_h_i47 T663)
(declare-const var_h46 T663)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h169 T663)
(declare-const var__temp_v170 Int)
(declare-const |var__temp_h'171| T663)
(declare-const var__temp_v_err172 T664)
(declare-const var_h154 T663)
(declare-const var_h102 T663)
(declare-const var_h46 T663)
(declare-const err T677)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T663)
(declare-fun sel (T663 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T663)
(declare-fun var_h154 () T663)
(declare-fun var_h46 () T663)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'171| () T663)
(declare-fun var__temp_v170 () Int)
(declare-fun var__temp_h169 () T663)
(declare-fun v () Int)
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h169 res) v) (= v |20|))
               (= (sel var__temp_h169 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'171| res) var__temp_v170)
                    (= var__temp_v170 |5|))
               (= (sel |var__temp_h'171| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h169 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************43
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i155 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i155, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v156:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i155 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h173 --->  Ty_heap  
 var__temp_v174 --->  Ty_int  
 var__temp_h'175 --->  Ty_heap  
 var__temp_v_err176 --->  error  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h173, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h173, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h173, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'175, res ) ==((sel)( , var__temp_h173, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'175, res ) ==(10)
 
VC_END(declare-const var_h_i155 T680)
(declare-const var_h154 T680)
(declare-const v Int)
(declare-const var_h_i103 T680)
(declare-const var_h102 T680)
(declare-const v Int)
(declare-const var_h_i47 T680)
(declare-const var_h46 T680)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h173 T680)
(declare-const var__temp_v174 Int)
(declare-const |var__temp_h'175| T680)
(declare-const var__temp_v_err176 T681)
(declare-const var_h154 T680)
(declare-const var_h102 T680)
(declare-const var_h46 T680)
(declare-const err T694)
    (declare-const |20| Int)
  
solver 
 (declare-sort T680)
(declare-fun sel (T680 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T680)
(declare-fun var_h154 () T680)
(declare-fun var_h46 () T680)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'175| () T680)
(declare-fun var__temp_h173 () T680)
(declare-fun v () Int)
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h173 res) v) (= v |20|))
               (= (sel var__temp_h173 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'175| res) (+ (sel var__temp_h173 res) 2))
               (= (sel |var__temp_h'175| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h173 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************44
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i155 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i155, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v156:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i155 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h177 --->  Ty_heap  
 var__temp_v178 --->  Ty_int  
 var__temp_h'179 --->  Ty_heap  
 var__temp_v_err180 --->  error  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h177, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h177, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h177, res ) > (20) => 
 	 Rel (sel)( , var__temp_h'179, res ) ==(sel)( , var__temp_h177, res ) => 
 	 Rel (sel)( , var__temp_h'179, res ) ==(10)
 
VC_END(declare-const var_h_i155 T697)
(declare-const var_h154 T697)
(declare-const v Int)
(declare-const var_h_i103 T697)
(declare-const var_h102 T697)
(declare-const v Int)
(declare-const var_h_i47 T697)
(declare-const var_h46 T697)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h177 T697)
(declare-const var__temp_v178 Int)
(declare-const |var__temp_h'179| T697)
(declare-const var__temp_v_err180 T698)
(declare-const var_h154 T697)
(declare-const var_h102 T697)
(declare-const var_h46 T697)
(declare-const err T711)
    (declare-const |20| Int)
  
solver 
 (declare-sort T697)
(declare-fun sel (T697 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T697)
(declare-fun var_h154 () T697)
(declare-fun var_h46 () T697)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'179| () T697)
(declare-fun var__temp_h177 () T697)
(declare-fun v () Int)
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h177 res) v) (= v |20|))
               (not (> (sel var__temp_h177 res) 20))))
      (a!2 (=> (not (> (sel var__temp_h177 res) 20))
               (=> (= (sel |var__temp_h'179| res) (sel var__temp_h177 res))
                   (= (sel |var__temp_h'179| res) 10)))))
  (not (and a!1 a!2))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************45
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i155 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i155, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v156:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i155 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h181 --->  Ty_heap  
 var__temp_v182 --->  Ty_int  
 var__temp_h'183 --->  Ty_heap  
 var__temp_v_err184 --->  error  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h181, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h181, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h181, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'183, res ) ==((sel)( , var__temp_h181, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h'183, res ) ==(10)
 
VC_END(declare-const var_h_i155 T714)
(declare-const var_h154 T714)
(declare-const v Int)
(declare-const var_h_i103 T714)
(declare-const var_h102 T714)
(declare-const v Int)
(declare-const var_h_i47 T714)
(declare-const var_h46 T714)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h181 T714)
(declare-const var__temp_v182 Int)
(declare-const |var__temp_h'183| T714)
(declare-const var__temp_v_err184 T715)
(declare-const var_h154 T714)
(declare-const var_h102 T714)
(declare-const var_h46 T714)
(declare-const err T728)
    (declare-const |20| Int)
  
solver 
 (declare-sort T714)
(declare-fun sel (T714 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T714)
(declare-fun var_h154 () T714)
(declare-fun var_h46 () T714)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'183| () T714)
(declare-fun var__temp_h181 () T714)
(declare-fun v () Int)
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h181 res) v) (= v |20|))
               (> (sel var__temp_h181 res) 4)))
      (a!2 (=> (= (sel |var__temp_h'183| res) (+ (sel var__temp_h181 res) 10))
               (= (sel |var__temp_h'183| res) 10))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h181 res) 4) a!2))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************46
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v156:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v156:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfoo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --c4	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i155 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i155, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v185:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
c2'
c2
 *********************Enumeration Iteration*****************47
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i155 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i155, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v185:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h186 --->  Ty_heap  
 var__temp_v187 --->  Ty_int  
 var__temp_h'188 --->  Ty_heap  
 var__temp_v_err189 --->  error  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h186, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h186, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h186, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'188, res ) ==((sel)( , var__temp_h186, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i155 T731)
(declare-const var_h154 T731)
(declare-const v Int)
(declare-const var_h_i103 T731)
(declare-const var_h102 T731)
(declare-const v Int)
(declare-const var_h_i47 T731)
(declare-const var_h46 T731)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h186 T731)
(declare-const var__temp_v187 Int)
(declare-const |var__temp_h'188| T731)
(declare-const var__temp_v_err189 T732)
(declare-const var_h154 T731)
(declare-const var_h102 T731)
(declare-const var_h46 T731)
(declare-const err T745)
    (declare-const |20| Int)
  
solver 
 (declare-sort T731)
(declare-fun sel (T731 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T731)
(declare-fun var_h154 () T731)
(declare-fun var_h46 () T731)
(declare-fun |20| () Int)
(declare-fun var__temp_h186 () T731)
(declare-fun |var__temp_h'188| () T731)
(declare-fun v () Int)
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h186 res) v) (= v |20|))
               (= (sel var__temp_h186 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'188| res) (+ (sel var__temp_h186 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h186 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************48
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i155 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i155, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v185:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h190 --->  Ty_heap  
 var__temp_v191 --->  Ty_int  
 var__temp_h'192 --->  Ty_heap  
 var__temp_v_err193 --->  error  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h190, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h190, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h190, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'192, res ) ==((sel)( , var__temp_h190, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i155 T748)
(declare-const var_h154 T748)
(declare-const v Int)
(declare-const var_h_i103 T748)
(declare-const var_h102 T748)
(declare-const v Int)
(declare-const var_h_i47 T748)
(declare-const var_h46 T748)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h190 T748)
(declare-const var__temp_v191 Int)
(declare-const |var__temp_h'192| T748)
(declare-const var__temp_v_err193 T749)
(declare-const var_h154 T748)
(declare-const var_h102 T748)
(declare-const var_h46 T748)
(declare-const err T762)
    (declare-const |20| Int)
  
solver 
 (declare-sort T748)
(declare-fun sel (T748 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T748)
(declare-fun var_h154 () T748)
(declare-fun var_h46 () T748)
(declare-fun |20| () Int)
(declare-fun var__temp_h190 () T748)
(declare-fun |var__temp_h'192| () T748)
(declare-fun v () Int)
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h190 res) v) (= v |20|))
               (= (sel var__temp_h190 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'192| res) (+ (sel var__temp_h190 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h190 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************49
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i155 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i155, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v185:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h194 --->  Ty_heap  
 var__temp_v195 --->  Ty_int  
 var__temp_h'196 --->  Ty_heap  
 var__temp_v_err197 --->  error  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h194, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h194, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h194, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'196, res ) ==((sel)( , var__temp_h194, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i155 T765)
(declare-const var_h154 T765)
(declare-const v Int)
(declare-const var_h_i103 T765)
(declare-const var_h102 T765)
(declare-const v Int)
(declare-const var_h_i47 T765)
(declare-const var_h46 T765)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h194 T765)
(declare-const var__temp_v195 Int)
(declare-const |var__temp_h'196| T765)
(declare-const var__temp_v_err197 T766)
(declare-const var_h154 T765)
(declare-const var_h102 T765)
(declare-const var_h46 T765)
(declare-const err T779)
    (declare-const |20| Int)
  
solver 
 (declare-sort T765)
(declare-fun sel (T765 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T765)
(declare-fun var_h154 () T765)
(declare-fun var_h46 () T765)
(declare-fun |20| () Int)
(declare-fun var__temp_h194 () T765)
(declare-fun |var__temp_h'196| () T765)
(declare-fun v () Int)
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h194 res) v) (= v |20|))
               (= (sel var__temp_h194 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'196| res) (+ (sel var__temp_h194 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h194 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************50
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i155 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i155, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v185:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h198 --->  Ty_heap  
 var__temp_v199 --->  Ty_int  
 var__temp_h'200 --->  Ty_heap  
 var__temp_v_err201 --->  error  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h198, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h198, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h198, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'200, res ) ==(var__temp_v199) AND 
 	 Base var__temp_v199 = 5 => 
 	 True
 
VC_END(declare-const var_h_i155 T782)
(declare-const var_h154 T782)
(declare-const v Int)
(declare-const var_h_i103 T782)
(declare-const var_h102 T782)
(declare-const v Int)
(declare-const var_h_i47 T782)
(declare-const var_h46 T782)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h198 T782)
(declare-const var__temp_v199 Int)
(declare-const |var__temp_h'200| T782)
(declare-const var__temp_v_err201 T783)
(declare-const var_h154 T782)
(declare-const var_h102 T782)
(declare-const var_h46 T782)
(declare-const err T796)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T782)
(declare-fun sel (T782 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T782)
(declare-fun var_h154 () T782)
(declare-fun var_h46 () T782)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_v199 () Int)
(declare-fun |var__temp_h'200| () T782)
(declare-fun var__temp_h198 () T782)
(declare-fun v () Int)
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h198 res) v) (= v |20|))
               (= (sel var__temp_h198 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'200| res) var__temp_v199)
                    (= var__temp_v199 |5|))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h198 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************51
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i155 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i155, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v185:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h202 --->  Ty_heap  
 var__temp_v203 --->  Ty_int  
 var__temp_h'204 --->  Ty_heap  
 var__temp_v_err205 --->  error  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h202, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h202, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h202, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'204, res ) ==((sel)( , var__temp_h202, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i155 T799)
(declare-const var_h154 T799)
(declare-const v Int)
(declare-const var_h_i103 T799)
(declare-const var_h102 T799)
(declare-const v Int)
(declare-const var_h_i47 T799)
(declare-const var_h46 T799)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h202 T799)
(declare-const var__temp_v203 Int)
(declare-const |var__temp_h'204| T799)
(declare-const var__temp_v_err205 T800)
(declare-const var_h154 T799)
(declare-const var_h102 T799)
(declare-const var_h46 T799)
(declare-const err T813)
    (declare-const |20| Int)
  
solver 
 (declare-sort T799)
(declare-fun sel (T799 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T799)
(declare-fun var_h154 () T799)
(declare-fun var_h46 () T799)
(declare-fun |20| () Int)
(declare-fun var__temp_h202 () T799)
(declare-fun |var__temp_h'204| () T799)
(declare-fun v () Int)
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h202 res) v) (= v |20|))
               (= (sel var__temp_h202 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'204| res) (+ (sel var__temp_h202 res) 2))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h202 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************52
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i155 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i155, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v185:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h206 --->  Ty_heap  
 var__temp_v207 --->  Ty_int  
 var__temp_h'208 --->  Ty_heap  
 var__temp_v_err209 --->  error  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h206, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h206, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h206, res ) > (20) => 
 	 Rel (sel)( , var__temp_h'208, res ) ==(sel)( , var__temp_h206, res ) => 
 	 True
 
VC_END(declare-const var_h_i155 T816)
(declare-const var_h154 T816)
(declare-const v Int)
(declare-const var_h_i103 T816)
(declare-const var_h102 T816)
(declare-const v Int)
(declare-const var_h_i47 T816)
(declare-const var_h46 T816)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h206 T816)
(declare-const var__temp_v207 Int)
(declare-const |var__temp_h'208| T816)
(declare-const var__temp_v_err209 T817)
(declare-const var_h154 T816)
(declare-const var_h102 T816)
(declare-const var_h46 T816)
(declare-const err T830)
    (declare-const |20| Int)
  
solver 
 (declare-sort T816)
(declare-fun sel (T816 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T816)
(declare-fun var_h154 () T816)
(declare-fun var_h46 () T816)
(declare-fun |20| () Int)
(declare-fun var__temp_h206 () T816)
(declare-fun |var__temp_h'208| () T816)
(declare-fun v () Int)
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h206 res) v) (= v |20|))
               (not (> (sel var__temp_h206 res) 20))))
      (a!2 (=> (not (> (sel var__temp_h206 res) 20))
               (=> (= (sel |var__temp_h'208| res) (sel var__temp_h206 res))
                   true))))
  (not (and a!1 a!2))))

***************Selection Successful************c2'
PARTIAL PATH NEW
NEW 	 --c3'	 --c4	 --foo'	 --c2'
post_substituted Forall 
 	 
 Key =var_h_i211 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i211 Value = Ty_heap{ (sel)( , var_h_i211, res ) ==(sel)( , var_h210, res ) } 
 } 
 
                                                RET :  Base {var_v212:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i211 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
c2
 *********************Enumeration Iteration*****************53
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i211 Value = Ty_heap{ (sel)( , var_h_i211, res ) ==(sel)( , var_h210, res ) } 
 } 
 
                                                RET :  Base {var_v212:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i211 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i211 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h213 --->  Ty_heap  
 var__temp_v214 --->  Ty_int  
 var__temp_h'215 --->  Ty_heap  
 var__temp_v_err216 --->  error  
 var_h210 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h210, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h213, res ) ==(sel)( , var_h210, res ) => 
 	 Rel (sel)( , var__temp_h213, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h213, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'215, res ) ==((sel)( , var__temp_h213, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'215, res ) ==(10)
 
VC_END(declare-const var_h_i211 T833)
(declare-const var_h210 T833)
(declare-const v Int)
(declare-const var_h_i155 T833)
(declare-const var_h154 T833)
(declare-const v Int)
(declare-const var_h_i103 T833)
(declare-const var_h102 T833)
(declare-const v Int)
(declare-const var_h_i47 T833)
(declare-const var_h46 T833)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h213 T833)
(declare-const var__temp_v214 Int)
(declare-const |var__temp_h'215| T833)
(declare-const var__temp_v_err216 T834)
(declare-const var_h210 T833)
(declare-const var_h154 T833)
(declare-const var_h102 T833)
(declare-const var_h46 T833)
(declare-const err T847)
    (declare-const |20| Int)
  
solver 
 (declare-sort T833)
(declare-fun v () Int)
(declare-fun sel (T833 Int) Int)
(declare-fun res () Int)
(declare-fun var_h210 () T833)
(declare-fun |20| () Int)
(declare-fun var_h102 () T833)
(declare-fun var_h154 () T833)
(declare-fun var_h46 () T833)
(declare-fun |var__temp_h'215| () T833)
(declare-fun var__temp_h213 () T833)
(assert (= (sel var_h210 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'215| res) (+ (sel var__temp_h213 res) 3))
               (= (sel |var__temp_h'215| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h213 res) (sel var_h210 res))
                    (= (sel var__temp_h213 res) 7))
                (=> (= (sel var__temp_h213 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************54
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i211 Value = Ty_heap{ (sel)( , var_h_i211, res ) ==(sel)( , var_h210, res ) } 
 } 
 
                                                RET :  Base {var_v212:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i211 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i211 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h217 --->  Ty_heap  
 var__temp_v218 --->  Ty_int  
 var__temp_h'219 --->  Ty_heap  
 var__temp_v_err220 --->  error  
 var_h210 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h210, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h217, res ) ==(sel)( , var_h210, res ) => 
 	 Rel (sel)( , var__temp_h217, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h217, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'219, res ) ==((sel)( , var__temp_h217, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'219, res ) ==(10)
 
VC_END(declare-const var_h_i211 T850)
(declare-const var_h210 T850)
(declare-const v Int)
(declare-const var_h_i155 T850)
(declare-const var_h154 T850)
(declare-const v Int)
(declare-const var_h_i103 T850)
(declare-const var_h102 T850)
(declare-const v Int)
(declare-const var_h_i47 T850)
(declare-const var_h46 T850)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h217 T850)
(declare-const var__temp_v218 Int)
(declare-const |var__temp_h'219| T850)
(declare-const var__temp_v_err220 T851)
(declare-const var_h210 T850)
(declare-const var_h154 T850)
(declare-const var_h102 T850)
(declare-const var_h46 T850)
(declare-const err T864)
    (declare-const |20| Int)
  
solver 
 (declare-sort T850)
(declare-fun v () Int)
(declare-fun sel (T850 Int) Int)
(declare-fun res () Int)
(declare-fun var_h210 () T850)
(declare-fun |20| () Int)
(declare-fun var_h102 () T850)
(declare-fun var_h154 () T850)
(declare-fun var_h46 () T850)
(declare-fun |var__temp_h'219| () T850)
(declare-fun var__temp_h217 () T850)
(assert (= (sel var_h210 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'219| res) (+ (sel var__temp_h217 res) 5))
               (= (sel |var__temp_h'219| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h217 res) (sel var_h210 res))
                    (= (sel var__temp_h217 res) 7))
                (=> (= (sel var__temp_h217 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************55
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i211 Value = Ty_heap{ (sel)( , var_h_i211, res ) ==(sel)( , var_h210, res ) } 
 } 
 
                                                RET :  Base {var_v212:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i211 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i211 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h221 --->  Ty_heap  
 var__temp_v222 --->  Ty_int  
 var__temp_h'223 --->  Ty_heap  
 var__temp_v_err224 --->  error  
 var_h210 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h210, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h221, res ) ==(sel)( , var_h210, res ) => 
 	 Rel (sel)( , var__temp_h221, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h221, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'223, res ) ==((sel)( , var__temp_h221, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'223, res ) ==(10)
 
VC_END(declare-const var_h_i211 T867)
(declare-const var_h210 T867)
(declare-const v Int)
(declare-const var_h_i155 T867)
(declare-const var_h154 T867)
(declare-const v Int)
(declare-const var_h_i103 T867)
(declare-const var_h102 T867)
(declare-const v Int)
(declare-const var_h_i47 T867)
(declare-const var_h46 T867)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h221 T867)
(declare-const var__temp_v222 Int)
(declare-const |var__temp_h'223| T867)
(declare-const var__temp_v_err224 T868)
(declare-const var_h210 T867)
(declare-const var_h154 T867)
(declare-const var_h102 T867)
(declare-const var_h46 T867)
(declare-const err T881)
    (declare-const |20| Int)
  
solver 
 (declare-sort T867)
(declare-fun v () Int)
(declare-fun sel (T867 Int) Int)
(declare-fun res () Int)
(declare-fun var_h210 () T867)
(declare-fun |20| () Int)
(declare-fun var_h102 () T867)
(declare-fun var_h154 () T867)
(declare-fun var_h46 () T867)
(declare-fun |var__temp_h'223| () T867)
(declare-fun var__temp_h221 () T867)
(assert (= (sel var_h210 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'223| res) (+ (sel var__temp_h221 res) 4))
               (= (sel |var__temp_h'223| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h221 res) (sel var_h210 res))
                    (= (sel var__temp_h221 res) 6))
                (=> (= (sel var__temp_h221 res) 6) a!1))))
  (not a!2))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************56
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i211 Value = Ty_heap{ (sel)( , var_h_i211, res ) ==(sel)( , var_h210, res ) } 
 } 
 
                                                RET :  Base {var_v212:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i211 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i211 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h225 --->  Ty_heap  
 var__temp_v226 --->  Ty_int  
 var__temp_h'227 --->  Ty_heap  
 var__temp_v_err228 --->  error  
 var_h210 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h210, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h225, res ) ==(sel)( , var_h210, res ) => 
 	 Rel (sel)( , var__temp_h225, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h225, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'227, res ) ==(var__temp_v226) AND 
 	 Base var__temp_v226 = 5 => 
 	 Rel (sel)( , var__temp_h'227, res ) ==(10)
 
VC_END(declare-const var_h_i211 T884)
(declare-const var_h210 T884)
(declare-const v Int)
(declare-const var_h_i155 T884)
(declare-const var_h154 T884)
(declare-const v Int)
(declare-const var_h_i103 T884)
(declare-const var_h102 T884)
(declare-const v Int)
(declare-const var_h_i47 T884)
(declare-const var_h46 T884)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h225 T884)
(declare-const var__temp_v226 Int)
(declare-const |var__temp_h'227| T884)
(declare-const var__temp_v_err228 T885)
(declare-const var_h210 T884)
(declare-const var_h154 T884)
(declare-const var_h102 T884)
(declare-const var_h46 T884)
(declare-const err T898)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T884)
(declare-fun v () Int)
(declare-fun sel (T884 Int) Int)
(declare-fun res () Int)
(declare-fun var_h210 () T884)
(declare-fun |20| () Int)
(declare-fun var_h102 () T884)
(declare-fun var_h154 () T884)
(declare-fun var_h46 () T884)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'227| () T884)
(declare-fun var__temp_v226 () Int)
(declare-fun var__temp_h225 () T884)
(assert (= (sel var_h210 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel |var__temp_h'227| res) var__temp_v226)
                    (= var__temp_v226 |5|))
               (= (sel |var__temp_h'227| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h225 res) (sel var_h210 res))
                    (= (sel var__temp_h225 res) 0))
                (=> (= (sel var__temp_h225 res) 0) a!1))))
  (not a!2))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************57
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i211 Value = Ty_heap{ (sel)( , var_h_i211, res ) ==(sel)( , var_h210, res ) } 
 } 
 
                                                RET :  Base {var_v212:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i211 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i211 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h229 --->  Ty_heap  
 var__temp_v230 --->  Ty_int  
 var__temp_h'231 --->  Ty_heap  
 var__temp_v_err232 --->  error  
 var_h210 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h210, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h229, res ) ==(sel)( , var_h210, res ) => 
 	 Rel (sel)( , var__temp_h229, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h229, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'231, res ) ==((sel)( , var__temp_h229, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'231, res ) ==(10)
 
VC_END(declare-const var_h_i211 T901)
(declare-const var_h210 T901)
(declare-const v Int)
(declare-const var_h_i155 T901)
(declare-const var_h154 T901)
(declare-const v Int)
(declare-const var_h_i103 T901)
(declare-const var_h102 T901)
(declare-const v Int)
(declare-const var_h_i47 T901)
(declare-const var_h46 T901)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h229 T901)
(declare-const var__temp_v230 Int)
(declare-const |var__temp_h'231| T901)
(declare-const var__temp_v_err232 T902)
(declare-const var_h210 T901)
(declare-const var_h154 T901)
(declare-const var_h102 T901)
(declare-const var_h46 T901)
(declare-const err T915)
    (declare-const |20| Int)
  
solver 
 (declare-sort T901)
(declare-fun v () Int)
(declare-fun sel (T901 Int) Int)
(declare-fun res () Int)
(declare-fun var_h210 () T901)
(declare-fun |20| () Int)
(declare-fun var_h102 () T901)
(declare-fun var_h154 () T901)
(declare-fun var_h46 () T901)
(declare-fun |var__temp_h'231| () T901)
(declare-fun var__temp_h229 () T901)
(assert (= (sel var_h210 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'231| res) (+ (sel var__temp_h229 res) 2))
               (= (sel |var__temp_h'231| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h229 res) (sel var_h210 res))
                    (= (sel var__temp_h229 res) 5))
                (=> (= (sel var__temp_h229 res) 5) a!1))))
  (not a!2))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************58
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i211 Value = Ty_heap{ (sel)( , var_h_i211, res ) ==(sel)( , var_h210, res ) } 
 } 
 
                                                RET :  Base {var_v212:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i211 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i211 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h233 --->  Ty_heap  
 var__temp_v234 --->  Ty_int  
 var__temp_h'235 --->  Ty_heap  
 var__temp_v_err236 --->  error  
 var_h210 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h210, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h233, res ) ==(sel)( , var_h210, res ) => 
 	 Rel (sel)( , var__temp_h233, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h233, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'235, res ) ==((sel)( , var__temp_h233, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h'235, res ) ==(10)
 
VC_END(declare-const var_h_i211 T918)
(declare-const var_h210 T918)
(declare-const v Int)
(declare-const var_h_i155 T918)
(declare-const var_h154 T918)
(declare-const v Int)
(declare-const var_h_i103 T918)
(declare-const var_h102 T918)
(declare-const v Int)
(declare-const var_h_i47 T918)
(declare-const var_h46 T918)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h233 T918)
(declare-const var__temp_v234 Int)
(declare-const |var__temp_h'235| T918)
(declare-const var__temp_v_err236 T919)
(declare-const var_h210 T918)
(declare-const var_h154 T918)
(declare-const var_h102 T918)
(declare-const var_h46 T918)
(declare-const err T932)
    (declare-const |20| Int)
  
solver 
 (declare-sort T918)
(declare-fun v () Int)
(declare-fun sel (T918 Int) Int)
(declare-fun res () Int)
(declare-fun var_h210 () T918)
(declare-fun |20| () Int)
(declare-fun var_h102 () T918)
(declare-fun var_h154 () T918)
(declare-fun var_h46 () T918)
(declare-fun |var__temp_h'235| () T918)
(declare-fun var__temp_h233 () T918)
(assert (= (sel var_h210 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'235| res) (+ (sel var__temp_h233 res) 10))
               (= (sel |var__temp_h'235| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h233 res) (sel var_h210 res))
                    (> (sel var__temp_h233 res) 4))
                (=> (> (sel var__temp_h233 res) 4) a!1))))
  (not a!2))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************59
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v212:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v212:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --c4	 --foo'	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i211 Value = Ty_heap{ (sel)( , var_h_i211, res ) ==(sel)( , var_h210, res ) } 
 } 
 
                                                RET :  Base {var_v237:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
c2
 *********************Enumeration Iteration*****************60
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i211 Value = Ty_heap{ (sel)( , var_h_i211, res ) ==(sel)( , var_h210, res ) } 
 } 
 
                                                RET :  Base {var_v237:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i211 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h238 --->  Ty_heap  
 var__temp_v239 --->  Ty_int  
 var__temp_h'240 --->  Ty_heap  
 var__temp_v_err241 --->  error  
 var_h210 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h210, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h238, res ) ==(sel)( , var_h210, res ) => 
 	 Rel (sel)( , var__temp_h238, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h238, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'240, res ) ==((sel)( , var__temp_h238, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i211 T935)
(declare-const var_h210 T935)
(declare-const v Int)
(declare-const var_h_i155 T935)
(declare-const var_h154 T935)
(declare-const v Int)
(declare-const var_h_i103 T935)
(declare-const var_h102 T935)
(declare-const v Int)
(declare-const var_h_i47 T935)
(declare-const var_h46 T935)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h238 T935)
(declare-const var__temp_v239 Int)
(declare-const |var__temp_h'240| T935)
(declare-const var__temp_v_err241 T936)
(declare-const var_h210 T935)
(declare-const var_h154 T935)
(declare-const var_h102 T935)
(declare-const var_h46 T935)
(declare-const err T949)
    (declare-const |20| Int)
  
solver 
 (declare-sort T935)
(declare-fun v () Int)
(declare-fun sel (T935 Int) Int)
(declare-fun res () Int)
(declare-fun var_h210 () T935)
(declare-fun |20| () Int)
(declare-fun var_h102 () T935)
(declare-fun var_h154 () T935)
(declare-fun var_h46 () T935)
(declare-fun var__temp_h238 () T935)
(declare-fun |var__temp_h'240| () T935)
(assert (= (sel var_h210 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'240| res) (+ (sel var__temp_h238 res) 3))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h238 res) (sel var_h210 res))
                    (= (sel var__temp_h238 res) 7))
                (=> (= (sel var__temp_h238 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************61
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i211 Value = Ty_heap{ (sel)( , var_h_i211, res ) ==(sel)( , var_h210, res ) } 
 } 
 
                                                RET :  Base {var_v237:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i211 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h242 --->  Ty_heap  
 var__temp_v243 --->  Ty_int  
 var__temp_h'244 --->  Ty_heap  
 var__temp_v_err245 --->  error  
 var_h210 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h210, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h242, res ) ==(sel)( , var_h210, res ) => 
 	 Rel (sel)( , var__temp_h242, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h242, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'244, res ) ==((sel)( , var__temp_h242, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i211 T952)
(declare-const var_h210 T952)
(declare-const v Int)
(declare-const var_h_i155 T952)
(declare-const var_h154 T952)
(declare-const v Int)
(declare-const var_h_i103 T952)
(declare-const var_h102 T952)
(declare-const v Int)
(declare-const var_h_i47 T952)
(declare-const var_h46 T952)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h242 T952)
(declare-const var__temp_v243 Int)
(declare-const |var__temp_h'244| T952)
(declare-const var__temp_v_err245 T953)
(declare-const var_h210 T952)
(declare-const var_h154 T952)
(declare-const var_h102 T952)
(declare-const var_h46 T952)
(declare-const err T966)
    (declare-const |20| Int)
  
solver 
 (declare-sort T952)
(declare-fun v () Int)
(declare-fun sel (T952 Int) Int)
(declare-fun res () Int)
(declare-fun var_h210 () T952)
(declare-fun |20| () Int)
(declare-fun var_h102 () T952)
(declare-fun var_h154 () T952)
(declare-fun var_h46 () T952)
(declare-fun var__temp_h242 () T952)
(declare-fun |var__temp_h'244| () T952)
(assert (= (sel var_h210 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'244| res) (+ (sel var__temp_h242 res) 5))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h242 res) (sel var_h210 res))
                    (= (sel var__temp_h242 res) 7))
                (=> (= (sel var__temp_h242 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************62
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i211 Value = Ty_heap{ (sel)( , var_h_i211, res ) ==(sel)( , var_h210, res ) } 
 } 
 
                                                RET :  Base {var_v237:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i211 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h246 --->  Ty_heap  
 var__temp_v247 --->  Ty_int  
 var__temp_h'248 --->  Ty_heap  
 var__temp_v_err249 --->  error  
 var_h210 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h210, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h246, res ) ==(sel)( , var_h210, res ) => 
 	 Rel (sel)( , var__temp_h246, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h246, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'248, res ) ==((sel)( , var__temp_h246, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i211 T969)
(declare-const var_h210 T969)
(declare-const v Int)
(declare-const var_h_i155 T969)
(declare-const var_h154 T969)
(declare-const v Int)
(declare-const var_h_i103 T969)
(declare-const var_h102 T969)
(declare-const v Int)
(declare-const var_h_i47 T969)
(declare-const var_h46 T969)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h246 T969)
(declare-const var__temp_v247 Int)
(declare-const |var__temp_h'248| T969)
(declare-const var__temp_v_err249 T970)
(declare-const var_h210 T969)
(declare-const var_h154 T969)
(declare-const var_h102 T969)
(declare-const var_h46 T969)
(declare-const err T983)
    (declare-const |20| Int)
  
solver 
 (declare-sort T969)
(declare-fun v () Int)
(declare-fun sel (T969 Int) Int)
(declare-fun res () Int)
(declare-fun var_h210 () T969)
(declare-fun |20| () Int)
(declare-fun var_h102 () T969)
(declare-fun var_h154 () T969)
(declare-fun var_h46 () T969)
(declare-fun var__temp_h246 () T969)
(declare-fun |var__temp_h'248| () T969)
(assert (= (sel var_h210 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'248| res) (+ (sel var__temp_h246 res) 4))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h246 res) (sel var_h210 res))
                    (= (sel var__temp_h246 res) 6))
                (=> (= (sel var__temp_h246 res) 6) a!1))))
  (not a!2))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************63
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i211 Value = Ty_heap{ (sel)( , var_h_i211, res ) ==(sel)( , var_h210, res ) } 
 } 
 
                                                RET :  Base {var_v237:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i211 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h250 --->  Ty_heap  
 var__temp_v251 --->  Ty_int  
 var__temp_h'252 --->  Ty_heap  
 var__temp_v_err253 --->  error  
 var_h210 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h210, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h250, res ) ==(sel)( , var_h210, res ) => 
 	 Rel (sel)( , var__temp_h250, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h250, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'252, res ) ==(var__temp_v251) AND 
 	 Base var__temp_v251 = 5 => 
 	 True
 
VC_END(declare-const var_h_i211 T986)
(declare-const var_h210 T986)
(declare-const v Int)
(declare-const var_h_i155 T986)
(declare-const var_h154 T986)
(declare-const v Int)
(declare-const var_h_i103 T986)
(declare-const var_h102 T986)
(declare-const v Int)
(declare-const var_h_i47 T986)
(declare-const var_h46 T986)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h250 T986)
(declare-const var__temp_v251 Int)
(declare-const |var__temp_h'252| T986)
(declare-const var__temp_v_err253 T987)
(declare-const var_h210 T986)
(declare-const var_h154 T986)
(declare-const var_h102 T986)
(declare-const var_h46 T986)
(declare-const err T1000)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T986)
(declare-fun v () Int)
(declare-fun sel (T986 Int) Int)
(declare-fun res () Int)
(declare-fun var_h210 () T986)
(declare-fun |20| () Int)
(declare-fun var_h102 () T986)
(declare-fun var_h154 () T986)
(declare-fun var_h46 () T986)
(declare-fun |5| () Int)
(declare-fun var__temp_v251 () Int)
(declare-fun |var__temp_h'252| () T986)
(declare-fun var__temp_h250 () T986)
(assert (= (sel var_h210 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel |var__temp_h'252| res) var__temp_v251)
                    (= var__temp_v251 |5|))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h250 res) (sel var_h210 res))
                    (= (sel var__temp_h250 res) 0))
                (=> (= (sel var__temp_h250 res) 0) a!1))))
  (not a!2))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************64
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i211 Value = Ty_heap{ (sel)( , var_h_i211, res ) ==(sel)( , var_h210, res ) } 
 } 
 
                                                RET :  Base {var_v237:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i211 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h254 --->  Ty_heap  
 var__temp_v255 --->  Ty_int  
 var__temp_h'256 --->  Ty_heap  
 var__temp_v_err257 --->  error  
 var_h210 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h210, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h254, res ) ==(sel)( , var_h210, res ) => 
 	 Rel (sel)( , var__temp_h254, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h254, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'256, res ) ==((sel)( , var__temp_h254, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i211 T1003)
(declare-const var_h210 T1003)
(declare-const v Int)
(declare-const var_h_i155 T1003)
(declare-const var_h154 T1003)
(declare-const v Int)
(declare-const var_h_i103 T1003)
(declare-const var_h102 T1003)
(declare-const v Int)
(declare-const var_h_i47 T1003)
(declare-const var_h46 T1003)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h254 T1003)
(declare-const var__temp_v255 Int)
(declare-const |var__temp_h'256| T1003)
(declare-const var__temp_v_err257 T1004)
(declare-const var_h210 T1003)
(declare-const var_h154 T1003)
(declare-const var_h102 T1003)
(declare-const var_h46 T1003)
(declare-const err T1017)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1003)
(declare-fun v () Int)
(declare-fun sel (T1003 Int) Int)
(declare-fun res () Int)
(declare-fun var_h210 () T1003)
(declare-fun |20| () Int)
(declare-fun var_h102 () T1003)
(declare-fun var_h154 () T1003)
(declare-fun var_h46 () T1003)
(declare-fun var__temp_h254 () T1003)
(declare-fun |var__temp_h'256| () T1003)
(assert (= (sel var_h210 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'256| res) (+ (sel var__temp_h254 res) 2))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h254 res) (sel var_h210 res))
                    (= (sel var__temp_h254 res) 5))
                (=> (= (sel var__temp_h254 res) 5) a!1))))
  (not a!2))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************65
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i211 Value = Ty_heap{ (sel)( , var_h_i211, res ) ==(sel)( , var_h210, res ) } 
 } 
 
                                                RET :  Base {var_v237:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i211 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h258 --->  Ty_heap  
 var__temp_v259 --->  Ty_int  
 var__temp_h'260 --->  Ty_heap  
 var__temp_v_err261 --->  error  
 var_h210 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h210, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h258, res ) ==(sel)( , var_h210, res ) => 
 	 Rel (sel)( , var__temp_h258, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h258, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'260, res ) ==((sel)( , var__temp_h258, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i211 T1020)
(declare-const var_h210 T1020)
(declare-const v Int)
(declare-const var_h_i155 T1020)
(declare-const var_h154 T1020)
(declare-const v Int)
(declare-const var_h_i103 T1020)
(declare-const var_h102 T1020)
(declare-const v Int)
(declare-const var_h_i47 T1020)
(declare-const var_h46 T1020)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h258 T1020)
(declare-const var__temp_v259 Int)
(declare-const |var__temp_h'260| T1020)
(declare-const var__temp_v_err261 T1021)
(declare-const var_h210 T1020)
(declare-const var_h154 T1020)
(declare-const var_h102 T1020)
(declare-const var_h46 T1020)
(declare-const err T1034)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1020)
(declare-fun v () Int)
(declare-fun sel (T1020 Int) Int)
(declare-fun res () Int)
(declare-fun var_h210 () T1020)
(declare-fun |20| () Int)
(declare-fun var_h102 () T1020)
(declare-fun var_h154 () T1020)
(declare-fun var_h46 () T1020)
(declare-fun var__temp_h258 () T1020)
(declare-fun |var__temp_h'260| () T1020)
(assert (= (sel var_h210 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'260| res) (+ (sel var__temp_h258 res) 10))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h258 res) (sel var_h210 res))
                    (> (sel var__temp_h258 res) 4))
                (=> (> (sel var__temp_h258 res) 4) a!1))))
  (not a!2))))

***************Selection Successful************c2
PARTIAL PATH NEW
NEW 	 --c3'	 --c4	 --foo'	 --c2'	 --c2
post_substituted Forall 
 	 
 Key =var_h_i263 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i263 Value = Ty_heap{ (sel)( , var_h_i263, res ) ==((sel)( , var_h262, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v264:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i263 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
 *********************Enumeration Iteration*****************66
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i263 Value = Ty_heap{ (sel)( , var_h_i263, res ) ==((sel)( , var_h262, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v264:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i263 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i263 --->  Ty_heap  
 var_h262 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i211 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h265 --->  Ty_heap  
 var__temp_v266 --->  Ty_int  
 var__temp_h'267 --->  Ty_heap  
 var__temp_v_err268 --->  error  
 var_h262 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h262, res ) ==(sel)( , var_h210, res ) AND 
 	 Rel (sel)( , var_h210, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h265, res ) ==((sel)( , var_h262, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h265, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h265, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'267, res ) ==((sel)( , var__temp_h265, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'267, res ) ==(10)
 
VC_END(declare-const var_h_i263 T1037)
(declare-const var_h262 T1037)
(declare-const v Int)
(declare-const var_h_i211 T1037)
(declare-const var_h210 T1037)
(declare-const v Int)
(declare-const var_h_i155 T1037)
(declare-const var_h154 T1037)
(declare-const v Int)
(declare-const var_h_i103 T1037)
(declare-const var_h102 T1037)
(declare-const v Int)
(declare-const var_h_i47 T1037)
(declare-const var_h46 T1037)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h265 T1037)
(declare-const var__temp_v266 Int)
(declare-const |var__temp_h'267| T1037)
(declare-const var__temp_v_err268 T1038)
(declare-const var_h262 T1037)
(declare-const var_h210 T1037)
(declare-const var_h154 T1037)
(declare-const var_h102 T1037)
(declare-const var_h46 T1037)
(declare-const err T1051)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1037)
(declare-fun sel (T1037 Int) Int)
(declare-fun res () Int)
(declare-fun var_h210 () T1037)
(declare-fun var_h262 () T1037)
(declare-fun v () Int)
(declare-fun |20| () Int)
(declare-fun var_h102 () T1037)
(declare-fun var_h154 () T1037)
(declare-fun var_h46 () T1037)
(declare-fun |var__temp_h'267| () T1037)
(declare-fun var__temp_h265 () T1037)
(assert (= (sel var_h262 res) (sel var_h210 res)))
(assert (= (sel var_h210 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h265 res) (+ (sel var_h262 res) 10))
               (= (sel var__temp_h265 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'267| res) (+ (sel var__temp_h265 res) 3))
               (= (sel |var__temp_h'267| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h265 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************67
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i263 Value = Ty_heap{ (sel)( , var_h_i263, res ) ==((sel)( , var_h262, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v264:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i263 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i263 --->  Ty_heap  
 var_h262 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i211 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h269 --->  Ty_heap  
 var__temp_v270 --->  Ty_int  
 var__temp_h'271 --->  Ty_heap  
 var__temp_v_err272 --->  error  
 var_h262 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h262, res ) ==(sel)( , var_h210, res ) AND 
 	 Rel (sel)( , var_h210, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h269, res ) ==((sel)( , var_h262, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h269, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h269, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'271, res ) ==((sel)( , var__temp_h269, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'271, res ) ==(10)
 
VC_END(declare-const var_h_i263 T1054)
(declare-const var_h262 T1054)
(declare-const v Int)
(declare-const var_h_i211 T1054)
(declare-const var_h210 T1054)
(declare-const v Int)
(declare-const var_h_i155 T1054)
(declare-const var_h154 T1054)
(declare-const v Int)
(declare-const var_h_i103 T1054)
(declare-const var_h102 T1054)
(declare-const v Int)
(declare-const var_h_i47 T1054)
(declare-const var_h46 T1054)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h269 T1054)
(declare-const var__temp_v270 Int)
(declare-const |var__temp_h'271| T1054)
(declare-const var__temp_v_err272 T1055)
(declare-const var_h262 T1054)
(declare-const var_h210 T1054)
(declare-const var_h154 T1054)
(declare-const var_h102 T1054)
(declare-const var_h46 T1054)
(declare-const err T1068)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1054)
(declare-fun sel (T1054 Int) Int)
(declare-fun res () Int)
(declare-fun var_h210 () T1054)
(declare-fun var_h262 () T1054)
(declare-fun v () Int)
(declare-fun |20| () Int)
(declare-fun var_h102 () T1054)
(declare-fun var_h154 () T1054)
(declare-fun var_h46 () T1054)
(declare-fun |var__temp_h'271| () T1054)
(declare-fun var__temp_h269 () T1054)
(assert (= (sel var_h262 res) (sel var_h210 res)))
(assert (= (sel var_h210 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h269 res) (+ (sel var_h262 res) 10))
               (= (sel var__temp_h269 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'271| res) (+ (sel var__temp_h269 res) 5))
               (= (sel |var__temp_h'271| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h269 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************68
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i263 Value = Ty_heap{ (sel)( , var_h_i263, res ) ==((sel)( , var_h262, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v264:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i263 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i263 --->  Ty_heap  
 var_h262 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i211 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h273 --->  Ty_heap  
 var__temp_v274 --->  Ty_int  
 var__temp_h'275 --->  Ty_heap  
 var__temp_v_err276 --->  error  
 var_h262 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h262, res ) ==(sel)( , var_h210, res ) AND 
 	 Rel (sel)( , var_h210, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h273, res ) ==((sel)( , var_h262, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h273, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h273, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'275, res ) ==((sel)( , var__temp_h273, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'275, res ) ==(10)
 
VC_END(declare-const var_h_i263 T1071)
(declare-const var_h262 T1071)
(declare-const v Int)
(declare-const var_h_i211 T1071)
(declare-const var_h210 T1071)
(declare-const v Int)
(declare-const var_h_i155 T1071)
(declare-const var_h154 T1071)
(declare-const v Int)
(declare-const var_h_i103 T1071)
(declare-const var_h102 T1071)
(declare-const v Int)
(declare-const var_h_i47 T1071)
(declare-const var_h46 T1071)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h273 T1071)
(declare-const var__temp_v274 Int)
(declare-const |var__temp_h'275| T1071)
(declare-const var__temp_v_err276 T1072)
(declare-const var_h262 T1071)
(declare-const var_h210 T1071)
(declare-const var_h154 T1071)
(declare-const var_h102 T1071)
(declare-const var_h46 T1071)
(declare-const err T1085)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1071)
(declare-fun sel (T1071 Int) Int)
(declare-fun res () Int)
(declare-fun var_h210 () T1071)
(declare-fun var_h262 () T1071)
(declare-fun v () Int)
(declare-fun |20| () Int)
(declare-fun var_h102 () T1071)
(declare-fun var_h154 () T1071)
(declare-fun var_h46 () T1071)
(declare-fun |var__temp_h'275| () T1071)
(declare-fun var__temp_h273 () T1071)
(assert (= (sel var_h262 res) (sel var_h210 res)))
(assert (= (sel var_h210 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h273 res) (+ (sel var_h262 res) 10))
               (= (sel var__temp_h273 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'275| res) (+ (sel var__temp_h273 res) 4))
               (= (sel |var__temp_h'275| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h273 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************69
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i263 Value = Ty_heap{ (sel)( , var_h_i263, res ) ==((sel)( , var_h262, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v264:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i263 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i263 --->  Ty_heap  
 var_h262 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i211 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h277 --->  Ty_heap  
 var__temp_v278 --->  Ty_int  
 var__temp_h'279 --->  Ty_heap  
 var__temp_v_err280 --->  error  
 var_h262 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h262, res ) ==(sel)( , var_h210, res ) AND 
 	 Rel (sel)( , var_h210, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h277, res ) ==((sel)( , var_h262, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h277, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h277, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'279, res ) ==(var__temp_v278) AND 
 	 Base var__temp_v278 = 5 => 
 	 Rel (sel)( , var__temp_h'279, res ) ==(10)
 
VC_END(declare-const var_h_i263 T1088)
(declare-const var_h262 T1088)
(declare-const v Int)
(declare-const var_h_i211 T1088)
(declare-const var_h210 T1088)
(declare-const v Int)
(declare-const var_h_i155 T1088)
(declare-const var_h154 T1088)
(declare-const v Int)
(declare-const var_h_i103 T1088)
(declare-const var_h102 T1088)
(declare-const v Int)
(declare-const var_h_i47 T1088)
(declare-const var_h46 T1088)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h277 T1088)
(declare-const var__temp_v278 Int)
(declare-const |var__temp_h'279| T1088)
(declare-const var__temp_v_err280 T1089)
(declare-const var_h262 T1088)
(declare-const var_h210 T1088)
(declare-const var_h154 T1088)
(declare-const var_h102 T1088)
(declare-const var_h46 T1088)
(declare-const err T1102)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T1088)
(declare-fun sel (T1088 Int) Int)
(declare-fun res () Int)
(declare-fun var_h210 () T1088)
(declare-fun var_h262 () T1088)
(declare-fun v () Int)
(declare-fun |20| () Int)
(declare-fun var_h102 () T1088)
(declare-fun var_h154 () T1088)
(declare-fun var_h46 () T1088)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'279| () T1088)
(declare-fun var__temp_v278 () Int)
(declare-fun var__temp_h277 () T1088)
(assert (= (sel var_h262 res) (sel var_h210 res)))
(assert (= (sel var_h210 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h277 res) (+ (sel var_h262 res) 10))
               (= (sel var__temp_h277 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'279| res) var__temp_v278)
                    (= var__temp_v278 |5|))
               (= (sel |var__temp_h'279| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h277 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************70
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i263 Value = Ty_heap{ (sel)( , var_h_i263, res ) ==((sel)( , var_h262, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v264:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i263 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i263 --->  Ty_heap  
 var_h262 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i211 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h281 --->  Ty_heap  
 var__temp_v282 --->  Ty_int  
 var__temp_h'283 --->  Ty_heap  
 var__temp_v_err284 --->  error  
 var_h262 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h262, res ) ==(sel)( , var_h210, res ) AND 
 	 Rel (sel)( , var_h210, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h281, res ) ==((sel)( , var_h262, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h281, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h281, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'283, res ) ==((sel)( , var__temp_h281, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'283, res ) ==(10)
 
VC_END(declare-const var_h_i263 T1105)
(declare-const var_h262 T1105)
(declare-const v Int)
(declare-const var_h_i211 T1105)
(declare-const var_h210 T1105)
(declare-const v Int)
(declare-const var_h_i155 T1105)
(declare-const var_h154 T1105)
(declare-const v Int)
(declare-const var_h_i103 T1105)
(declare-const var_h102 T1105)
(declare-const v Int)
(declare-const var_h_i47 T1105)
(declare-const var_h46 T1105)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h281 T1105)
(declare-const var__temp_v282 Int)
(declare-const |var__temp_h'283| T1105)
(declare-const var__temp_v_err284 T1106)
(declare-const var_h262 T1105)
(declare-const var_h210 T1105)
(declare-const var_h154 T1105)
(declare-const var_h102 T1105)
(declare-const var_h46 T1105)
(declare-const err T1119)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1105)
(declare-fun sel (T1105 Int) Int)
(declare-fun res () Int)
(declare-fun var_h210 () T1105)
(declare-fun var_h262 () T1105)
(declare-fun v () Int)
(declare-fun |20| () Int)
(declare-fun var_h102 () T1105)
(declare-fun var_h154 () T1105)
(declare-fun var_h46 () T1105)
(declare-fun |var__temp_h'283| () T1105)
(declare-fun var__temp_h281 () T1105)
(assert (= (sel var_h262 res) (sel var_h210 res)))
(assert (= (sel var_h210 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h281 res) (+ (sel var_h262 res) 10))
               (= (sel var__temp_h281 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'283| res) (+ (sel var__temp_h281 res) 2))
               (= (sel |var__temp_h'283| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h281 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************71
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v264:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v264:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2c2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --c4	 --foo'	 --c2'	 --c2
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i263 Value = Ty_heap{ (sel)( , var_h_i263, res ) ==((sel)( , var_h262, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v285:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
 *********************Enumeration Iteration*****************72
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i263 Value = Ty_heap{ (sel)( , var_h_i263, res ) ==((sel)( , var_h262, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v285:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i263 --->  Ty_heap  
 var_h262 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i211 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h286 --->  Ty_heap  
 var__temp_v287 --->  Ty_int  
 var__temp_h'288 --->  Ty_heap  
 var__temp_v_err289 --->  error  
 var_h262 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h262, res ) ==(sel)( , var_h210, res ) AND 
 	 Rel (sel)( , var_h210, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h286, res ) ==((sel)( , var_h262, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h286, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h286, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'288, res ) ==((sel)( , var__temp_h286, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i263 T1122)
(declare-const var_h262 T1122)
(declare-const v Int)
(declare-const var_h_i211 T1122)
(declare-const var_h210 T1122)
(declare-const v Int)
(declare-const var_h_i155 T1122)
(declare-const var_h154 T1122)
(declare-const v Int)
(declare-const var_h_i103 T1122)
(declare-const var_h102 T1122)
(declare-const v Int)
(declare-const var_h_i47 T1122)
(declare-const var_h46 T1122)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h286 T1122)
(declare-const var__temp_v287 Int)
(declare-const |var__temp_h'288| T1122)
(declare-const var__temp_v_err289 T1123)
(declare-const var_h262 T1122)
(declare-const var_h210 T1122)
(declare-const var_h154 T1122)
(declare-const var_h102 T1122)
(declare-const var_h46 T1122)
(declare-const err T1136)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1122)
(declare-fun sel (T1122 Int) Int)
(declare-fun res () Int)
(declare-fun var_h210 () T1122)
(declare-fun var_h262 () T1122)
(declare-fun v () Int)
(declare-fun |20| () Int)
(declare-fun var_h102 () T1122)
(declare-fun var_h154 () T1122)
(declare-fun var_h46 () T1122)
(declare-fun var__temp_h286 () T1122)
(declare-fun |var__temp_h'288| () T1122)
(assert (= (sel var_h262 res) (sel var_h210 res)))
(assert (= (sel var_h210 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h286 res) (+ (sel var_h262 res) 10))
               (= (sel var__temp_h286 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'288| res) (+ (sel var__temp_h286 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h286 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************73
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i263 Value = Ty_heap{ (sel)( , var_h_i263, res ) ==((sel)( , var_h262, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v285:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i263 --->  Ty_heap  
 var_h262 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i211 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h290 --->  Ty_heap  
 var__temp_v291 --->  Ty_int  
 var__temp_h'292 --->  Ty_heap  
 var__temp_v_err293 --->  error  
 var_h262 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h262, res ) ==(sel)( , var_h210, res ) AND 
 	 Rel (sel)( , var_h210, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h290, res ) ==((sel)( , var_h262, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h290, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h290, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'292, res ) ==((sel)( , var__temp_h290, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i263 T1139)
(declare-const var_h262 T1139)
(declare-const v Int)
(declare-const var_h_i211 T1139)
(declare-const var_h210 T1139)
(declare-const v Int)
(declare-const var_h_i155 T1139)
(declare-const var_h154 T1139)
(declare-const v Int)
(declare-const var_h_i103 T1139)
(declare-const var_h102 T1139)
(declare-const v Int)
(declare-const var_h_i47 T1139)
(declare-const var_h46 T1139)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h290 T1139)
(declare-const var__temp_v291 Int)
(declare-const |var__temp_h'292| T1139)
(declare-const var__temp_v_err293 T1140)
(declare-const var_h262 T1139)
(declare-const var_h210 T1139)
(declare-const var_h154 T1139)
(declare-const var_h102 T1139)
(declare-const var_h46 T1139)
(declare-const err T1153)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1139)
(declare-fun sel (T1139 Int) Int)
(declare-fun res () Int)
(declare-fun var_h210 () T1139)
(declare-fun var_h262 () T1139)
(declare-fun v () Int)
(declare-fun |20| () Int)
(declare-fun var_h102 () T1139)
(declare-fun var_h154 () T1139)
(declare-fun var_h46 () T1139)
(declare-fun var__temp_h290 () T1139)
(declare-fun |var__temp_h'292| () T1139)
(assert (= (sel var_h262 res) (sel var_h210 res)))
(assert (= (sel var_h210 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h290 res) (+ (sel var_h262 res) 10))
               (= (sel var__temp_h290 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'292| res) (+ (sel var__temp_h290 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h290 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************74
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i263 Value = Ty_heap{ (sel)( , var_h_i263, res ) ==((sel)( , var_h262, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v285:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i263 --->  Ty_heap  
 var_h262 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i211 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h294 --->  Ty_heap  
 var__temp_v295 --->  Ty_int  
 var__temp_h'296 --->  Ty_heap  
 var__temp_v_err297 --->  error  
 var_h262 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h262, res ) ==(sel)( , var_h210, res ) AND 
 	 Rel (sel)( , var_h210, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h294, res ) ==((sel)( , var_h262, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h294, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h294, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'296, res ) ==((sel)( , var__temp_h294, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i263 T1156)
(declare-const var_h262 T1156)
(declare-const v Int)
(declare-const var_h_i211 T1156)
(declare-const var_h210 T1156)
(declare-const v Int)
(declare-const var_h_i155 T1156)
(declare-const var_h154 T1156)
(declare-const v Int)
(declare-const var_h_i103 T1156)
(declare-const var_h102 T1156)
(declare-const v Int)
(declare-const var_h_i47 T1156)
(declare-const var_h46 T1156)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h294 T1156)
(declare-const var__temp_v295 Int)
(declare-const |var__temp_h'296| T1156)
(declare-const var__temp_v_err297 T1157)
(declare-const var_h262 T1156)
(declare-const var_h210 T1156)
(declare-const var_h154 T1156)
(declare-const var_h102 T1156)
(declare-const var_h46 T1156)
(declare-const err T1170)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1156)
(declare-fun sel (T1156 Int) Int)
(declare-fun res () Int)
(declare-fun var_h210 () T1156)
(declare-fun var_h262 () T1156)
(declare-fun v () Int)
(declare-fun |20| () Int)
(declare-fun var_h102 () T1156)
(declare-fun var_h154 () T1156)
(declare-fun var_h46 () T1156)
(declare-fun var__temp_h294 () T1156)
(declare-fun |var__temp_h'296| () T1156)
(assert (= (sel var_h262 res) (sel var_h210 res)))
(assert (= (sel var_h210 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h294 res) (+ (sel var_h262 res) 10))
               (= (sel var__temp_h294 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'296| res) (+ (sel var__temp_h294 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h294 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************75
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i263 Value = Ty_heap{ (sel)( , var_h_i263, res ) ==((sel)( , var_h262, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v285:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i263 --->  Ty_heap  
 var_h262 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i211 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h298 --->  Ty_heap  
 var__temp_v299 --->  Ty_int  
 var__temp_h'300 --->  Ty_heap  
 var__temp_v_err301 --->  error  
 var_h262 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h262, res ) ==(sel)( , var_h210, res ) AND 
 	 Rel (sel)( , var_h210, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h298, res ) ==((sel)( , var_h262, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h298, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h298, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'300, res ) ==(var__temp_v299) AND 
 	 Base var__temp_v299 = 5 => 
 	 True
 
VC_END(declare-const var_h_i263 T1173)
(declare-const var_h262 T1173)
(declare-const v Int)
(declare-const var_h_i211 T1173)
(declare-const var_h210 T1173)
(declare-const v Int)
(declare-const var_h_i155 T1173)
(declare-const var_h154 T1173)
(declare-const v Int)
(declare-const var_h_i103 T1173)
(declare-const var_h102 T1173)
(declare-const v Int)
(declare-const var_h_i47 T1173)
(declare-const var_h46 T1173)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h298 T1173)
(declare-const var__temp_v299 Int)
(declare-const |var__temp_h'300| T1173)
(declare-const var__temp_v_err301 T1174)
(declare-const var_h262 T1173)
(declare-const var_h210 T1173)
(declare-const var_h154 T1173)
(declare-const var_h102 T1173)
(declare-const var_h46 T1173)
(declare-const err T1187)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T1173)
(declare-fun sel (T1173 Int) Int)
(declare-fun res () Int)
(declare-fun var_h210 () T1173)
(declare-fun var_h262 () T1173)
(declare-fun v () Int)
(declare-fun |20| () Int)
(declare-fun var_h102 () T1173)
(declare-fun var_h154 () T1173)
(declare-fun var_h46 () T1173)
(declare-fun |5| () Int)
(declare-fun var__temp_v299 () Int)
(declare-fun |var__temp_h'300| () T1173)
(declare-fun var__temp_h298 () T1173)
(assert (= (sel var_h262 res) (sel var_h210 res)))
(assert (= (sel var_h210 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h298 res) (+ (sel var_h262 res) 10))
               (= (sel var__temp_h298 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'300| res) var__temp_v299)
                    (= var__temp_v299 |5|))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h298 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************76
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i263 Value = Ty_heap{ (sel)( , var_h_i263, res ) ==((sel)( , var_h262, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v285:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i263 --->  Ty_heap  
 var_h262 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i211 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h302 --->  Ty_heap  
 var__temp_v303 --->  Ty_int  
 var__temp_h'304 --->  Ty_heap  
 var__temp_v_err305 --->  error  
 var_h262 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h262, res ) ==(sel)( , var_h210, res ) AND 
 	 Rel (sel)( , var_h210, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h302, res ) ==((sel)( , var_h262, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h302, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h302, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'304, res ) ==((sel)( , var__temp_h302, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i263 T1190)
(declare-const var_h262 T1190)
(declare-const v Int)
(declare-const var_h_i211 T1190)
(declare-const var_h210 T1190)
(declare-const v Int)
(declare-const var_h_i155 T1190)
(declare-const var_h154 T1190)
(declare-const v Int)
(declare-const var_h_i103 T1190)
(declare-const var_h102 T1190)
(declare-const v Int)
(declare-const var_h_i47 T1190)
(declare-const var_h46 T1190)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h302 T1190)
(declare-const var__temp_v303 Int)
(declare-const |var__temp_h'304| T1190)
(declare-const var__temp_v_err305 T1191)
(declare-const var_h262 T1190)
(declare-const var_h210 T1190)
(declare-const var_h154 T1190)
(declare-const var_h102 T1190)
(declare-const var_h46 T1190)
(declare-const err T1204)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1190)
(declare-fun sel (T1190 Int) Int)
(declare-fun res () Int)
(declare-fun var_h210 () T1190)
(declare-fun var_h262 () T1190)
(declare-fun v () Int)
(declare-fun |20| () Int)
(declare-fun var_h102 () T1190)
(declare-fun var_h154 () T1190)
(declare-fun var_h46 () T1190)
(declare-fun var__temp_h302 () T1190)
(declare-fun |var__temp_h'304| () T1190)
(assert (= (sel var_h262 res) (sel var_h210 res)))
(assert (= (sel var_h210 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h302 res) (+ (sel var_h262 res) 10))
               (= (sel var__temp_h302 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'304| res) (+ (sel var__temp_h302 res) 2))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h302 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************77
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 	 --c3'	 --c4	 --foo'	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i211 Value = Ty_heap{ (sel)( , var_h_i211, res ) ==(sel)( , var_h210, res ) } 
 } 
 
                                                RET :  Base {var_v306:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
 *********************Enumeration Iteration*****************78
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i211 Value = Ty_heap{ (sel)( , var_h_i211, res ) ==(sel)( , var_h210, res ) } 
 } 
 
                                                RET :  Base {var_v306:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i211 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h307 --->  Ty_heap  
 var__temp_v308 --->  Ty_int  
 var__temp_h'309 --->  Ty_heap  
 var__temp_v_err310 --->  error  
 var_h210 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h210, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h307, res ) ==(sel)( , var_h210, res ) => 
 	 Rel (sel)( , var__temp_h307, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h307, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'309, res ) ==((sel)( , var__temp_h307, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i211 T1207)
(declare-const var_h210 T1207)
(declare-const v Int)
(declare-const var_h_i155 T1207)
(declare-const var_h154 T1207)
(declare-const v Int)
(declare-const var_h_i103 T1207)
(declare-const var_h102 T1207)
(declare-const v Int)
(declare-const var_h_i47 T1207)
(declare-const var_h46 T1207)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h307 T1207)
(declare-const var__temp_v308 Int)
(declare-const |var__temp_h'309| T1207)
(declare-const var__temp_v_err310 T1208)
(declare-const var_h210 T1207)
(declare-const var_h154 T1207)
(declare-const var_h102 T1207)
(declare-const var_h46 T1207)
(declare-const err T1221)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1207)
(declare-fun v () Int)
(declare-fun sel (T1207 Int) Int)
(declare-fun res () Int)
(declare-fun var_h210 () T1207)
(declare-fun |20| () Int)
(declare-fun var_h102 () T1207)
(declare-fun var_h154 () T1207)
(declare-fun var_h46 () T1207)
(declare-fun var__temp_h307 () T1207)
(declare-fun |var__temp_h'309| () T1207)
(assert (= (sel var_h210 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'309| res) (+ (sel var__temp_h307 res) 3))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h307 res) (sel var_h210 res))
                    (= (sel var__temp_h307 res) 7))
                (=> (= (sel var__temp_h307 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************79
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i211 Value = Ty_heap{ (sel)( , var_h_i211, res ) ==(sel)( , var_h210, res ) } 
 } 
 
                                                RET :  Base {var_v306:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i211 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h311 --->  Ty_heap  
 var__temp_v312 --->  Ty_int  
 var__temp_h'313 --->  Ty_heap  
 var__temp_v_err314 --->  error  
 var_h210 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h210, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h311, res ) ==(sel)( , var_h210, res ) => 
 	 Rel (sel)( , var__temp_h311, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h311, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'313, res ) ==((sel)( , var__temp_h311, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i211 T1224)
(declare-const var_h210 T1224)
(declare-const v Int)
(declare-const var_h_i155 T1224)
(declare-const var_h154 T1224)
(declare-const v Int)
(declare-const var_h_i103 T1224)
(declare-const var_h102 T1224)
(declare-const v Int)
(declare-const var_h_i47 T1224)
(declare-const var_h46 T1224)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h311 T1224)
(declare-const var__temp_v312 Int)
(declare-const |var__temp_h'313| T1224)
(declare-const var__temp_v_err314 T1225)
(declare-const var_h210 T1224)
(declare-const var_h154 T1224)
(declare-const var_h102 T1224)
(declare-const var_h46 T1224)
(declare-const err T1238)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1224)
(declare-fun v () Int)
(declare-fun sel (T1224 Int) Int)
(declare-fun res () Int)
(declare-fun var_h210 () T1224)
(declare-fun |20| () Int)
(declare-fun var_h102 () T1224)
(declare-fun var_h154 () T1224)
(declare-fun var_h46 () T1224)
(declare-fun var__temp_h311 () T1224)
(declare-fun |var__temp_h'313| () T1224)
(assert (= (sel var_h210 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'313| res) (+ (sel var__temp_h311 res) 5))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h311 res) (sel var_h210 res))
                    (= (sel var__temp_h311 res) 7))
                (=> (= (sel var__temp_h311 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************80
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i211 Value = Ty_heap{ (sel)( , var_h_i211, res ) ==(sel)( , var_h210, res ) } 
 } 
 
                                                RET :  Base {var_v306:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i211 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h315 --->  Ty_heap  
 var__temp_v316 --->  Ty_int  
 var__temp_h'317 --->  Ty_heap  
 var__temp_v_err318 --->  error  
 var_h210 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h210, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h315, res ) ==(sel)( , var_h210, res ) => 
 	 Rel (sel)( , var__temp_h315, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h315, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'317, res ) ==((sel)( , var__temp_h315, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i211 T1241)
(declare-const var_h210 T1241)
(declare-const v Int)
(declare-const var_h_i155 T1241)
(declare-const var_h154 T1241)
(declare-const v Int)
(declare-const var_h_i103 T1241)
(declare-const var_h102 T1241)
(declare-const v Int)
(declare-const var_h_i47 T1241)
(declare-const var_h46 T1241)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h315 T1241)
(declare-const var__temp_v316 Int)
(declare-const |var__temp_h'317| T1241)
(declare-const var__temp_v_err318 T1242)
(declare-const var_h210 T1241)
(declare-const var_h154 T1241)
(declare-const var_h102 T1241)
(declare-const var_h46 T1241)
(declare-const err T1255)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1241)
(declare-fun v () Int)
(declare-fun sel (T1241 Int) Int)
(declare-fun res () Int)
(declare-fun var_h210 () T1241)
(declare-fun |20| () Int)
(declare-fun var_h102 () T1241)
(declare-fun var_h154 () T1241)
(declare-fun var_h46 () T1241)
(declare-fun var__temp_h315 () T1241)
(declare-fun |var__temp_h'317| () T1241)
(assert (= (sel var_h210 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'317| res) (+ (sel var__temp_h315 res) 4))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h315 res) (sel var_h210 res))
                    (= (sel var__temp_h315 res) 6))
                (=> (= (sel var__temp_h315 res) 6) a!1))))
  (not a!2))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************81
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i211 Value = Ty_heap{ (sel)( , var_h_i211, res ) ==(sel)( , var_h210, res ) } 
 } 
 
                                                RET :  Base {var_v306:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i211 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h319 --->  Ty_heap  
 var__temp_v320 --->  Ty_int  
 var__temp_h'321 --->  Ty_heap  
 var__temp_v_err322 --->  error  
 var_h210 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h210, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h319, res ) ==(sel)( , var_h210, res ) => 
 	 Rel (sel)( , var__temp_h319, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h319, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'321, res ) ==(var__temp_v320) AND 
 	 Base var__temp_v320 = 5 => 
 	 True
 
VC_END(declare-const var_h_i211 T1258)
(declare-const var_h210 T1258)
(declare-const v Int)
(declare-const var_h_i155 T1258)
(declare-const var_h154 T1258)
(declare-const v Int)
(declare-const var_h_i103 T1258)
(declare-const var_h102 T1258)
(declare-const v Int)
(declare-const var_h_i47 T1258)
(declare-const var_h46 T1258)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h319 T1258)
(declare-const var__temp_v320 Int)
(declare-const |var__temp_h'321| T1258)
(declare-const var__temp_v_err322 T1259)
(declare-const var_h210 T1258)
(declare-const var_h154 T1258)
(declare-const var_h102 T1258)
(declare-const var_h46 T1258)
(declare-const err T1272)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T1258)
(declare-fun v () Int)
(declare-fun sel (T1258 Int) Int)
(declare-fun res () Int)
(declare-fun var_h210 () T1258)
(declare-fun |20| () Int)
(declare-fun var_h102 () T1258)
(declare-fun var_h154 () T1258)
(declare-fun var_h46 () T1258)
(declare-fun |5| () Int)
(declare-fun var__temp_v320 () Int)
(declare-fun |var__temp_h'321| () T1258)
(declare-fun var__temp_h319 () T1258)
(assert (= (sel var_h210 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel |var__temp_h'321| res) var__temp_v320)
                    (= var__temp_v320 |5|))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h319 res) (sel var_h210 res))
                    (= (sel var__temp_h319 res) 0))
                (=> (= (sel var__temp_h319 res) 0) a!1))))
  (not a!2))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************82
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i211 Value = Ty_heap{ (sel)( , var_h_i211, res ) ==(sel)( , var_h210, res ) } 
 } 
 
                                                RET :  Base {var_v306:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i211 --->  Ty_heap  
 var_h210 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h323 --->  Ty_heap  
 var__temp_v324 --->  Ty_int  
 var__temp_h'325 --->  Ty_heap  
 var__temp_v_err326 --->  error  
 var_h210 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h210, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h323, res ) ==(sel)( , var_h210, res ) => 
 	 Rel (sel)( , var__temp_h323, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h323, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'325, res ) ==((sel)( , var__temp_h323, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i211 T1275)
(declare-const var_h210 T1275)
(declare-const v Int)
(declare-const var_h_i155 T1275)
(declare-const var_h154 T1275)
(declare-const v Int)
(declare-const var_h_i103 T1275)
(declare-const var_h102 T1275)
(declare-const v Int)
(declare-const var_h_i47 T1275)
(declare-const var_h46 T1275)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h323 T1275)
(declare-const var__temp_v324 Int)
(declare-const |var__temp_h'325| T1275)
(declare-const var__temp_v_err326 T1276)
(declare-const var_h210 T1275)
(declare-const var_h154 T1275)
(declare-const var_h102 T1275)
(declare-const var_h46 T1275)
(declare-const err T1289)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1275)
(declare-fun v () Int)
(declare-fun sel (T1275 Int) Int)
(declare-fun res () Int)
(declare-fun var_h210 () T1275)
(declare-fun |20| () Int)
(declare-fun var_h102 () T1275)
(declare-fun var_h154 () T1275)
(declare-fun var_h46 () T1275)
(declare-fun var__temp_h323 () T1275)
(declare-fun |var__temp_h'325| () T1275)
(assert (= (sel var_h210 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'325| res) (+ (sel var__temp_h323 res) 2))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h323 res) (sel var_h210 res))
                    (= (sel var__temp_h323 res) 5))
                (=> (= (sel var__temp_h323 res) 5) a!1))))
  (not a!2))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************83
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 	 --c3'	 --c4	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i155 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i155, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v327:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
c2
 *********************Enumeration Iteration*****************84
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i155 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i155, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v327:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h328 --->  Ty_heap  
 var__temp_v329 --->  Ty_int  
 var__temp_h'330 --->  Ty_heap  
 var__temp_v_err331 --->  error  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h328, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h328, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h328, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'330, res ) ==((sel)( , var__temp_h328, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i155 T1292)
(declare-const var_h154 T1292)
(declare-const v Int)
(declare-const var_h_i103 T1292)
(declare-const var_h102 T1292)
(declare-const v Int)
(declare-const var_h_i47 T1292)
(declare-const var_h46 T1292)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h328 T1292)
(declare-const var__temp_v329 Int)
(declare-const |var__temp_h'330| T1292)
(declare-const var__temp_v_err331 T1293)
(declare-const var_h154 T1292)
(declare-const var_h102 T1292)
(declare-const var_h46 T1292)
(declare-const err T1306)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1292)
(declare-fun sel (T1292 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T1292)
(declare-fun var_h154 () T1292)
(declare-fun var_h46 () T1292)
(declare-fun |20| () Int)
(declare-fun var__temp_h328 () T1292)
(declare-fun |var__temp_h'330| () T1292)
(declare-fun v () Int)
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h328 res) v) (= v |20|))
               (= (sel var__temp_h328 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'330| res) (+ (sel var__temp_h328 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h328 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************85
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i155 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i155, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v327:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h332 --->  Ty_heap  
 var__temp_v333 --->  Ty_int  
 var__temp_h'334 --->  Ty_heap  
 var__temp_v_err335 --->  error  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h332, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h332, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h332, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'334, res ) ==((sel)( , var__temp_h332, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i155 T1309)
(declare-const var_h154 T1309)
(declare-const v Int)
(declare-const var_h_i103 T1309)
(declare-const var_h102 T1309)
(declare-const v Int)
(declare-const var_h_i47 T1309)
(declare-const var_h46 T1309)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h332 T1309)
(declare-const var__temp_v333 Int)
(declare-const |var__temp_h'334| T1309)
(declare-const var__temp_v_err335 T1310)
(declare-const var_h154 T1309)
(declare-const var_h102 T1309)
(declare-const var_h46 T1309)
(declare-const err T1323)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1309)
(declare-fun sel (T1309 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T1309)
(declare-fun var_h154 () T1309)
(declare-fun var_h46 () T1309)
(declare-fun |20| () Int)
(declare-fun var__temp_h332 () T1309)
(declare-fun |var__temp_h'334| () T1309)
(declare-fun v () Int)
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h332 res) v) (= v |20|))
               (= (sel var__temp_h332 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'334| res) (+ (sel var__temp_h332 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h332 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************86
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i155 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i155, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v327:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h336 --->  Ty_heap  
 var__temp_v337 --->  Ty_int  
 var__temp_h'338 --->  Ty_heap  
 var__temp_v_err339 --->  error  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h336, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h336, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h336, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'338, res ) ==((sel)( , var__temp_h336, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i155 T1326)
(declare-const var_h154 T1326)
(declare-const v Int)
(declare-const var_h_i103 T1326)
(declare-const var_h102 T1326)
(declare-const v Int)
(declare-const var_h_i47 T1326)
(declare-const var_h46 T1326)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h336 T1326)
(declare-const var__temp_v337 Int)
(declare-const |var__temp_h'338| T1326)
(declare-const var__temp_v_err339 T1327)
(declare-const var_h154 T1326)
(declare-const var_h102 T1326)
(declare-const var_h46 T1326)
(declare-const err T1340)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1326)
(declare-fun sel (T1326 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T1326)
(declare-fun var_h154 () T1326)
(declare-fun var_h46 () T1326)
(declare-fun |20| () Int)
(declare-fun var__temp_h336 () T1326)
(declare-fun |var__temp_h'338| () T1326)
(declare-fun v () Int)
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h336 res) v) (= v |20|))
               (= (sel var__temp_h336 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'338| res) (+ (sel var__temp_h336 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h336 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************87
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i155 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i155, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v327:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h340 --->  Ty_heap  
 var__temp_v341 --->  Ty_int  
 var__temp_h'342 --->  Ty_heap  
 var__temp_v_err343 --->  error  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h340, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h340, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h340, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'342, res ) ==(var__temp_v341) AND 
 	 Base var__temp_v341 = 5 => 
 	 True
 
VC_END(declare-const var_h_i155 T1343)
(declare-const var_h154 T1343)
(declare-const v Int)
(declare-const var_h_i103 T1343)
(declare-const var_h102 T1343)
(declare-const v Int)
(declare-const var_h_i47 T1343)
(declare-const var_h46 T1343)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h340 T1343)
(declare-const var__temp_v341 Int)
(declare-const |var__temp_h'342| T1343)
(declare-const var__temp_v_err343 T1344)
(declare-const var_h154 T1343)
(declare-const var_h102 T1343)
(declare-const var_h46 T1343)
(declare-const err T1357)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T1343)
(declare-fun sel (T1343 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T1343)
(declare-fun var_h154 () T1343)
(declare-fun var_h46 () T1343)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_v341 () Int)
(declare-fun |var__temp_h'342| () T1343)
(declare-fun var__temp_h340 () T1343)
(declare-fun v () Int)
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h340 res) v) (= v |20|))
               (= (sel var__temp_h340 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'342| res) var__temp_v341)
                    (= var__temp_v341 |5|))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h340 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************88
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i155 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i155, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v327:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h344 --->  Ty_heap  
 var__temp_v345 --->  Ty_int  
 var__temp_h'346 --->  Ty_heap  
 var__temp_v_err347 --->  error  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h344, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h344, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h344, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'346, res ) ==((sel)( , var__temp_h344, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i155 T1360)
(declare-const var_h154 T1360)
(declare-const v Int)
(declare-const var_h_i103 T1360)
(declare-const var_h102 T1360)
(declare-const v Int)
(declare-const var_h_i47 T1360)
(declare-const var_h46 T1360)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h344 T1360)
(declare-const var__temp_v345 Int)
(declare-const |var__temp_h'346| T1360)
(declare-const var__temp_v_err347 T1361)
(declare-const var_h154 T1360)
(declare-const var_h102 T1360)
(declare-const var_h46 T1360)
(declare-const err T1374)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1360)
(declare-fun sel (T1360 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T1360)
(declare-fun var_h154 () T1360)
(declare-fun var_h46 () T1360)
(declare-fun |20| () Int)
(declare-fun var__temp_h344 () T1360)
(declare-fun |var__temp_h'346| () T1360)
(declare-fun v () Int)
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h344 res) v) (= v |20|))
               (= (sel var__temp_h344 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'346| res) (+ (sel var__temp_h344 res) 2))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h344 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************89
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i155 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i155, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v327:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h348 --->  Ty_heap  
 var__temp_v349 --->  Ty_int  
 var__temp_h'350 --->  Ty_heap  
 var__temp_v_err351 --->  error  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h348, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h348, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h348, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'350, res ) ==((sel)( , var__temp_h348, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i155 T1377)
(declare-const var_h154 T1377)
(declare-const v Int)
(declare-const var_h_i103 T1377)
(declare-const var_h102 T1377)
(declare-const v Int)
(declare-const var_h_i47 T1377)
(declare-const var_h46 T1377)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h348 T1377)
(declare-const var__temp_v349 Int)
(declare-const |var__temp_h'350| T1377)
(declare-const var__temp_v_err351 T1378)
(declare-const var_h154 T1377)
(declare-const var_h102 T1377)
(declare-const var_h46 T1377)
(declare-const err T1391)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1377)
(declare-fun sel (T1377 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T1377)
(declare-fun var_h154 () T1377)
(declare-fun var_h46 () T1377)
(declare-fun |20| () Int)
(declare-fun var__temp_h348 () T1377)
(declare-fun |var__temp_h'350| () T1377)
(declare-fun v () Int)
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h348 res) v) (= v |20|))
               (> (sel var__temp_h348 res) 4)))
      (a!2 (=> (= (sel |var__temp_h'350| res) (+ (sel var__temp_h348 res) 10))
               true)))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h348 res) 4) a!2))))
  (not a!3))))

***************Selection Successful************c2
PARTIAL PATH NEW
NEW 	 --c3'	 --c4	 --foo'	 --c2
post_substituted Forall 
 	 
 Key =var_h_i353 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i353 Value = Ty_heap{ (sel)( , var_h_i353, res ) ==((sel)( , var_h352, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v354:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i353 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
 *********************Enumeration Iteration*****************90
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i353 Value = Ty_heap{ (sel)( , var_h_i353, res ) ==((sel)( , var_h352, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v354:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i353 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i353 --->  Ty_heap  
 var_h352 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h355 --->  Ty_heap  
 var__temp_v356 --->  Ty_int  
 var__temp_h'357 --->  Ty_heap  
 var__temp_v_err358 --->  error  
 var_h352 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h352, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h355, res ) ==((sel)( , var_h352, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h355, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h355, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'357, res ) ==((sel)( , var__temp_h355, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'357, res ) ==(10)
 
VC_END(declare-const var_h_i353 T1394)
(declare-const var_h352 T1394)
(declare-const v Int)
(declare-const var_h_i155 T1394)
(declare-const var_h154 T1394)
(declare-const v Int)
(declare-const var_h_i103 T1394)
(declare-const var_h102 T1394)
(declare-const v Int)
(declare-const var_h_i47 T1394)
(declare-const var_h46 T1394)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h355 T1394)
(declare-const var__temp_v356 Int)
(declare-const |var__temp_h'357| T1394)
(declare-const var__temp_v_err358 T1395)
(declare-const var_h352 T1394)
(declare-const var_h154 T1394)
(declare-const var_h102 T1394)
(declare-const var_h46 T1394)
(declare-const err T1408)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1394)
(declare-fun v () Int)
(declare-fun sel (T1394 Int) Int)
(declare-fun res () Int)
(declare-fun var_h352 () T1394)
(declare-fun |20| () Int)
(declare-fun var_h102 () T1394)
(declare-fun var_h154 () T1394)
(declare-fun var_h46 () T1394)
(declare-fun |var__temp_h'357| () T1394)
(declare-fun var__temp_h355 () T1394)
(assert (= (sel var_h352 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h355 res) (+ (sel var_h352 res) 10))
               (= (sel var__temp_h355 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'357| res) (+ (sel var__temp_h355 res) 3))
               (= (sel |var__temp_h'357| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h355 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************91
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i353 Value = Ty_heap{ (sel)( , var_h_i353, res ) ==((sel)( , var_h352, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v354:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i353 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i353 --->  Ty_heap  
 var_h352 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h359 --->  Ty_heap  
 var__temp_v360 --->  Ty_int  
 var__temp_h'361 --->  Ty_heap  
 var__temp_v_err362 --->  error  
 var_h352 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h352, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h359, res ) ==((sel)( , var_h352, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h359, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h359, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'361, res ) ==((sel)( , var__temp_h359, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'361, res ) ==(10)
 
VC_END(declare-const var_h_i353 T1411)
(declare-const var_h352 T1411)
(declare-const v Int)
(declare-const var_h_i155 T1411)
(declare-const var_h154 T1411)
(declare-const v Int)
(declare-const var_h_i103 T1411)
(declare-const var_h102 T1411)
(declare-const v Int)
(declare-const var_h_i47 T1411)
(declare-const var_h46 T1411)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h359 T1411)
(declare-const var__temp_v360 Int)
(declare-const |var__temp_h'361| T1411)
(declare-const var__temp_v_err362 T1412)
(declare-const var_h352 T1411)
(declare-const var_h154 T1411)
(declare-const var_h102 T1411)
(declare-const var_h46 T1411)
(declare-const err T1425)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1411)
(declare-fun v () Int)
(declare-fun sel (T1411 Int) Int)
(declare-fun res () Int)
(declare-fun var_h352 () T1411)
(declare-fun |20| () Int)
(declare-fun var_h102 () T1411)
(declare-fun var_h154 () T1411)
(declare-fun var_h46 () T1411)
(declare-fun |var__temp_h'361| () T1411)
(declare-fun var__temp_h359 () T1411)
(assert (= (sel var_h352 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h359 res) (+ (sel var_h352 res) 10))
               (= (sel var__temp_h359 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'361| res) (+ (sel var__temp_h359 res) 5))
               (= (sel |var__temp_h'361| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h359 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************92
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i353 Value = Ty_heap{ (sel)( , var_h_i353, res ) ==((sel)( , var_h352, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v354:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i353 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i353 --->  Ty_heap  
 var_h352 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h363 --->  Ty_heap  
 var__temp_v364 --->  Ty_int  
 var__temp_h'365 --->  Ty_heap  
 var__temp_v_err366 --->  error  
 var_h352 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h352, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h363, res ) ==((sel)( , var_h352, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h363, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h363, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'365, res ) ==((sel)( , var__temp_h363, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'365, res ) ==(10)
 
VC_END(declare-const var_h_i353 T1428)
(declare-const var_h352 T1428)
(declare-const v Int)
(declare-const var_h_i155 T1428)
(declare-const var_h154 T1428)
(declare-const v Int)
(declare-const var_h_i103 T1428)
(declare-const var_h102 T1428)
(declare-const v Int)
(declare-const var_h_i47 T1428)
(declare-const var_h46 T1428)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h363 T1428)
(declare-const var__temp_v364 Int)
(declare-const |var__temp_h'365| T1428)
(declare-const var__temp_v_err366 T1429)
(declare-const var_h352 T1428)
(declare-const var_h154 T1428)
(declare-const var_h102 T1428)
(declare-const var_h46 T1428)
(declare-const err T1442)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1428)
(declare-fun v () Int)
(declare-fun sel (T1428 Int) Int)
(declare-fun res () Int)
(declare-fun var_h352 () T1428)
(declare-fun |20| () Int)
(declare-fun var_h102 () T1428)
(declare-fun var_h154 () T1428)
(declare-fun var_h46 () T1428)
(declare-fun |var__temp_h'365| () T1428)
(declare-fun var__temp_h363 () T1428)
(assert (= (sel var_h352 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h363 res) (+ (sel var_h352 res) 10))
               (= (sel var__temp_h363 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'365| res) (+ (sel var__temp_h363 res) 4))
               (= (sel |var__temp_h'365| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h363 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************93
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i353 Value = Ty_heap{ (sel)( , var_h_i353, res ) ==((sel)( , var_h352, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v354:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i353 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i353 --->  Ty_heap  
 var_h352 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h367 --->  Ty_heap  
 var__temp_v368 --->  Ty_int  
 var__temp_h'369 --->  Ty_heap  
 var__temp_v_err370 --->  error  
 var_h352 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h352, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h367, res ) ==((sel)( , var_h352, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h367, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h367, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'369, res ) ==(var__temp_v368) AND 
 	 Base var__temp_v368 = 5 => 
 	 Rel (sel)( , var__temp_h'369, res ) ==(10)
 
VC_END(declare-const var_h_i353 T1445)
(declare-const var_h352 T1445)
(declare-const v Int)
(declare-const var_h_i155 T1445)
(declare-const var_h154 T1445)
(declare-const v Int)
(declare-const var_h_i103 T1445)
(declare-const var_h102 T1445)
(declare-const v Int)
(declare-const var_h_i47 T1445)
(declare-const var_h46 T1445)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h367 T1445)
(declare-const var__temp_v368 Int)
(declare-const |var__temp_h'369| T1445)
(declare-const var__temp_v_err370 T1446)
(declare-const var_h352 T1445)
(declare-const var_h154 T1445)
(declare-const var_h102 T1445)
(declare-const var_h46 T1445)
(declare-const err T1459)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T1445)
(declare-fun v () Int)
(declare-fun sel (T1445 Int) Int)
(declare-fun res () Int)
(declare-fun var_h352 () T1445)
(declare-fun |20| () Int)
(declare-fun var_h102 () T1445)
(declare-fun var_h154 () T1445)
(declare-fun var_h46 () T1445)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'369| () T1445)
(declare-fun var__temp_v368 () Int)
(declare-fun var__temp_h367 () T1445)
(assert (= (sel var_h352 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h367 res) (+ (sel var_h352 res) 10))
               (= (sel var__temp_h367 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'369| res) var__temp_v368)
                    (= var__temp_v368 |5|))
               (= (sel |var__temp_h'369| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h367 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************94
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i353 Value = Ty_heap{ (sel)( , var_h_i353, res ) ==((sel)( , var_h352, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v354:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i353 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i353 --->  Ty_heap  
 var_h352 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h371 --->  Ty_heap  
 var__temp_v372 --->  Ty_int  
 var__temp_h'373 --->  Ty_heap  
 var__temp_v_err374 --->  error  
 var_h352 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h352, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h371, res ) ==((sel)( , var_h352, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h371, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h371, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'373, res ) ==((sel)( , var__temp_h371, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'373, res ) ==(10)
 
VC_END(declare-const var_h_i353 T1462)
(declare-const var_h352 T1462)
(declare-const v Int)
(declare-const var_h_i155 T1462)
(declare-const var_h154 T1462)
(declare-const v Int)
(declare-const var_h_i103 T1462)
(declare-const var_h102 T1462)
(declare-const v Int)
(declare-const var_h_i47 T1462)
(declare-const var_h46 T1462)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h371 T1462)
(declare-const var__temp_v372 Int)
(declare-const |var__temp_h'373| T1462)
(declare-const var__temp_v_err374 T1463)
(declare-const var_h352 T1462)
(declare-const var_h154 T1462)
(declare-const var_h102 T1462)
(declare-const var_h46 T1462)
(declare-const err T1476)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1462)
(declare-fun v () Int)
(declare-fun sel (T1462 Int) Int)
(declare-fun res () Int)
(declare-fun var_h352 () T1462)
(declare-fun |20| () Int)
(declare-fun var_h102 () T1462)
(declare-fun var_h154 () T1462)
(declare-fun var_h46 () T1462)
(declare-fun |var__temp_h'373| () T1462)
(declare-fun var__temp_h371 () T1462)
(assert (= (sel var_h352 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h371 res) (+ (sel var_h352 res) 10))
               (= (sel var__temp_h371 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'373| res) (+ (sel var__temp_h371 res) 2))
               (= (sel |var__temp_h'373| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h371 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************95
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v354:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v354:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2c2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --c4	 --foo'	 --c2
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i353 Value = Ty_heap{ (sel)( , var_h_i353, res ) ==((sel)( , var_h352, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v375:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
 *********************Enumeration Iteration*****************96
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i353 Value = Ty_heap{ (sel)( , var_h_i353, res ) ==((sel)( , var_h352, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v375:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i353 --->  Ty_heap  
 var_h352 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h376 --->  Ty_heap  
 var__temp_v377 --->  Ty_int  
 var__temp_h'378 --->  Ty_heap  
 var__temp_v_err379 --->  error  
 var_h352 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h352, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h376, res ) ==((sel)( , var_h352, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h376, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h376, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'378, res ) ==((sel)( , var__temp_h376, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i353 T1479)
(declare-const var_h352 T1479)
(declare-const v Int)
(declare-const var_h_i155 T1479)
(declare-const var_h154 T1479)
(declare-const v Int)
(declare-const var_h_i103 T1479)
(declare-const var_h102 T1479)
(declare-const v Int)
(declare-const var_h_i47 T1479)
(declare-const var_h46 T1479)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h376 T1479)
(declare-const var__temp_v377 Int)
(declare-const |var__temp_h'378| T1479)
(declare-const var__temp_v_err379 T1480)
(declare-const var_h352 T1479)
(declare-const var_h154 T1479)
(declare-const var_h102 T1479)
(declare-const var_h46 T1479)
(declare-const err T1493)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1479)
(declare-fun v () Int)
(declare-fun sel (T1479 Int) Int)
(declare-fun res () Int)
(declare-fun var_h352 () T1479)
(declare-fun |20| () Int)
(declare-fun var_h102 () T1479)
(declare-fun var_h154 () T1479)
(declare-fun var_h46 () T1479)
(declare-fun var__temp_h376 () T1479)
(declare-fun |var__temp_h'378| () T1479)
(assert (= (sel var_h352 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h376 res) (+ (sel var_h352 res) 10))
               (= (sel var__temp_h376 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'378| res) (+ (sel var__temp_h376 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h376 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************97
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i353 Value = Ty_heap{ (sel)( , var_h_i353, res ) ==((sel)( , var_h352, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v375:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i353 --->  Ty_heap  
 var_h352 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h380 --->  Ty_heap  
 var__temp_v381 --->  Ty_int  
 var__temp_h'382 --->  Ty_heap  
 var__temp_v_err383 --->  error  
 var_h352 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h352, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h380, res ) ==((sel)( , var_h352, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h380, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h380, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'382, res ) ==((sel)( , var__temp_h380, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i353 T1496)
(declare-const var_h352 T1496)
(declare-const v Int)
(declare-const var_h_i155 T1496)
(declare-const var_h154 T1496)
(declare-const v Int)
(declare-const var_h_i103 T1496)
(declare-const var_h102 T1496)
(declare-const v Int)
(declare-const var_h_i47 T1496)
(declare-const var_h46 T1496)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h380 T1496)
(declare-const var__temp_v381 Int)
(declare-const |var__temp_h'382| T1496)
(declare-const var__temp_v_err383 T1497)
(declare-const var_h352 T1496)
(declare-const var_h154 T1496)
(declare-const var_h102 T1496)
(declare-const var_h46 T1496)
(declare-const err T1510)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1496)
(declare-fun v () Int)
(declare-fun sel (T1496 Int) Int)
(declare-fun res () Int)
(declare-fun var_h352 () T1496)
(declare-fun |20| () Int)
(declare-fun var_h102 () T1496)
(declare-fun var_h154 () T1496)
(declare-fun var_h46 () T1496)
(declare-fun var__temp_h380 () T1496)
(declare-fun |var__temp_h'382| () T1496)
(assert (= (sel var_h352 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h380 res) (+ (sel var_h352 res) 10))
               (= (sel var__temp_h380 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'382| res) (+ (sel var__temp_h380 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h380 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************98
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i353 Value = Ty_heap{ (sel)( , var_h_i353, res ) ==((sel)( , var_h352, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v375:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i353 --->  Ty_heap  
 var_h352 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h384 --->  Ty_heap  
 var__temp_v385 --->  Ty_int  
 var__temp_h'386 --->  Ty_heap  
 var__temp_v_err387 --->  error  
 var_h352 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h352, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h384, res ) ==((sel)( , var_h352, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h384, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h384, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'386, res ) ==((sel)( , var__temp_h384, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i353 T1513)
(declare-const var_h352 T1513)
(declare-const v Int)
(declare-const var_h_i155 T1513)
(declare-const var_h154 T1513)
(declare-const v Int)
(declare-const var_h_i103 T1513)
(declare-const var_h102 T1513)
(declare-const v Int)
(declare-const var_h_i47 T1513)
(declare-const var_h46 T1513)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h384 T1513)
(declare-const var__temp_v385 Int)
(declare-const |var__temp_h'386| T1513)
(declare-const var__temp_v_err387 T1514)
(declare-const var_h352 T1513)
(declare-const var_h154 T1513)
(declare-const var_h102 T1513)
(declare-const var_h46 T1513)
(declare-const err T1527)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1513)
(declare-fun v () Int)
(declare-fun sel (T1513 Int) Int)
(declare-fun res () Int)
(declare-fun var_h352 () T1513)
(declare-fun |20| () Int)
(declare-fun var_h102 () T1513)
(declare-fun var_h154 () T1513)
(declare-fun var_h46 () T1513)
(declare-fun var__temp_h384 () T1513)
(declare-fun |var__temp_h'386| () T1513)
(assert (= (sel var_h352 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h384 res) (+ (sel var_h352 res) 10))
               (= (sel var__temp_h384 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'386| res) (+ (sel var__temp_h384 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h384 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************99
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i353 Value = Ty_heap{ (sel)( , var_h_i353, res ) ==((sel)( , var_h352, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v375:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i353 --->  Ty_heap  
 var_h352 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h388 --->  Ty_heap  
 var__temp_v389 --->  Ty_int  
 var__temp_h'390 --->  Ty_heap  
 var__temp_v_err391 --->  error  
 var_h352 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h352, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h388, res ) ==((sel)( , var_h352, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h388, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h388, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'390, res ) ==(var__temp_v389) AND 
 	 Base var__temp_v389 = 5 => 
 	 True
 
VC_END(declare-const var_h_i353 T1530)
(declare-const var_h352 T1530)
(declare-const v Int)
(declare-const var_h_i155 T1530)
(declare-const var_h154 T1530)
(declare-const v Int)
(declare-const var_h_i103 T1530)
(declare-const var_h102 T1530)
(declare-const v Int)
(declare-const var_h_i47 T1530)
(declare-const var_h46 T1530)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h388 T1530)
(declare-const var__temp_v389 Int)
(declare-const |var__temp_h'390| T1530)
(declare-const var__temp_v_err391 T1531)
(declare-const var_h352 T1530)
(declare-const var_h154 T1530)
(declare-const var_h102 T1530)
(declare-const var_h46 T1530)
(declare-const err T1544)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T1530)
(declare-fun v () Int)
(declare-fun sel (T1530 Int) Int)
(declare-fun res () Int)
(declare-fun var_h352 () T1530)
(declare-fun |20| () Int)
(declare-fun var_h102 () T1530)
(declare-fun var_h154 () T1530)
(declare-fun var_h46 () T1530)
(declare-fun |5| () Int)
(declare-fun var__temp_v389 () Int)
(declare-fun |var__temp_h'390| () T1530)
(declare-fun var__temp_h388 () T1530)
(assert (= (sel var_h352 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h388 res) (+ (sel var_h352 res) 10))
               (= (sel var__temp_h388 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'390| res) var__temp_v389)
                    (= var__temp_v389 |5|))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h388 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************100
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i353 Value = Ty_heap{ (sel)( , var_h_i353, res ) ==((sel)( , var_h352, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v375:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i353 --->  Ty_heap  
 var_h352 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h392 --->  Ty_heap  
 var__temp_v393 --->  Ty_int  
 var__temp_h'394 --->  Ty_heap  
 var__temp_v_err395 --->  error  
 var_h352 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h352, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h392, res ) ==((sel)( , var_h352, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h392, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h392, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'394, res ) ==((sel)( , var__temp_h392, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i353 T1547)
(declare-const var_h352 T1547)
(declare-const v Int)
(declare-const var_h_i155 T1547)
(declare-const var_h154 T1547)
(declare-const v Int)
(declare-const var_h_i103 T1547)
(declare-const var_h102 T1547)
(declare-const v Int)
(declare-const var_h_i47 T1547)
(declare-const var_h46 T1547)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h392 T1547)
(declare-const var__temp_v393 Int)
(declare-const |var__temp_h'394| T1547)
(declare-const var__temp_v_err395 T1548)
(declare-const var_h352 T1547)
(declare-const var_h154 T1547)
(declare-const var_h102 T1547)
(declare-const var_h46 T1547)
(declare-const err T1561)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1547)
(declare-fun v () Int)
(declare-fun sel (T1547 Int) Int)
(declare-fun res () Int)
(declare-fun var_h352 () T1547)
(declare-fun |20| () Int)
(declare-fun var_h102 () T1547)
(declare-fun var_h154 () T1547)
(declare-fun var_h46 () T1547)
(declare-fun var__temp_h392 () T1547)
(declare-fun |var__temp_h'394| () T1547)
(assert (= (sel var_h352 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h392 res) (+ (sel var_h352 res) 10))
               (= (sel var__temp_h392 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'394| res) (+ (sel var__temp_h392 res) 2))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h392 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************101
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 	 --c3'	 --c4	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i155 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i155, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v396:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
 *********************Enumeration Iteration*****************102
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i155 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i155, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v396:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h397 --->  Ty_heap  
 var__temp_v398 --->  Ty_int  
 var__temp_h'399 --->  Ty_heap  
 var__temp_v_err400 --->  error  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h397, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h397, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h397, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'399, res ) ==((sel)( , var__temp_h397, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i155 T1564)
(declare-const var_h154 T1564)
(declare-const v Int)
(declare-const var_h_i103 T1564)
(declare-const var_h102 T1564)
(declare-const v Int)
(declare-const var_h_i47 T1564)
(declare-const var_h46 T1564)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h397 T1564)
(declare-const var__temp_v398 Int)
(declare-const |var__temp_h'399| T1564)
(declare-const var__temp_v_err400 T1565)
(declare-const var_h154 T1564)
(declare-const var_h102 T1564)
(declare-const var_h46 T1564)
(declare-const err T1578)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1564)
(declare-fun sel (T1564 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T1564)
(declare-fun var_h154 () T1564)
(declare-fun var_h46 () T1564)
(declare-fun |20| () Int)
(declare-fun var__temp_h397 () T1564)
(declare-fun |var__temp_h'399| () T1564)
(declare-fun v () Int)
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h397 res) v) (= v |20|))
               (= (sel var__temp_h397 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'399| res) (+ (sel var__temp_h397 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h397 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************103
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i155 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i155, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v396:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h401 --->  Ty_heap  
 var__temp_v402 --->  Ty_int  
 var__temp_h'403 --->  Ty_heap  
 var__temp_v_err404 --->  error  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h401, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h401, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h401, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'403, res ) ==((sel)( , var__temp_h401, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i155 T1581)
(declare-const var_h154 T1581)
(declare-const v Int)
(declare-const var_h_i103 T1581)
(declare-const var_h102 T1581)
(declare-const v Int)
(declare-const var_h_i47 T1581)
(declare-const var_h46 T1581)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h401 T1581)
(declare-const var__temp_v402 Int)
(declare-const |var__temp_h'403| T1581)
(declare-const var__temp_v_err404 T1582)
(declare-const var_h154 T1581)
(declare-const var_h102 T1581)
(declare-const var_h46 T1581)
(declare-const err T1595)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1581)
(declare-fun sel (T1581 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T1581)
(declare-fun var_h154 () T1581)
(declare-fun var_h46 () T1581)
(declare-fun |20| () Int)
(declare-fun var__temp_h401 () T1581)
(declare-fun |var__temp_h'403| () T1581)
(declare-fun v () Int)
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h401 res) v) (= v |20|))
               (= (sel var__temp_h401 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'403| res) (+ (sel var__temp_h401 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h401 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************104
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i155 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i155, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v396:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h405 --->  Ty_heap  
 var__temp_v406 --->  Ty_int  
 var__temp_h'407 --->  Ty_heap  
 var__temp_v_err408 --->  error  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h405, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h405, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h405, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'407, res ) ==((sel)( , var__temp_h405, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i155 T1598)
(declare-const var_h154 T1598)
(declare-const v Int)
(declare-const var_h_i103 T1598)
(declare-const var_h102 T1598)
(declare-const v Int)
(declare-const var_h_i47 T1598)
(declare-const var_h46 T1598)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h405 T1598)
(declare-const var__temp_v406 Int)
(declare-const |var__temp_h'407| T1598)
(declare-const var__temp_v_err408 T1599)
(declare-const var_h154 T1598)
(declare-const var_h102 T1598)
(declare-const var_h46 T1598)
(declare-const err T1612)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1598)
(declare-fun sel (T1598 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T1598)
(declare-fun var_h154 () T1598)
(declare-fun var_h46 () T1598)
(declare-fun |20| () Int)
(declare-fun var__temp_h405 () T1598)
(declare-fun |var__temp_h'407| () T1598)
(declare-fun v () Int)
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h405 res) v) (= v |20|))
               (= (sel var__temp_h405 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'407| res) (+ (sel var__temp_h405 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h405 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************105
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i155 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i155, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v396:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h409 --->  Ty_heap  
 var__temp_v410 --->  Ty_int  
 var__temp_h'411 --->  Ty_heap  
 var__temp_v_err412 --->  error  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h409, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h409, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h409, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'411, res ) ==(var__temp_v410) AND 
 	 Base var__temp_v410 = 5 => 
 	 True
 
VC_END(declare-const var_h_i155 T1615)
(declare-const var_h154 T1615)
(declare-const v Int)
(declare-const var_h_i103 T1615)
(declare-const var_h102 T1615)
(declare-const v Int)
(declare-const var_h_i47 T1615)
(declare-const var_h46 T1615)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h409 T1615)
(declare-const var__temp_v410 Int)
(declare-const |var__temp_h'411| T1615)
(declare-const var__temp_v_err412 T1616)
(declare-const var_h154 T1615)
(declare-const var_h102 T1615)
(declare-const var_h46 T1615)
(declare-const err T1629)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T1615)
(declare-fun sel (T1615 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T1615)
(declare-fun var_h154 () T1615)
(declare-fun var_h46 () T1615)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_v410 () Int)
(declare-fun |var__temp_h'411| () T1615)
(declare-fun var__temp_h409 () T1615)
(declare-fun v () Int)
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h409 res) v) (= v |20|))
               (= (sel var__temp_h409 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'411| res) var__temp_v410)
                    (= var__temp_v410 |5|))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h409 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************106
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i155 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i155, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v396:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i155 --->  Ty_heap  
 var_h154 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h413 --->  Ty_heap  
 var__temp_v414 --->  Ty_int  
 var__temp_h'415 --->  Ty_heap  
 var__temp_v_err416 --->  error  
 var_h154 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h154, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h413, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h413, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h413, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'415, res ) ==((sel)( , var__temp_h413, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i155 T1632)
(declare-const var_h154 T1632)
(declare-const v Int)
(declare-const var_h_i103 T1632)
(declare-const var_h102 T1632)
(declare-const v Int)
(declare-const var_h_i47 T1632)
(declare-const var_h46 T1632)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h413 T1632)
(declare-const var__temp_v414 Int)
(declare-const |var__temp_h'415| T1632)
(declare-const var__temp_v_err416 T1633)
(declare-const var_h154 T1632)
(declare-const var_h102 T1632)
(declare-const var_h46 T1632)
(declare-const err T1646)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1632)
(declare-fun sel (T1632 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T1632)
(declare-fun var_h154 () T1632)
(declare-fun var_h46 () T1632)
(declare-fun |20| () Int)
(declare-fun var__temp_h413 () T1632)
(declare-fun |var__temp_h'415| () T1632)
(declare-fun v () Int)
(assert (= (sel var_h154 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h413 res) v) (= v |20|))
               (= (sel var__temp_h413 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'415| res) (+ (sel var__temp_h413 res) 2))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h413 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************107
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 	 --c3'	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v417:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
c2'
c2
 *********************Enumeration Iteration*****************108
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v417:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h418 --->  Ty_heap  
 var__temp_v419 --->  Ty_int  
 var__temp_h'420 --->  Ty_heap  
 var__temp_v_err421 --->  error  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h418, res ) ==((sel)( , var_h102, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h418, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h418, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'420, res ) ==((sel)( , var__temp_h418, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i103 T1649)
(declare-const var_h102 T1649)
(declare-const v Int)
(declare-const var_h_i47 T1649)
(declare-const var_h46 T1649)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h418 T1649)
(declare-const var__temp_v419 Int)
(declare-const |var__temp_h'420| T1649)
(declare-const var__temp_v_err421 T1650)
(declare-const var_h102 T1649)
(declare-const var_h46 T1649)
(declare-const err T1663)

solver 
 (declare-sort T1649)
(declare-fun sel (T1649 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T1649)
(declare-fun var_h102 () T1649)
(declare-fun var__temp_h418 () T1649)
(declare-fun |var__temp_h'420| () T1649)
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h418 res) (+ (sel var_h102 res) 6))
               (= (sel var__temp_h418 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'420| res) (+ (sel var__temp_h418 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h418 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************109
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v417:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h422 --->  Ty_heap  
 var__temp_v423 --->  Ty_int  
 var__temp_h'424 --->  Ty_heap  
 var__temp_v_err425 --->  error  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h422, res ) ==((sel)( , var_h102, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h422, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h422, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'424, res ) ==((sel)( , var__temp_h422, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i103 T1666)
(declare-const var_h102 T1666)
(declare-const v Int)
(declare-const var_h_i47 T1666)
(declare-const var_h46 T1666)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h422 T1666)
(declare-const var__temp_v423 Int)
(declare-const |var__temp_h'424| T1666)
(declare-const var__temp_v_err425 T1667)
(declare-const var_h102 T1666)
(declare-const var_h46 T1666)
(declare-const err T1680)

solver 
 (declare-sort T1666)
(declare-fun sel (T1666 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T1666)
(declare-fun var_h102 () T1666)
(declare-fun var__temp_h422 () T1666)
(declare-fun |var__temp_h'424| () T1666)
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h422 res) (+ (sel var_h102 res) 6))
               (= (sel var__temp_h422 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'424| res) (+ (sel var__temp_h422 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h422 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************110
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v417:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h426 --->  Ty_heap  
 var__temp_v427 --->  Ty_int  
 var__temp_h'428 --->  Ty_heap  
 var__temp_v_err429 --->  error  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h426, res ) ==((sel)( , var_h102, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h426, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h426, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'428, res ) ==((sel)( , var__temp_h426, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i103 T1683)
(declare-const var_h102 T1683)
(declare-const v Int)
(declare-const var_h_i47 T1683)
(declare-const var_h46 T1683)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h426 T1683)
(declare-const var__temp_v427 Int)
(declare-const |var__temp_h'428| T1683)
(declare-const var__temp_v_err429 T1684)
(declare-const var_h102 T1683)
(declare-const var_h46 T1683)
(declare-const err T1697)

solver 
 (declare-sort T1683)
(declare-fun sel (T1683 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T1683)
(declare-fun var_h102 () T1683)
(declare-fun var__temp_h426 () T1683)
(declare-fun |var__temp_h'428| () T1683)
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h426 res) (+ (sel var_h102 res) 6))
               (= (sel var__temp_h426 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'428| res) (+ (sel var__temp_h426 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h426 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************111
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v417:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h430 --->  Ty_heap  
 var__temp_v431 --->  Ty_int  
 var__temp_h'432 --->  Ty_heap  
 var__temp_v_err433 --->  error  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h430, res ) ==((sel)( , var_h102, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h430, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h430, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'432, res ) ==(var__temp_v431) AND 
 	 Base var__temp_v431 = 5 => 
 	 True
 
VC_END(declare-const var_h_i103 T1700)
(declare-const var_h102 T1700)
(declare-const v Int)
(declare-const var_h_i47 T1700)
(declare-const var_h46 T1700)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h430 T1700)
(declare-const var__temp_v431 Int)
(declare-const |var__temp_h'432| T1700)
(declare-const var__temp_v_err433 T1701)
(declare-const var_h102 T1700)
(declare-const var_h46 T1700)
(declare-const err T1714)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1700)
(declare-fun sel (T1700 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T1700)
(declare-fun var_h102 () T1700)
(declare-fun |5| () Int)
(declare-fun var__temp_v431 () Int)
(declare-fun |var__temp_h'432| () T1700)
(declare-fun var__temp_h430 () T1700)
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h430 res) (+ (sel var_h102 res) 6))
               (= (sel var__temp_h430 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'432| res) var__temp_v431)
                    (= var__temp_v431 |5|))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h430 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************112
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v417:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h434 --->  Ty_heap  
 var__temp_v435 --->  Ty_int  
 var__temp_h'436 --->  Ty_heap  
 var__temp_v_err437 --->  error  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h434, res ) ==((sel)( , var_h102, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h434, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h434, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'436, res ) ==((sel)( , var__temp_h434, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i103 T1717)
(declare-const var_h102 T1717)
(declare-const v Int)
(declare-const var_h_i47 T1717)
(declare-const var_h46 T1717)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h434 T1717)
(declare-const var__temp_v435 Int)
(declare-const |var__temp_h'436| T1717)
(declare-const var__temp_v_err437 T1718)
(declare-const var_h102 T1717)
(declare-const var_h46 T1717)
(declare-const err T1731)

solver 
 (declare-sort T1717)
(declare-fun sel (T1717 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T1717)
(declare-fun var_h102 () T1717)
(declare-fun var__temp_h434 () T1717)
(declare-fun |var__temp_h'436| () T1717)
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h434 res) (+ (sel var_h102 res) 6))
               (= (sel var__temp_h434 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'436| res) (+ (sel var__temp_h434 res) 2))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h434 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************113
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v417:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h438 --->  Ty_heap  
 var__temp_v439 --->  Ty_int  
 var__temp_h'440 --->  Ty_heap  
 var__temp_v_err441 --->  error  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h438, res ) ==((sel)( , var_h102, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h438, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h438, res ) > (20) => 
 	 Rel (sel)( , var__temp_h'440, res ) ==(sel)( , var__temp_h438, res ) => 
 	 True
 
VC_END(declare-const var_h_i103 T1734)
(declare-const var_h102 T1734)
(declare-const v Int)
(declare-const var_h_i47 T1734)
(declare-const var_h46 T1734)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h438 T1734)
(declare-const var__temp_v439 Int)
(declare-const |var__temp_h'440| T1734)
(declare-const var__temp_v_err441 T1735)
(declare-const var_h102 T1734)
(declare-const var_h46 T1734)
(declare-const err T1748)

solver 
 (declare-sort T1734)
(declare-fun sel (T1734 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T1734)
(declare-fun var_h102 () T1734)
(declare-fun var__temp_h438 () T1734)
(declare-fun |var__temp_h'440| () T1734)
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h438 res) (+ (sel var_h102 res) 6))
               (not (> (sel var__temp_h438 res) 20))))
      (a!2 (=> (not (> (sel var__temp_h438 res) 20))
               (=> (= (sel |var__temp_h'440| res) (sel var__temp_h438 res))
                   true))))
  (not (and a!1 a!2))))

***************Selection Successful************c2'
PARTIAL PATH NEW
NEW 	 --c3'	 --c4	 --c2'
post_substituted Forall 
 	 
 Key =var_h_i443 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i443 Value = Ty_heap{ (sel)( , var_h_i443, res ) ==(sel)( , var_h442, res ) } 
 } 
 
                                                RET :  Base {var_v444:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i443 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
c2
 *********************Enumeration Iteration*****************114
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i443 Value = Ty_heap{ (sel)( , var_h_i443, res ) ==(sel)( , var_h442, res ) } 
 } 
 
                                                RET :  Base {var_v444:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i443 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i443 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h445 --->  Ty_heap  
 var__temp_v446 --->  Ty_int  
 var__temp_h'447 --->  Ty_heap  
 var__temp_v_err448 --->  error  
 var_h442 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h442, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h445, res ) ==(sel)( , var_h442, res ) => 
 	 Rel (sel)( , var__temp_h445, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h445, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'447, res ) ==((sel)( , var__temp_h445, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'447, res ) ==(10)
 
VC_END(declare-const var_h_i443 T1751)
(declare-const var_h442 T1751)
(declare-const v Int)
(declare-const var_h_i103 T1751)
(declare-const var_h102 T1751)
(declare-const v Int)
(declare-const var_h_i47 T1751)
(declare-const var_h46 T1751)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h445 T1751)
(declare-const var__temp_v446 Int)
(declare-const |var__temp_h'447| T1751)
(declare-const var__temp_v_err448 T1752)
(declare-const var_h442 T1751)
(declare-const var_h102 T1751)
(declare-const var_h46 T1751)
(declare-const err T1765)

solver 
 (declare-sort T1751)
(declare-fun sel (T1751 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T1751)
(declare-fun var_h442 () T1751)
(declare-fun var_h46 () T1751)
(declare-fun |var__temp_h'447| () T1751)
(declare-fun var__temp_h445 () T1751)
(assert (= (sel var_h442 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'447| res) (+ (sel var__temp_h445 res) 3))
               (= (sel |var__temp_h'447| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h445 res) (sel var_h442 res))
                    (= (sel var__temp_h445 res) 7))
                (=> (= (sel var__temp_h445 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************115
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i443 Value = Ty_heap{ (sel)( , var_h_i443, res ) ==(sel)( , var_h442, res ) } 
 } 
 
                                                RET :  Base {var_v444:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i443 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i443 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h449 --->  Ty_heap  
 var__temp_v450 --->  Ty_int  
 var__temp_h'451 --->  Ty_heap  
 var__temp_v_err452 --->  error  
 var_h442 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h442, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h449, res ) ==(sel)( , var_h442, res ) => 
 	 Rel (sel)( , var__temp_h449, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h449, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'451, res ) ==((sel)( , var__temp_h449, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'451, res ) ==(10)
 
VC_END(declare-const var_h_i443 T1768)
(declare-const var_h442 T1768)
(declare-const v Int)
(declare-const var_h_i103 T1768)
(declare-const var_h102 T1768)
(declare-const v Int)
(declare-const var_h_i47 T1768)
(declare-const var_h46 T1768)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h449 T1768)
(declare-const var__temp_v450 Int)
(declare-const |var__temp_h'451| T1768)
(declare-const var__temp_v_err452 T1769)
(declare-const var_h442 T1768)
(declare-const var_h102 T1768)
(declare-const var_h46 T1768)
(declare-const err T1782)

solver 
 (declare-sort T1768)
(declare-fun sel (T1768 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T1768)
(declare-fun var_h442 () T1768)
(declare-fun var_h46 () T1768)
(declare-fun |var__temp_h'451| () T1768)
(declare-fun var__temp_h449 () T1768)
(assert (= (sel var_h442 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'451| res) (+ (sel var__temp_h449 res) 5))
               (= (sel |var__temp_h'451| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h449 res) (sel var_h442 res))
                    (= (sel var__temp_h449 res) 7))
                (=> (= (sel var__temp_h449 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************116
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i443 Value = Ty_heap{ (sel)( , var_h_i443, res ) ==(sel)( , var_h442, res ) } 
 } 
 
                                                RET :  Base {var_v444:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i443 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i443 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h453 --->  Ty_heap  
 var__temp_v454 --->  Ty_int  
 var__temp_h'455 --->  Ty_heap  
 var__temp_v_err456 --->  error  
 var_h442 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h442, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h453, res ) ==(sel)( , var_h442, res ) => 
 	 Rel (sel)( , var__temp_h453, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h453, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'455, res ) ==((sel)( , var__temp_h453, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'455, res ) ==(10)
 
VC_END(declare-const var_h_i443 T1785)
(declare-const var_h442 T1785)
(declare-const v Int)
(declare-const var_h_i103 T1785)
(declare-const var_h102 T1785)
(declare-const v Int)
(declare-const var_h_i47 T1785)
(declare-const var_h46 T1785)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h453 T1785)
(declare-const var__temp_v454 Int)
(declare-const |var__temp_h'455| T1785)
(declare-const var__temp_v_err456 T1786)
(declare-const var_h442 T1785)
(declare-const var_h102 T1785)
(declare-const var_h46 T1785)
(declare-const err T1799)

solver 
 (declare-sort T1785)
(declare-fun sel (T1785 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T1785)
(declare-fun var_h442 () T1785)
(declare-fun var_h46 () T1785)
(declare-fun |var__temp_h'455| () T1785)
(declare-fun var__temp_h453 () T1785)
(assert (= (sel var_h442 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'455| res) (+ (sel var__temp_h453 res) 4))
               (= (sel |var__temp_h'455| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h453 res) (sel var_h442 res))
                    (= (sel var__temp_h453 res) 6))
                (=> (= (sel var__temp_h453 res) 6) a!1))))
  (not a!2))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************117
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i443 Value = Ty_heap{ (sel)( , var_h_i443, res ) ==(sel)( , var_h442, res ) } 
 } 
 
                                                RET :  Base {var_v444:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i443 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i443 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h457 --->  Ty_heap  
 var__temp_v458 --->  Ty_int  
 var__temp_h'459 --->  Ty_heap  
 var__temp_v_err460 --->  error  
 var_h442 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h442, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h457, res ) ==(sel)( , var_h442, res ) => 
 	 Rel (sel)( , var__temp_h457, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h457, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'459, res ) ==(var__temp_v458) AND 
 	 Base var__temp_v458 = 5 => 
 	 Rel (sel)( , var__temp_h'459, res ) ==(10)
 
VC_END(declare-const var_h_i443 T1802)
(declare-const var_h442 T1802)
(declare-const v Int)
(declare-const var_h_i103 T1802)
(declare-const var_h102 T1802)
(declare-const v Int)
(declare-const var_h_i47 T1802)
(declare-const var_h46 T1802)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h457 T1802)
(declare-const var__temp_v458 Int)
(declare-const |var__temp_h'459| T1802)
(declare-const var__temp_v_err460 T1803)
(declare-const var_h442 T1802)
(declare-const var_h102 T1802)
(declare-const var_h46 T1802)
(declare-const err T1816)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1802)
(declare-fun sel (T1802 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T1802)
(declare-fun var_h442 () T1802)
(declare-fun var_h46 () T1802)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'459| () T1802)
(declare-fun var__temp_v458 () Int)
(declare-fun var__temp_h457 () T1802)
(assert (= (sel var_h442 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel |var__temp_h'459| res) var__temp_v458)
                    (= var__temp_v458 |5|))
               (= (sel |var__temp_h'459| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h457 res) (sel var_h442 res))
                    (= (sel var__temp_h457 res) 0))
                (=> (= (sel var__temp_h457 res) 0) a!1))))
  (not a!2))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************118
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i443 Value = Ty_heap{ (sel)( , var_h_i443, res ) ==(sel)( , var_h442, res ) } 
 } 
 
                                                RET :  Base {var_v444:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i443 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i443 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h461 --->  Ty_heap  
 var__temp_v462 --->  Ty_int  
 var__temp_h'463 --->  Ty_heap  
 var__temp_v_err464 --->  error  
 var_h442 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h442, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h461, res ) ==(sel)( , var_h442, res ) => 
 	 Rel (sel)( , var__temp_h461, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h461, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'463, res ) ==((sel)( , var__temp_h461, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'463, res ) ==(10)
 
VC_END(declare-const var_h_i443 T1819)
(declare-const var_h442 T1819)
(declare-const v Int)
(declare-const var_h_i103 T1819)
(declare-const var_h102 T1819)
(declare-const v Int)
(declare-const var_h_i47 T1819)
(declare-const var_h46 T1819)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h461 T1819)
(declare-const var__temp_v462 Int)
(declare-const |var__temp_h'463| T1819)
(declare-const var__temp_v_err464 T1820)
(declare-const var_h442 T1819)
(declare-const var_h102 T1819)
(declare-const var_h46 T1819)
(declare-const err T1833)

solver 
 (declare-sort T1819)
(declare-fun sel (T1819 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T1819)
(declare-fun var_h442 () T1819)
(declare-fun var_h46 () T1819)
(declare-fun |var__temp_h'463| () T1819)
(declare-fun var__temp_h461 () T1819)
(assert (= (sel var_h442 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'463| res) (+ (sel var__temp_h461 res) 2))
               (= (sel |var__temp_h'463| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h461 res) (sel var_h442 res))
                    (= (sel var__temp_h461 res) 5))
                (=> (= (sel var__temp_h461 res) 5) a!1))))
  (not a!2))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************119
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i443 Value = Ty_heap{ (sel)( , var_h_i443, res ) ==(sel)( , var_h442, res ) } 
 } 
 
                                                RET :  Base {var_v444:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i443 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i443 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h465 --->  Ty_heap  
 var__temp_v466 --->  Ty_int  
 var__temp_h'467 --->  Ty_heap  
 var__temp_v_err468 --->  error  
 var_h442 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h442, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h465, res ) ==(sel)( , var_h442, res ) => 
 	 Rel (sel)( , var__temp_h465, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h465, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'467, res ) ==((sel)( , var__temp_h465, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h'467, res ) ==(10)
 
VC_END(declare-const var_h_i443 T1836)
(declare-const var_h442 T1836)
(declare-const v Int)
(declare-const var_h_i103 T1836)
(declare-const var_h102 T1836)
(declare-const v Int)
(declare-const var_h_i47 T1836)
(declare-const var_h46 T1836)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h465 T1836)
(declare-const var__temp_v466 Int)
(declare-const |var__temp_h'467| T1836)
(declare-const var__temp_v_err468 T1837)
(declare-const var_h442 T1836)
(declare-const var_h102 T1836)
(declare-const var_h46 T1836)
(declare-const err T1850)

solver 
 (declare-sort T1836)
(declare-fun sel (T1836 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T1836)
(declare-fun var_h442 () T1836)
(declare-fun var_h46 () T1836)
(declare-fun |var__temp_h'467| () T1836)
(declare-fun var__temp_h465 () T1836)
(assert (= (sel var_h442 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'467| res) (+ (sel var__temp_h465 res) 10))
               (= (sel |var__temp_h'467| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h465 res) (sel var_h442 res))
                    (> (sel var__temp_h465 res) 4))
                (=> (> (sel var__temp_h465 res) 4) a!1))))
  (not a!2))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************120
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v444:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v444:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --c4	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i443 Value = Ty_heap{ (sel)( , var_h_i443, res ) ==(sel)( , var_h442, res ) } 
 } 
 
                                                RET :  Base {var_v469:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
c2
 *********************Enumeration Iteration*****************121
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i443 Value = Ty_heap{ (sel)( , var_h_i443, res ) ==(sel)( , var_h442, res ) } 
 } 
 
                                                RET :  Base {var_v469:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i443 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h470 --->  Ty_heap  
 var__temp_v471 --->  Ty_int  
 var__temp_h'472 --->  Ty_heap  
 var__temp_v_err473 --->  error  
 var_h442 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h442, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h470, res ) ==(sel)( , var_h442, res ) => 
 	 Rel (sel)( , var__temp_h470, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h470, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'472, res ) ==((sel)( , var__temp_h470, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i443 T1853)
(declare-const var_h442 T1853)
(declare-const v Int)
(declare-const var_h_i103 T1853)
(declare-const var_h102 T1853)
(declare-const v Int)
(declare-const var_h_i47 T1853)
(declare-const var_h46 T1853)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h470 T1853)
(declare-const var__temp_v471 Int)
(declare-const |var__temp_h'472| T1853)
(declare-const var__temp_v_err473 T1854)
(declare-const var_h442 T1853)
(declare-const var_h102 T1853)
(declare-const var_h46 T1853)
(declare-const err T1867)

solver 
 (declare-sort T1853)
(declare-fun sel (T1853 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T1853)
(declare-fun var_h442 () T1853)
(declare-fun var_h46 () T1853)
(declare-fun var__temp_h470 () T1853)
(declare-fun |var__temp_h'472| () T1853)
(assert (= (sel var_h442 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'472| res) (+ (sel var__temp_h470 res) 3))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h470 res) (sel var_h442 res))
                    (= (sel var__temp_h470 res) 7))
                (=> (= (sel var__temp_h470 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************122
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i443 Value = Ty_heap{ (sel)( , var_h_i443, res ) ==(sel)( , var_h442, res ) } 
 } 
 
                                                RET :  Base {var_v469:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i443 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h474 --->  Ty_heap  
 var__temp_v475 --->  Ty_int  
 var__temp_h'476 --->  Ty_heap  
 var__temp_v_err477 --->  error  
 var_h442 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h442, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h474, res ) ==(sel)( , var_h442, res ) => 
 	 Rel (sel)( , var__temp_h474, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h474, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'476, res ) ==((sel)( , var__temp_h474, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i443 T1870)
(declare-const var_h442 T1870)
(declare-const v Int)
(declare-const var_h_i103 T1870)
(declare-const var_h102 T1870)
(declare-const v Int)
(declare-const var_h_i47 T1870)
(declare-const var_h46 T1870)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h474 T1870)
(declare-const var__temp_v475 Int)
(declare-const |var__temp_h'476| T1870)
(declare-const var__temp_v_err477 T1871)
(declare-const var_h442 T1870)
(declare-const var_h102 T1870)
(declare-const var_h46 T1870)
(declare-const err T1884)

solver 
 (declare-sort T1870)
(declare-fun sel (T1870 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T1870)
(declare-fun var_h442 () T1870)
(declare-fun var_h46 () T1870)
(declare-fun var__temp_h474 () T1870)
(declare-fun |var__temp_h'476| () T1870)
(assert (= (sel var_h442 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'476| res) (+ (sel var__temp_h474 res) 5))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h474 res) (sel var_h442 res))
                    (= (sel var__temp_h474 res) 7))
                (=> (= (sel var__temp_h474 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************123
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i443 Value = Ty_heap{ (sel)( , var_h_i443, res ) ==(sel)( , var_h442, res ) } 
 } 
 
                                                RET :  Base {var_v469:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i443 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h478 --->  Ty_heap  
 var__temp_v479 --->  Ty_int  
 var__temp_h'480 --->  Ty_heap  
 var__temp_v_err481 --->  error  
 var_h442 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h442, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h478, res ) ==(sel)( , var_h442, res ) => 
 	 Rel (sel)( , var__temp_h478, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h478, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'480, res ) ==((sel)( , var__temp_h478, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i443 T1887)
(declare-const var_h442 T1887)
(declare-const v Int)
(declare-const var_h_i103 T1887)
(declare-const var_h102 T1887)
(declare-const v Int)
(declare-const var_h_i47 T1887)
(declare-const var_h46 T1887)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h478 T1887)
(declare-const var__temp_v479 Int)
(declare-const |var__temp_h'480| T1887)
(declare-const var__temp_v_err481 T1888)
(declare-const var_h442 T1887)
(declare-const var_h102 T1887)
(declare-const var_h46 T1887)
(declare-const err T1901)

solver 
 (declare-sort T1887)
(declare-fun sel (T1887 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T1887)
(declare-fun var_h442 () T1887)
(declare-fun var_h46 () T1887)
(declare-fun var__temp_h478 () T1887)
(declare-fun |var__temp_h'480| () T1887)
(assert (= (sel var_h442 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'480| res) (+ (sel var__temp_h478 res) 4))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h478 res) (sel var_h442 res))
                    (= (sel var__temp_h478 res) 6))
                (=> (= (sel var__temp_h478 res) 6) a!1))))
  (not a!2))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************124
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i443 Value = Ty_heap{ (sel)( , var_h_i443, res ) ==(sel)( , var_h442, res ) } 
 } 
 
                                                RET :  Base {var_v469:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i443 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h482 --->  Ty_heap  
 var__temp_v483 --->  Ty_int  
 var__temp_h'484 --->  Ty_heap  
 var__temp_v_err485 --->  error  
 var_h442 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h442, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h482, res ) ==(sel)( , var_h442, res ) => 
 	 Rel (sel)( , var__temp_h482, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h482, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'484, res ) ==(var__temp_v483) AND 
 	 Base var__temp_v483 = 5 => 
 	 True
 
VC_END(declare-const var_h_i443 T1904)
(declare-const var_h442 T1904)
(declare-const v Int)
(declare-const var_h_i103 T1904)
(declare-const var_h102 T1904)
(declare-const v Int)
(declare-const var_h_i47 T1904)
(declare-const var_h46 T1904)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h482 T1904)
(declare-const var__temp_v483 Int)
(declare-const |var__temp_h'484| T1904)
(declare-const var__temp_v_err485 T1905)
(declare-const var_h442 T1904)
(declare-const var_h102 T1904)
(declare-const var_h46 T1904)
(declare-const err T1918)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1904)
(declare-fun sel (T1904 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T1904)
(declare-fun var_h442 () T1904)
(declare-fun var_h46 () T1904)
(declare-fun |5| () Int)
(declare-fun var__temp_v483 () Int)
(declare-fun |var__temp_h'484| () T1904)
(declare-fun var__temp_h482 () T1904)
(assert (= (sel var_h442 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel |var__temp_h'484| res) var__temp_v483)
                    (= var__temp_v483 |5|))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h482 res) (sel var_h442 res))
                    (= (sel var__temp_h482 res) 0))
                (=> (= (sel var__temp_h482 res) 0) a!1))))
  (not a!2))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************125
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i443 Value = Ty_heap{ (sel)( , var_h_i443, res ) ==(sel)( , var_h442, res ) } 
 } 
 
                                                RET :  Base {var_v469:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i443 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h486 --->  Ty_heap  
 var__temp_v487 --->  Ty_int  
 var__temp_h'488 --->  Ty_heap  
 var__temp_v_err489 --->  error  
 var_h442 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h442, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h486, res ) ==(sel)( , var_h442, res ) => 
 	 Rel (sel)( , var__temp_h486, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h486, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'488, res ) ==((sel)( , var__temp_h486, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i443 T1921)
(declare-const var_h442 T1921)
(declare-const v Int)
(declare-const var_h_i103 T1921)
(declare-const var_h102 T1921)
(declare-const v Int)
(declare-const var_h_i47 T1921)
(declare-const var_h46 T1921)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h486 T1921)
(declare-const var__temp_v487 Int)
(declare-const |var__temp_h'488| T1921)
(declare-const var__temp_v_err489 T1922)
(declare-const var_h442 T1921)
(declare-const var_h102 T1921)
(declare-const var_h46 T1921)
(declare-const err T1935)

solver 
 (declare-sort T1921)
(declare-fun sel (T1921 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T1921)
(declare-fun var_h442 () T1921)
(declare-fun var_h46 () T1921)
(declare-fun var__temp_h486 () T1921)
(declare-fun |var__temp_h'488| () T1921)
(assert (= (sel var_h442 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'488| res) (+ (sel var__temp_h486 res) 2))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h486 res) (sel var_h442 res))
                    (= (sel var__temp_h486 res) 5))
                (=> (= (sel var__temp_h486 res) 5) a!1))))
  (not a!2))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************126
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i443 Value = Ty_heap{ (sel)( , var_h_i443, res ) ==(sel)( , var_h442, res ) } 
 } 
 
                                                RET :  Base {var_v469:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i443 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h490 --->  Ty_heap  
 var__temp_v491 --->  Ty_int  
 var__temp_h'492 --->  Ty_heap  
 var__temp_v_err493 --->  error  
 var_h442 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h442, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h490, res ) ==(sel)( , var_h442, res ) => 
 	 Rel (sel)( , var__temp_h490, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h490, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'492, res ) ==((sel)( , var__temp_h490, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i443 T1938)
(declare-const var_h442 T1938)
(declare-const v Int)
(declare-const var_h_i103 T1938)
(declare-const var_h102 T1938)
(declare-const v Int)
(declare-const var_h_i47 T1938)
(declare-const var_h46 T1938)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h490 T1938)
(declare-const var__temp_v491 Int)
(declare-const |var__temp_h'492| T1938)
(declare-const var__temp_v_err493 T1939)
(declare-const var_h442 T1938)
(declare-const var_h102 T1938)
(declare-const var_h46 T1938)
(declare-const err T1952)

solver 
 (declare-sort T1938)
(declare-fun sel (T1938 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T1938)
(declare-fun var_h442 () T1938)
(declare-fun var_h46 () T1938)
(declare-fun var__temp_h490 () T1938)
(declare-fun |var__temp_h'492| () T1938)
(assert (= (sel var_h442 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'492| res) (+ (sel var__temp_h490 res) 10))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h490 res) (sel var_h442 res))
                    (> (sel var__temp_h490 res) 4))
                (=> (> (sel var__temp_h490 res) 4) a!1))))
  (not a!2))))

***************Selection Successful************c2
PARTIAL PATH NEW
NEW 	 --c3'	 --c4	 --c2'	 --c2
post_substituted Forall 
 	 
 Key =var_h_i495 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i495 Value = Ty_heap{ (sel)( , var_h_i495, res ) ==((sel)( , var_h494, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v496:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i495 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
 *********************Enumeration Iteration*****************127
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i495 Value = Ty_heap{ (sel)( , var_h_i495, res ) ==((sel)( , var_h494, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v496:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i495 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i495 --->  Ty_heap  
 var_h494 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i443 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h497 --->  Ty_heap  
 var__temp_v498 --->  Ty_int  
 var__temp_h'499 --->  Ty_heap  
 var__temp_v_err500 --->  error  
 var_h494 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h494, res ) ==(sel)( , var_h442, res ) AND 
 	 Rel (sel)( , var_h442, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h497, res ) ==((sel)( , var_h494, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h497, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h497, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'499, res ) ==((sel)( , var__temp_h497, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'499, res ) ==(10)
 
VC_END(declare-const var_h_i495 T1955)
(declare-const var_h494 T1955)
(declare-const v Int)
(declare-const var_h_i443 T1955)
(declare-const var_h442 T1955)
(declare-const v Int)
(declare-const var_h_i103 T1955)
(declare-const var_h102 T1955)
(declare-const v Int)
(declare-const var_h_i47 T1955)
(declare-const var_h46 T1955)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h497 T1955)
(declare-const var__temp_v498 Int)
(declare-const |var__temp_h'499| T1955)
(declare-const var__temp_v_err500 T1956)
(declare-const var_h494 T1955)
(declare-const var_h442 T1955)
(declare-const var_h102 T1955)
(declare-const var_h46 T1955)
(declare-const err T1969)

solver 
 (declare-sort T1955)
(declare-fun sel (T1955 Int) Int)
(declare-fun res () Int)
(declare-fun var_h442 () T1955)
(declare-fun var_h494 () T1955)
(declare-fun var_h102 () T1955)
(declare-fun var_h46 () T1955)
(declare-fun |var__temp_h'499| () T1955)
(declare-fun var__temp_h497 () T1955)
(assert (= (sel var_h494 res) (sel var_h442 res)))
(assert (= (sel var_h442 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h497 res) (+ (sel var_h494 res) 10))
               (= (sel var__temp_h497 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'499| res) (+ (sel var__temp_h497 res) 3))
               (= (sel |var__temp_h'499| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h497 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************128
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i495 Value = Ty_heap{ (sel)( , var_h_i495, res ) ==((sel)( , var_h494, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v496:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i495 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i495 --->  Ty_heap  
 var_h494 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i443 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h501 --->  Ty_heap  
 var__temp_v502 --->  Ty_int  
 var__temp_h'503 --->  Ty_heap  
 var__temp_v_err504 --->  error  
 var_h494 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h494, res ) ==(sel)( , var_h442, res ) AND 
 	 Rel (sel)( , var_h442, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h501, res ) ==((sel)( , var_h494, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h501, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h501, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'503, res ) ==((sel)( , var__temp_h501, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'503, res ) ==(10)
 
VC_END(declare-const var_h_i495 T1972)
(declare-const var_h494 T1972)
(declare-const v Int)
(declare-const var_h_i443 T1972)
(declare-const var_h442 T1972)
(declare-const v Int)
(declare-const var_h_i103 T1972)
(declare-const var_h102 T1972)
(declare-const v Int)
(declare-const var_h_i47 T1972)
(declare-const var_h46 T1972)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h501 T1972)
(declare-const var__temp_v502 Int)
(declare-const |var__temp_h'503| T1972)
(declare-const var__temp_v_err504 T1973)
(declare-const var_h494 T1972)
(declare-const var_h442 T1972)
(declare-const var_h102 T1972)
(declare-const var_h46 T1972)
(declare-const err T1986)

solver 
 (declare-sort T1972)
(declare-fun sel (T1972 Int) Int)
(declare-fun res () Int)
(declare-fun var_h442 () T1972)
(declare-fun var_h494 () T1972)
(declare-fun var_h102 () T1972)
(declare-fun var_h46 () T1972)
(declare-fun |var__temp_h'503| () T1972)
(declare-fun var__temp_h501 () T1972)
(assert (= (sel var_h494 res) (sel var_h442 res)))
(assert (= (sel var_h442 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h501 res) (+ (sel var_h494 res) 10))
               (= (sel var__temp_h501 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'503| res) (+ (sel var__temp_h501 res) 5))
               (= (sel |var__temp_h'503| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h501 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************129
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i495 Value = Ty_heap{ (sel)( , var_h_i495, res ) ==((sel)( , var_h494, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v496:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i495 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i495 --->  Ty_heap  
 var_h494 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i443 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h505 --->  Ty_heap  
 var__temp_v506 --->  Ty_int  
 var__temp_h'507 --->  Ty_heap  
 var__temp_v_err508 --->  error  
 var_h494 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h494, res ) ==(sel)( , var_h442, res ) AND 
 	 Rel (sel)( , var_h442, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h505, res ) ==((sel)( , var_h494, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h505, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h505, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'507, res ) ==((sel)( , var__temp_h505, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'507, res ) ==(10)
 
VC_END(declare-const var_h_i495 T1989)
(declare-const var_h494 T1989)
(declare-const v Int)
(declare-const var_h_i443 T1989)
(declare-const var_h442 T1989)
(declare-const v Int)
(declare-const var_h_i103 T1989)
(declare-const var_h102 T1989)
(declare-const v Int)
(declare-const var_h_i47 T1989)
(declare-const var_h46 T1989)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h505 T1989)
(declare-const var__temp_v506 Int)
(declare-const |var__temp_h'507| T1989)
(declare-const var__temp_v_err508 T1990)
(declare-const var_h494 T1989)
(declare-const var_h442 T1989)
(declare-const var_h102 T1989)
(declare-const var_h46 T1989)
(declare-const err T2003)

solver 
 (declare-sort T1989)
(declare-fun sel (T1989 Int) Int)
(declare-fun res () Int)
(declare-fun var_h442 () T1989)
(declare-fun var_h494 () T1989)
(declare-fun var_h102 () T1989)
(declare-fun var_h46 () T1989)
(declare-fun |var__temp_h'507| () T1989)
(declare-fun var__temp_h505 () T1989)
(assert (= (sel var_h494 res) (sel var_h442 res)))
(assert (= (sel var_h442 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h505 res) (+ (sel var_h494 res) 10))
               (= (sel var__temp_h505 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'507| res) (+ (sel var__temp_h505 res) 4))
               (= (sel |var__temp_h'507| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h505 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************130
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i495 Value = Ty_heap{ (sel)( , var_h_i495, res ) ==((sel)( , var_h494, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v496:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i495 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i495 --->  Ty_heap  
 var_h494 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i443 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h509 --->  Ty_heap  
 var__temp_v510 --->  Ty_int  
 var__temp_h'511 --->  Ty_heap  
 var__temp_v_err512 --->  error  
 var_h494 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h494, res ) ==(sel)( , var_h442, res ) AND 
 	 Rel (sel)( , var_h442, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h509, res ) ==((sel)( , var_h494, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h509, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h509, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'511, res ) ==(var__temp_v510) AND 
 	 Base var__temp_v510 = 5 => 
 	 Rel (sel)( , var__temp_h'511, res ) ==(10)
 
VC_END(declare-const var_h_i495 T2006)
(declare-const var_h494 T2006)
(declare-const v Int)
(declare-const var_h_i443 T2006)
(declare-const var_h442 T2006)
(declare-const v Int)
(declare-const var_h_i103 T2006)
(declare-const var_h102 T2006)
(declare-const v Int)
(declare-const var_h_i47 T2006)
(declare-const var_h46 T2006)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h509 T2006)
(declare-const var__temp_v510 Int)
(declare-const |var__temp_h'511| T2006)
(declare-const var__temp_v_err512 T2007)
(declare-const var_h494 T2006)
(declare-const var_h442 T2006)
(declare-const var_h102 T2006)
(declare-const var_h46 T2006)
(declare-const err T2020)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2006)
(declare-fun sel (T2006 Int) Int)
(declare-fun res () Int)
(declare-fun var_h442 () T2006)
(declare-fun var_h494 () T2006)
(declare-fun var_h102 () T2006)
(declare-fun var_h46 () T2006)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'511| () T2006)
(declare-fun var__temp_v510 () Int)
(declare-fun var__temp_h509 () T2006)
(assert (= (sel var_h494 res) (sel var_h442 res)))
(assert (= (sel var_h442 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h509 res) (+ (sel var_h494 res) 10))
               (= (sel var__temp_h509 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'511| res) var__temp_v510)
                    (= var__temp_v510 |5|))
               (= (sel |var__temp_h'511| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h509 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************131
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i495 Value = Ty_heap{ (sel)( , var_h_i495, res ) ==((sel)( , var_h494, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v496:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i495 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i495 --->  Ty_heap  
 var_h494 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i443 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h513 --->  Ty_heap  
 var__temp_v514 --->  Ty_int  
 var__temp_h'515 --->  Ty_heap  
 var__temp_v_err516 --->  error  
 var_h494 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h494, res ) ==(sel)( , var_h442, res ) AND 
 	 Rel (sel)( , var_h442, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h513, res ) ==((sel)( , var_h494, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h513, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h513, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'515, res ) ==((sel)( , var__temp_h513, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'515, res ) ==(10)
 
VC_END(declare-const var_h_i495 T2023)
(declare-const var_h494 T2023)
(declare-const v Int)
(declare-const var_h_i443 T2023)
(declare-const var_h442 T2023)
(declare-const v Int)
(declare-const var_h_i103 T2023)
(declare-const var_h102 T2023)
(declare-const v Int)
(declare-const var_h_i47 T2023)
(declare-const var_h46 T2023)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h513 T2023)
(declare-const var__temp_v514 Int)
(declare-const |var__temp_h'515| T2023)
(declare-const var__temp_v_err516 T2024)
(declare-const var_h494 T2023)
(declare-const var_h442 T2023)
(declare-const var_h102 T2023)
(declare-const var_h46 T2023)
(declare-const err T2037)

solver 
 (declare-sort T2023)
(declare-fun sel (T2023 Int) Int)
(declare-fun res () Int)
(declare-fun var_h442 () T2023)
(declare-fun var_h494 () T2023)
(declare-fun var_h102 () T2023)
(declare-fun var_h46 () T2023)
(declare-fun |var__temp_h'515| () T2023)
(declare-fun var__temp_h513 () T2023)
(assert (= (sel var_h494 res) (sel var_h442 res)))
(assert (= (sel var_h442 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h513 res) (+ (sel var_h494 res) 10))
               (= (sel var__temp_h513 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'515| res) (+ (sel var__temp_h513 res) 2))
               (= (sel |var__temp_h'515| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h513 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************132
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v496:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v496:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2c2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --c4	 --c2'	 --c2
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i495 Value = Ty_heap{ (sel)( , var_h_i495, res ) ==((sel)( , var_h494, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v517:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
 *********************Enumeration Iteration*****************133
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i495 Value = Ty_heap{ (sel)( , var_h_i495, res ) ==((sel)( , var_h494, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v517:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i495 --->  Ty_heap  
 var_h494 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i443 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h518 --->  Ty_heap  
 var__temp_v519 --->  Ty_int  
 var__temp_h'520 --->  Ty_heap  
 var__temp_v_err521 --->  error  
 var_h494 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h494, res ) ==(sel)( , var_h442, res ) AND 
 	 Rel (sel)( , var_h442, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h518, res ) ==((sel)( , var_h494, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h518, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h518, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'520, res ) ==((sel)( , var__temp_h518, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i495 T2040)
(declare-const var_h494 T2040)
(declare-const v Int)
(declare-const var_h_i443 T2040)
(declare-const var_h442 T2040)
(declare-const v Int)
(declare-const var_h_i103 T2040)
(declare-const var_h102 T2040)
(declare-const v Int)
(declare-const var_h_i47 T2040)
(declare-const var_h46 T2040)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h518 T2040)
(declare-const var__temp_v519 Int)
(declare-const |var__temp_h'520| T2040)
(declare-const var__temp_v_err521 T2041)
(declare-const var_h494 T2040)
(declare-const var_h442 T2040)
(declare-const var_h102 T2040)
(declare-const var_h46 T2040)
(declare-const err T2054)

solver 
 (declare-sort T2040)
(declare-fun sel (T2040 Int) Int)
(declare-fun res () Int)
(declare-fun var_h442 () T2040)
(declare-fun var_h494 () T2040)
(declare-fun var_h102 () T2040)
(declare-fun var_h46 () T2040)
(declare-fun var__temp_h518 () T2040)
(declare-fun |var__temp_h'520| () T2040)
(assert (= (sel var_h494 res) (sel var_h442 res)))
(assert (= (sel var_h442 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h518 res) (+ (sel var_h494 res) 10))
               (= (sel var__temp_h518 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'520| res) (+ (sel var__temp_h518 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h518 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************134
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i495 Value = Ty_heap{ (sel)( , var_h_i495, res ) ==((sel)( , var_h494, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v517:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i495 --->  Ty_heap  
 var_h494 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i443 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h522 --->  Ty_heap  
 var__temp_v523 --->  Ty_int  
 var__temp_h'524 --->  Ty_heap  
 var__temp_v_err525 --->  error  
 var_h494 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h494, res ) ==(sel)( , var_h442, res ) AND 
 	 Rel (sel)( , var_h442, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h522, res ) ==((sel)( , var_h494, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h522, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h522, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'524, res ) ==((sel)( , var__temp_h522, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i495 T2057)
(declare-const var_h494 T2057)
(declare-const v Int)
(declare-const var_h_i443 T2057)
(declare-const var_h442 T2057)
(declare-const v Int)
(declare-const var_h_i103 T2057)
(declare-const var_h102 T2057)
(declare-const v Int)
(declare-const var_h_i47 T2057)
(declare-const var_h46 T2057)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h522 T2057)
(declare-const var__temp_v523 Int)
(declare-const |var__temp_h'524| T2057)
(declare-const var__temp_v_err525 T2058)
(declare-const var_h494 T2057)
(declare-const var_h442 T2057)
(declare-const var_h102 T2057)
(declare-const var_h46 T2057)
(declare-const err T2071)

solver 
 (declare-sort T2057)
(declare-fun sel (T2057 Int) Int)
(declare-fun res () Int)
(declare-fun var_h442 () T2057)
(declare-fun var_h494 () T2057)
(declare-fun var_h102 () T2057)
(declare-fun var_h46 () T2057)
(declare-fun var__temp_h522 () T2057)
(declare-fun |var__temp_h'524| () T2057)
(assert (= (sel var_h494 res) (sel var_h442 res)))
(assert (= (sel var_h442 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h522 res) (+ (sel var_h494 res) 10))
               (= (sel var__temp_h522 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'524| res) (+ (sel var__temp_h522 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h522 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************135
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i495 Value = Ty_heap{ (sel)( , var_h_i495, res ) ==((sel)( , var_h494, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v517:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i495 --->  Ty_heap  
 var_h494 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i443 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h526 --->  Ty_heap  
 var__temp_v527 --->  Ty_int  
 var__temp_h'528 --->  Ty_heap  
 var__temp_v_err529 --->  error  
 var_h494 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h494, res ) ==(sel)( , var_h442, res ) AND 
 	 Rel (sel)( , var_h442, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h526, res ) ==((sel)( , var_h494, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h526, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h526, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'528, res ) ==((sel)( , var__temp_h526, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i495 T2074)
(declare-const var_h494 T2074)
(declare-const v Int)
(declare-const var_h_i443 T2074)
(declare-const var_h442 T2074)
(declare-const v Int)
(declare-const var_h_i103 T2074)
(declare-const var_h102 T2074)
(declare-const v Int)
(declare-const var_h_i47 T2074)
(declare-const var_h46 T2074)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h526 T2074)
(declare-const var__temp_v527 Int)
(declare-const |var__temp_h'528| T2074)
(declare-const var__temp_v_err529 T2075)
(declare-const var_h494 T2074)
(declare-const var_h442 T2074)
(declare-const var_h102 T2074)
(declare-const var_h46 T2074)
(declare-const err T2088)

solver 
 (declare-sort T2074)
(declare-fun sel (T2074 Int) Int)
(declare-fun res () Int)
(declare-fun var_h442 () T2074)
(declare-fun var_h494 () T2074)
(declare-fun var_h102 () T2074)
(declare-fun var_h46 () T2074)
(declare-fun var__temp_h526 () T2074)
(declare-fun |var__temp_h'528| () T2074)
(assert (= (sel var_h494 res) (sel var_h442 res)))
(assert (= (sel var_h442 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h526 res) (+ (sel var_h494 res) 10))
               (= (sel var__temp_h526 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'528| res) (+ (sel var__temp_h526 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h526 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************136
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i495 Value = Ty_heap{ (sel)( , var_h_i495, res ) ==((sel)( , var_h494, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v517:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i495 --->  Ty_heap  
 var_h494 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i443 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h530 --->  Ty_heap  
 var__temp_v531 --->  Ty_int  
 var__temp_h'532 --->  Ty_heap  
 var__temp_v_err533 --->  error  
 var_h494 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h494, res ) ==(sel)( , var_h442, res ) AND 
 	 Rel (sel)( , var_h442, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h530, res ) ==((sel)( , var_h494, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h530, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h530, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'532, res ) ==(var__temp_v531) AND 
 	 Base var__temp_v531 = 5 => 
 	 True
 
VC_END(declare-const var_h_i495 T2091)
(declare-const var_h494 T2091)
(declare-const v Int)
(declare-const var_h_i443 T2091)
(declare-const var_h442 T2091)
(declare-const v Int)
(declare-const var_h_i103 T2091)
(declare-const var_h102 T2091)
(declare-const v Int)
(declare-const var_h_i47 T2091)
(declare-const var_h46 T2091)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h530 T2091)
(declare-const var__temp_v531 Int)
(declare-const |var__temp_h'532| T2091)
(declare-const var__temp_v_err533 T2092)
(declare-const var_h494 T2091)
(declare-const var_h442 T2091)
(declare-const var_h102 T2091)
(declare-const var_h46 T2091)
(declare-const err T2105)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2091)
(declare-fun sel (T2091 Int) Int)
(declare-fun res () Int)
(declare-fun var_h442 () T2091)
(declare-fun var_h494 () T2091)
(declare-fun var_h102 () T2091)
(declare-fun var_h46 () T2091)
(declare-fun |5| () Int)
(declare-fun var__temp_v531 () Int)
(declare-fun |var__temp_h'532| () T2091)
(declare-fun var__temp_h530 () T2091)
(assert (= (sel var_h494 res) (sel var_h442 res)))
(assert (= (sel var_h442 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h530 res) (+ (sel var_h494 res) 10))
               (= (sel var__temp_h530 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'532| res) var__temp_v531)
                    (= var__temp_v531 |5|))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h530 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************137
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i495 Value = Ty_heap{ (sel)( , var_h_i495, res ) ==((sel)( , var_h494, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v517:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i495 --->  Ty_heap  
 var_h494 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i443 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h534 --->  Ty_heap  
 var__temp_v535 --->  Ty_int  
 var__temp_h'536 --->  Ty_heap  
 var__temp_v_err537 --->  error  
 var_h494 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h494, res ) ==(sel)( , var_h442, res ) AND 
 	 Rel (sel)( , var_h442, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h534, res ) ==((sel)( , var_h494, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h534, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h534, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'536, res ) ==((sel)( , var__temp_h534, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i495 T2108)
(declare-const var_h494 T2108)
(declare-const v Int)
(declare-const var_h_i443 T2108)
(declare-const var_h442 T2108)
(declare-const v Int)
(declare-const var_h_i103 T2108)
(declare-const var_h102 T2108)
(declare-const v Int)
(declare-const var_h_i47 T2108)
(declare-const var_h46 T2108)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h534 T2108)
(declare-const var__temp_v535 Int)
(declare-const |var__temp_h'536| T2108)
(declare-const var__temp_v_err537 T2109)
(declare-const var_h494 T2108)
(declare-const var_h442 T2108)
(declare-const var_h102 T2108)
(declare-const var_h46 T2108)
(declare-const err T2122)

solver 
 (declare-sort T2108)
(declare-fun sel (T2108 Int) Int)
(declare-fun res () Int)
(declare-fun var_h442 () T2108)
(declare-fun var_h494 () T2108)
(declare-fun var_h102 () T2108)
(declare-fun var_h46 () T2108)
(declare-fun var__temp_h534 () T2108)
(declare-fun |var__temp_h'536| () T2108)
(assert (= (sel var_h494 res) (sel var_h442 res)))
(assert (= (sel var_h442 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h534 res) (+ (sel var_h494 res) 10))
               (= (sel var__temp_h534 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'536| res) (+ (sel var__temp_h534 res) 2))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h534 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************138
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 	 --c3'	 --c4	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i443 Value = Ty_heap{ (sel)( , var_h_i443, res ) ==(sel)( , var_h442, res ) } 
 } 
 
                                                RET :  Base {var_v538:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
 *********************Enumeration Iteration*****************139
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i443 Value = Ty_heap{ (sel)( , var_h_i443, res ) ==(sel)( , var_h442, res ) } 
 } 
 
                                                RET :  Base {var_v538:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i443 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h539 --->  Ty_heap  
 var__temp_v540 --->  Ty_int  
 var__temp_h'541 --->  Ty_heap  
 var__temp_v_err542 --->  error  
 var_h442 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h442, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h539, res ) ==(sel)( , var_h442, res ) => 
 	 Rel (sel)( , var__temp_h539, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h539, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'541, res ) ==((sel)( , var__temp_h539, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i443 T2125)
(declare-const var_h442 T2125)
(declare-const v Int)
(declare-const var_h_i103 T2125)
(declare-const var_h102 T2125)
(declare-const v Int)
(declare-const var_h_i47 T2125)
(declare-const var_h46 T2125)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h539 T2125)
(declare-const var__temp_v540 Int)
(declare-const |var__temp_h'541| T2125)
(declare-const var__temp_v_err542 T2126)
(declare-const var_h442 T2125)
(declare-const var_h102 T2125)
(declare-const var_h46 T2125)
(declare-const err T2139)

solver 
 (declare-sort T2125)
(declare-fun sel (T2125 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T2125)
(declare-fun var_h442 () T2125)
(declare-fun var_h46 () T2125)
(declare-fun var__temp_h539 () T2125)
(declare-fun |var__temp_h'541| () T2125)
(assert (= (sel var_h442 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'541| res) (+ (sel var__temp_h539 res) 3))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h539 res) (sel var_h442 res))
                    (= (sel var__temp_h539 res) 7))
                (=> (= (sel var__temp_h539 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************140
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i443 Value = Ty_heap{ (sel)( , var_h_i443, res ) ==(sel)( , var_h442, res ) } 
 } 
 
                                                RET :  Base {var_v538:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i443 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h543 --->  Ty_heap  
 var__temp_v544 --->  Ty_int  
 var__temp_h'545 --->  Ty_heap  
 var__temp_v_err546 --->  error  
 var_h442 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h442, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h543, res ) ==(sel)( , var_h442, res ) => 
 	 Rel (sel)( , var__temp_h543, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h543, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'545, res ) ==((sel)( , var__temp_h543, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i443 T2142)
(declare-const var_h442 T2142)
(declare-const v Int)
(declare-const var_h_i103 T2142)
(declare-const var_h102 T2142)
(declare-const v Int)
(declare-const var_h_i47 T2142)
(declare-const var_h46 T2142)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h543 T2142)
(declare-const var__temp_v544 Int)
(declare-const |var__temp_h'545| T2142)
(declare-const var__temp_v_err546 T2143)
(declare-const var_h442 T2142)
(declare-const var_h102 T2142)
(declare-const var_h46 T2142)
(declare-const err T2156)

solver 
 (declare-sort T2142)
(declare-fun sel (T2142 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T2142)
(declare-fun var_h442 () T2142)
(declare-fun var_h46 () T2142)
(declare-fun var__temp_h543 () T2142)
(declare-fun |var__temp_h'545| () T2142)
(assert (= (sel var_h442 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'545| res) (+ (sel var__temp_h543 res) 5))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h543 res) (sel var_h442 res))
                    (= (sel var__temp_h543 res) 7))
                (=> (= (sel var__temp_h543 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************141
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i443 Value = Ty_heap{ (sel)( , var_h_i443, res ) ==(sel)( , var_h442, res ) } 
 } 
 
                                                RET :  Base {var_v538:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i443 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h547 --->  Ty_heap  
 var__temp_v548 --->  Ty_int  
 var__temp_h'549 --->  Ty_heap  
 var__temp_v_err550 --->  error  
 var_h442 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h442, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h547, res ) ==(sel)( , var_h442, res ) => 
 	 Rel (sel)( , var__temp_h547, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h547, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'549, res ) ==((sel)( , var__temp_h547, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i443 T2159)
(declare-const var_h442 T2159)
(declare-const v Int)
(declare-const var_h_i103 T2159)
(declare-const var_h102 T2159)
(declare-const v Int)
(declare-const var_h_i47 T2159)
(declare-const var_h46 T2159)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h547 T2159)
(declare-const var__temp_v548 Int)
(declare-const |var__temp_h'549| T2159)
(declare-const var__temp_v_err550 T2160)
(declare-const var_h442 T2159)
(declare-const var_h102 T2159)
(declare-const var_h46 T2159)
(declare-const err T2173)

solver 
 (declare-sort T2159)
(declare-fun sel (T2159 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T2159)
(declare-fun var_h442 () T2159)
(declare-fun var_h46 () T2159)
(declare-fun var__temp_h547 () T2159)
(declare-fun |var__temp_h'549| () T2159)
(assert (= (sel var_h442 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'549| res) (+ (sel var__temp_h547 res) 4))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h547 res) (sel var_h442 res))
                    (= (sel var__temp_h547 res) 6))
                (=> (= (sel var__temp_h547 res) 6) a!1))))
  (not a!2))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************142
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i443 Value = Ty_heap{ (sel)( , var_h_i443, res ) ==(sel)( , var_h442, res ) } 
 } 
 
                                                RET :  Base {var_v538:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i443 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h551 --->  Ty_heap  
 var__temp_v552 --->  Ty_int  
 var__temp_h'553 --->  Ty_heap  
 var__temp_v_err554 --->  error  
 var_h442 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h442, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h551, res ) ==(sel)( , var_h442, res ) => 
 	 Rel (sel)( , var__temp_h551, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h551, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'553, res ) ==(var__temp_v552) AND 
 	 Base var__temp_v552 = 5 => 
 	 True
 
VC_END(declare-const var_h_i443 T2176)
(declare-const var_h442 T2176)
(declare-const v Int)
(declare-const var_h_i103 T2176)
(declare-const var_h102 T2176)
(declare-const v Int)
(declare-const var_h_i47 T2176)
(declare-const var_h46 T2176)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h551 T2176)
(declare-const var__temp_v552 Int)
(declare-const |var__temp_h'553| T2176)
(declare-const var__temp_v_err554 T2177)
(declare-const var_h442 T2176)
(declare-const var_h102 T2176)
(declare-const var_h46 T2176)
(declare-const err T2190)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2176)
(declare-fun sel (T2176 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T2176)
(declare-fun var_h442 () T2176)
(declare-fun var_h46 () T2176)
(declare-fun |5| () Int)
(declare-fun var__temp_v552 () Int)
(declare-fun |var__temp_h'553| () T2176)
(declare-fun var__temp_h551 () T2176)
(assert (= (sel var_h442 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel |var__temp_h'553| res) var__temp_v552)
                    (= var__temp_v552 |5|))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h551 res) (sel var_h442 res))
                    (= (sel var__temp_h551 res) 0))
                (=> (= (sel var__temp_h551 res) 0) a!1))))
  (not a!2))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************143
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i443 Value = Ty_heap{ (sel)( , var_h_i443, res ) ==(sel)( , var_h442, res ) } 
 } 
 
                                                RET :  Base {var_v538:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i443 --->  Ty_heap  
 var_h442 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h555 --->  Ty_heap  
 var__temp_v556 --->  Ty_int  
 var__temp_h'557 --->  Ty_heap  
 var__temp_v_err558 --->  error  
 var_h442 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h442, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h555, res ) ==(sel)( , var_h442, res ) => 
 	 Rel (sel)( , var__temp_h555, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h555, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'557, res ) ==((sel)( , var__temp_h555, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i443 T2193)
(declare-const var_h442 T2193)
(declare-const v Int)
(declare-const var_h_i103 T2193)
(declare-const var_h102 T2193)
(declare-const v Int)
(declare-const var_h_i47 T2193)
(declare-const var_h46 T2193)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h555 T2193)
(declare-const var__temp_v556 Int)
(declare-const |var__temp_h'557| T2193)
(declare-const var__temp_v_err558 T2194)
(declare-const var_h442 T2193)
(declare-const var_h102 T2193)
(declare-const var_h46 T2193)
(declare-const err T2207)

solver 
 (declare-sort T2193)
(declare-fun sel (T2193 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T2193)
(declare-fun var_h442 () T2193)
(declare-fun var_h46 () T2193)
(declare-fun var__temp_h555 () T2193)
(declare-fun |var__temp_h'557| () T2193)
(assert (= (sel var_h442 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'557| res) (+ (sel var__temp_h555 res) 2))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h555 res) (sel var_h442 res))
                    (= (sel var__temp_h555 res) 5))
                (=> (= (sel var__temp_h555 res) 5) a!1))))
  (not a!2))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************144
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 	 --c3'	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v559:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
c2
 *********************Enumeration Iteration*****************145
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v559:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h560 --->  Ty_heap  
 var__temp_v561 --->  Ty_int  
 var__temp_h'562 --->  Ty_heap  
 var__temp_v_err563 --->  error  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h560, res ) ==((sel)( , var_h102, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h560, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h560, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'562, res ) ==((sel)( , var__temp_h560, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i103 T2210)
(declare-const var_h102 T2210)
(declare-const v Int)
(declare-const var_h_i47 T2210)
(declare-const var_h46 T2210)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h560 T2210)
(declare-const var__temp_v561 Int)
(declare-const |var__temp_h'562| T2210)
(declare-const var__temp_v_err563 T2211)
(declare-const var_h102 T2210)
(declare-const var_h46 T2210)
(declare-const err T2224)

solver 
 (declare-sort T2210)
(declare-fun sel (T2210 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T2210)
(declare-fun var_h102 () T2210)
(declare-fun var__temp_h560 () T2210)
(declare-fun |var__temp_h'562| () T2210)
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h560 res) (+ (sel var_h102 res) 6))
               (= (sel var__temp_h560 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'562| res) (+ (sel var__temp_h560 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h560 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************146
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v559:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h564 --->  Ty_heap  
 var__temp_v565 --->  Ty_int  
 var__temp_h'566 --->  Ty_heap  
 var__temp_v_err567 --->  error  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h564, res ) ==((sel)( , var_h102, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h564, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h564, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'566, res ) ==((sel)( , var__temp_h564, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i103 T2227)
(declare-const var_h102 T2227)
(declare-const v Int)
(declare-const var_h_i47 T2227)
(declare-const var_h46 T2227)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h564 T2227)
(declare-const var__temp_v565 Int)
(declare-const |var__temp_h'566| T2227)
(declare-const var__temp_v_err567 T2228)
(declare-const var_h102 T2227)
(declare-const var_h46 T2227)
(declare-const err T2241)

solver 
 (declare-sort T2227)
(declare-fun sel (T2227 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T2227)
(declare-fun var_h102 () T2227)
(declare-fun var__temp_h564 () T2227)
(declare-fun |var__temp_h'566| () T2227)
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h564 res) (+ (sel var_h102 res) 6))
               (= (sel var__temp_h564 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'566| res) (+ (sel var__temp_h564 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h564 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************147
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v559:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h568 --->  Ty_heap  
 var__temp_v569 --->  Ty_int  
 var__temp_h'570 --->  Ty_heap  
 var__temp_v_err571 --->  error  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h568, res ) ==((sel)( , var_h102, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h568, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h568, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'570, res ) ==((sel)( , var__temp_h568, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i103 T2244)
(declare-const var_h102 T2244)
(declare-const v Int)
(declare-const var_h_i47 T2244)
(declare-const var_h46 T2244)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h568 T2244)
(declare-const var__temp_v569 Int)
(declare-const |var__temp_h'570| T2244)
(declare-const var__temp_v_err571 T2245)
(declare-const var_h102 T2244)
(declare-const var_h46 T2244)
(declare-const err T2258)

solver 
 (declare-sort T2244)
(declare-fun sel (T2244 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T2244)
(declare-fun var_h102 () T2244)
(declare-fun var__temp_h568 () T2244)
(declare-fun |var__temp_h'570| () T2244)
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h568 res) (+ (sel var_h102 res) 6))
               (= (sel var__temp_h568 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'570| res) (+ (sel var__temp_h568 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h568 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************148
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v559:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h572 --->  Ty_heap  
 var__temp_v573 --->  Ty_int  
 var__temp_h'574 --->  Ty_heap  
 var__temp_v_err575 --->  error  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h572, res ) ==((sel)( , var_h102, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h572, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h572, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'574, res ) ==(var__temp_v573) AND 
 	 Base var__temp_v573 = 5 => 
 	 True
 
VC_END(declare-const var_h_i103 T2261)
(declare-const var_h102 T2261)
(declare-const v Int)
(declare-const var_h_i47 T2261)
(declare-const var_h46 T2261)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h572 T2261)
(declare-const var__temp_v573 Int)
(declare-const |var__temp_h'574| T2261)
(declare-const var__temp_v_err575 T2262)
(declare-const var_h102 T2261)
(declare-const var_h46 T2261)
(declare-const err T2275)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2261)
(declare-fun sel (T2261 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T2261)
(declare-fun var_h102 () T2261)
(declare-fun |5| () Int)
(declare-fun var__temp_v573 () Int)
(declare-fun |var__temp_h'574| () T2261)
(declare-fun var__temp_h572 () T2261)
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h572 res) (+ (sel var_h102 res) 6))
               (= (sel var__temp_h572 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'574| res) var__temp_v573)
                    (= var__temp_v573 |5|))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h572 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************149
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v559:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h576 --->  Ty_heap  
 var__temp_v577 --->  Ty_int  
 var__temp_h'578 --->  Ty_heap  
 var__temp_v_err579 --->  error  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h576, res ) ==((sel)( , var_h102, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h576, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h576, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'578, res ) ==((sel)( , var__temp_h576, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i103 T2278)
(declare-const var_h102 T2278)
(declare-const v Int)
(declare-const var_h_i47 T2278)
(declare-const var_h46 T2278)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h576 T2278)
(declare-const var__temp_v577 Int)
(declare-const |var__temp_h'578| T2278)
(declare-const var__temp_v_err579 T2279)
(declare-const var_h102 T2278)
(declare-const var_h46 T2278)
(declare-const err T2292)

solver 
 (declare-sort T2278)
(declare-fun sel (T2278 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T2278)
(declare-fun var_h102 () T2278)
(declare-fun var__temp_h576 () T2278)
(declare-fun |var__temp_h'578| () T2278)
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h576 res) (+ (sel var_h102 res) 6))
               (= (sel var__temp_h576 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'578| res) (+ (sel var__temp_h576 res) 2))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h576 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************150
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v559:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h580 --->  Ty_heap  
 var__temp_v581 --->  Ty_int  
 var__temp_h'582 --->  Ty_heap  
 var__temp_v_err583 --->  error  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h580, res ) ==((sel)( , var_h102, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h580, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h580, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'582, res ) ==((sel)( , var__temp_h580, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i103 T2295)
(declare-const var_h102 T2295)
(declare-const v Int)
(declare-const var_h_i47 T2295)
(declare-const var_h46 T2295)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h580 T2295)
(declare-const var__temp_v581 Int)
(declare-const |var__temp_h'582| T2295)
(declare-const var__temp_v_err583 T2296)
(declare-const var_h102 T2295)
(declare-const var_h46 T2295)
(declare-const err T2309)

solver 
 (declare-sort T2295)
(declare-fun sel (T2295 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T2295)
(declare-fun var_h102 () T2295)
(declare-fun var__temp_h580 () T2295)
(declare-fun |var__temp_h'582| () T2295)
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h580 res) (+ (sel var_h102 res) 6))
               (> (sel var__temp_h580 res) 4)))
      (a!2 (=> (= (sel |var__temp_h'582| res) (+ (sel var__temp_h580 res) 10))
               true)))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h580 res) 4) a!2))))
  (not a!3))))

***************Selection Successful************c2
PARTIAL PATH NEW
NEW 	 --c3'	 --c4	 --c2
post_substituted Forall 
 	 
 Key =var_h_i585 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i585 Value = Ty_heap{ (sel)( , var_h_i585, res ) ==((sel)( , var_h584, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v586:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i585 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
 *********************Enumeration Iteration*****************151
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i585 Value = Ty_heap{ (sel)( , var_h_i585, res ) ==((sel)( , var_h584, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v586:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i585 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i585 --->  Ty_heap  
 var_h584 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h587 --->  Ty_heap  
 var__temp_v588 --->  Ty_int  
 var__temp_h'589 --->  Ty_heap  
 var__temp_v_err590 --->  error  
 var_h584 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h584, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h587, res ) ==((sel)( , var_h584, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h587, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h587, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'589, res ) ==((sel)( , var__temp_h587, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'589, res ) ==(10)
 
VC_END(declare-const var_h_i585 T2312)
(declare-const var_h584 T2312)
(declare-const v Int)
(declare-const var_h_i103 T2312)
(declare-const var_h102 T2312)
(declare-const v Int)
(declare-const var_h_i47 T2312)
(declare-const var_h46 T2312)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h587 T2312)
(declare-const var__temp_v588 Int)
(declare-const |var__temp_h'589| T2312)
(declare-const var__temp_v_err590 T2313)
(declare-const var_h584 T2312)
(declare-const var_h102 T2312)
(declare-const var_h46 T2312)
(declare-const err T2326)

solver 
 (declare-sort T2312)
(declare-fun sel (T2312 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T2312)
(declare-fun var_h584 () T2312)
(declare-fun var_h46 () T2312)
(declare-fun |var__temp_h'589| () T2312)
(declare-fun var__temp_h587 () T2312)
(assert (= (sel var_h584 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h587 res) (+ (sel var_h584 res) 10))
               (= (sel var__temp_h587 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'589| res) (+ (sel var__temp_h587 res) 3))
               (= (sel |var__temp_h'589| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h587 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************152
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i585 Value = Ty_heap{ (sel)( , var_h_i585, res ) ==((sel)( , var_h584, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v586:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i585 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i585 --->  Ty_heap  
 var_h584 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h591 --->  Ty_heap  
 var__temp_v592 --->  Ty_int  
 var__temp_h'593 --->  Ty_heap  
 var__temp_v_err594 --->  error  
 var_h584 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h584, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h591, res ) ==((sel)( , var_h584, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h591, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h591, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'593, res ) ==((sel)( , var__temp_h591, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'593, res ) ==(10)
 
VC_END(declare-const var_h_i585 T2329)
(declare-const var_h584 T2329)
(declare-const v Int)
(declare-const var_h_i103 T2329)
(declare-const var_h102 T2329)
(declare-const v Int)
(declare-const var_h_i47 T2329)
(declare-const var_h46 T2329)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h591 T2329)
(declare-const var__temp_v592 Int)
(declare-const |var__temp_h'593| T2329)
(declare-const var__temp_v_err594 T2330)
(declare-const var_h584 T2329)
(declare-const var_h102 T2329)
(declare-const var_h46 T2329)
(declare-const err T2343)

solver 
 (declare-sort T2329)
(declare-fun sel (T2329 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T2329)
(declare-fun var_h584 () T2329)
(declare-fun var_h46 () T2329)
(declare-fun |var__temp_h'593| () T2329)
(declare-fun var__temp_h591 () T2329)
(assert (= (sel var_h584 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h591 res) (+ (sel var_h584 res) 10))
               (= (sel var__temp_h591 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'593| res) (+ (sel var__temp_h591 res) 5))
               (= (sel |var__temp_h'593| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h591 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************153
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i585 Value = Ty_heap{ (sel)( , var_h_i585, res ) ==((sel)( , var_h584, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v586:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i585 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i585 --->  Ty_heap  
 var_h584 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h595 --->  Ty_heap  
 var__temp_v596 --->  Ty_int  
 var__temp_h'597 --->  Ty_heap  
 var__temp_v_err598 --->  error  
 var_h584 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h584, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h595, res ) ==((sel)( , var_h584, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h595, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h595, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'597, res ) ==((sel)( , var__temp_h595, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'597, res ) ==(10)
 
VC_END(declare-const var_h_i585 T2346)
(declare-const var_h584 T2346)
(declare-const v Int)
(declare-const var_h_i103 T2346)
(declare-const var_h102 T2346)
(declare-const v Int)
(declare-const var_h_i47 T2346)
(declare-const var_h46 T2346)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h595 T2346)
(declare-const var__temp_v596 Int)
(declare-const |var__temp_h'597| T2346)
(declare-const var__temp_v_err598 T2347)
(declare-const var_h584 T2346)
(declare-const var_h102 T2346)
(declare-const var_h46 T2346)
(declare-const err T2360)

solver 
 (declare-sort T2346)
(declare-fun sel (T2346 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T2346)
(declare-fun var_h584 () T2346)
(declare-fun var_h46 () T2346)
(declare-fun |var__temp_h'597| () T2346)
(declare-fun var__temp_h595 () T2346)
(assert (= (sel var_h584 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h595 res) (+ (sel var_h584 res) 10))
               (= (sel var__temp_h595 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'597| res) (+ (sel var__temp_h595 res) 4))
               (= (sel |var__temp_h'597| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h595 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************154
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i585 Value = Ty_heap{ (sel)( , var_h_i585, res ) ==((sel)( , var_h584, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v586:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i585 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i585 --->  Ty_heap  
 var_h584 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h599 --->  Ty_heap  
 var__temp_v600 --->  Ty_int  
 var__temp_h'601 --->  Ty_heap  
 var__temp_v_err602 --->  error  
 var_h584 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h584, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h599, res ) ==((sel)( , var_h584, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h599, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h599, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'601, res ) ==(var__temp_v600) AND 
 	 Base var__temp_v600 = 5 => 
 	 Rel (sel)( , var__temp_h'601, res ) ==(10)
 
VC_END(declare-const var_h_i585 T2363)
(declare-const var_h584 T2363)
(declare-const v Int)
(declare-const var_h_i103 T2363)
(declare-const var_h102 T2363)
(declare-const v Int)
(declare-const var_h_i47 T2363)
(declare-const var_h46 T2363)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h599 T2363)
(declare-const var__temp_v600 Int)
(declare-const |var__temp_h'601| T2363)
(declare-const var__temp_v_err602 T2364)
(declare-const var_h584 T2363)
(declare-const var_h102 T2363)
(declare-const var_h46 T2363)
(declare-const err T2377)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2363)
(declare-fun sel (T2363 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T2363)
(declare-fun var_h584 () T2363)
(declare-fun var_h46 () T2363)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'601| () T2363)
(declare-fun var__temp_v600 () Int)
(declare-fun var__temp_h599 () T2363)
(assert (= (sel var_h584 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h599 res) (+ (sel var_h584 res) 10))
               (= (sel var__temp_h599 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'601| res) var__temp_v600)
                    (= var__temp_v600 |5|))
               (= (sel |var__temp_h'601| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h599 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************155
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i585 Value = Ty_heap{ (sel)( , var_h_i585, res ) ==((sel)( , var_h584, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v586:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i585 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i585 --->  Ty_heap  
 var_h584 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h603 --->  Ty_heap  
 var__temp_v604 --->  Ty_int  
 var__temp_h'605 --->  Ty_heap  
 var__temp_v_err606 --->  error  
 var_h584 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h584, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h603, res ) ==((sel)( , var_h584, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h603, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h603, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'605, res ) ==((sel)( , var__temp_h603, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'605, res ) ==(10)
 
VC_END(declare-const var_h_i585 T2380)
(declare-const var_h584 T2380)
(declare-const v Int)
(declare-const var_h_i103 T2380)
(declare-const var_h102 T2380)
(declare-const v Int)
(declare-const var_h_i47 T2380)
(declare-const var_h46 T2380)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h603 T2380)
(declare-const var__temp_v604 Int)
(declare-const |var__temp_h'605| T2380)
(declare-const var__temp_v_err606 T2381)
(declare-const var_h584 T2380)
(declare-const var_h102 T2380)
(declare-const var_h46 T2380)
(declare-const err T2394)

solver 
 (declare-sort T2380)
(declare-fun sel (T2380 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T2380)
(declare-fun var_h584 () T2380)
(declare-fun var_h46 () T2380)
(declare-fun |var__temp_h'605| () T2380)
(declare-fun var__temp_h603 () T2380)
(assert (= (sel var_h584 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h603 res) (+ (sel var_h584 res) 10))
               (= (sel var__temp_h603 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'605| res) (+ (sel var__temp_h603 res) 2))
               (= (sel |var__temp_h'605| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h603 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************156
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v586:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v586:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2c2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --c4	 --c2
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i585 Value = Ty_heap{ (sel)( , var_h_i585, res ) ==((sel)( , var_h584, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v607:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
 *********************Enumeration Iteration*****************157
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i585 Value = Ty_heap{ (sel)( , var_h_i585, res ) ==((sel)( , var_h584, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v607:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i585 --->  Ty_heap  
 var_h584 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h608 --->  Ty_heap  
 var__temp_v609 --->  Ty_int  
 var__temp_h'610 --->  Ty_heap  
 var__temp_v_err611 --->  error  
 var_h584 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h584, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h608, res ) ==((sel)( , var_h584, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h608, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h608, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'610, res ) ==((sel)( , var__temp_h608, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i585 T2397)
(declare-const var_h584 T2397)
(declare-const v Int)
(declare-const var_h_i103 T2397)
(declare-const var_h102 T2397)
(declare-const v Int)
(declare-const var_h_i47 T2397)
(declare-const var_h46 T2397)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h608 T2397)
(declare-const var__temp_v609 Int)
(declare-const |var__temp_h'610| T2397)
(declare-const var__temp_v_err611 T2398)
(declare-const var_h584 T2397)
(declare-const var_h102 T2397)
(declare-const var_h46 T2397)
(declare-const err T2411)

solver 
 (declare-sort T2397)
(declare-fun sel (T2397 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T2397)
(declare-fun var_h584 () T2397)
(declare-fun var_h46 () T2397)
(declare-fun var__temp_h608 () T2397)
(declare-fun |var__temp_h'610| () T2397)
(assert (= (sel var_h584 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h608 res) (+ (sel var_h584 res) 10))
               (= (sel var__temp_h608 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'610| res) (+ (sel var__temp_h608 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h608 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************158
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i585 Value = Ty_heap{ (sel)( , var_h_i585, res ) ==((sel)( , var_h584, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v607:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i585 --->  Ty_heap  
 var_h584 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h612 --->  Ty_heap  
 var__temp_v613 --->  Ty_int  
 var__temp_h'614 --->  Ty_heap  
 var__temp_v_err615 --->  error  
 var_h584 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h584, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h612, res ) ==((sel)( , var_h584, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h612, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h612, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'614, res ) ==((sel)( , var__temp_h612, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i585 T2414)
(declare-const var_h584 T2414)
(declare-const v Int)
(declare-const var_h_i103 T2414)
(declare-const var_h102 T2414)
(declare-const v Int)
(declare-const var_h_i47 T2414)
(declare-const var_h46 T2414)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h612 T2414)
(declare-const var__temp_v613 Int)
(declare-const |var__temp_h'614| T2414)
(declare-const var__temp_v_err615 T2415)
(declare-const var_h584 T2414)
(declare-const var_h102 T2414)
(declare-const var_h46 T2414)
(declare-const err T2428)

solver 
 (declare-sort T2414)
(declare-fun sel (T2414 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T2414)
(declare-fun var_h584 () T2414)
(declare-fun var_h46 () T2414)
(declare-fun var__temp_h612 () T2414)
(declare-fun |var__temp_h'614| () T2414)
(assert (= (sel var_h584 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h612 res) (+ (sel var_h584 res) 10))
               (= (sel var__temp_h612 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'614| res) (+ (sel var__temp_h612 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h612 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************159
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i585 Value = Ty_heap{ (sel)( , var_h_i585, res ) ==((sel)( , var_h584, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v607:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i585 --->  Ty_heap  
 var_h584 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h616 --->  Ty_heap  
 var__temp_v617 --->  Ty_int  
 var__temp_h'618 --->  Ty_heap  
 var__temp_v_err619 --->  error  
 var_h584 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h584, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h616, res ) ==((sel)( , var_h584, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h616, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h616, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'618, res ) ==((sel)( , var__temp_h616, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i585 T2431)
(declare-const var_h584 T2431)
(declare-const v Int)
(declare-const var_h_i103 T2431)
(declare-const var_h102 T2431)
(declare-const v Int)
(declare-const var_h_i47 T2431)
(declare-const var_h46 T2431)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h616 T2431)
(declare-const var__temp_v617 Int)
(declare-const |var__temp_h'618| T2431)
(declare-const var__temp_v_err619 T2432)
(declare-const var_h584 T2431)
(declare-const var_h102 T2431)
(declare-const var_h46 T2431)
(declare-const err T2445)

solver 
 (declare-sort T2431)
(declare-fun sel (T2431 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T2431)
(declare-fun var_h584 () T2431)
(declare-fun var_h46 () T2431)
(declare-fun var__temp_h616 () T2431)
(declare-fun |var__temp_h'618| () T2431)
(assert (= (sel var_h584 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h616 res) (+ (sel var_h584 res) 10))
               (= (sel var__temp_h616 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'618| res) (+ (sel var__temp_h616 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h616 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************160
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i585 Value = Ty_heap{ (sel)( , var_h_i585, res ) ==((sel)( , var_h584, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v607:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i585 --->  Ty_heap  
 var_h584 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h620 --->  Ty_heap  
 var__temp_v621 --->  Ty_int  
 var__temp_h'622 --->  Ty_heap  
 var__temp_v_err623 --->  error  
 var_h584 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h584, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h620, res ) ==((sel)( , var_h584, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h620, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h620, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'622, res ) ==(var__temp_v621) AND 
 	 Base var__temp_v621 = 5 => 
 	 True
 
VC_END(declare-const var_h_i585 T2448)
(declare-const var_h584 T2448)
(declare-const v Int)
(declare-const var_h_i103 T2448)
(declare-const var_h102 T2448)
(declare-const v Int)
(declare-const var_h_i47 T2448)
(declare-const var_h46 T2448)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h620 T2448)
(declare-const var__temp_v621 Int)
(declare-const |var__temp_h'622| T2448)
(declare-const var__temp_v_err623 T2449)
(declare-const var_h584 T2448)
(declare-const var_h102 T2448)
(declare-const var_h46 T2448)
(declare-const err T2462)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2448)
(declare-fun sel (T2448 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T2448)
(declare-fun var_h584 () T2448)
(declare-fun var_h46 () T2448)
(declare-fun |5| () Int)
(declare-fun var__temp_v621 () Int)
(declare-fun |var__temp_h'622| () T2448)
(declare-fun var__temp_h620 () T2448)
(assert (= (sel var_h584 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h620 res) (+ (sel var_h584 res) 10))
               (= (sel var__temp_h620 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'622| res) var__temp_v621)
                    (= var__temp_v621 |5|))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h620 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************161
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i585 Value = Ty_heap{ (sel)( , var_h_i585, res ) ==((sel)( , var_h584, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v607:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i585 --->  Ty_heap  
 var_h584 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h624 --->  Ty_heap  
 var__temp_v625 --->  Ty_int  
 var__temp_h'626 --->  Ty_heap  
 var__temp_v_err627 --->  error  
 var_h584 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h584, res ) ==((sel)( , var_h102, res ) + (6)) AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h624, res ) ==((sel)( , var_h584, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h624, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h624, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'626, res ) ==((sel)( , var__temp_h624, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i585 T2465)
(declare-const var_h584 T2465)
(declare-const v Int)
(declare-const var_h_i103 T2465)
(declare-const var_h102 T2465)
(declare-const v Int)
(declare-const var_h_i47 T2465)
(declare-const var_h46 T2465)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h624 T2465)
(declare-const var__temp_v625 Int)
(declare-const |var__temp_h'626| T2465)
(declare-const var__temp_v_err627 T2466)
(declare-const var_h584 T2465)
(declare-const var_h102 T2465)
(declare-const var_h46 T2465)
(declare-const err T2479)

solver 
 (declare-sort T2465)
(declare-fun sel (T2465 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T2465)
(declare-fun var_h584 () T2465)
(declare-fun var_h46 () T2465)
(declare-fun var__temp_h624 () T2465)
(declare-fun |var__temp_h'626| () T2465)
(assert (= (sel var_h584 res) (+ (sel var_h102 res) 6)))
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h624 res) (+ (sel var_h584 res) 10))
               (= (sel var__temp_h624 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'626| res) (+ (sel var__temp_h624 res) 2))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h624 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************162
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 	 --c3'	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v628:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
 *********************Enumeration Iteration*****************163
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v628:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h629 --->  Ty_heap  
 var__temp_v630 --->  Ty_int  
 var__temp_h'631 --->  Ty_heap  
 var__temp_v_err632 --->  error  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h629, res ) ==((sel)( , var_h102, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h629, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h629, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'631, res ) ==((sel)( , var__temp_h629, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i103 T2482)
(declare-const var_h102 T2482)
(declare-const v Int)
(declare-const var_h_i47 T2482)
(declare-const var_h46 T2482)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h629 T2482)
(declare-const var__temp_v630 Int)
(declare-const |var__temp_h'631| T2482)
(declare-const var__temp_v_err632 T2483)
(declare-const var_h102 T2482)
(declare-const var_h46 T2482)
(declare-const err T2496)

solver 
 (declare-sort T2482)
(declare-fun sel (T2482 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T2482)
(declare-fun var_h102 () T2482)
(declare-fun var__temp_h629 () T2482)
(declare-fun |var__temp_h'631| () T2482)
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h629 res) (+ (sel var_h102 res) 6))
               (= (sel var__temp_h629 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'631| res) (+ (sel var__temp_h629 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h629 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************164
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v628:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h633 --->  Ty_heap  
 var__temp_v634 --->  Ty_int  
 var__temp_h'635 --->  Ty_heap  
 var__temp_v_err636 --->  error  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h633, res ) ==((sel)( , var_h102, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h633, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h633, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'635, res ) ==((sel)( , var__temp_h633, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i103 T2499)
(declare-const var_h102 T2499)
(declare-const v Int)
(declare-const var_h_i47 T2499)
(declare-const var_h46 T2499)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h633 T2499)
(declare-const var__temp_v634 Int)
(declare-const |var__temp_h'635| T2499)
(declare-const var__temp_v_err636 T2500)
(declare-const var_h102 T2499)
(declare-const var_h46 T2499)
(declare-const err T2513)

solver 
 (declare-sort T2499)
(declare-fun sel (T2499 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T2499)
(declare-fun var_h102 () T2499)
(declare-fun var__temp_h633 () T2499)
(declare-fun |var__temp_h'635| () T2499)
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h633 res) (+ (sel var_h102 res) 6))
               (= (sel var__temp_h633 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'635| res) (+ (sel var__temp_h633 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h633 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************165
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v628:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h637 --->  Ty_heap  
 var__temp_v638 --->  Ty_int  
 var__temp_h'639 --->  Ty_heap  
 var__temp_v_err640 --->  error  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h637, res ) ==((sel)( , var_h102, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h637, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h637, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'639, res ) ==((sel)( , var__temp_h637, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i103 T2516)
(declare-const var_h102 T2516)
(declare-const v Int)
(declare-const var_h_i47 T2516)
(declare-const var_h46 T2516)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h637 T2516)
(declare-const var__temp_v638 Int)
(declare-const |var__temp_h'639| T2516)
(declare-const var__temp_v_err640 T2517)
(declare-const var_h102 T2516)
(declare-const var_h46 T2516)
(declare-const err T2530)

solver 
 (declare-sort T2516)
(declare-fun sel (T2516 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T2516)
(declare-fun var_h102 () T2516)
(declare-fun var__temp_h637 () T2516)
(declare-fun |var__temp_h'639| () T2516)
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h637 res) (+ (sel var_h102 res) 6))
               (= (sel var__temp_h637 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'639| res) (+ (sel var__temp_h637 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h637 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************166
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v628:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h641 --->  Ty_heap  
 var__temp_v642 --->  Ty_int  
 var__temp_h'643 --->  Ty_heap  
 var__temp_v_err644 --->  error  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h641, res ) ==((sel)( , var_h102, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h641, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h641, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'643, res ) ==(var__temp_v642) AND 
 	 Base var__temp_v642 = 5 => 
 	 True
 
VC_END(declare-const var_h_i103 T2533)
(declare-const var_h102 T2533)
(declare-const v Int)
(declare-const var_h_i47 T2533)
(declare-const var_h46 T2533)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h641 T2533)
(declare-const var__temp_v642 Int)
(declare-const |var__temp_h'643| T2533)
(declare-const var__temp_v_err644 T2534)
(declare-const var_h102 T2533)
(declare-const var_h46 T2533)
(declare-const err T2547)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2533)
(declare-fun sel (T2533 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T2533)
(declare-fun var_h102 () T2533)
(declare-fun |5| () Int)
(declare-fun var__temp_v642 () Int)
(declare-fun |var__temp_h'643| () T2533)
(declare-fun var__temp_h641 () T2533)
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h641 res) (+ (sel var_h102 res) 6))
               (= (sel var__temp_h641 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'643| res) var__temp_v642)
                    (= var__temp_v642 |5|))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h641 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************167
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v628:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h645 --->  Ty_heap  
 var__temp_v646 --->  Ty_int  
 var__temp_h'647 --->  Ty_heap  
 var__temp_v_err648 --->  error  
 var_h102 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h102, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h645, res ) ==((sel)( , var_h102, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h645, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h645, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'647, res ) ==((sel)( , var__temp_h645, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i103 T2550)
(declare-const var_h102 T2550)
(declare-const v Int)
(declare-const var_h_i47 T2550)
(declare-const var_h46 T2550)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h645 T2550)
(declare-const var__temp_v646 Int)
(declare-const |var__temp_h'647| T2550)
(declare-const var__temp_v_err648 T2551)
(declare-const var_h102 T2550)
(declare-const var_h46 T2550)
(declare-const err T2564)

solver 
 (declare-sort T2550)
(declare-fun sel (T2550 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T2550)
(declare-fun var_h102 () T2550)
(declare-fun var__temp_h645 () T2550)
(declare-fun |var__temp_h'647| () T2550)
(assert (= (sel var_h102 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h645 res) (+ (sel var_h102 res) 6))
               (= (sel var__temp_h645 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'647| res) (+ (sel var__temp_h645 res) 2))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h645 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************168
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v649:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo'
foo
bar
c2'
c2
 *********************Enumeration Iteration*****************169
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v649:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h650 --->  Ty_heap  
 var__temp_v651 --->  Ty_int  
 var__temp_h'652 --->  Ty_heap  
 var__temp_v_err653 --->  error  
 var_h46 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h650, res ) ==((sel)( , var_h46, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h650, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h650, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'652, res ) ==((sel)( , var__temp_h650, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i47 T2567)
(declare-const var_h46 T2567)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h650 T2567)
(declare-const var__temp_v651 Int)
(declare-const |var__temp_h'652| T2567)
(declare-const var__temp_v_err653 T2568)
(declare-const var_h46 T2567)
(declare-const err T2581)

solver 
 (declare-sort T2567)
(declare-fun sel (T2567 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T2567)
(declare-fun var__temp_h650 () T2567)
(declare-fun |var__temp_h'652| () T2567)
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h650 res) (+ (sel var_h46 res) 3))
               (= (sel var__temp_h650 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'652| res) (+ (sel var__temp_h650 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h650 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************170
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v649:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h654 --->  Ty_heap  
 var__temp_v655 --->  Ty_int  
 var__temp_h'656 --->  Ty_heap  
 var__temp_v_err657 --->  error  
 var_h46 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h654, res ) ==((sel)( , var_h46, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h654, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h654, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'656, res ) ==((sel)( , var__temp_h654, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i47 T2584)
(declare-const var_h46 T2584)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h654 T2584)
(declare-const var__temp_v655 Int)
(declare-const |var__temp_h'656| T2584)
(declare-const var__temp_v_err657 T2585)
(declare-const var_h46 T2584)
(declare-const err T2598)

solver 
 (declare-sort T2584)
(declare-fun sel (T2584 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T2584)
(declare-fun var__temp_h654 () T2584)
(declare-fun |var__temp_h'656| () T2584)
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h654 res) (+ (sel var_h46 res) 3))
               (= (sel var__temp_h654 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'656| res) (+ (sel var__temp_h654 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h654 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************171
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v649:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h658 --->  Ty_heap  
 var__temp_v659 --->  Ty_int  
 var__temp_h'660 --->  Ty_heap  
 var__temp_v_err661 --->  error  
 var_h46 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h658, res ) ==((sel)( , var_h46, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h658, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h658, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'660, res ) ==((sel)( , var__temp_h658, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i47 T2601)
(declare-const var_h46 T2601)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h658 T2601)
(declare-const var__temp_v659 Int)
(declare-const |var__temp_h'660| T2601)
(declare-const var__temp_v_err661 T2602)
(declare-const var_h46 T2601)
(declare-const err T2615)

solver 
 (declare-sort T2601)
(declare-fun sel (T2601 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T2601)
(declare-fun var__temp_h658 () T2601)
(declare-fun |var__temp_h'660| () T2601)
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h658 res) (+ (sel var_h46 res) 3))
               (= (sel var__temp_h658 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'660| res) (+ (sel var__temp_h658 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h658 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************172
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 20} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v649:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h662 --->  Ty_heap  
 var__temp_v663 --->  Ty_int  
 var__temp_h'664 --->  Ty_heap  
 var__temp_v_err665 --->  error  
 var_h46 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h662, res ) ==((sel)( , var_h46, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h662, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h662, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'664, res ) ==(var__temp_v663) AND 
 	 Base var__temp_v663 = 20 => 
 	 True
 
VC_END(declare-const var_h_i47 T2618)
(declare-const var_h46 T2618)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h662 T2618)
(declare-const var__temp_v663 Int)
(declare-const |var__temp_h'664| T2618)
(declare-const var__temp_v_err665 T2619)
(declare-const var_h46 T2618)
(declare-const err T2632)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2618)
(declare-fun sel (T2618 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T2618)
(declare-fun |20| () Int)
(declare-fun var__temp_v663 () Int)
(declare-fun |var__temp_h'664| () T2618)
(declare-fun var__temp_h662 () T2618)
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (= (sel var__temp_h662 res) (+ (sel var_h46 res) 3))
               (not (> (sel var__temp_h662 res) 20))))
      (a!2 (=> (and (= (sel |var__temp_h'664| res) var__temp_v663)
                    (= var__temp_v663 |20|))
               true)))
(let ((a!3 (=> (not (> (sel var__temp_h662 res) 20)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Successful************foo'
PARTIAL PATH NEW
NEW 	 --c3'	 --foo'
post_substituted Forall 
 	 
 Key =var_h_i667 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i667 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i667, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v668:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i667 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
c2'
c2
 *********************Enumeration Iteration*****************173
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i667 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i667, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v668:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i667 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h669 --->  Ty_heap  
 var__temp_v670 --->  Ty_int  
 var__temp_h'671 --->  Ty_heap  
 var__temp_v_err672 --->  error  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h669, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h669, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h669, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'671, res ) ==((sel)( , var__temp_h669, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'671, res ) ==(10)
 
VC_END(declare-const var_h_i667 T2635)
(declare-const var_h666 T2635)
(declare-const v Int)
(declare-const var_h_i47 T2635)
(declare-const var_h46 T2635)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h669 T2635)
(declare-const var__temp_v670 Int)
(declare-const |var__temp_h'671| T2635)
(declare-const var__temp_v_err672 T2636)
(declare-const var_h666 T2635)
(declare-const var_h46 T2635)
(declare-const err T2649)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2635)
(declare-fun sel (T2635 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T2635)
(declare-fun var_h666 () T2635)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'671| () T2635)
(declare-fun var__temp_h669 () T2635)
(declare-fun v () Int)
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h669 res) v) (= v |20|))
               (= (sel var__temp_h669 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'671| res) (+ (sel var__temp_h669 res) 3))
               (= (sel |var__temp_h'671| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h669 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************174
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i667 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i667, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v668:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i667 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h673 --->  Ty_heap  
 var__temp_v674 --->  Ty_int  
 var__temp_h'675 --->  Ty_heap  
 var__temp_v_err676 --->  error  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h673, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h673, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h673, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'675, res ) ==((sel)( , var__temp_h673, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'675, res ) ==(10)
 
VC_END(declare-const var_h_i667 T2652)
(declare-const var_h666 T2652)
(declare-const v Int)
(declare-const var_h_i47 T2652)
(declare-const var_h46 T2652)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h673 T2652)
(declare-const var__temp_v674 Int)
(declare-const |var__temp_h'675| T2652)
(declare-const var__temp_v_err676 T2653)
(declare-const var_h666 T2652)
(declare-const var_h46 T2652)
(declare-const err T2666)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2652)
(declare-fun sel (T2652 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T2652)
(declare-fun var_h666 () T2652)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'675| () T2652)
(declare-fun var__temp_h673 () T2652)
(declare-fun v () Int)
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h673 res) v) (= v |20|))
               (= (sel var__temp_h673 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'675| res) (+ (sel var__temp_h673 res) 5))
               (= (sel |var__temp_h'675| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h673 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************175
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i667 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i667, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v668:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i667 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h677 --->  Ty_heap  
 var__temp_v678 --->  Ty_int  
 var__temp_h'679 --->  Ty_heap  
 var__temp_v_err680 --->  error  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h677, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h677, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h677, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'679, res ) ==((sel)( , var__temp_h677, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'679, res ) ==(10)
 
VC_END(declare-const var_h_i667 T2669)
(declare-const var_h666 T2669)
(declare-const v Int)
(declare-const var_h_i47 T2669)
(declare-const var_h46 T2669)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h677 T2669)
(declare-const var__temp_v678 Int)
(declare-const |var__temp_h'679| T2669)
(declare-const var__temp_v_err680 T2670)
(declare-const var_h666 T2669)
(declare-const var_h46 T2669)
(declare-const err T2683)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2669)
(declare-fun sel (T2669 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T2669)
(declare-fun var_h666 () T2669)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'679| () T2669)
(declare-fun var__temp_h677 () T2669)
(declare-fun v () Int)
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h677 res) v) (= v |20|))
               (= (sel var__temp_h677 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'679| res) (+ (sel var__temp_h677 res) 4))
               (= (sel |var__temp_h'679| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h677 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************176
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i667 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i667, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v668:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i667 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h681 --->  Ty_heap  
 var__temp_v682 --->  Ty_int  
 var__temp_h'683 --->  Ty_heap  
 var__temp_v_err684 --->  error  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h681, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h681, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h681, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'683, res ) ==(var__temp_v682) AND 
 	 Base var__temp_v682 = 5 => 
 	 Rel (sel)( , var__temp_h'683, res ) ==(10)
 
VC_END(declare-const var_h_i667 T2686)
(declare-const var_h666 T2686)
(declare-const v Int)
(declare-const var_h_i47 T2686)
(declare-const var_h46 T2686)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h681 T2686)
(declare-const var__temp_v682 Int)
(declare-const |var__temp_h'683| T2686)
(declare-const var__temp_v_err684 T2687)
(declare-const var_h666 T2686)
(declare-const var_h46 T2686)
(declare-const err T2700)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T2686)
(declare-fun sel (T2686 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T2686)
(declare-fun var_h666 () T2686)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'683| () T2686)
(declare-fun var__temp_v682 () Int)
(declare-fun var__temp_h681 () T2686)
(declare-fun v () Int)
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h681 res) v) (= v |20|))
               (= (sel var__temp_h681 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'683| res) var__temp_v682)
                    (= var__temp_v682 |5|))
               (= (sel |var__temp_h'683| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h681 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************177
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i667 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i667, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v668:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i667 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h685 --->  Ty_heap  
 var__temp_v686 --->  Ty_int  
 var__temp_h'687 --->  Ty_heap  
 var__temp_v_err688 --->  error  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h685, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h685, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h685, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'687, res ) ==((sel)( , var__temp_h685, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'687, res ) ==(10)
 
VC_END(declare-const var_h_i667 T2703)
(declare-const var_h666 T2703)
(declare-const v Int)
(declare-const var_h_i47 T2703)
(declare-const var_h46 T2703)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h685 T2703)
(declare-const var__temp_v686 Int)
(declare-const |var__temp_h'687| T2703)
(declare-const var__temp_v_err688 T2704)
(declare-const var_h666 T2703)
(declare-const var_h46 T2703)
(declare-const err T2717)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2703)
(declare-fun sel (T2703 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T2703)
(declare-fun var_h666 () T2703)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'687| () T2703)
(declare-fun var__temp_h685 () T2703)
(declare-fun v () Int)
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h685 res) v) (= v |20|))
               (= (sel var__temp_h685 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'687| res) (+ (sel var__temp_h685 res) 2))
               (= (sel |var__temp_h'687| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h685 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************178
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i667 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i667, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v668:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i667 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h689 --->  Ty_heap  
 var__temp_v690 --->  Ty_int  
 var__temp_h'691 --->  Ty_heap  
 var__temp_v_err692 --->  error  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h689, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h689, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h689, res ) > (20) => 
 	 Rel (sel)( , var__temp_h'691, res ) ==(sel)( , var__temp_h689, res ) => 
 	 Rel (sel)( , var__temp_h'691, res ) ==(10)
 
VC_END(declare-const var_h_i667 T2720)
(declare-const var_h666 T2720)
(declare-const v Int)
(declare-const var_h_i47 T2720)
(declare-const var_h46 T2720)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h689 T2720)
(declare-const var__temp_v690 Int)
(declare-const |var__temp_h'691| T2720)
(declare-const var__temp_v_err692 T2721)
(declare-const var_h666 T2720)
(declare-const var_h46 T2720)
(declare-const err T2734)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2720)
(declare-fun sel (T2720 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T2720)
(declare-fun var_h666 () T2720)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'691| () T2720)
(declare-fun var__temp_h689 () T2720)
(declare-fun v () Int)
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h689 res) v) (= v |20|))
               (not (> (sel var__temp_h689 res) 20))))
      (a!2 (=> (not (> (sel var__temp_h689 res) 20))
               (=> (= (sel |var__temp_h'691| res) (sel var__temp_h689 res))
                   (= (sel |var__temp_h'691| res) 10)))))
  (not (and a!1 a!2))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************179
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i667 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i667, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v668:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i667 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h693 --->  Ty_heap  
 var__temp_v694 --->  Ty_int  
 var__temp_h'695 --->  Ty_heap  
 var__temp_v_err696 --->  error  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h693, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h693, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h693, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'695, res ) ==((sel)( , var__temp_h693, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h'695, res ) ==(10)
 
VC_END(declare-const var_h_i667 T2737)
(declare-const var_h666 T2737)
(declare-const v Int)
(declare-const var_h_i47 T2737)
(declare-const var_h46 T2737)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h693 T2737)
(declare-const var__temp_v694 Int)
(declare-const |var__temp_h'695| T2737)
(declare-const var__temp_v_err696 T2738)
(declare-const var_h666 T2737)
(declare-const var_h46 T2737)
(declare-const err T2751)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2737)
(declare-fun sel (T2737 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T2737)
(declare-fun var_h666 () T2737)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'695| () T2737)
(declare-fun var__temp_h693 () T2737)
(declare-fun v () Int)
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h693 res) v) (= v |20|))
               (> (sel var__temp_h693 res) 4)))
      (a!2 (=> (= (sel |var__temp_h'695| res) (+ (sel var__temp_h693 res) 10))
               (= (sel |var__temp_h'695| res) 10))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h693 res) 4) a!2))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************180
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v668:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v668:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfoo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i667 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i667, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v697:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
c2'
c2
 *********************Enumeration Iteration*****************181
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i667 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i667, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v697:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h698 --->  Ty_heap  
 var__temp_v699 --->  Ty_int  
 var__temp_h'700 --->  Ty_heap  
 var__temp_v_err701 --->  error  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h698, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h698, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h698, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'700, res ) ==((sel)( , var__temp_h698, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i667 T2754)
(declare-const var_h666 T2754)
(declare-const v Int)
(declare-const var_h_i47 T2754)
(declare-const var_h46 T2754)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h698 T2754)
(declare-const var__temp_v699 Int)
(declare-const |var__temp_h'700| T2754)
(declare-const var__temp_v_err701 T2755)
(declare-const var_h666 T2754)
(declare-const var_h46 T2754)
(declare-const err T2768)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2754)
(declare-fun sel (T2754 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T2754)
(declare-fun var_h666 () T2754)
(declare-fun |20| () Int)
(declare-fun var__temp_h698 () T2754)
(declare-fun |var__temp_h'700| () T2754)
(declare-fun v () Int)
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h698 res) v) (= v |20|))
               (= (sel var__temp_h698 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'700| res) (+ (sel var__temp_h698 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h698 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************182
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i667 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i667, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v697:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h702 --->  Ty_heap  
 var__temp_v703 --->  Ty_int  
 var__temp_h'704 --->  Ty_heap  
 var__temp_v_err705 --->  error  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h702, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h702, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h702, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'704, res ) ==((sel)( , var__temp_h702, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i667 T2771)
(declare-const var_h666 T2771)
(declare-const v Int)
(declare-const var_h_i47 T2771)
(declare-const var_h46 T2771)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h702 T2771)
(declare-const var__temp_v703 Int)
(declare-const |var__temp_h'704| T2771)
(declare-const var__temp_v_err705 T2772)
(declare-const var_h666 T2771)
(declare-const var_h46 T2771)
(declare-const err T2785)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2771)
(declare-fun sel (T2771 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T2771)
(declare-fun var_h666 () T2771)
(declare-fun |20| () Int)
(declare-fun var__temp_h702 () T2771)
(declare-fun |var__temp_h'704| () T2771)
(declare-fun v () Int)
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h702 res) v) (= v |20|))
               (= (sel var__temp_h702 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'704| res) (+ (sel var__temp_h702 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h702 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************183
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i667 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i667, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v697:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h706 --->  Ty_heap  
 var__temp_v707 --->  Ty_int  
 var__temp_h'708 --->  Ty_heap  
 var__temp_v_err709 --->  error  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h706, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h706, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h706, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'708, res ) ==((sel)( , var__temp_h706, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i667 T2788)
(declare-const var_h666 T2788)
(declare-const v Int)
(declare-const var_h_i47 T2788)
(declare-const var_h46 T2788)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h706 T2788)
(declare-const var__temp_v707 Int)
(declare-const |var__temp_h'708| T2788)
(declare-const var__temp_v_err709 T2789)
(declare-const var_h666 T2788)
(declare-const var_h46 T2788)
(declare-const err T2802)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2788)
(declare-fun sel (T2788 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T2788)
(declare-fun var_h666 () T2788)
(declare-fun |20| () Int)
(declare-fun var__temp_h706 () T2788)
(declare-fun |var__temp_h'708| () T2788)
(declare-fun v () Int)
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h706 res) v) (= v |20|))
               (= (sel var__temp_h706 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'708| res) (+ (sel var__temp_h706 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h706 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************184
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i667 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i667, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v697:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h710 --->  Ty_heap  
 var__temp_v711 --->  Ty_int  
 var__temp_h'712 --->  Ty_heap  
 var__temp_v_err713 --->  error  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h710, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h710, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h710, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'712, res ) ==(var__temp_v711) AND 
 	 Base var__temp_v711 = 5 => 
 	 True
 
VC_END(declare-const var_h_i667 T2805)
(declare-const var_h666 T2805)
(declare-const v Int)
(declare-const var_h_i47 T2805)
(declare-const var_h46 T2805)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h710 T2805)
(declare-const var__temp_v711 Int)
(declare-const |var__temp_h'712| T2805)
(declare-const var__temp_v_err713 T2806)
(declare-const var_h666 T2805)
(declare-const var_h46 T2805)
(declare-const err T2819)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T2805)
(declare-fun sel (T2805 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T2805)
(declare-fun var_h666 () T2805)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_v711 () Int)
(declare-fun |var__temp_h'712| () T2805)
(declare-fun var__temp_h710 () T2805)
(declare-fun v () Int)
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h710 res) v) (= v |20|))
               (= (sel var__temp_h710 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'712| res) var__temp_v711)
                    (= var__temp_v711 |5|))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h710 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************185
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i667 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i667, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v697:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h714 --->  Ty_heap  
 var__temp_v715 --->  Ty_int  
 var__temp_h'716 --->  Ty_heap  
 var__temp_v_err717 --->  error  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h714, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h714, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h714, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'716, res ) ==((sel)( , var__temp_h714, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i667 T2822)
(declare-const var_h666 T2822)
(declare-const v Int)
(declare-const var_h_i47 T2822)
(declare-const var_h46 T2822)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h714 T2822)
(declare-const var__temp_v715 Int)
(declare-const |var__temp_h'716| T2822)
(declare-const var__temp_v_err717 T2823)
(declare-const var_h666 T2822)
(declare-const var_h46 T2822)
(declare-const err T2836)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2822)
(declare-fun sel (T2822 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T2822)
(declare-fun var_h666 () T2822)
(declare-fun |20| () Int)
(declare-fun var__temp_h714 () T2822)
(declare-fun |var__temp_h'716| () T2822)
(declare-fun v () Int)
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h714 res) v) (= v |20|))
               (= (sel var__temp_h714 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'716| res) (+ (sel var__temp_h714 res) 2))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h714 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************186
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i667 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i667, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v697:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h718 --->  Ty_heap  
 var__temp_v719 --->  Ty_int  
 var__temp_h'720 --->  Ty_heap  
 var__temp_v_err721 --->  error  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h718, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h718, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h718, res ) > (20) => 
 	 Rel (sel)( , var__temp_h'720, res ) ==(sel)( , var__temp_h718, res ) => 
 	 True
 
VC_END(declare-const var_h_i667 T2839)
(declare-const var_h666 T2839)
(declare-const v Int)
(declare-const var_h_i47 T2839)
(declare-const var_h46 T2839)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h718 T2839)
(declare-const var__temp_v719 Int)
(declare-const |var__temp_h'720| T2839)
(declare-const var__temp_v_err721 T2840)
(declare-const var_h666 T2839)
(declare-const var_h46 T2839)
(declare-const err T2853)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2839)
(declare-fun sel (T2839 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T2839)
(declare-fun var_h666 () T2839)
(declare-fun |20| () Int)
(declare-fun var__temp_h718 () T2839)
(declare-fun |var__temp_h'720| () T2839)
(declare-fun v () Int)
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h718 res) v) (= v |20|))
               (not (> (sel var__temp_h718 res) 20))))
      (a!2 (=> (not (> (sel var__temp_h718 res) 20))
               (=> (= (sel |var__temp_h'720| res) (sel var__temp_h718 res))
                   true))))
  (not (and a!1 a!2))))

***************Selection Successful************c2'
PARTIAL PATH NEW
NEW 	 --c3'	 --foo'	 --c2'
post_substituted Forall 
 	 
 Key =var_h_i723 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i723 Value = Ty_heap{ (sel)( , var_h_i723, res ) ==(sel)( , var_h722, res ) } 
 } 
 
                                                RET :  Base {var_v724:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i723 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
c2
 *********************Enumeration Iteration*****************187
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i723 Value = Ty_heap{ (sel)( , var_h_i723, res ) ==(sel)( , var_h722, res ) } 
 } 
 
                                                RET :  Base {var_v724:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i723 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i723 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h725 --->  Ty_heap  
 var__temp_v726 --->  Ty_int  
 var__temp_h'727 --->  Ty_heap  
 var__temp_v_err728 --->  error  
 var_h722 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h722, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h725, res ) ==(sel)( , var_h722, res ) => 
 	 Rel (sel)( , var__temp_h725, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h725, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'727, res ) ==((sel)( , var__temp_h725, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'727, res ) ==(10)
 
VC_END(declare-const var_h_i723 T2856)
(declare-const var_h722 T2856)
(declare-const v Int)
(declare-const var_h_i667 T2856)
(declare-const var_h666 T2856)
(declare-const v Int)
(declare-const var_h_i47 T2856)
(declare-const var_h46 T2856)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h725 T2856)
(declare-const var__temp_v726 Int)
(declare-const |var__temp_h'727| T2856)
(declare-const var__temp_v_err728 T2857)
(declare-const var_h722 T2856)
(declare-const var_h666 T2856)
(declare-const var_h46 T2856)
(declare-const err T2870)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2856)
(declare-fun v () Int)
(declare-fun sel (T2856 Int) Int)
(declare-fun res () Int)
(declare-fun var_h722 () T2856)
(declare-fun |20| () Int)
(declare-fun var_h46 () T2856)
(declare-fun var_h666 () T2856)
(declare-fun |var__temp_h'727| () T2856)
(declare-fun var__temp_h725 () T2856)
(assert (= (sel var_h722 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'727| res) (+ (sel var__temp_h725 res) 3))
               (= (sel |var__temp_h'727| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h725 res) (sel var_h722 res))
                    (= (sel var__temp_h725 res) 7))
                (=> (= (sel var__temp_h725 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************188
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i723 Value = Ty_heap{ (sel)( , var_h_i723, res ) ==(sel)( , var_h722, res ) } 
 } 
 
                                                RET :  Base {var_v724:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i723 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i723 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h729 --->  Ty_heap  
 var__temp_v730 --->  Ty_int  
 var__temp_h'731 --->  Ty_heap  
 var__temp_v_err732 --->  error  
 var_h722 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h722, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h729, res ) ==(sel)( , var_h722, res ) => 
 	 Rel (sel)( , var__temp_h729, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h729, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'731, res ) ==((sel)( , var__temp_h729, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'731, res ) ==(10)
 
VC_END(declare-const var_h_i723 T2873)
(declare-const var_h722 T2873)
(declare-const v Int)
(declare-const var_h_i667 T2873)
(declare-const var_h666 T2873)
(declare-const v Int)
(declare-const var_h_i47 T2873)
(declare-const var_h46 T2873)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h729 T2873)
(declare-const var__temp_v730 Int)
(declare-const |var__temp_h'731| T2873)
(declare-const var__temp_v_err732 T2874)
(declare-const var_h722 T2873)
(declare-const var_h666 T2873)
(declare-const var_h46 T2873)
(declare-const err T2887)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2873)
(declare-fun v () Int)
(declare-fun sel (T2873 Int) Int)
(declare-fun res () Int)
(declare-fun var_h722 () T2873)
(declare-fun |20| () Int)
(declare-fun var_h46 () T2873)
(declare-fun var_h666 () T2873)
(declare-fun |var__temp_h'731| () T2873)
(declare-fun var__temp_h729 () T2873)
(assert (= (sel var_h722 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'731| res) (+ (sel var__temp_h729 res) 5))
               (= (sel |var__temp_h'731| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h729 res) (sel var_h722 res))
                    (= (sel var__temp_h729 res) 7))
                (=> (= (sel var__temp_h729 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************189
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i723 Value = Ty_heap{ (sel)( , var_h_i723, res ) ==(sel)( , var_h722, res ) } 
 } 
 
                                                RET :  Base {var_v724:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i723 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i723 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h733 --->  Ty_heap  
 var__temp_v734 --->  Ty_int  
 var__temp_h'735 --->  Ty_heap  
 var__temp_v_err736 --->  error  
 var_h722 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h722, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h733, res ) ==(sel)( , var_h722, res ) => 
 	 Rel (sel)( , var__temp_h733, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h733, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'735, res ) ==((sel)( , var__temp_h733, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'735, res ) ==(10)
 
VC_END(declare-const var_h_i723 T2890)
(declare-const var_h722 T2890)
(declare-const v Int)
(declare-const var_h_i667 T2890)
(declare-const var_h666 T2890)
(declare-const v Int)
(declare-const var_h_i47 T2890)
(declare-const var_h46 T2890)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h733 T2890)
(declare-const var__temp_v734 Int)
(declare-const |var__temp_h'735| T2890)
(declare-const var__temp_v_err736 T2891)
(declare-const var_h722 T2890)
(declare-const var_h666 T2890)
(declare-const var_h46 T2890)
(declare-const err T2904)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2890)
(declare-fun v () Int)
(declare-fun sel (T2890 Int) Int)
(declare-fun res () Int)
(declare-fun var_h722 () T2890)
(declare-fun |20| () Int)
(declare-fun var_h46 () T2890)
(declare-fun var_h666 () T2890)
(declare-fun |var__temp_h'735| () T2890)
(declare-fun var__temp_h733 () T2890)
(assert (= (sel var_h722 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'735| res) (+ (sel var__temp_h733 res) 4))
               (= (sel |var__temp_h'735| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h733 res) (sel var_h722 res))
                    (= (sel var__temp_h733 res) 6))
                (=> (= (sel var__temp_h733 res) 6) a!1))))
  (not a!2))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************190
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i723 Value = Ty_heap{ (sel)( , var_h_i723, res ) ==(sel)( , var_h722, res ) } 
 } 
 
                                                RET :  Base {var_v724:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i723 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i723 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h737 --->  Ty_heap  
 var__temp_v738 --->  Ty_int  
 var__temp_h'739 --->  Ty_heap  
 var__temp_v_err740 --->  error  
 var_h722 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h722, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h737, res ) ==(sel)( , var_h722, res ) => 
 	 Rel (sel)( , var__temp_h737, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h737, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'739, res ) ==(var__temp_v738) AND 
 	 Base var__temp_v738 = 5 => 
 	 Rel (sel)( , var__temp_h'739, res ) ==(10)
 
VC_END(declare-const var_h_i723 T2907)
(declare-const var_h722 T2907)
(declare-const v Int)
(declare-const var_h_i667 T2907)
(declare-const var_h666 T2907)
(declare-const v Int)
(declare-const var_h_i47 T2907)
(declare-const var_h46 T2907)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h737 T2907)
(declare-const var__temp_v738 Int)
(declare-const |var__temp_h'739| T2907)
(declare-const var__temp_v_err740 T2908)
(declare-const var_h722 T2907)
(declare-const var_h666 T2907)
(declare-const var_h46 T2907)
(declare-const err T2921)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T2907)
(declare-fun v () Int)
(declare-fun sel (T2907 Int) Int)
(declare-fun res () Int)
(declare-fun var_h722 () T2907)
(declare-fun |20| () Int)
(declare-fun var_h46 () T2907)
(declare-fun var_h666 () T2907)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'739| () T2907)
(declare-fun var__temp_v738 () Int)
(declare-fun var__temp_h737 () T2907)
(assert (= (sel var_h722 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel |var__temp_h'739| res) var__temp_v738)
                    (= var__temp_v738 |5|))
               (= (sel |var__temp_h'739| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h737 res) (sel var_h722 res))
                    (= (sel var__temp_h737 res) 0))
                (=> (= (sel var__temp_h737 res) 0) a!1))))
  (not a!2))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************191
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i723 Value = Ty_heap{ (sel)( , var_h_i723, res ) ==(sel)( , var_h722, res ) } 
 } 
 
                                                RET :  Base {var_v724:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i723 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i723 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h741 --->  Ty_heap  
 var__temp_v742 --->  Ty_int  
 var__temp_h'743 --->  Ty_heap  
 var__temp_v_err744 --->  error  
 var_h722 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h722, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h741, res ) ==(sel)( , var_h722, res ) => 
 	 Rel (sel)( , var__temp_h741, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h741, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'743, res ) ==((sel)( , var__temp_h741, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'743, res ) ==(10)
 
VC_END(declare-const var_h_i723 T2924)
(declare-const var_h722 T2924)
(declare-const v Int)
(declare-const var_h_i667 T2924)
(declare-const var_h666 T2924)
(declare-const v Int)
(declare-const var_h_i47 T2924)
(declare-const var_h46 T2924)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h741 T2924)
(declare-const var__temp_v742 Int)
(declare-const |var__temp_h'743| T2924)
(declare-const var__temp_v_err744 T2925)
(declare-const var_h722 T2924)
(declare-const var_h666 T2924)
(declare-const var_h46 T2924)
(declare-const err T2938)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2924)
(declare-fun v () Int)
(declare-fun sel (T2924 Int) Int)
(declare-fun res () Int)
(declare-fun var_h722 () T2924)
(declare-fun |20| () Int)
(declare-fun var_h46 () T2924)
(declare-fun var_h666 () T2924)
(declare-fun |var__temp_h'743| () T2924)
(declare-fun var__temp_h741 () T2924)
(assert (= (sel var_h722 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'743| res) (+ (sel var__temp_h741 res) 2))
               (= (sel |var__temp_h'743| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h741 res) (sel var_h722 res))
                    (= (sel var__temp_h741 res) 5))
                (=> (= (sel var__temp_h741 res) 5) a!1))))
  (not a!2))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************192
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i723 Value = Ty_heap{ (sel)( , var_h_i723, res ) ==(sel)( , var_h722, res ) } 
 } 
 
                                                RET :  Base {var_v724:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i723 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i723 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h745 --->  Ty_heap  
 var__temp_v746 --->  Ty_int  
 var__temp_h'747 --->  Ty_heap  
 var__temp_v_err748 --->  error  
 var_h722 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h722, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h745, res ) ==(sel)( , var_h722, res ) => 
 	 Rel (sel)( , var__temp_h745, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h745, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'747, res ) ==((sel)( , var__temp_h745, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h'747, res ) ==(10)
 
VC_END(declare-const var_h_i723 T2941)
(declare-const var_h722 T2941)
(declare-const v Int)
(declare-const var_h_i667 T2941)
(declare-const var_h666 T2941)
(declare-const v Int)
(declare-const var_h_i47 T2941)
(declare-const var_h46 T2941)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h745 T2941)
(declare-const var__temp_v746 Int)
(declare-const |var__temp_h'747| T2941)
(declare-const var__temp_v_err748 T2942)
(declare-const var_h722 T2941)
(declare-const var_h666 T2941)
(declare-const var_h46 T2941)
(declare-const err T2955)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2941)
(declare-fun v () Int)
(declare-fun sel (T2941 Int) Int)
(declare-fun res () Int)
(declare-fun var_h722 () T2941)
(declare-fun |20| () Int)
(declare-fun var_h46 () T2941)
(declare-fun var_h666 () T2941)
(declare-fun |var__temp_h'747| () T2941)
(declare-fun var__temp_h745 () T2941)
(assert (= (sel var_h722 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'747| res) (+ (sel var__temp_h745 res) 10))
               (= (sel |var__temp_h'747| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h745 res) (sel var_h722 res))
                    (> (sel var__temp_h745 res) 4))
                (=> (> (sel var__temp_h745 res) 4) a!1))))
  (not a!2))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************193
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v724:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v724:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --foo'	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i723 Value = Ty_heap{ (sel)( , var_h_i723, res ) ==(sel)( , var_h722, res ) } 
 } 
 
                                                RET :  Base {var_v749:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
c2
 *********************Enumeration Iteration*****************194
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i723 Value = Ty_heap{ (sel)( , var_h_i723, res ) ==(sel)( , var_h722, res ) } 
 } 
 
                                                RET :  Base {var_v749:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i723 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h750 --->  Ty_heap  
 var__temp_v751 --->  Ty_int  
 var__temp_h'752 --->  Ty_heap  
 var__temp_v_err753 --->  error  
 var_h722 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h722, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h750, res ) ==(sel)( , var_h722, res ) => 
 	 Rel (sel)( , var__temp_h750, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h750, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'752, res ) ==((sel)( , var__temp_h750, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i723 T2958)
(declare-const var_h722 T2958)
(declare-const v Int)
(declare-const var_h_i667 T2958)
(declare-const var_h666 T2958)
(declare-const v Int)
(declare-const var_h_i47 T2958)
(declare-const var_h46 T2958)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h750 T2958)
(declare-const var__temp_v751 Int)
(declare-const |var__temp_h'752| T2958)
(declare-const var__temp_v_err753 T2959)
(declare-const var_h722 T2958)
(declare-const var_h666 T2958)
(declare-const var_h46 T2958)
(declare-const err T2972)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2958)
(declare-fun v () Int)
(declare-fun sel (T2958 Int) Int)
(declare-fun res () Int)
(declare-fun var_h722 () T2958)
(declare-fun |20| () Int)
(declare-fun var_h46 () T2958)
(declare-fun var_h666 () T2958)
(declare-fun var__temp_h750 () T2958)
(declare-fun |var__temp_h'752| () T2958)
(assert (= (sel var_h722 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'752| res) (+ (sel var__temp_h750 res) 3))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h750 res) (sel var_h722 res))
                    (= (sel var__temp_h750 res) 7))
                (=> (= (sel var__temp_h750 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************195
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i723 Value = Ty_heap{ (sel)( , var_h_i723, res ) ==(sel)( , var_h722, res ) } 
 } 
 
                                                RET :  Base {var_v749:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i723 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h754 --->  Ty_heap  
 var__temp_v755 --->  Ty_int  
 var__temp_h'756 --->  Ty_heap  
 var__temp_v_err757 --->  error  
 var_h722 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h722, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h754, res ) ==(sel)( , var_h722, res ) => 
 	 Rel (sel)( , var__temp_h754, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h754, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'756, res ) ==((sel)( , var__temp_h754, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i723 T2975)
(declare-const var_h722 T2975)
(declare-const v Int)
(declare-const var_h_i667 T2975)
(declare-const var_h666 T2975)
(declare-const v Int)
(declare-const var_h_i47 T2975)
(declare-const var_h46 T2975)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h754 T2975)
(declare-const var__temp_v755 Int)
(declare-const |var__temp_h'756| T2975)
(declare-const var__temp_v_err757 T2976)
(declare-const var_h722 T2975)
(declare-const var_h666 T2975)
(declare-const var_h46 T2975)
(declare-const err T2989)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2975)
(declare-fun v () Int)
(declare-fun sel (T2975 Int) Int)
(declare-fun res () Int)
(declare-fun var_h722 () T2975)
(declare-fun |20| () Int)
(declare-fun var_h46 () T2975)
(declare-fun var_h666 () T2975)
(declare-fun var__temp_h754 () T2975)
(declare-fun |var__temp_h'756| () T2975)
(assert (= (sel var_h722 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'756| res) (+ (sel var__temp_h754 res) 5))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h754 res) (sel var_h722 res))
                    (= (sel var__temp_h754 res) 7))
                (=> (= (sel var__temp_h754 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************196
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i723 Value = Ty_heap{ (sel)( , var_h_i723, res ) ==(sel)( , var_h722, res ) } 
 } 
 
                                                RET :  Base {var_v749:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i723 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h758 --->  Ty_heap  
 var__temp_v759 --->  Ty_int  
 var__temp_h'760 --->  Ty_heap  
 var__temp_v_err761 --->  error  
 var_h722 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h722, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h758, res ) ==(sel)( , var_h722, res ) => 
 	 Rel (sel)( , var__temp_h758, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h758, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'760, res ) ==((sel)( , var__temp_h758, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i723 T2992)
(declare-const var_h722 T2992)
(declare-const v Int)
(declare-const var_h_i667 T2992)
(declare-const var_h666 T2992)
(declare-const v Int)
(declare-const var_h_i47 T2992)
(declare-const var_h46 T2992)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h758 T2992)
(declare-const var__temp_v759 Int)
(declare-const |var__temp_h'760| T2992)
(declare-const var__temp_v_err761 T2993)
(declare-const var_h722 T2992)
(declare-const var_h666 T2992)
(declare-const var_h46 T2992)
(declare-const err T3006)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2992)
(declare-fun v () Int)
(declare-fun sel (T2992 Int) Int)
(declare-fun res () Int)
(declare-fun var_h722 () T2992)
(declare-fun |20| () Int)
(declare-fun var_h46 () T2992)
(declare-fun var_h666 () T2992)
(declare-fun var__temp_h758 () T2992)
(declare-fun |var__temp_h'760| () T2992)
(assert (= (sel var_h722 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'760| res) (+ (sel var__temp_h758 res) 4))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h758 res) (sel var_h722 res))
                    (= (sel var__temp_h758 res) 6))
                (=> (= (sel var__temp_h758 res) 6) a!1))))
  (not a!2))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************197
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i723 Value = Ty_heap{ (sel)( , var_h_i723, res ) ==(sel)( , var_h722, res ) } 
 } 
 
                                                RET :  Base {var_v749:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i723 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h762 --->  Ty_heap  
 var__temp_v763 --->  Ty_int  
 var__temp_h'764 --->  Ty_heap  
 var__temp_v_err765 --->  error  
 var_h722 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h722, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h762, res ) ==(sel)( , var_h722, res ) => 
 	 Rel (sel)( , var__temp_h762, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h762, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'764, res ) ==(var__temp_v763) AND 
 	 Base var__temp_v763 = 5 => 
 	 True
 
VC_END(declare-const var_h_i723 T3009)
(declare-const var_h722 T3009)
(declare-const v Int)
(declare-const var_h_i667 T3009)
(declare-const var_h666 T3009)
(declare-const v Int)
(declare-const var_h_i47 T3009)
(declare-const var_h46 T3009)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h762 T3009)
(declare-const var__temp_v763 Int)
(declare-const |var__temp_h'764| T3009)
(declare-const var__temp_v_err765 T3010)
(declare-const var_h722 T3009)
(declare-const var_h666 T3009)
(declare-const var_h46 T3009)
(declare-const err T3023)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T3009)
(declare-fun v () Int)
(declare-fun sel (T3009 Int) Int)
(declare-fun res () Int)
(declare-fun var_h722 () T3009)
(declare-fun |20| () Int)
(declare-fun var_h46 () T3009)
(declare-fun var_h666 () T3009)
(declare-fun |5| () Int)
(declare-fun var__temp_v763 () Int)
(declare-fun |var__temp_h'764| () T3009)
(declare-fun var__temp_h762 () T3009)
(assert (= (sel var_h722 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel |var__temp_h'764| res) var__temp_v763)
                    (= var__temp_v763 |5|))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h762 res) (sel var_h722 res))
                    (= (sel var__temp_h762 res) 0))
                (=> (= (sel var__temp_h762 res) 0) a!1))))
  (not a!2))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************198
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i723 Value = Ty_heap{ (sel)( , var_h_i723, res ) ==(sel)( , var_h722, res ) } 
 } 
 
                                                RET :  Base {var_v749:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i723 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h766 --->  Ty_heap  
 var__temp_v767 --->  Ty_int  
 var__temp_h'768 --->  Ty_heap  
 var__temp_v_err769 --->  error  
 var_h722 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h722, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h766, res ) ==(sel)( , var_h722, res ) => 
 	 Rel (sel)( , var__temp_h766, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h766, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'768, res ) ==((sel)( , var__temp_h766, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i723 T3026)
(declare-const var_h722 T3026)
(declare-const v Int)
(declare-const var_h_i667 T3026)
(declare-const var_h666 T3026)
(declare-const v Int)
(declare-const var_h_i47 T3026)
(declare-const var_h46 T3026)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h766 T3026)
(declare-const var__temp_v767 Int)
(declare-const |var__temp_h'768| T3026)
(declare-const var__temp_v_err769 T3027)
(declare-const var_h722 T3026)
(declare-const var_h666 T3026)
(declare-const var_h46 T3026)
(declare-const err T3040)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3026)
(declare-fun v () Int)
(declare-fun sel (T3026 Int) Int)
(declare-fun res () Int)
(declare-fun var_h722 () T3026)
(declare-fun |20| () Int)
(declare-fun var_h46 () T3026)
(declare-fun var_h666 () T3026)
(declare-fun var__temp_h766 () T3026)
(declare-fun |var__temp_h'768| () T3026)
(assert (= (sel var_h722 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'768| res) (+ (sel var__temp_h766 res) 2))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h766 res) (sel var_h722 res))
                    (= (sel var__temp_h766 res) 5))
                (=> (= (sel var__temp_h766 res) 5) a!1))))
  (not a!2))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************199
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i723 Value = Ty_heap{ (sel)( , var_h_i723, res ) ==(sel)( , var_h722, res ) } 
 } 
 
                                                RET :  Base {var_v749:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i723 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h770 --->  Ty_heap  
 var__temp_v771 --->  Ty_int  
 var__temp_h'772 --->  Ty_heap  
 var__temp_v_err773 --->  error  
 var_h722 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h722, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h770, res ) ==(sel)( , var_h722, res ) => 
 	 Rel (sel)( , var__temp_h770, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h770, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'772, res ) ==((sel)( , var__temp_h770, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i723 T3043)
(declare-const var_h722 T3043)
(declare-const v Int)
(declare-const var_h_i667 T3043)
(declare-const var_h666 T3043)
(declare-const v Int)
(declare-const var_h_i47 T3043)
(declare-const var_h46 T3043)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h770 T3043)
(declare-const var__temp_v771 Int)
(declare-const |var__temp_h'772| T3043)
(declare-const var__temp_v_err773 T3044)
(declare-const var_h722 T3043)
(declare-const var_h666 T3043)
(declare-const var_h46 T3043)
(declare-const err T3057)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3043)
(declare-fun v () Int)
(declare-fun sel (T3043 Int) Int)
(declare-fun res () Int)
(declare-fun var_h722 () T3043)
(declare-fun |20| () Int)
(declare-fun var_h46 () T3043)
(declare-fun var_h666 () T3043)
(declare-fun var__temp_h770 () T3043)
(declare-fun |var__temp_h'772| () T3043)
(assert (= (sel var_h722 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'772| res) (+ (sel var__temp_h770 res) 10))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h770 res) (sel var_h722 res))
                    (> (sel var__temp_h770 res) 4))
                (=> (> (sel var__temp_h770 res) 4) a!1))))
  (not a!2))))

***************Selection Successful************c2
PARTIAL PATH NEW
NEW 	 --c3'	 --foo'	 --c2'	 --c2
post_substituted Forall 
 	 
 Key =var_h_i775 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i775 Value = Ty_heap{ (sel)( , var_h_i775, res ) ==((sel)( , var_h774, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v776:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i775 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
 *********************Enumeration Iteration*****************200
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i775 Value = Ty_heap{ (sel)( , var_h_i775, res ) ==((sel)( , var_h774, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v776:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i775 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i775 --->  Ty_heap  
 var_h774 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i723 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h777 --->  Ty_heap  
 var__temp_v778 --->  Ty_int  
 var__temp_h'779 --->  Ty_heap  
 var__temp_v_err780 --->  error  
 var_h774 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h774, res ) ==(sel)( , var_h722, res ) AND 
 	 Rel (sel)( , var_h722, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h777, res ) ==((sel)( , var_h774, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h777, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h777, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'779, res ) ==((sel)( , var__temp_h777, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'779, res ) ==(10)
 
VC_END(declare-const var_h_i775 T3060)
(declare-const var_h774 T3060)
(declare-const v Int)
(declare-const var_h_i723 T3060)
(declare-const var_h722 T3060)
(declare-const v Int)
(declare-const var_h_i667 T3060)
(declare-const var_h666 T3060)
(declare-const v Int)
(declare-const var_h_i47 T3060)
(declare-const var_h46 T3060)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h777 T3060)
(declare-const var__temp_v778 Int)
(declare-const |var__temp_h'779| T3060)
(declare-const var__temp_v_err780 T3061)
(declare-const var_h774 T3060)
(declare-const var_h722 T3060)
(declare-const var_h666 T3060)
(declare-const var_h46 T3060)
(declare-const err T3074)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3060)
(declare-fun sel (T3060 Int) Int)
(declare-fun res () Int)
(declare-fun var_h722 () T3060)
(declare-fun var_h774 () T3060)
(declare-fun v () Int)
(declare-fun |20| () Int)
(declare-fun var_h46 () T3060)
(declare-fun var_h666 () T3060)
(declare-fun |var__temp_h'779| () T3060)
(declare-fun var__temp_h777 () T3060)
(assert (= (sel var_h774 res) (sel var_h722 res)))
(assert (= (sel var_h722 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h777 res) (+ (sel var_h774 res) 10))
               (= (sel var__temp_h777 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'779| res) (+ (sel var__temp_h777 res) 3))
               (= (sel |var__temp_h'779| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h777 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************201
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i775 Value = Ty_heap{ (sel)( , var_h_i775, res ) ==((sel)( , var_h774, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v776:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i775 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i775 --->  Ty_heap  
 var_h774 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i723 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h781 --->  Ty_heap  
 var__temp_v782 --->  Ty_int  
 var__temp_h'783 --->  Ty_heap  
 var__temp_v_err784 --->  error  
 var_h774 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h774, res ) ==(sel)( , var_h722, res ) AND 
 	 Rel (sel)( , var_h722, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h781, res ) ==((sel)( , var_h774, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h781, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h781, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'783, res ) ==((sel)( , var__temp_h781, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'783, res ) ==(10)
 
VC_END(declare-const var_h_i775 T3077)
(declare-const var_h774 T3077)
(declare-const v Int)
(declare-const var_h_i723 T3077)
(declare-const var_h722 T3077)
(declare-const v Int)
(declare-const var_h_i667 T3077)
(declare-const var_h666 T3077)
(declare-const v Int)
(declare-const var_h_i47 T3077)
(declare-const var_h46 T3077)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h781 T3077)
(declare-const var__temp_v782 Int)
(declare-const |var__temp_h'783| T3077)
(declare-const var__temp_v_err784 T3078)
(declare-const var_h774 T3077)
(declare-const var_h722 T3077)
(declare-const var_h666 T3077)
(declare-const var_h46 T3077)
(declare-const err T3091)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3077)
(declare-fun sel (T3077 Int) Int)
(declare-fun res () Int)
(declare-fun var_h722 () T3077)
(declare-fun var_h774 () T3077)
(declare-fun v () Int)
(declare-fun |20| () Int)
(declare-fun var_h46 () T3077)
(declare-fun var_h666 () T3077)
(declare-fun |var__temp_h'783| () T3077)
(declare-fun var__temp_h781 () T3077)
(assert (= (sel var_h774 res) (sel var_h722 res)))
(assert (= (sel var_h722 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h781 res) (+ (sel var_h774 res) 10))
               (= (sel var__temp_h781 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'783| res) (+ (sel var__temp_h781 res) 5))
               (= (sel |var__temp_h'783| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h781 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************202
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i775 Value = Ty_heap{ (sel)( , var_h_i775, res ) ==((sel)( , var_h774, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v776:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i775 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i775 --->  Ty_heap  
 var_h774 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i723 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h785 --->  Ty_heap  
 var__temp_v786 --->  Ty_int  
 var__temp_h'787 --->  Ty_heap  
 var__temp_v_err788 --->  error  
 var_h774 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h774, res ) ==(sel)( , var_h722, res ) AND 
 	 Rel (sel)( , var_h722, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h785, res ) ==((sel)( , var_h774, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h785, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h785, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'787, res ) ==((sel)( , var__temp_h785, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'787, res ) ==(10)
 
VC_END(declare-const var_h_i775 T3094)
(declare-const var_h774 T3094)
(declare-const v Int)
(declare-const var_h_i723 T3094)
(declare-const var_h722 T3094)
(declare-const v Int)
(declare-const var_h_i667 T3094)
(declare-const var_h666 T3094)
(declare-const v Int)
(declare-const var_h_i47 T3094)
(declare-const var_h46 T3094)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h785 T3094)
(declare-const var__temp_v786 Int)
(declare-const |var__temp_h'787| T3094)
(declare-const var__temp_v_err788 T3095)
(declare-const var_h774 T3094)
(declare-const var_h722 T3094)
(declare-const var_h666 T3094)
(declare-const var_h46 T3094)
(declare-const err T3108)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3094)
(declare-fun sel (T3094 Int) Int)
(declare-fun res () Int)
(declare-fun var_h722 () T3094)
(declare-fun var_h774 () T3094)
(declare-fun v () Int)
(declare-fun |20| () Int)
(declare-fun var_h46 () T3094)
(declare-fun var_h666 () T3094)
(declare-fun |var__temp_h'787| () T3094)
(declare-fun var__temp_h785 () T3094)
(assert (= (sel var_h774 res) (sel var_h722 res)))
(assert (= (sel var_h722 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h785 res) (+ (sel var_h774 res) 10))
               (= (sel var__temp_h785 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'787| res) (+ (sel var__temp_h785 res) 4))
               (= (sel |var__temp_h'787| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h785 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************203
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i775 Value = Ty_heap{ (sel)( , var_h_i775, res ) ==((sel)( , var_h774, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v776:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i775 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i775 --->  Ty_heap  
 var_h774 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i723 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h789 --->  Ty_heap  
 var__temp_v790 --->  Ty_int  
 var__temp_h'791 --->  Ty_heap  
 var__temp_v_err792 --->  error  
 var_h774 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h774, res ) ==(sel)( , var_h722, res ) AND 
 	 Rel (sel)( , var_h722, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h789, res ) ==((sel)( , var_h774, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h789, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h789, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'791, res ) ==(var__temp_v790) AND 
 	 Base var__temp_v790 = 5 => 
 	 Rel (sel)( , var__temp_h'791, res ) ==(10)
 
VC_END(declare-const var_h_i775 T3111)
(declare-const var_h774 T3111)
(declare-const v Int)
(declare-const var_h_i723 T3111)
(declare-const var_h722 T3111)
(declare-const v Int)
(declare-const var_h_i667 T3111)
(declare-const var_h666 T3111)
(declare-const v Int)
(declare-const var_h_i47 T3111)
(declare-const var_h46 T3111)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h789 T3111)
(declare-const var__temp_v790 Int)
(declare-const |var__temp_h'791| T3111)
(declare-const var__temp_v_err792 T3112)
(declare-const var_h774 T3111)
(declare-const var_h722 T3111)
(declare-const var_h666 T3111)
(declare-const var_h46 T3111)
(declare-const err T3125)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T3111)
(declare-fun sel (T3111 Int) Int)
(declare-fun res () Int)
(declare-fun var_h722 () T3111)
(declare-fun var_h774 () T3111)
(declare-fun v () Int)
(declare-fun |20| () Int)
(declare-fun var_h46 () T3111)
(declare-fun var_h666 () T3111)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'791| () T3111)
(declare-fun var__temp_v790 () Int)
(declare-fun var__temp_h789 () T3111)
(assert (= (sel var_h774 res) (sel var_h722 res)))
(assert (= (sel var_h722 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h789 res) (+ (sel var_h774 res) 10))
               (= (sel var__temp_h789 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'791| res) var__temp_v790)
                    (= var__temp_v790 |5|))
               (= (sel |var__temp_h'791| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h789 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************204
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i775 Value = Ty_heap{ (sel)( , var_h_i775, res ) ==((sel)( , var_h774, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v776:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i775 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i775 --->  Ty_heap  
 var_h774 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i723 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h793 --->  Ty_heap  
 var__temp_v794 --->  Ty_int  
 var__temp_h'795 --->  Ty_heap  
 var__temp_v_err796 --->  error  
 var_h774 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h774, res ) ==(sel)( , var_h722, res ) AND 
 	 Rel (sel)( , var_h722, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h793, res ) ==((sel)( , var_h774, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h793, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h793, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'795, res ) ==((sel)( , var__temp_h793, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'795, res ) ==(10)
 
VC_END(declare-const var_h_i775 T3128)
(declare-const var_h774 T3128)
(declare-const v Int)
(declare-const var_h_i723 T3128)
(declare-const var_h722 T3128)
(declare-const v Int)
(declare-const var_h_i667 T3128)
(declare-const var_h666 T3128)
(declare-const v Int)
(declare-const var_h_i47 T3128)
(declare-const var_h46 T3128)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h793 T3128)
(declare-const var__temp_v794 Int)
(declare-const |var__temp_h'795| T3128)
(declare-const var__temp_v_err796 T3129)
(declare-const var_h774 T3128)
(declare-const var_h722 T3128)
(declare-const var_h666 T3128)
(declare-const var_h46 T3128)
(declare-const err T3142)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3128)
(declare-fun sel (T3128 Int) Int)
(declare-fun res () Int)
(declare-fun var_h722 () T3128)
(declare-fun var_h774 () T3128)
(declare-fun v () Int)
(declare-fun |20| () Int)
(declare-fun var_h46 () T3128)
(declare-fun var_h666 () T3128)
(declare-fun |var__temp_h'795| () T3128)
(declare-fun var__temp_h793 () T3128)
(assert (= (sel var_h774 res) (sel var_h722 res)))
(assert (= (sel var_h722 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h793 res) (+ (sel var_h774 res) 10))
               (= (sel var__temp_h793 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'795| res) (+ (sel var__temp_h793 res) 2))
               (= (sel |var__temp_h'795| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h793 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************205
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v776:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v776:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2c2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --foo'	 --c2'	 --c2
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i775 Value = Ty_heap{ (sel)( , var_h_i775, res ) ==((sel)( , var_h774, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v797:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
 *********************Enumeration Iteration*****************206
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i775 Value = Ty_heap{ (sel)( , var_h_i775, res ) ==((sel)( , var_h774, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v797:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i775 --->  Ty_heap  
 var_h774 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i723 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h798 --->  Ty_heap  
 var__temp_v799 --->  Ty_int  
 var__temp_h'800 --->  Ty_heap  
 var__temp_v_err801 --->  error  
 var_h774 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h774, res ) ==(sel)( , var_h722, res ) AND 
 	 Rel (sel)( , var_h722, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h798, res ) ==((sel)( , var_h774, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h798, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h798, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'800, res ) ==((sel)( , var__temp_h798, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i775 T3145)
(declare-const var_h774 T3145)
(declare-const v Int)
(declare-const var_h_i723 T3145)
(declare-const var_h722 T3145)
(declare-const v Int)
(declare-const var_h_i667 T3145)
(declare-const var_h666 T3145)
(declare-const v Int)
(declare-const var_h_i47 T3145)
(declare-const var_h46 T3145)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h798 T3145)
(declare-const var__temp_v799 Int)
(declare-const |var__temp_h'800| T3145)
(declare-const var__temp_v_err801 T3146)
(declare-const var_h774 T3145)
(declare-const var_h722 T3145)
(declare-const var_h666 T3145)
(declare-const var_h46 T3145)
(declare-const err T3159)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3145)
(declare-fun sel (T3145 Int) Int)
(declare-fun res () Int)
(declare-fun var_h722 () T3145)
(declare-fun var_h774 () T3145)
(declare-fun v () Int)
(declare-fun |20| () Int)
(declare-fun var_h46 () T3145)
(declare-fun var_h666 () T3145)
(declare-fun var__temp_h798 () T3145)
(declare-fun |var__temp_h'800| () T3145)
(assert (= (sel var_h774 res) (sel var_h722 res)))
(assert (= (sel var_h722 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h798 res) (+ (sel var_h774 res) 10))
               (= (sel var__temp_h798 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'800| res) (+ (sel var__temp_h798 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h798 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************207
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i775 Value = Ty_heap{ (sel)( , var_h_i775, res ) ==((sel)( , var_h774, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v797:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i775 --->  Ty_heap  
 var_h774 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i723 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h802 --->  Ty_heap  
 var__temp_v803 --->  Ty_int  
 var__temp_h'804 --->  Ty_heap  
 var__temp_v_err805 --->  error  
 var_h774 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h774, res ) ==(sel)( , var_h722, res ) AND 
 	 Rel (sel)( , var_h722, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h802, res ) ==((sel)( , var_h774, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h802, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h802, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'804, res ) ==((sel)( , var__temp_h802, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i775 T3162)
(declare-const var_h774 T3162)
(declare-const v Int)
(declare-const var_h_i723 T3162)
(declare-const var_h722 T3162)
(declare-const v Int)
(declare-const var_h_i667 T3162)
(declare-const var_h666 T3162)
(declare-const v Int)
(declare-const var_h_i47 T3162)
(declare-const var_h46 T3162)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h802 T3162)
(declare-const var__temp_v803 Int)
(declare-const |var__temp_h'804| T3162)
(declare-const var__temp_v_err805 T3163)
(declare-const var_h774 T3162)
(declare-const var_h722 T3162)
(declare-const var_h666 T3162)
(declare-const var_h46 T3162)
(declare-const err T3176)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3162)
(declare-fun sel (T3162 Int) Int)
(declare-fun res () Int)
(declare-fun var_h722 () T3162)
(declare-fun var_h774 () T3162)
(declare-fun v () Int)
(declare-fun |20| () Int)
(declare-fun var_h46 () T3162)
(declare-fun var_h666 () T3162)
(declare-fun var__temp_h802 () T3162)
(declare-fun |var__temp_h'804| () T3162)
(assert (= (sel var_h774 res) (sel var_h722 res)))
(assert (= (sel var_h722 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h802 res) (+ (sel var_h774 res) 10))
               (= (sel var__temp_h802 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'804| res) (+ (sel var__temp_h802 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h802 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************208
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i775 Value = Ty_heap{ (sel)( , var_h_i775, res ) ==((sel)( , var_h774, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v797:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i775 --->  Ty_heap  
 var_h774 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i723 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h806 --->  Ty_heap  
 var__temp_v807 --->  Ty_int  
 var__temp_h'808 --->  Ty_heap  
 var__temp_v_err809 --->  error  
 var_h774 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h774, res ) ==(sel)( , var_h722, res ) AND 
 	 Rel (sel)( , var_h722, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h806, res ) ==((sel)( , var_h774, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h806, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h806, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'808, res ) ==((sel)( , var__temp_h806, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i775 T3179)
(declare-const var_h774 T3179)
(declare-const v Int)
(declare-const var_h_i723 T3179)
(declare-const var_h722 T3179)
(declare-const v Int)
(declare-const var_h_i667 T3179)
(declare-const var_h666 T3179)
(declare-const v Int)
(declare-const var_h_i47 T3179)
(declare-const var_h46 T3179)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h806 T3179)
(declare-const var__temp_v807 Int)
(declare-const |var__temp_h'808| T3179)
(declare-const var__temp_v_err809 T3180)
(declare-const var_h774 T3179)
(declare-const var_h722 T3179)
(declare-const var_h666 T3179)
(declare-const var_h46 T3179)
(declare-const err T3193)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3179)
(declare-fun sel (T3179 Int) Int)
(declare-fun res () Int)
(declare-fun var_h722 () T3179)
(declare-fun var_h774 () T3179)
(declare-fun v () Int)
(declare-fun |20| () Int)
(declare-fun var_h46 () T3179)
(declare-fun var_h666 () T3179)
(declare-fun var__temp_h806 () T3179)
(declare-fun |var__temp_h'808| () T3179)
(assert (= (sel var_h774 res) (sel var_h722 res)))
(assert (= (sel var_h722 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h806 res) (+ (sel var_h774 res) 10))
               (= (sel var__temp_h806 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'808| res) (+ (sel var__temp_h806 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h806 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************209
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i775 Value = Ty_heap{ (sel)( , var_h_i775, res ) ==((sel)( , var_h774, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v797:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i775 --->  Ty_heap  
 var_h774 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i723 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h810 --->  Ty_heap  
 var__temp_v811 --->  Ty_int  
 var__temp_h'812 --->  Ty_heap  
 var__temp_v_err813 --->  error  
 var_h774 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h774, res ) ==(sel)( , var_h722, res ) AND 
 	 Rel (sel)( , var_h722, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h810, res ) ==((sel)( , var_h774, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h810, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h810, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'812, res ) ==(var__temp_v811) AND 
 	 Base var__temp_v811 = 5 => 
 	 True
 
VC_END(declare-const var_h_i775 T3196)
(declare-const var_h774 T3196)
(declare-const v Int)
(declare-const var_h_i723 T3196)
(declare-const var_h722 T3196)
(declare-const v Int)
(declare-const var_h_i667 T3196)
(declare-const var_h666 T3196)
(declare-const v Int)
(declare-const var_h_i47 T3196)
(declare-const var_h46 T3196)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h810 T3196)
(declare-const var__temp_v811 Int)
(declare-const |var__temp_h'812| T3196)
(declare-const var__temp_v_err813 T3197)
(declare-const var_h774 T3196)
(declare-const var_h722 T3196)
(declare-const var_h666 T3196)
(declare-const var_h46 T3196)
(declare-const err T3210)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T3196)
(declare-fun sel (T3196 Int) Int)
(declare-fun res () Int)
(declare-fun var_h722 () T3196)
(declare-fun var_h774 () T3196)
(declare-fun v () Int)
(declare-fun |20| () Int)
(declare-fun var_h46 () T3196)
(declare-fun var_h666 () T3196)
(declare-fun |5| () Int)
(declare-fun var__temp_v811 () Int)
(declare-fun |var__temp_h'812| () T3196)
(declare-fun var__temp_h810 () T3196)
(assert (= (sel var_h774 res) (sel var_h722 res)))
(assert (= (sel var_h722 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h810 res) (+ (sel var_h774 res) 10))
               (= (sel var__temp_h810 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'812| res) var__temp_v811)
                    (= var__temp_v811 |5|))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h810 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************210
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i775 Value = Ty_heap{ (sel)( , var_h_i775, res ) ==((sel)( , var_h774, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v797:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i775 --->  Ty_heap  
 var_h774 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i723 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h814 --->  Ty_heap  
 var__temp_v815 --->  Ty_int  
 var__temp_h'816 --->  Ty_heap  
 var__temp_v_err817 --->  error  
 var_h774 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h774, res ) ==(sel)( , var_h722, res ) AND 
 	 Rel (sel)( , var_h722, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h814, res ) ==((sel)( , var_h774, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h814, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h814, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'816, res ) ==((sel)( , var__temp_h814, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i775 T3213)
(declare-const var_h774 T3213)
(declare-const v Int)
(declare-const var_h_i723 T3213)
(declare-const var_h722 T3213)
(declare-const v Int)
(declare-const var_h_i667 T3213)
(declare-const var_h666 T3213)
(declare-const v Int)
(declare-const var_h_i47 T3213)
(declare-const var_h46 T3213)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h814 T3213)
(declare-const var__temp_v815 Int)
(declare-const |var__temp_h'816| T3213)
(declare-const var__temp_v_err817 T3214)
(declare-const var_h774 T3213)
(declare-const var_h722 T3213)
(declare-const var_h666 T3213)
(declare-const var_h46 T3213)
(declare-const err T3227)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3213)
(declare-fun sel (T3213 Int) Int)
(declare-fun res () Int)
(declare-fun var_h722 () T3213)
(declare-fun var_h774 () T3213)
(declare-fun v () Int)
(declare-fun |20| () Int)
(declare-fun var_h46 () T3213)
(declare-fun var_h666 () T3213)
(declare-fun var__temp_h814 () T3213)
(declare-fun |var__temp_h'816| () T3213)
(assert (= (sel var_h774 res) (sel var_h722 res)))
(assert (= (sel var_h722 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h814 res) (+ (sel var_h774 res) 10))
               (= (sel var__temp_h814 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'816| res) (+ (sel var__temp_h814 res) 2))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h814 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************211
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 	 --c3'	 --foo'	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i723 Value = Ty_heap{ (sel)( , var_h_i723, res ) ==(sel)( , var_h722, res ) } 
 } 
 
                                                RET :  Base {var_v818:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
 *********************Enumeration Iteration*****************212
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i723 Value = Ty_heap{ (sel)( , var_h_i723, res ) ==(sel)( , var_h722, res ) } 
 } 
 
                                                RET :  Base {var_v818:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i723 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h819 --->  Ty_heap  
 var__temp_v820 --->  Ty_int  
 var__temp_h'821 --->  Ty_heap  
 var__temp_v_err822 --->  error  
 var_h722 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h722, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h819, res ) ==(sel)( , var_h722, res ) => 
 	 Rel (sel)( , var__temp_h819, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h819, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'821, res ) ==((sel)( , var__temp_h819, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i723 T3230)
(declare-const var_h722 T3230)
(declare-const v Int)
(declare-const var_h_i667 T3230)
(declare-const var_h666 T3230)
(declare-const v Int)
(declare-const var_h_i47 T3230)
(declare-const var_h46 T3230)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h819 T3230)
(declare-const var__temp_v820 Int)
(declare-const |var__temp_h'821| T3230)
(declare-const var__temp_v_err822 T3231)
(declare-const var_h722 T3230)
(declare-const var_h666 T3230)
(declare-const var_h46 T3230)
(declare-const err T3244)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3230)
(declare-fun v () Int)
(declare-fun sel (T3230 Int) Int)
(declare-fun res () Int)
(declare-fun var_h722 () T3230)
(declare-fun |20| () Int)
(declare-fun var_h46 () T3230)
(declare-fun var_h666 () T3230)
(declare-fun var__temp_h819 () T3230)
(declare-fun |var__temp_h'821| () T3230)
(assert (= (sel var_h722 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'821| res) (+ (sel var__temp_h819 res) 3))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h819 res) (sel var_h722 res))
                    (= (sel var__temp_h819 res) 7))
                (=> (= (sel var__temp_h819 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************213
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i723 Value = Ty_heap{ (sel)( , var_h_i723, res ) ==(sel)( , var_h722, res ) } 
 } 
 
                                                RET :  Base {var_v818:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i723 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h823 --->  Ty_heap  
 var__temp_v824 --->  Ty_int  
 var__temp_h'825 --->  Ty_heap  
 var__temp_v_err826 --->  error  
 var_h722 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h722, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h823, res ) ==(sel)( , var_h722, res ) => 
 	 Rel (sel)( , var__temp_h823, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h823, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'825, res ) ==((sel)( , var__temp_h823, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i723 T3247)
(declare-const var_h722 T3247)
(declare-const v Int)
(declare-const var_h_i667 T3247)
(declare-const var_h666 T3247)
(declare-const v Int)
(declare-const var_h_i47 T3247)
(declare-const var_h46 T3247)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h823 T3247)
(declare-const var__temp_v824 Int)
(declare-const |var__temp_h'825| T3247)
(declare-const var__temp_v_err826 T3248)
(declare-const var_h722 T3247)
(declare-const var_h666 T3247)
(declare-const var_h46 T3247)
(declare-const err T3261)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3247)
(declare-fun v () Int)
(declare-fun sel (T3247 Int) Int)
(declare-fun res () Int)
(declare-fun var_h722 () T3247)
(declare-fun |20| () Int)
(declare-fun var_h46 () T3247)
(declare-fun var_h666 () T3247)
(declare-fun var__temp_h823 () T3247)
(declare-fun |var__temp_h'825| () T3247)
(assert (= (sel var_h722 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'825| res) (+ (sel var__temp_h823 res) 5))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h823 res) (sel var_h722 res))
                    (= (sel var__temp_h823 res) 7))
                (=> (= (sel var__temp_h823 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************214
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i723 Value = Ty_heap{ (sel)( , var_h_i723, res ) ==(sel)( , var_h722, res ) } 
 } 
 
                                                RET :  Base {var_v818:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i723 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h827 --->  Ty_heap  
 var__temp_v828 --->  Ty_int  
 var__temp_h'829 --->  Ty_heap  
 var__temp_v_err830 --->  error  
 var_h722 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h722, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h827, res ) ==(sel)( , var_h722, res ) => 
 	 Rel (sel)( , var__temp_h827, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h827, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'829, res ) ==((sel)( , var__temp_h827, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i723 T3264)
(declare-const var_h722 T3264)
(declare-const v Int)
(declare-const var_h_i667 T3264)
(declare-const var_h666 T3264)
(declare-const v Int)
(declare-const var_h_i47 T3264)
(declare-const var_h46 T3264)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h827 T3264)
(declare-const var__temp_v828 Int)
(declare-const |var__temp_h'829| T3264)
(declare-const var__temp_v_err830 T3265)
(declare-const var_h722 T3264)
(declare-const var_h666 T3264)
(declare-const var_h46 T3264)
(declare-const err T3278)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3264)
(declare-fun v () Int)
(declare-fun sel (T3264 Int) Int)
(declare-fun res () Int)
(declare-fun var_h722 () T3264)
(declare-fun |20| () Int)
(declare-fun var_h46 () T3264)
(declare-fun var_h666 () T3264)
(declare-fun var__temp_h827 () T3264)
(declare-fun |var__temp_h'829| () T3264)
(assert (= (sel var_h722 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'829| res) (+ (sel var__temp_h827 res) 4))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h827 res) (sel var_h722 res))
                    (= (sel var__temp_h827 res) 6))
                (=> (= (sel var__temp_h827 res) 6) a!1))))
  (not a!2))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************215
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i723 Value = Ty_heap{ (sel)( , var_h_i723, res ) ==(sel)( , var_h722, res ) } 
 } 
 
                                                RET :  Base {var_v818:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i723 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h831 --->  Ty_heap  
 var__temp_v832 --->  Ty_int  
 var__temp_h'833 --->  Ty_heap  
 var__temp_v_err834 --->  error  
 var_h722 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h722, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h831, res ) ==(sel)( , var_h722, res ) => 
 	 Rel (sel)( , var__temp_h831, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h831, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'833, res ) ==(var__temp_v832) AND 
 	 Base var__temp_v832 = 5 => 
 	 True
 
VC_END(declare-const var_h_i723 T3281)
(declare-const var_h722 T3281)
(declare-const v Int)
(declare-const var_h_i667 T3281)
(declare-const var_h666 T3281)
(declare-const v Int)
(declare-const var_h_i47 T3281)
(declare-const var_h46 T3281)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h831 T3281)
(declare-const var__temp_v832 Int)
(declare-const |var__temp_h'833| T3281)
(declare-const var__temp_v_err834 T3282)
(declare-const var_h722 T3281)
(declare-const var_h666 T3281)
(declare-const var_h46 T3281)
(declare-const err T3295)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T3281)
(declare-fun v () Int)
(declare-fun sel (T3281 Int) Int)
(declare-fun res () Int)
(declare-fun var_h722 () T3281)
(declare-fun |20| () Int)
(declare-fun var_h46 () T3281)
(declare-fun var_h666 () T3281)
(declare-fun |5| () Int)
(declare-fun var__temp_v832 () Int)
(declare-fun |var__temp_h'833| () T3281)
(declare-fun var__temp_h831 () T3281)
(assert (= (sel var_h722 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel |var__temp_h'833| res) var__temp_v832)
                    (= var__temp_v832 |5|))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h831 res) (sel var_h722 res))
                    (= (sel var__temp_h831 res) 0))
                (=> (= (sel var__temp_h831 res) 0) a!1))))
  (not a!2))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************216
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i723 Value = Ty_heap{ (sel)( , var_h_i723, res ) ==(sel)( , var_h722, res ) } 
 } 
 
                                                RET :  Base {var_v818:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i723 --->  Ty_heap  
 var_h722 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h835 --->  Ty_heap  
 var__temp_v836 --->  Ty_int  
 var__temp_h'837 --->  Ty_heap  
 var__temp_v_err838 --->  error  
 var_h722 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h722, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h835, res ) ==(sel)( , var_h722, res ) => 
 	 Rel (sel)( , var__temp_h835, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h835, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'837, res ) ==((sel)( , var__temp_h835, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i723 T3298)
(declare-const var_h722 T3298)
(declare-const v Int)
(declare-const var_h_i667 T3298)
(declare-const var_h666 T3298)
(declare-const v Int)
(declare-const var_h_i47 T3298)
(declare-const var_h46 T3298)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h835 T3298)
(declare-const var__temp_v836 Int)
(declare-const |var__temp_h'837| T3298)
(declare-const var__temp_v_err838 T3299)
(declare-const var_h722 T3298)
(declare-const var_h666 T3298)
(declare-const var_h46 T3298)
(declare-const err T3312)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3298)
(declare-fun v () Int)
(declare-fun sel (T3298 Int) Int)
(declare-fun res () Int)
(declare-fun var_h722 () T3298)
(declare-fun |20| () Int)
(declare-fun var_h46 () T3298)
(declare-fun var_h666 () T3298)
(declare-fun var__temp_h835 () T3298)
(declare-fun |var__temp_h'837| () T3298)
(assert (= (sel var_h722 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'837| res) (+ (sel var__temp_h835 res) 2))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h835 res) (sel var_h722 res))
                    (= (sel var__temp_h835 res) 5))
                (=> (= (sel var__temp_h835 res) 5) a!1))))
  (not a!2))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************217
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 	 --c3'	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i667 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i667, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v839:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
c2
 *********************Enumeration Iteration*****************218
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i667 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i667, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v839:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h840 --->  Ty_heap  
 var__temp_v841 --->  Ty_int  
 var__temp_h'842 --->  Ty_heap  
 var__temp_v_err843 --->  error  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h840, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h840, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h840, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'842, res ) ==((sel)( , var__temp_h840, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i667 T3315)
(declare-const var_h666 T3315)
(declare-const v Int)
(declare-const var_h_i47 T3315)
(declare-const var_h46 T3315)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h840 T3315)
(declare-const var__temp_v841 Int)
(declare-const |var__temp_h'842| T3315)
(declare-const var__temp_v_err843 T3316)
(declare-const var_h666 T3315)
(declare-const var_h46 T3315)
(declare-const err T3329)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3315)
(declare-fun sel (T3315 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3315)
(declare-fun var_h666 () T3315)
(declare-fun |20| () Int)
(declare-fun var__temp_h840 () T3315)
(declare-fun |var__temp_h'842| () T3315)
(declare-fun v () Int)
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h840 res) v) (= v |20|))
               (= (sel var__temp_h840 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'842| res) (+ (sel var__temp_h840 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h840 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************219
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i667 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i667, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v839:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h844 --->  Ty_heap  
 var__temp_v845 --->  Ty_int  
 var__temp_h'846 --->  Ty_heap  
 var__temp_v_err847 --->  error  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h844, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h844, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h844, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'846, res ) ==((sel)( , var__temp_h844, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i667 T3332)
(declare-const var_h666 T3332)
(declare-const v Int)
(declare-const var_h_i47 T3332)
(declare-const var_h46 T3332)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h844 T3332)
(declare-const var__temp_v845 Int)
(declare-const |var__temp_h'846| T3332)
(declare-const var__temp_v_err847 T3333)
(declare-const var_h666 T3332)
(declare-const var_h46 T3332)
(declare-const err T3346)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3332)
(declare-fun sel (T3332 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3332)
(declare-fun var_h666 () T3332)
(declare-fun |20| () Int)
(declare-fun var__temp_h844 () T3332)
(declare-fun |var__temp_h'846| () T3332)
(declare-fun v () Int)
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h844 res) v) (= v |20|))
               (= (sel var__temp_h844 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'846| res) (+ (sel var__temp_h844 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h844 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************220
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i667 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i667, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v839:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h848 --->  Ty_heap  
 var__temp_v849 --->  Ty_int  
 var__temp_h'850 --->  Ty_heap  
 var__temp_v_err851 --->  error  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h848, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h848, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h848, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'850, res ) ==((sel)( , var__temp_h848, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i667 T3349)
(declare-const var_h666 T3349)
(declare-const v Int)
(declare-const var_h_i47 T3349)
(declare-const var_h46 T3349)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h848 T3349)
(declare-const var__temp_v849 Int)
(declare-const |var__temp_h'850| T3349)
(declare-const var__temp_v_err851 T3350)
(declare-const var_h666 T3349)
(declare-const var_h46 T3349)
(declare-const err T3363)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3349)
(declare-fun sel (T3349 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3349)
(declare-fun var_h666 () T3349)
(declare-fun |20| () Int)
(declare-fun var__temp_h848 () T3349)
(declare-fun |var__temp_h'850| () T3349)
(declare-fun v () Int)
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h848 res) v) (= v |20|))
               (= (sel var__temp_h848 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'850| res) (+ (sel var__temp_h848 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h848 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************221
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i667 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i667, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v839:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h852 --->  Ty_heap  
 var__temp_v853 --->  Ty_int  
 var__temp_h'854 --->  Ty_heap  
 var__temp_v_err855 --->  error  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h852, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h852, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h852, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'854, res ) ==(var__temp_v853) AND 
 	 Base var__temp_v853 = 5 => 
 	 True
 
VC_END(declare-const var_h_i667 T3366)
(declare-const var_h666 T3366)
(declare-const v Int)
(declare-const var_h_i47 T3366)
(declare-const var_h46 T3366)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h852 T3366)
(declare-const var__temp_v853 Int)
(declare-const |var__temp_h'854| T3366)
(declare-const var__temp_v_err855 T3367)
(declare-const var_h666 T3366)
(declare-const var_h46 T3366)
(declare-const err T3380)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T3366)
(declare-fun sel (T3366 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3366)
(declare-fun var_h666 () T3366)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_v853 () Int)
(declare-fun |var__temp_h'854| () T3366)
(declare-fun var__temp_h852 () T3366)
(declare-fun v () Int)
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h852 res) v) (= v |20|))
               (= (sel var__temp_h852 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'854| res) var__temp_v853)
                    (= var__temp_v853 |5|))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h852 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************222
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i667 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i667, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v839:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h856 --->  Ty_heap  
 var__temp_v857 --->  Ty_int  
 var__temp_h'858 --->  Ty_heap  
 var__temp_v_err859 --->  error  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h856, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h856, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h856, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'858, res ) ==((sel)( , var__temp_h856, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i667 T3383)
(declare-const var_h666 T3383)
(declare-const v Int)
(declare-const var_h_i47 T3383)
(declare-const var_h46 T3383)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h856 T3383)
(declare-const var__temp_v857 Int)
(declare-const |var__temp_h'858| T3383)
(declare-const var__temp_v_err859 T3384)
(declare-const var_h666 T3383)
(declare-const var_h46 T3383)
(declare-const err T3397)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3383)
(declare-fun sel (T3383 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3383)
(declare-fun var_h666 () T3383)
(declare-fun |20| () Int)
(declare-fun var__temp_h856 () T3383)
(declare-fun |var__temp_h'858| () T3383)
(declare-fun v () Int)
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h856 res) v) (= v |20|))
               (= (sel var__temp_h856 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'858| res) (+ (sel var__temp_h856 res) 2))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h856 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************223
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i667 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i667, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v839:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h860 --->  Ty_heap  
 var__temp_v861 --->  Ty_int  
 var__temp_h'862 --->  Ty_heap  
 var__temp_v_err863 --->  error  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h860, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h860, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h860, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'862, res ) ==((sel)( , var__temp_h860, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i667 T3400)
(declare-const var_h666 T3400)
(declare-const v Int)
(declare-const var_h_i47 T3400)
(declare-const var_h46 T3400)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h860 T3400)
(declare-const var__temp_v861 Int)
(declare-const |var__temp_h'862| T3400)
(declare-const var__temp_v_err863 T3401)
(declare-const var_h666 T3400)
(declare-const var_h46 T3400)
(declare-const err T3414)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3400)
(declare-fun sel (T3400 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3400)
(declare-fun var_h666 () T3400)
(declare-fun |20| () Int)
(declare-fun var__temp_h860 () T3400)
(declare-fun |var__temp_h'862| () T3400)
(declare-fun v () Int)
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h860 res) v) (= v |20|))
               (> (sel var__temp_h860 res) 4)))
      (a!2 (=> (= (sel |var__temp_h'862| res) (+ (sel var__temp_h860 res) 10))
               true)))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h860 res) 4) a!2))))
  (not a!3))))

***************Selection Successful************c2
PARTIAL PATH NEW
NEW 	 --c3'	 --foo'	 --c2
post_substituted Forall 
 	 
 Key =var_h_i865 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ (sel)( , var_h_i865, res ) ==((sel)( , var_h864, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v866:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i865 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
 *********************Enumeration Iteration*****************224
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ (sel)( , var_h_i865, res ) ==((sel)( , var_h864, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v866:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i865 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h867 --->  Ty_heap  
 var__temp_v868 --->  Ty_int  
 var__temp_h'869 --->  Ty_heap  
 var__temp_v_err870 --->  error  
 var_h864 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h864, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h867, res ) ==((sel)( , var_h864, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h867, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h867, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'869, res ) ==((sel)( , var__temp_h867, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'869, res ) ==(10)
 
VC_END(declare-const var_h_i865 T3417)
(declare-const var_h864 T3417)
(declare-const v Int)
(declare-const var_h_i667 T3417)
(declare-const var_h666 T3417)
(declare-const v Int)
(declare-const var_h_i47 T3417)
(declare-const var_h46 T3417)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h867 T3417)
(declare-const var__temp_v868 Int)
(declare-const |var__temp_h'869| T3417)
(declare-const var__temp_v_err870 T3418)
(declare-const var_h864 T3417)
(declare-const var_h666 T3417)
(declare-const var_h46 T3417)
(declare-const err T3431)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3417)
(declare-fun v () Int)
(declare-fun sel (T3417 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3417)
(declare-fun |20| () Int)
(declare-fun var_h46 () T3417)
(declare-fun var_h666 () T3417)
(declare-fun |var__temp_h'869| () T3417)
(declare-fun var__temp_h867 () T3417)
(assert (= (sel var_h864 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h867 res) (+ (sel var_h864 res) 10))
               (= (sel var__temp_h867 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'869| res) (+ (sel var__temp_h867 res) 3))
               (= (sel |var__temp_h'869| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h867 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************225
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ (sel)( , var_h_i865, res ) ==((sel)( , var_h864, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v866:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i865 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h871 --->  Ty_heap  
 var__temp_v872 --->  Ty_int  
 var__temp_h'873 --->  Ty_heap  
 var__temp_v_err874 --->  error  
 var_h864 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h864, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h871, res ) ==((sel)( , var_h864, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h871, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h871, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'873, res ) ==((sel)( , var__temp_h871, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'873, res ) ==(10)
 
VC_END(declare-const var_h_i865 T3434)
(declare-const var_h864 T3434)
(declare-const v Int)
(declare-const var_h_i667 T3434)
(declare-const var_h666 T3434)
(declare-const v Int)
(declare-const var_h_i47 T3434)
(declare-const var_h46 T3434)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h871 T3434)
(declare-const var__temp_v872 Int)
(declare-const |var__temp_h'873| T3434)
(declare-const var__temp_v_err874 T3435)
(declare-const var_h864 T3434)
(declare-const var_h666 T3434)
(declare-const var_h46 T3434)
(declare-const err T3448)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3434)
(declare-fun v () Int)
(declare-fun sel (T3434 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3434)
(declare-fun |20| () Int)
(declare-fun var_h46 () T3434)
(declare-fun var_h666 () T3434)
(declare-fun |var__temp_h'873| () T3434)
(declare-fun var__temp_h871 () T3434)
(assert (= (sel var_h864 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h871 res) (+ (sel var_h864 res) 10))
               (= (sel var__temp_h871 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'873| res) (+ (sel var__temp_h871 res) 5))
               (= (sel |var__temp_h'873| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h871 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************226
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ (sel)( , var_h_i865, res ) ==((sel)( , var_h864, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v866:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i865 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h875 --->  Ty_heap  
 var__temp_v876 --->  Ty_int  
 var__temp_h'877 --->  Ty_heap  
 var__temp_v_err878 --->  error  
 var_h864 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h864, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h875, res ) ==((sel)( , var_h864, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h875, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h875, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'877, res ) ==((sel)( , var__temp_h875, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'877, res ) ==(10)
 
VC_END(declare-const var_h_i865 T3451)
(declare-const var_h864 T3451)
(declare-const v Int)
(declare-const var_h_i667 T3451)
(declare-const var_h666 T3451)
(declare-const v Int)
(declare-const var_h_i47 T3451)
(declare-const var_h46 T3451)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h875 T3451)
(declare-const var__temp_v876 Int)
(declare-const |var__temp_h'877| T3451)
(declare-const var__temp_v_err878 T3452)
(declare-const var_h864 T3451)
(declare-const var_h666 T3451)
(declare-const var_h46 T3451)
(declare-const err T3465)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3451)
(declare-fun v () Int)
(declare-fun sel (T3451 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3451)
(declare-fun |20| () Int)
(declare-fun var_h46 () T3451)
(declare-fun var_h666 () T3451)
(declare-fun |var__temp_h'877| () T3451)
(declare-fun var__temp_h875 () T3451)
(assert (= (sel var_h864 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h875 res) (+ (sel var_h864 res) 10))
               (= (sel var__temp_h875 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'877| res) (+ (sel var__temp_h875 res) 4))
               (= (sel |var__temp_h'877| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h875 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************227
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ (sel)( , var_h_i865, res ) ==((sel)( , var_h864, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v866:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i865 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h879 --->  Ty_heap  
 var__temp_v880 --->  Ty_int  
 var__temp_h'881 --->  Ty_heap  
 var__temp_v_err882 --->  error  
 var_h864 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h864, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h879, res ) ==((sel)( , var_h864, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h879, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h879, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'881, res ) ==(var__temp_v880) AND 
 	 Base var__temp_v880 = 5 => 
 	 Rel (sel)( , var__temp_h'881, res ) ==(10)
 
VC_END(declare-const var_h_i865 T3468)
(declare-const var_h864 T3468)
(declare-const v Int)
(declare-const var_h_i667 T3468)
(declare-const var_h666 T3468)
(declare-const v Int)
(declare-const var_h_i47 T3468)
(declare-const var_h46 T3468)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h879 T3468)
(declare-const var__temp_v880 Int)
(declare-const |var__temp_h'881| T3468)
(declare-const var__temp_v_err882 T3469)
(declare-const var_h864 T3468)
(declare-const var_h666 T3468)
(declare-const var_h46 T3468)
(declare-const err T3482)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T3468)
(declare-fun v () Int)
(declare-fun sel (T3468 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3468)
(declare-fun |20| () Int)
(declare-fun var_h46 () T3468)
(declare-fun var_h666 () T3468)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'881| () T3468)
(declare-fun var__temp_v880 () Int)
(declare-fun var__temp_h879 () T3468)
(assert (= (sel var_h864 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h879 res) (+ (sel var_h864 res) 10))
               (= (sel var__temp_h879 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'881| res) var__temp_v880)
                    (= var__temp_v880 |5|))
               (= (sel |var__temp_h'881| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h879 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************228
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ (sel)( , var_h_i865, res ) ==((sel)( , var_h864, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v866:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i865 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h883 --->  Ty_heap  
 var__temp_v884 --->  Ty_int  
 var__temp_h'885 --->  Ty_heap  
 var__temp_v_err886 --->  error  
 var_h864 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h864, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h883, res ) ==((sel)( , var_h864, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h883, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h883, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'885, res ) ==((sel)( , var__temp_h883, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'885, res ) ==(10)
 
VC_END(declare-const var_h_i865 T3485)
(declare-const var_h864 T3485)
(declare-const v Int)
(declare-const var_h_i667 T3485)
(declare-const var_h666 T3485)
(declare-const v Int)
(declare-const var_h_i47 T3485)
(declare-const var_h46 T3485)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h883 T3485)
(declare-const var__temp_v884 Int)
(declare-const |var__temp_h'885| T3485)
(declare-const var__temp_v_err886 T3486)
(declare-const var_h864 T3485)
(declare-const var_h666 T3485)
(declare-const var_h46 T3485)
(declare-const err T3499)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3485)
(declare-fun v () Int)
(declare-fun sel (T3485 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3485)
(declare-fun |20| () Int)
(declare-fun var_h46 () T3485)
(declare-fun var_h666 () T3485)
(declare-fun |var__temp_h'885| () T3485)
(declare-fun var__temp_h883 () T3485)
(assert (= (sel var_h864 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h883 res) (+ (sel var_h864 res) 10))
               (= (sel var__temp_h883 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'885| res) (+ (sel var__temp_h883 res) 2))
               (= (sel |var__temp_h'885| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h883 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************229
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v866:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v866:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2c2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --foo'	 --c2
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ (sel)( , var_h_i865, res ) ==((sel)( , var_h864, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v887:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
 *********************Enumeration Iteration*****************230
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ (sel)( , var_h_i865, res ) ==((sel)( , var_h864, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v887:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h888 --->  Ty_heap  
 var__temp_v889 --->  Ty_int  
 var__temp_h'890 --->  Ty_heap  
 var__temp_v_err891 --->  error  
 var_h864 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h864, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h888, res ) ==((sel)( , var_h864, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h888, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h888, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'890, res ) ==((sel)( , var__temp_h888, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i865 T3502)
(declare-const var_h864 T3502)
(declare-const v Int)
(declare-const var_h_i667 T3502)
(declare-const var_h666 T3502)
(declare-const v Int)
(declare-const var_h_i47 T3502)
(declare-const var_h46 T3502)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h888 T3502)
(declare-const var__temp_v889 Int)
(declare-const |var__temp_h'890| T3502)
(declare-const var__temp_v_err891 T3503)
(declare-const var_h864 T3502)
(declare-const var_h666 T3502)
(declare-const var_h46 T3502)
(declare-const err T3516)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3502)
(declare-fun v () Int)
(declare-fun sel (T3502 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3502)
(declare-fun |20| () Int)
(declare-fun var_h46 () T3502)
(declare-fun var_h666 () T3502)
(declare-fun var__temp_h888 () T3502)
(declare-fun |var__temp_h'890| () T3502)
(assert (= (sel var_h864 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h888 res) (+ (sel var_h864 res) 10))
               (= (sel var__temp_h888 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'890| res) (+ (sel var__temp_h888 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h888 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************231
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ (sel)( , var_h_i865, res ) ==((sel)( , var_h864, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v887:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h892 --->  Ty_heap  
 var__temp_v893 --->  Ty_int  
 var__temp_h'894 --->  Ty_heap  
 var__temp_v_err895 --->  error  
 var_h864 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h864, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h892, res ) ==((sel)( , var_h864, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h892, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h892, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'894, res ) ==((sel)( , var__temp_h892, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i865 T3519)
(declare-const var_h864 T3519)
(declare-const v Int)
(declare-const var_h_i667 T3519)
(declare-const var_h666 T3519)
(declare-const v Int)
(declare-const var_h_i47 T3519)
(declare-const var_h46 T3519)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h892 T3519)
(declare-const var__temp_v893 Int)
(declare-const |var__temp_h'894| T3519)
(declare-const var__temp_v_err895 T3520)
(declare-const var_h864 T3519)
(declare-const var_h666 T3519)
(declare-const var_h46 T3519)
(declare-const err T3533)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3519)
(declare-fun v () Int)
(declare-fun sel (T3519 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3519)
(declare-fun |20| () Int)
(declare-fun var_h46 () T3519)
(declare-fun var_h666 () T3519)
(declare-fun var__temp_h892 () T3519)
(declare-fun |var__temp_h'894| () T3519)
(assert (= (sel var_h864 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h892 res) (+ (sel var_h864 res) 10))
               (= (sel var__temp_h892 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'894| res) (+ (sel var__temp_h892 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h892 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************232
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ (sel)( , var_h_i865, res ) ==((sel)( , var_h864, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v887:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h896 --->  Ty_heap  
 var__temp_v897 --->  Ty_int  
 var__temp_h'898 --->  Ty_heap  
 var__temp_v_err899 --->  error  
 var_h864 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h864, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h896, res ) ==((sel)( , var_h864, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h896, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h896, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'898, res ) ==((sel)( , var__temp_h896, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i865 T3536)
(declare-const var_h864 T3536)
(declare-const v Int)
(declare-const var_h_i667 T3536)
(declare-const var_h666 T3536)
(declare-const v Int)
(declare-const var_h_i47 T3536)
(declare-const var_h46 T3536)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h896 T3536)
(declare-const var__temp_v897 Int)
(declare-const |var__temp_h'898| T3536)
(declare-const var__temp_v_err899 T3537)
(declare-const var_h864 T3536)
(declare-const var_h666 T3536)
(declare-const var_h46 T3536)
(declare-const err T3550)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3536)
(declare-fun v () Int)
(declare-fun sel (T3536 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3536)
(declare-fun |20| () Int)
(declare-fun var_h46 () T3536)
(declare-fun var_h666 () T3536)
(declare-fun var__temp_h896 () T3536)
(declare-fun |var__temp_h'898| () T3536)
(assert (= (sel var_h864 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h896 res) (+ (sel var_h864 res) 10))
               (= (sel var__temp_h896 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'898| res) (+ (sel var__temp_h896 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h896 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************233
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ (sel)( , var_h_i865, res ) ==((sel)( , var_h864, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v887:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h900 --->  Ty_heap  
 var__temp_v901 --->  Ty_int  
 var__temp_h'902 --->  Ty_heap  
 var__temp_v_err903 --->  error  
 var_h864 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h864, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h900, res ) ==((sel)( , var_h864, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h900, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h900, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'902, res ) ==(var__temp_v901) AND 
 	 Base var__temp_v901 = 5 => 
 	 True
 
VC_END(declare-const var_h_i865 T3553)
(declare-const var_h864 T3553)
(declare-const v Int)
(declare-const var_h_i667 T3553)
(declare-const var_h666 T3553)
(declare-const v Int)
(declare-const var_h_i47 T3553)
(declare-const var_h46 T3553)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h900 T3553)
(declare-const var__temp_v901 Int)
(declare-const |var__temp_h'902| T3553)
(declare-const var__temp_v_err903 T3554)
(declare-const var_h864 T3553)
(declare-const var_h666 T3553)
(declare-const var_h46 T3553)
(declare-const err T3567)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T3553)
(declare-fun v () Int)
(declare-fun sel (T3553 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3553)
(declare-fun |20| () Int)
(declare-fun var_h46 () T3553)
(declare-fun var_h666 () T3553)
(declare-fun |5| () Int)
(declare-fun var__temp_v901 () Int)
(declare-fun |var__temp_h'902| () T3553)
(declare-fun var__temp_h900 () T3553)
(assert (= (sel var_h864 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h900 res) (+ (sel var_h864 res) 10))
               (= (sel var__temp_h900 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'902| res) var__temp_v901)
                    (= var__temp_v901 |5|))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h900 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************234
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ (sel)( , var_h_i865, res ) ==((sel)( , var_h864, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v887:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h904 --->  Ty_heap  
 var__temp_v905 --->  Ty_int  
 var__temp_h'906 --->  Ty_heap  
 var__temp_v_err907 --->  error  
 var_h864 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h864, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h904, res ) ==((sel)( , var_h864, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h904, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h904, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'906, res ) ==((sel)( , var__temp_h904, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i865 T3570)
(declare-const var_h864 T3570)
(declare-const v Int)
(declare-const var_h_i667 T3570)
(declare-const var_h666 T3570)
(declare-const v Int)
(declare-const var_h_i47 T3570)
(declare-const var_h46 T3570)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h904 T3570)
(declare-const var__temp_v905 Int)
(declare-const |var__temp_h'906| T3570)
(declare-const var__temp_v_err907 T3571)
(declare-const var_h864 T3570)
(declare-const var_h666 T3570)
(declare-const var_h46 T3570)
(declare-const err T3584)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3570)
(declare-fun v () Int)
(declare-fun sel (T3570 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3570)
(declare-fun |20| () Int)
(declare-fun var_h46 () T3570)
(declare-fun var_h666 () T3570)
(declare-fun var__temp_h904 () T3570)
(declare-fun |var__temp_h'906| () T3570)
(assert (= (sel var_h864 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h904 res) (+ (sel var_h864 res) 10))
               (= (sel var__temp_h904 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'906| res) (+ (sel var__temp_h904 res) 2))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h904 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************235
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 	 --c3'	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i667 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i667, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v908:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
 *********************Enumeration Iteration*****************236
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i667 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i667, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v908:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h909 --->  Ty_heap  
 var__temp_v910 --->  Ty_int  
 var__temp_h'911 --->  Ty_heap  
 var__temp_v_err912 --->  error  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h909, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h909, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h909, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'911, res ) ==((sel)( , var__temp_h909, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i667 T3587)
(declare-const var_h666 T3587)
(declare-const v Int)
(declare-const var_h_i47 T3587)
(declare-const var_h46 T3587)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h909 T3587)
(declare-const var__temp_v910 Int)
(declare-const |var__temp_h'911| T3587)
(declare-const var__temp_v_err912 T3588)
(declare-const var_h666 T3587)
(declare-const var_h46 T3587)
(declare-const err T3601)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3587)
(declare-fun sel (T3587 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3587)
(declare-fun var_h666 () T3587)
(declare-fun |20| () Int)
(declare-fun var__temp_h909 () T3587)
(declare-fun |var__temp_h'911| () T3587)
(declare-fun v () Int)
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h909 res) v) (= v |20|))
               (= (sel var__temp_h909 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'911| res) (+ (sel var__temp_h909 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h909 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************237
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i667 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i667, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v908:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h913 --->  Ty_heap  
 var__temp_v914 --->  Ty_int  
 var__temp_h'915 --->  Ty_heap  
 var__temp_v_err916 --->  error  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h913, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h913, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h913, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'915, res ) ==((sel)( , var__temp_h913, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i667 T3604)
(declare-const var_h666 T3604)
(declare-const v Int)
(declare-const var_h_i47 T3604)
(declare-const var_h46 T3604)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h913 T3604)
(declare-const var__temp_v914 Int)
(declare-const |var__temp_h'915| T3604)
(declare-const var__temp_v_err916 T3605)
(declare-const var_h666 T3604)
(declare-const var_h46 T3604)
(declare-const err T3618)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3604)
(declare-fun sel (T3604 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3604)
(declare-fun var_h666 () T3604)
(declare-fun |20| () Int)
(declare-fun var__temp_h913 () T3604)
(declare-fun |var__temp_h'915| () T3604)
(declare-fun v () Int)
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h913 res) v) (= v |20|))
               (= (sel var__temp_h913 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'915| res) (+ (sel var__temp_h913 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h913 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************238
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i667 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i667, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v908:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h917 --->  Ty_heap  
 var__temp_v918 --->  Ty_int  
 var__temp_h'919 --->  Ty_heap  
 var__temp_v_err920 --->  error  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h917, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h917, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h917, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'919, res ) ==((sel)( , var__temp_h917, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i667 T3621)
(declare-const var_h666 T3621)
(declare-const v Int)
(declare-const var_h_i47 T3621)
(declare-const var_h46 T3621)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h917 T3621)
(declare-const var__temp_v918 Int)
(declare-const |var__temp_h'919| T3621)
(declare-const var__temp_v_err920 T3622)
(declare-const var_h666 T3621)
(declare-const var_h46 T3621)
(declare-const err T3635)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3621)
(declare-fun sel (T3621 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3621)
(declare-fun var_h666 () T3621)
(declare-fun |20| () Int)
(declare-fun var__temp_h917 () T3621)
(declare-fun |var__temp_h'919| () T3621)
(declare-fun v () Int)
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h917 res) v) (= v |20|))
               (= (sel var__temp_h917 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'919| res) (+ (sel var__temp_h917 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h917 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************239
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i667 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i667, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v908:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h921 --->  Ty_heap  
 var__temp_v922 --->  Ty_int  
 var__temp_h'923 --->  Ty_heap  
 var__temp_v_err924 --->  error  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h921, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h921, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h921, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'923, res ) ==(var__temp_v922) AND 
 	 Base var__temp_v922 = 5 => 
 	 True
 
VC_END(declare-const var_h_i667 T3638)
(declare-const var_h666 T3638)
(declare-const v Int)
(declare-const var_h_i47 T3638)
(declare-const var_h46 T3638)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h921 T3638)
(declare-const var__temp_v922 Int)
(declare-const |var__temp_h'923| T3638)
(declare-const var__temp_v_err924 T3639)
(declare-const var_h666 T3638)
(declare-const var_h46 T3638)
(declare-const err T3652)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T3638)
(declare-fun sel (T3638 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3638)
(declare-fun var_h666 () T3638)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_v922 () Int)
(declare-fun |var__temp_h'923| () T3638)
(declare-fun var__temp_h921 () T3638)
(declare-fun v () Int)
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h921 res) v) (= v |20|))
               (= (sel var__temp_h921 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'923| res) var__temp_v922)
                    (= var__temp_v922 |5|))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h921 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************240
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i667 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i667, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v908:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i667 --->  Ty_heap  
 var_h666 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h925 --->  Ty_heap  
 var__temp_v926 --->  Ty_int  
 var__temp_h'927 --->  Ty_heap  
 var__temp_v_err928 --->  error  
 var_h666 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h666, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h925, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h925, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h925, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'927, res ) ==((sel)( , var__temp_h925, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i667 T3655)
(declare-const var_h666 T3655)
(declare-const v Int)
(declare-const var_h_i47 T3655)
(declare-const var_h46 T3655)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h925 T3655)
(declare-const var__temp_v926 Int)
(declare-const |var__temp_h'927| T3655)
(declare-const var__temp_v_err928 T3656)
(declare-const var_h666 T3655)
(declare-const var_h46 T3655)
(declare-const err T3669)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3655)
(declare-fun sel (T3655 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3655)
(declare-fun var_h666 () T3655)
(declare-fun |20| () Int)
(declare-fun var__temp_h925 () T3655)
(declare-fun |var__temp_h'927| () T3655)
(declare-fun v () Int)
(assert (= (sel var_h666 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h925 res) v) (= v |20|))
               (= (sel var__temp_h925 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'927| res) (+ (sel var__temp_h925 res) 2))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h925 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************241
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v929:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
c2'
c2
 *********************Enumeration Iteration*****************242
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v929:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h930 --->  Ty_heap  
 var__temp_v931 --->  Ty_int  
 var__temp_h'932 --->  Ty_heap  
 var__temp_v_err933 --->  error  
 var_h46 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h930, res ) ==((sel)( , var_h46, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h930, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h930, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'932, res ) ==((sel)( , var__temp_h930, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i47 T3672)
(declare-const var_h46 T3672)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h930 T3672)
(declare-const var__temp_v931 Int)
(declare-const |var__temp_h'932| T3672)
(declare-const var__temp_v_err933 T3673)
(declare-const var_h46 T3672)
(declare-const err T3686)

solver 
 (declare-sort T3672)
(declare-fun sel (T3672 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3672)
(declare-fun var__temp_h930 () T3672)
(declare-fun |var__temp_h'932| () T3672)
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h930 res) (+ (sel var_h46 res) 3))
               (= (sel var__temp_h930 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'932| res) (+ (sel var__temp_h930 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h930 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************243
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v929:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h934 --->  Ty_heap  
 var__temp_v935 --->  Ty_int  
 var__temp_h'936 --->  Ty_heap  
 var__temp_v_err937 --->  error  
 var_h46 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h934, res ) ==((sel)( , var_h46, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h934, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h934, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'936, res ) ==((sel)( , var__temp_h934, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i47 T3689)
(declare-const var_h46 T3689)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h934 T3689)
(declare-const var__temp_v935 Int)
(declare-const |var__temp_h'936| T3689)
(declare-const var__temp_v_err937 T3690)
(declare-const var_h46 T3689)
(declare-const err T3703)

solver 
 (declare-sort T3689)
(declare-fun sel (T3689 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3689)
(declare-fun var__temp_h934 () T3689)
(declare-fun |var__temp_h'936| () T3689)
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h934 res) (+ (sel var_h46 res) 3))
               (= (sel var__temp_h934 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'936| res) (+ (sel var__temp_h934 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h934 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************244
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v929:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h938 --->  Ty_heap  
 var__temp_v939 --->  Ty_int  
 var__temp_h'940 --->  Ty_heap  
 var__temp_v_err941 --->  error  
 var_h46 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h938, res ) ==((sel)( , var_h46, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h938, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h938, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'940, res ) ==((sel)( , var__temp_h938, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i47 T3706)
(declare-const var_h46 T3706)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h938 T3706)
(declare-const var__temp_v939 Int)
(declare-const |var__temp_h'940| T3706)
(declare-const var__temp_v_err941 T3707)
(declare-const var_h46 T3706)
(declare-const err T3720)

solver 
 (declare-sort T3706)
(declare-fun sel (T3706 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3706)
(declare-fun var__temp_h938 () T3706)
(declare-fun |var__temp_h'940| () T3706)
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h938 res) (+ (sel var_h46 res) 3))
               (= (sel var__temp_h938 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'940| res) (+ (sel var__temp_h938 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h938 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************245
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v929:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h942 --->  Ty_heap  
 var__temp_v943 --->  Ty_int  
 var__temp_h'944 --->  Ty_heap  
 var__temp_v_err945 --->  error  
 var_h46 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h942, res ) ==((sel)( , var_h46, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h942, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h942, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'944, res ) ==(var__temp_v943) AND 
 	 Base var__temp_v943 = 5 => 
 	 True
 
VC_END(declare-const var_h_i47 T3723)
(declare-const var_h46 T3723)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h942 T3723)
(declare-const var__temp_v943 Int)
(declare-const |var__temp_h'944| T3723)
(declare-const var__temp_v_err945 T3724)
(declare-const var_h46 T3723)
(declare-const err T3737)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3723)
(declare-fun sel (T3723 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3723)
(declare-fun |5| () Int)
(declare-fun var__temp_v943 () Int)
(declare-fun |var__temp_h'944| () T3723)
(declare-fun var__temp_h942 () T3723)
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h942 res) (+ (sel var_h46 res) 3))
               (= (sel var__temp_h942 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'944| res) var__temp_v943)
                    (= var__temp_v943 |5|))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h942 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************246
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v929:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h946 --->  Ty_heap  
 var__temp_v947 --->  Ty_int  
 var__temp_h'948 --->  Ty_heap  
 var__temp_v_err949 --->  error  
 var_h46 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h946, res ) ==((sel)( , var_h46, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h946, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h946, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'948, res ) ==((sel)( , var__temp_h946, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i47 T3740)
(declare-const var_h46 T3740)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h946 T3740)
(declare-const var__temp_v947 Int)
(declare-const |var__temp_h'948| T3740)
(declare-const var__temp_v_err949 T3741)
(declare-const var_h46 T3740)
(declare-const err T3754)

solver 
 (declare-sort T3740)
(declare-fun sel (T3740 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3740)
(declare-fun var__temp_h946 () T3740)
(declare-fun |var__temp_h'948| () T3740)
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h946 res) (+ (sel var_h46 res) 3))
               (= (sel var__temp_h946 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'948| res) (+ (sel var__temp_h946 res) 2))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h946 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************247
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v929:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h950 --->  Ty_heap  
 var__temp_v951 --->  Ty_int  
 var__temp_h'952 --->  Ty_heap  
 var__temp_v_err953 --->  error  
 var_h46 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h950, res ) ==((sel)( , var_h46, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h950, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h950, res ) > (20) => 
 	 Rel (sel)( , var__temp_h'952, res ) ==(sel)( , var__temp_h950, res ) => 
 	 True
 
VC_END(declare-const var_h_i47 T3757)
(declare-const var_h46 T3757)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h950 T3757)
(declare-const var__temp_v951 Int)
(declare-const |var__temp_h'952| T3757)
(declare-const var__temp_v_err953 T3758)
(declare-const var_h46 T3757)
(declare-const err T3771)

solver 
 (declare-sort T3757)
(declare-fun sel (T3757 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3757)
(declare-fun var__temp_h950 () T3757)
(declare-fun |var__temp_h'952| () T3757)
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h950 res) (+ (sel var_h46 res) 3))
               (not (> (sel var__temp_h950 res) 20))))
      (a!2 (=> (not (> (sel var__temp_h950 res) 20))
               (=> (= (sel |var__temp_h'952| res) (sel var__temp_h950 res))
                   true))))
  (not (and a!1 a!2))))

***************Selection Successful************c2'
PARTIAL PATH NEW
NEW 	 --c3'	 --c2'
post_substituted Forall 
 	 
 Key =var_h_i955 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i955 Value = Ty_heap{ (sel)( , var_h_i955, res ) ==(sel)( , var_h954, res ) } 
 } 
 
                                                RET :  Base {var_v956:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i955 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
c2
 *********************Enumeration Iteration*****************248
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i955 Value = Ty_heap{ (sel)( , var_h_i955, res ) ==(sel)( , var_h954, res ) } 
 } 
 
                                                RET :  Base {var_v956:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i955 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i955 --->  Ty_heap  
 var_h954 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h957 --->  Ty_heap  
 var__temp_v958 --->  Ty_int  
 var__temp_h'959 --->  Ty_heap  
 var__temp_v_err960 --->  error  
 var_h954 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h954, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h957, res ) ==(sel)( , var_h954, res ) => 
 	 Rel (sel)( , var__temp_h957, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h957, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'959, res ) ==((sel)( , var__temp_h957, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'959, res ) ==(10)
 
VC_END(declare-const var_h_i955 T3774)
(declare-const var_h954 T3774)
(declare-const v Int)
(declare-const var_h_i47 T3774)
(declare-const var_h46 T3774)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h957 T3774)
(declare-const var__temp_v958 Int)
(declare-const |var__temp_h'959| T3774)
(declare-const var__temp_v_err960 T3775)
(declare-const var_h954 T3774)
(declare-const var_h46 T3774)
(declare-const err T3788)

solver 
 (declare-sort T3774)
(declare-fun sel (T3774 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3774)
(declare-fun var_h954 () T3774)
(declare-fun |var__temp_h'959| () T3774)
(declare-fun var__temp_h957 () T3774)
(assert (= (sel var_h954 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'959| res) (+ (sel var__temp_h957 res) 3))
               (= (sel |var__temp_h'959| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h957 res) (sel var_h954 res))
                    (= (sel var__temp_h957 res) 7))
                (=> (= (sel var__temp_h957 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************249
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i955 Value = Ty_heap{ (sel)( , var_h_i955, res ) ==(sel)( , var_h954, res ) } 
 } 
 
                                                RET :  Base {var_v956:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i955 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i955 --->  Ty_heap  
 var_h954 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h961 --->  Ty_heap  
 var__temp_v962 --->  Ty_int  
 var__temp_h'963 --->  Ty_heap  
 var__temp_v_err964 --->  error  
 var_h954 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h954, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h961, res ) ==(sel)( , var_h954, res ) => 
 	 Rel (sel)( , var__temp_h961, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h961, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'963, res ) ==((sel)( , var__temp_h961, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'963, res ) ==(10)
 
VC_END(declare-const var_h_i955 T3791)
(declare-const var_h954 T3791)
(declare-const v Int)
(declare-const var_h_i47 T3791)
(declare-const var_h46 T3791)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h961 T3791)
(declare-const var__temp_v962 Int)
(declare-const |var__temp_h'963| T3791)
(declare-const var__temp_v_err964 T3792)
(declare-const var_h954 T3791)
(declare-const var_h46 T3791)
(declare-const err T3805)

solver 
 (declare-sort T3791)
(declare-fun sel (T3791 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3791)
(declare-fun var_h954 () T3791)
(declare-fun |var__temp_h'963| () T3791)
(declare-fun var__temp_h961 () T3791)
(assert (= (sel var_h954 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'963| res) (+ (sel var__temp_h961 res) 5))
               (= (sel |var__temp_h'963| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h961 res) (sel var_h954 res))
                    (= (sel var__temp_h961 res) 7))
                (=> (= (sel var__temp_h961 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************250
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i955 Value = Ty_heap{ (sel)( , var_h_i955, res ) ==(sel)( , var_h954, res ) } 
 } 
 
                                                RET :  Base {var_v956:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i955 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i955 --->  Ty_heap  
 var_h954 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h965 --->  Ty_heap  
 var__temp_v966 --->  Ty_int  
 var__temp_h'967 --->  Ty_heap  
 var__temp_v_err968 --->  error  
 var_h954 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h954, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h965, res ) ==(sel)( , var_h954, res ) => 
 	 Rel (sel)( , var__temp_h965, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h965, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'967, res ) ==((sel)( , var__temp_h965, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'967, res ) ==(10)
 
VC_END(declare-const var_h_i955 T3808)
(declare-const var_h954 T3808)
(declare-const v Int)
(declare-const var_h_i47 T3808)
(declare-const var_h46 T3808)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h965 T3808)
(declare-const var__temp_v966 Int)
(declare-const |var__temp_h'967| T3808)
(declare-const var__temp_v_err968 T3809)
(declare-const var_h954 T3808)
(declare-const var_h46 T3808)
(declare-const err T3822)

solver 
 (declare-sort T3808)
(declare-fun sel (T3808 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3808)
(declare-fun var_h954 () T3808)
(declare-fun |var__temp_h'967| () T3808)
(declare-fun var__temp_h965 () T3808)
(assert (= (sel var_h954 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'967| res) (+ (sel var__temp_h965 res) 4))
               (= (sel |var__temp_h'967| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h965 res) (sel var_h954 res))
                    (= (sel var__temp_h965 res) 6))
                (=> (= (sel var__temp_h965 res) 6) a!1))))
  (not a!2))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************251
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i955 Value = Ty_heap{ (sel)( , var_h_i955, res ) ==(sel)( , var_h954, res ) } 
 } 
 
                                                RET :  Base {var_v956:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i955 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i955 --->  Ty_heap  
 var_h954 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h969 --->  Ty_heap  
 var__temp_v970 --->  Ty_int  
 var__temp_h'971 --->  Ty_heap  
 var__temp_v_err972 --->  error  
 var_h954 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h954, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h969, res ) ==(sel)( , var_h954, res ) => 
 	 Rel (sel)( , var__temp_h969, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h969, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'971, res ) ==(var__temp_v970) AND 
 	 Base var__temp_v970 = 5 => 
 	 Rel (sel)( , var__temp_h'971, res ) ==(10)
 
VC_END(declare-const var_h_i955 T3825)
(declare-const var_h954 T3825)
(declare-const v Int)
(declare-const var_h_i47 T3825)
(declare-const var_h46 T3825)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h969 T3825)
(declare-const var__temp_v970 Int)
(declare-const |var__temp_h'971| T3825)
(declare-const var__temp_v_err972 T3826)
(declare-const var_h954 T3825)
(declare-const var_h46 T3825)
(declare-const err T3839)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3825)
(declare-fun sel (T3825 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3825)
(declare-fun var_h954 () T3825)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'971| () T3825)
(declare-fun var__temp_v970 () Int)
(declare-fun var__temp_h969 () T3825)
(assert (= (sel var_h954 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel |var__temp_h'971| res) var__temp_v970)
                    (= var__temp_v970 |5|))
               (= (sel |var__temp_h'971| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h969 res) (sel var_h954 res))
                    (= (sel var__temp_h969 res) 0))
                (=> (= (sel var__temp_h969 res) 0) a!1))))
  (not a!2))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************252
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i955 Value = Ty_heap{ (sel)( , var_h_i955, res ) ==(sel)( , var_h954, res ) } 
 } 
 
                                                RET :  Base {var_v956:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i955 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i955 --->  Ty_heap  
 var_h954 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h973 --->  Ty_heap  
 var__temp_v974 --->  Ty_int  
 var__temp_h'975 --->  Ty_heap  
 var__temp_v_err976 --->  error  
 var_h954 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h954, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h973, res ) ==(sel)( , var_h954, res ) => 
 	 Rel (sel)( , var__temp_h973, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h973, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'975, res ) ==((sel)( , var__temp_h973, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'975, res ) ==(10)
 
VC_END(declare-const var_h_i955 T3842)
(declare-const var_h954 T3842)
(declare-const v Int)
(declare-const var_h_i47 T3842)
(declare-const var_h46 T3842)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h973 T3842)
(declare-const var__temp_v974 Int)
(declare-const |var__temp_h'975| T3842)
(declare-const var__temp_v_err976 T3843)
(declare-const var_h954 T3842)
(declare-const var_h46 T3842)
(declare-const err T3856)

solver 
 (declare-sort T3842)
(declare-fun sel (T3842 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3842)
(declare-fun var_h954 () T3842)
(declare-fun |var__temp_h'975| () T3842)
(declare-fun var__temp_h973 () T3842)
(assert (= (sel var_h954 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'975| res) (+ (sel var__temp_h973 res) 2))
               (= (sel |var__temp_h'975| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h973 res) (sel var_h954 res))
                    (= (sel var__temp_h973 res) 5))
                (=> (= (sel var__temp_h973 res) 5) a!1))))
  (not a!2))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************253
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i955 Value = Ty_heap{ (sel)( , var_h_i955, res ) ==(sel)( , var_h954, res ) } 
 } 
 
                                                RET :  Base {var_v956:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i955 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i955 --->  Ty_heap  
 var_h954 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h977 --->  Ty_heap  
 var__temp_v978 --->  Ty_int  
 var__temp_h'979 --->  Ty_heap  
 var__temp_v_err980 --->  error  
 var_h954 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h954, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h977, res ) ==(sel)( , var_h954, res ) => 
 	 Rel (sel)( , var__temp_h977, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h977, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'979, res ) ==((sel)( , var__temp_h977, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h'979, res ) ==(10)
 
VC_END(declare-const var_h_i955 T3859)
(declare-const var_h954 T3859)
(declare-const v Int)
(declare-const var_h_i47 T3859)
(declare-const var_h46 T3859)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h977 T3859)
(declare-const var__temp_v978 Int)
(declare-const |var__temp_h'979| T3859)
(declare-const var__temp_v_err980 T3860)
(declare-const var_h954 T3859)
(declare-const var_h46 T3859)
(declare-const err T3873)

solver 
 (declare-sort T3859)
(declare-fun sel (T3859 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3859)
(declare-fun var_h954 () T3859)
(declare-fun |var__temp_h'979| () T3859)
(declare-fun var__temp_h977 () T3859)
(assert (= (sel var_h954 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'979| res) (+ (sel var__temp_h977 res) 10))
               (= (sel |var__temp_h'979| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h977 res) (sel var_h954 res))
                    (> (sel var__temp_h977 res) 4))
                (=> (> (sel var__temp_h977 res) 4) a!1))))
  (not a!2))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************254
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v956:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v956:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i955 Value = Ty_heap{ (sel)( , var_h_i955, res ) ==(sel)( , var_h954, res ) } 
 } 
 
                                                RET :  Base {var_v981:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
c2
 *********************Enumeration Iteration*****************255
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i955 Value = Ty_heap{ (sel)( , var_h_i955, res ) ==(sel)( , var_h954, res ) } 
 } 
 
                                                RET :  Base {var_v981:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i955 --->  Ty_heap  
 var_h954 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h982 --->  Ty_heap  
 var__temp_v983 --->  Ty_int  
 var__temp_h'984 --->  Ty_heap  
 var__temp_v_err985 --->  error  
 var_h954 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h954, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h982, res ) ==(sel)( , var_h954, res ) => 
 	 Rel (sel)( , var__temp_h982, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h982, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'984, res ) ==((sel)( , var__temp_h982, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i955 T3876)
(declare-const var_h954 T3876)
(declare-const v Int)
(declare-const var_h_i47 T3876)
(declare-const var_h46 T3876)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h982 T3876)
(declare-const var__temp_v983 Int)
(declare-const |var__temp_h'984| T3876)
(declare-const var__temp_v_err985 T3877)
(declare-const var_h954 T3876)
(declare-const var_h46 T3876)
(declare-const err T3890)

solver 
 (declare-sort T3876)
(declare-fun sel (T3876 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3876)
(declare-fun var_h954 () T3876)
(declare-fun var__temp_h982 () T3876)
(declare-fun |var__temp_h'984| () T3876)
(assert (= (sel var_h954 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'984| res) (+ (sel var__temp_h982 res) 3))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h982 res) (sel var_h954 res))
                    (= (sel var__temp_h982 res) 7))
                (=> (= (sel var__temp_h982 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************256
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i955 Value = Ty_heap{ (sel)( , var_h_i955, res ) ==(sel)( , var_h954, res ) } 
 } 
 
                                                RET :  Base {var_v981:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i955 --->  Ty_heap  
 var_h954 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h986 --->  Ty_heap  
 var__temp_v987 --->  Ty_int  
 var__temp_h'988 --->  Ty_heap  
 var__temp_v_err989 --->  error  
 var_h954 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h954, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h986, res ) ==(sel)( , var_h954, res ) => 
 	 Rel (sel)( , var__temp_h986, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h986, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'988, res ) ==((sel)( , var__temp_h986, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i955 T3893)
(declare-const var_h954 T3893)
(declare-const v Int)
(declare-const var_h_i47 T3893)
(declare-const var_h46 T3893)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h986 T3893)
(declare-const var__temp_v987 Int)
(declare-const |var__temp_h'988| T3893)
(declare-const var__temp_v_err989 T3894)
(declare-const var_h954 T3893)
(declare-const var_h46 T3893)
(declare-const err T3907)

solver 
 (declare-sort T3893)
(declare-fun sel (T3893 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3893)
(declare-fun var_h954 () T3893)
(declare-fun var__temp_h986 () T3893)
(declare-fun |var__temp_h'988| () T3893)
(assert (= (sel var_h954 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'988| res) (+ (sel var__temp_h986 res) 5))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h986 res) (sel var_h954 res))
                    (= (sel var__temp_h986 res) 7))
                (=> (= (sel var__temp_h986 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************257
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i955 Value = Ty_heap{ (sel)( , var_h_i955, res ) ==(sel)( , var_h954, res ) } 
 } 
 
                                                RET :  Base {var_v981:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i955 --->  Ty_heap  
 var_h954 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h990 --->  Ty_heap  
 var__temp_v991 --->  Ty_int  
 var__temp_h'992 --->  Ty_heap  
 var__temp_v_err993 --->  error  
 var_h954 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h954, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h990, res ) ==(sel)( , var_h954, res ) => 
 	 Rel (sel)( , var__temp_h990, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h990, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'992, res ) ==((sel)( , var__temp_h990, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i955 T3910)
(declare-const var_h954 T3910)
(declare-const v Int)
(declare-const var_h_i47 T3910)
(declare-const var_h46 T3910)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h990 T3910)
(declare-const var__temp_v991 Int)
(declare-const |var__temp_h'992| T3910)
(declare-const var__temp_v_err993 T3911)
(declare-const var_h954 T3910)
(declare-const var_h46 T3910)
(declare-const err T3924)

solver 
 (declare-sort T3910)
(declare-fun sel (T3910 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3910)
(declare-fun var_h954 () T3910)
(declare-fun var__temp_h990 () T3910)
(declare-fun |var__temp_h'992| () T3910)
(assert (= (sel var_h954 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'992| res) (+ (sel var__temp_h990 res) 4))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h990 res) (sel var_h954 res))
                    (= (sel var__temp_h990 res) 6))
                (=> (= (sel var__temp_h990 res) 6) a!1))))
  (not a!2))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************258
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i955 Value = Ty_heap{ (sel)( , var_h_i955, res ) ==(sel)( , var_h954, res ) } 
 } 
 
                                                RET :  Base {var_v981:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i955 --->  Ty_heap  
 var_h954 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h994 --->  Ty_heap  
 var__temp_v995 --->  Ty_int  
 var__temp_h'996 --->  Ty_heap  
 var__temp_v_err997 --->  error  
 var_h954 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h954, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h994, res ) ==(sel)( , var_h954, res ) => 
 	 Rel (sel)( , var__temp_h994, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h994, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'996, res ) ==(var__temp_v995) AND 
 	 Base var__temp_v995 = 5 => 
 	 True
 
VC_END(declare-const var_h_i955 T3927)
(declare-const var_h954 T3927)
(declare-const v Int)
(declare-const var_h_i47 T3927)
(declare-const var_h46 T3927)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h994 T3927)
(declare-const var__temp_v995 Int)
(declare-const |var__temp_h'996| T3927)
(declare-const var__temp_v_err997 T3928)
(declare-const var_h954 T3927)
(declare-const var_h46 T3927)
(declare-const err T3941)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3927)
(declare-fun sel (T3927 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3927)
(declare-fun var_h954 () T3927)
(declare-fun |5| () Int)
(declare-fun var__temp_v995 () Int)
(declare-fun |var__temp_h'996| () T3927)
(declare-fun var__temp_h994 () T3927)
(assert (= (sel var_h954 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel |var__temp_h'996| res) var__temp_v995)
                    (= var__temp_v995 |5|))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h994 res) (sel var_h954 res))
                    (= (sel var__temp_h994 res) 0))
                (=> (= (sel var__temp_h994 res) 0) a!1))))
  (not a!2))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************259
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i955 Value = Ty_heap{ (sel)( , var_h_i955, res ) ==(sel)( , var_h954, res ) } 
 } 
 
                                                RET :  Base {var_v981:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i955 --->  Ty_heap  
 var_h954 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h998 --->  Ty_heap  
 var__temp_v999 --->  Ty_int  
 var__temp_h'1000 --->  Ty_heap  
 var__temp_v_err1001 --->  error  
 var_h954 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h954, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h998, res ) ==(sel)( , var_h954, res ) => 
 	 Rel (sel)( , var__temp_h998, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h998, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'1000, res ) ==((sel)( , var__temp_h998, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i955 T3944)
(declare-const var_h954 T3944)
(declare-const v Int)
(declare-const var_h_i47 T3944)
(declare-const var_h46 T3944)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h998 T3944)
(declare-const var__temp_v999 Int)
(declare-const |var__temp_h'1000| T3944)
(declare-const var__temp_v_err1001 T3945)
(declare-const var_h954 T3944)
(declare-const var_h46 T3944)
(declare-const err T3958)

solver 
 (declare-sort T3944)
(declare-fun sel (T3944 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3944)
(declare-fun var_h954 () T3944)
(declare-fun var__temp_h998 () T3944)
(declare-fun |var__temp_h'1000| () T3944)
(assert (= (sel var_h954 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'1000| res) (+ (sel var__temp_h998 res) 2))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h998 res) (sel var_h954 res))
                    (= (sel var__temp_h998 res) 5))
                (=> (= (sel var__temp_h998 res) 5) a!1))))
  (not a!2))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************260
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i955 Value = Ty_heap{ (sel)( , var_h_i955, res ) ==(sel)( , var_h954, res ) } 
 } 
 
                                                RET :  Base {var_v981:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i955 --->  Ty_heap  
 var_h954 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1002 --->  Ty_heap  
 var__temp_v1003 --->  Ty_int  
 var__temp_h'1004 --->  Ty_heap  
 var__temp_v_err1005 --->  error  
 var_h954 --->  Ty_heap  
 var_h46 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h954, res ) ==((sel)( , var_h46, res ) + (3)) AND 
 	 Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1002, res ) ==(sel)( , var_h954, res ) => 
 	 Rel (sel)( , var__temp_h1002, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1002, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'1004, res ) ==((sel)( , var__temp_h1002, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i955 T3961)
(declare-const var_h954 T3961)
(declare-const v Int)
(declare-const var_h_i47 T3961)
(declare-const var_h46 T3961)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h1002 T3961)
(declare-const var__temp_v1003 Int)
(declare-const |var__temp_h'1004| T3961)
(declare-const var__temp_v_err1005 T3962)
(declare-const var_h954 T3961)
(declare-const var_h46 T3961)
(declare-const err T3975)

solver 
 (declare-sort T3961)
(declare-fun sel (T3961 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3961)
(declare-fun var_h954 () T3961)
(declare-fun var__temp_h1002 () T3961)
(declare-fun |var__temp_h'1004| () T3961)
(assert (= (sel var_h954 res) (+ (sel var_h46 res) 3)))
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'1004| res) (+ (sel var__temp_h1002 res) 10))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h1002 res) (sel var_h954 res))
                    (> (sel var__temp_h1002 res) 4))
                (=> (> (sel var__temp_h1002 res) 4) a!1))))
  (not a!2))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************261
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2'
PARTIAL PATH
SUB 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v1006:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo
bar
c2
 *********************Enumeration Iteration*****************262
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v1006:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1007 --->  Ty_heap  
 var__temp_v1008 --->  Ty_int  
 var__temp_h'1009 --->  Ty_heap  
 var__temp_v_err1010 --->  error  
 var_h46 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1007, res ) ==((sel)( , var_h46, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h1007, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1007, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1009, res ) ==((sel)( , var__temp_h1007, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i47 T3978)
(declare-const var_h46 T3978)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h1007 T3978)
(declare-const var__temp_v1008 Int)
(declare-const |var__temp_h'1009| T3978)
(declare-const var__temp_v_err1010 T3979)
(declare-const var_h46 T3978)
(declare-const err T3992)

solver 
 (declare-sort T3978)
(declare-fun sel (T3978 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3978)
(declare-fun var__temp_h1007 () T3978)
(declare-fun |var__temp_h'1009| () T3978)
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1007 res) (+ (sel var_h46 res) 3))
               (= (sel var__temp_h1007 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1009| res) (+ (sel var__temp_h1007 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1007 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************263
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v1006:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1011 --->  Ty_heap  
 var__temp_v1012 --->  Ty_int  
 var__temp_h'1013 --->  Ty_heap  
 var__temp_v_err1014 --->  error  
 var_h46 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1011, res ) ==((sel)( , var_h46, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h1011, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1011, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1013, res ) ==((sel)( , var__temp_h1011, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i47 T3995)
(declare-const var_h46 T3995)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h1011 T3995)
(declare-const var__temp_v1012 Int)
(declare-const |var__temp_h'1013| T3995)
(declare-const var__temp_v_err1014 T3996)
(declare-const var_h46 T3995)
(declare-const err T4009)

solver 
 (declare-sort T3995)
(declare-fun sel (T3995 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T3995)
(declare-fun var__temp_h1011 () T3995)
(declare-fun |var__temp_h'1013| () T3995)
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1011 res) (+ (sel var_h46 res) 3))
               (= (sel var__temp_h1011 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1013| res) (+ (sel var__temp_h1011 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1011 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************264
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v1006:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1015 --->  Ty_heap  
 var__temp_v1016 --->  Ty_int  
 var__temp_h'1017 --->  Ty_heap  
 var__temp_v_err1018 --->  error  
 var_h46 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1015, res ) ==((sel)( , var_h46, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h1015, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h1015, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'1017, res ) ==((sel)( , var__temp_h1015, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i47 T4012)
(declare-const var_h46 T4012)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h1015 T4012)
(declare-const var__temp_v1016 Int)
(declare-const |var__temp_h'1017| T4012)
(declare-const var__temp_v_err1018 T4013)
(declare-const var_h46 T4012)
(declare-const err T4026)

solver 
 (declare-sort T4012)
(declare-fun sel (T4012 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T4012)
(declare-fun var__temp_h1015 () T4012)
(declare-fun |var__temp_h'1017| () T4012)
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1015 res) (+ (sel var_h46 res) 3))
               (= (sel var__temp_h1015 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'1017| res) (+ (sel var__temp_h1015 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1015 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************265
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v1006:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1019 --->  Ty_heap  
 var__temp_v1020 --->  Ty_int  
 var__temp_h'1021 --->  Ty_heap  
 var__temp_v_err1022 --->  error  
 var_h46 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1019, res ) ==((sel)( , var_h46, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h1019, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h1019, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1021, res ) ==(var__temp_v1020) AND 
 	 Base var__temp_v1020 = 5 => 
 	 True
 
VC_END(declare-const var_h_i47 T4029)
(declare-const var_h46 T4029)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h1019 T4029)
(declare-const var__temp_v1020 Int)
(declare-const |var__temp_h'1021| T4029)
(declare-const var__temp_v_err1022 T4030)
(declare-const var_h46 T4029)
(declare-const err T4043)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4029)
(declare-fun sel (T4029 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T4029)
(declare-fun |5| () Int)
(declare-fun var__temp_v1020 () Int)
(declare-fun |var__temp_h'1021| () T4029)
(declare-fun var__temp_h1019 () T4029)
(assert (= (sel var_h46 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h1019 res) (+ (sel var_h46 res) 3))
               (= (sel var__temp_h1019 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'1021| res) var__temp_v1020)
                    (= var__temp_v1020 |5|))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1019 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************266
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v1006:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1023 --->  Ty_heap  
 var__temp_v1024 --->  Ty_int  
 var__temp_h'1025 --->  Ty_heap  
 var__temp_v_err1026 --->  error  
 var_h46 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1023, res ) ==((sel)( , var_h46, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h1023, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1023, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'1025, res ) ==((sel)( , var__temp_h1023, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i47 T4046)
(declare-const var_h46 T4046)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h1023 T4046)
(declare-const var__temp_v1024 Int)
(declare-const |var__temp_h'1025| T4046)
(declare-const var__temp_v_err1026 T4047)
(declare-const var_h46 T4046)
(declare-const err T4060)

solver 
 (declare-sort T4046)
(declare-fun sel (T4046 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T4046)
(declare-fun var__temp_h1023 () T4046)
(declare-fun |var__temp_h'1025| () T4046)
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1023 res) (+ (sel var_h46 res) 3))
               (= (sel var__temp_h1023 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'1025| res) (+ (sel var__temp_h1023 res) 2))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1023 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************267
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i47 Value = Ty_heap{ (sel)( , var_h_i47, res ) ==((sel)( , var_h46, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v1006:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i47 --->  Ty_heap  
 var_h46 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1027 --->  Ty_heap  
 var__temp_v1028 --->  Ty_int  
 var__temp_h'1029 --->  Ty_heap  
 var__temp_v_err1030 --->  error  
 var_h46 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h46, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1027, res ) ==((sel)( , var_h46, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h1027, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1027, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'1029, res ) ==((sel)( , var__temp_h1027, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i47 T4063)
(declare-const var_h46 T4063)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h1027 T4063)
(declare-const var__temp_v1028 Int)
(declare-const |var__temp_h'1029| T4063)
(declare-const var__temp_v_err1030 T4064)
(declare-const var_h46 T4063)
(declare-const err T4077)

solver 
 (declare-sort T4063)
(declare-fun sel (T4063 Int) Int)
(declare-fun res () Int)
(declare-fun var_h46 () T4063)
(declare-fun var__temp_h1027 () T4063)
(declare-fun |var__temp_h'1029| () T4063)
(assert (= (sel var_h46 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1027 res) (+ (sel var_h46 res) 3))
               (> (sel var__temp_h1027 res) 4)))
      (a!2 (=> (= (sel |var__temp_h'1029| res) (+ (sel var__temp_h1027 res) 10))
               true)))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h1027 res) 4) a!2))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************268
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2'
PARTIAL PATH
SUB 
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {var_v1031:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
c4
foo'
foo
bar
c2'
c2
 *********************Enumeration Iteration*****************269
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {var_v1031:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1032 --->  Ty_heap  
 var__temp_v1033 --->  Ty_int  
 var__temp_h'1034 --->  Ty_heap  
 var__temp_v_err1035 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1032, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h1032, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1032, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1034, res ) ==((sel)( , var__temp_h1032, res ) + (3)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h1032 T4080)
(declare-const var__temp_v1033 Int)
(declare-const |var__temp_h'1034| T4080)
(declare-const var__temp_v_err1035 T4081)
(declare-const err T4094)

solver 
 (declare-sort T4080)
(declare-fun sel (T4080 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h1032 () T4080)
(declare-fun |var__temp_h'1034| () T4080)
(assert true)
(assert (let ((a!1 (=> (= (sel |var__temp_h'1034| res) (+ (sel var__temp_h1032 res) 3))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h1032 res) 0)
                    (= (sel var__temp_h1032 res) 7))
                (=> (= (sel var__temp_h1032 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************270
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {var_v1031:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1036 --->  Ty_heap  
 var__temp_v1037 --->  Ty_int  
 var__temp_h'1038 --->  Ty_heap  
 var__temp_v_err1039 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1036, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h1036, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1036, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1038, res ) ==((sel)( , var__temp_h1036, res ) + (5)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h1036 T4097)
(declare-const var__temp_v1037 Int)
(declare-const |var__temp_h'1038| T4097)
(declare-const var__temp_v_err1039 T4098)
(declare-const err T4111)

solver 
 (declare-sort T4097)
(declare-fun sel (T4097 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h1036 () T4097)
(declare-fun |var__temp_h'1038| () T4097)
(assert true)
(assert (let ((a!1 (=> (= (sel |var__temp_h'1038| res) (+ (sel var__temp_h1036 res) 5))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h1036 res) 0)
                    (= (sel var__temp_h1036 res) 7))
                (=> (= (sel var__temp_h1036 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************271
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {var_v1031:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1040 --->  Ty_heap  
 var__temp_v1041 --->  Ty_int  
 var__temp_h'1042 --->  Ty_heap  
 var__temp_v_err1043 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1040, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h1040, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h1040, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'1042, res ) ==((sel)( , var__temp_h1040, res ) + (4)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h1040 T4114)
(declare-const var__temp_v1041 Int)
(declare-const |var__temp_h'1042| T4114)
(declare-const var__temp_v_err1043 T4115)
(declare-const err T4128)

solver 
 (declare-sort T4114)
(declare-fun sel (T4114 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h1040 () T4114)
(declare-fun |var__temp_h'1042| () T4114)
(assert true)
(assert (let ((a!1 (=> (= (sel |var__temp_h'1042| res) (+ (sel var__temp_h1040 res) 4))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h1040 res) 0)
                    (= (sel var__temp_h1040 res) 6))
                (=> (= (sel var__temp_h1040 res) 6) a!1))))
  (not a!2))))

***************Selection Failed************c41
 *********************Enumeration Iteration*****************272
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (30) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (6)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {var_v1031:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (6)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1044 --->  Ty_heap  
 var__temp_v1045 --->  Ty_int  
 var__temp_h'1046 --->  Ty_heap  
 var__temp_v_err1047 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1044, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h1044, res ) > (30) AND 
 	 Rel (sel)( , var__temp_h1044, res ) > (30) => 
 	 Rel (sel)( , var__temp_h'1046, res ) ==((sel)( , var__temp_h1044, res ) + (6)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h1044 T4131)
(declare-const var__temp_v1045 Int)
(declare-const |var__temp_h'1046| T4131)
(declare-const var__temp_v_err1047 T4132)
(declare-const err T4145)

solver 
 (declare-sort T4131)
(declare-fun sel (T4131 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h1044 () T4131)
(declare-fun |var__temp_h'1046| () T4131)
(assert true)
(assert (let ((a!1 (=> (= (sel var__temp_h1044 res) 0)
               (not (> (sel var__temp_h1044 res) 30))))
      (a!2 (=> (= (sel |var__temp_h'1046| res) (+ (sel var__temp_h1044 res) 6))
               true)))
(let ((a!3 (=> (not (> (sel var__temp_h1044 res) 30)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Successful************c4
PARTIAL PATH NEW
NEW 	 --c4
post_substituted Forall 
 	 
 Key =var_h_i1049 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1049 Value = Ty_heap{ (sel)( , var_h_i1049, res ) ==((sel)( , var_h1048, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v1050:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1049 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c41
foo'
foo
bar
c2'
c2
 *********************Enumeration Iteration*****************273
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1049 Value = Ty_heap{ (sel)( , var_h_i1049, res ) ==((sel)( , var_h1048, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v1050:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1049 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1049 --->  Ty_heap  
 var_h1048 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1051 --->  Ty_heap  
 var__temp_v1052 --->  Ty_int  
 var__temp_h'1053 --->  Ty_heap  
 var__temp_v_err1054 --->  error  
 var_h1048 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1048, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1051, res ) ==((sel)( , var_h1048, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h1051, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1051, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1053, res ) ==((sel)( , var__temp_h1051, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'1053, res ) ==(10)
 
VC_END(declare-const var_h_i1049 T4148)
(declare-const var_h1048 T4148)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h1051 T4148)
(declare-const var__temp_v1052 Int)
(declare-const |var__temp_h'1053| T4148)
(declare-const var__temp_v_err1054 T4149)
(declare-const var_h1048 T4148)
(declare-const err T4162)

solver 
 (declare-sort T4148)
(declare-fun sel (T4148 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1048 () T4148)
(declare-fun |var__temp_h'1053| () T4148)
(declare-fun var__temp_h1051 () T4148)
(assert (= (sel var_h1048 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1051 res) (+ (sel var_h1048 res) 6))
               (= (sel var__temp_h1051 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1053| res) (+ (sel var__temp_h1051 res) 3))
               (= (sel |var__temp_h'1053| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1051 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************274
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1049 Value = Ty_heap{ (sel)( , var_h_i1049, res ) ==((sel)( , var_h1048, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v1050:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1049 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1049 --->  Ty_heap  
 var_h1048 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1055 --->  Ty_heap  
 var__temp_v1056 --->  Ty_int  
 var__temp_h'1057 --->  Ty_heap  
 var__temp_v_err1058 --->  error  
 var_h1048 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1048, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1055, res ) ==((sel)( , var_h1048, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h1055, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1055, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1057, res ) ==((sel)( , var__temp_h1055, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'1057, res ) ==(10)
 
VC_END(declare-const var_h_i1049 T4165)
(declare-const var_h1048 T4165)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h1055 T4165)
(declare-const var__temp_v1056 Int)
(declare-const |var__temp_h'1057| T4165)
(declare-const var__temp_v_err1058 T4166)
(declare-const var_h1048 T4165)
(declare-const err T4179)

solver 
 (declare-sort T4165)
(declare-fun sel (T4165 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1048 () T4165)
(declare-fun |var__temp_h'1057| () T4165)
(declare-fun var__temp_h1055 () T4165)
(assert (= (sel var_h1048 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1055 res) (+ (sel var_h1048 res) 6))
               (= (sel var__temp_h1055 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1057| res) (+ (sel var__temp_h1055 res) 5))
               (= (sel |var__temp_h'1057| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1055 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************275
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1049 Value = Ty_heap{ (sel)( , var_h_i1049, res ) ==((sel)( , var_h1048, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v1050:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1049 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1049 --->  Ty_heap  
 var_h1048 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c41 --->  Ty_int  
 c4 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1059 --->  Ty_heap  
 var__temp_v1060 --->  Ty_int  
 var__temp_h'1061 --->  Ty_heap  
 var__temp_v_err1062 --->  error  
 var_h1048 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1048, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1059, res ) ==((sel)( , var_h1048, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h1059, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h1059, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'1061, res ) ==((sel)( , var__temp_h1059, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'1061, res ) ==(10)
 
VC_END(declare-const var_h_i1049 T4182)
(declare-const var_h1048 T4182)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c41 Int)
(declare-const c4 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const res Int)
(declare-const var__temp_h1059 T4182)
(declare-const var__temp_v1060 Int)
(declare-const |var__temp_h'1061| T4182)
(declare-const var__temp_v_err1062 T4183)
(declare-const var_h1048 T4182)
(declare-const err T4196)

solver 
 (declare-sort T4182)
(declare-fun sel (T4182 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1048 () T4182)
(declare-fun |var__temp_h'1061| () T4182)
(declare-fun var__temp_h1059 () T4182)
(assert (= (sel var_h1048 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1059 res) (+ (sel var_h1048 res) 6))
               (= (sel var__temp_h1059 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'1061| res) (+ (sel var__temp_h1059 res) 4))
               (= (sel |var__temp_h'1061| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1059 res) 6) a!2))))
  (not a!3))))

***************Selection Successful************c41Single Component Enumeration Succeeded
PARTIAL PATH NEW
SUB 	 --c4	 --c41
Found e2 in (x <- e1 in e2)
{ 
Eret { 
Evar c41 
 } 
 }
ENUM ::c41::c5::baz::c4::c41::c5::baz::c2::bar::foo::c41::c5::baz::c2::bar::foo::c41::c5::baz::c2::bar::foo::c41::c5::baz::c2'::bar::foo::c41::c5::baz::bar::foo::c41::c5::baz::bar::foo::c41::c5::baz::bar::foo::c41::c5::baz::c2::bar::foo::c41::c5::baz::bar::foo::c41::c5::baz::bar::foo::c41::c5::baz::bar::foo::c41::c5::baz::c2::bar::foo::c41::c5::baz::c2::bar::foo::c41::c5::baz::c2'::bar::foo::c41::c5::baz::c2::c2'::bar::foo::c41::c5::baz::foo'::c41::c5::baz::bar::foo::c41::c5::baz::bar::foo::c41::c5::baz::bar::foo::c41::c5::baz::c2::bar::foo::c41::c5::baz::bar::foo::c41::c5::baz::bar::foo::c41::c5::baz::bar::foo::c41::c5::baz::c2::bar::foo::c41::c5::baz::c2::bar::foo::c41::c5::baz::c2'::bar::foo::c41::c5::baz::bar::foo::c41::c5::baz::bar::foo::c41::c5::baz::bar::foo::c41::c5::baz::c2::bar::foo::c41::c5::baz::bar::foo::c41::c5::baz::bar::foo::c41::c5::baz::bar::foo::c41::c5::baz::c2::bar::foo::c41::c5::baz::c2::bar::foo::c41::c5::baz::c2'::bar::foo::c41::c5::baz::c2::c2'::bar::foo::c41::c5::baz::foo'::c41::c5::baz::c2::c2'::bar::foo::foo'::c41::c5::baz::c4::c41::c5::baz::c2::c2'::bar::foo::foo'::c4::c41::c5::baz::c3'::c2::c2'::bar::foo::foo'::c4::c41::c5::baz::c3'
SUB 
 	 --c4
 	 --c41
 	 --c4Success : { 
Ebind Evar v <- { 
Eret { 
Evar c4 
 } 
 } in { 
Eret { 
Evar c41 
 } 
 } 
 }