
 specfile :: synth_tests/eff12.specres : int;

bar : State  {\(h : heap). sel (h, res) == 5} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == v 
		/\ sel (h', res) == sel (h, res) + 2};

foo : State  {\(h : heap). sel (h, res) == 0} 
	v : { v : int |  [v=5]} 
	{\(h : heap), (v : int), (h' : heap). sel (h', res) == v /\ [v=5]};

foo' : State  {\(h : heap). true} 
	v : { v : int |  [v=5]} 
	{\(h : heap), (v : int), (h' : heap). sel (h', res) == v /\ [v=20]};


c2 : State  {\(h : heap). sel (h, res) > 4} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == v 
		/\ sel (h', res) == sel (h, res) + 10};


c2' : State  {\(h : heap). not (sel (h, res) > 20)} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == v 
		/\ sel (h, res) == sel (h, res)};


c4 : State  {\(h : heap). not (sel (h, res) > 30)} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == v 
		/\ sel (h', res) == sel (h, res) + 5};



c5 : State  {\(h : heap). sel (h, res) == 7} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == v 
		/\ sel (h', res) == sel (h, res) + 5};


baz : State  {\(h : heap). sel (h, res) == 7} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == v 
		/\ sel (h', res) == sel (h, res) + 3};

c3' : State  {\(h : heap). not (sel (h, res) > 8)} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == v 
		/\ sel (h', res) == sel (h, res) + 3};



goal : State  {\(h : heap). sel (h, res) == 0} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == v 
		/\ sel (h', res) == 10};

var: res
whitespace colon
whitespace var: int
semicolon
var: bar
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 5
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 2
rcurly
semicolon
var: foo
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 0
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace lbrace
var: v
equalopint: 5
rbrace
rcurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace conjwhitespace lbrace
var: v
equalopint: 5
rbrace
rcurly
semicolon
var: foo'
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace truercurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace lbrace
var: v
equalopint: 5
rbrace
rcurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace conjwhitespace lbrace
var: v
equalopint: 20
rbrace
rcurly
semicolon
var: c2
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace lessthanopwhitespace int: 4
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 10
rcurly
semicolon
var: c2'
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace notwhitespace lparen
var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace lessthanopwhitespace int: 20
rparen
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace whitespace conjwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
rcurly
semicolon
var: c4
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace notwhitespace lparen
var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace lessthanopwhitespace int: 30
rparen
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 5
rcurly
semicolon
var: c5
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 7
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 5
rcurly
semicolon
var: baz
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 7
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 3
rcurly
semicolon
var: c3'
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace notwhitespace lparen
var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace lessthanopwhitespace int: 8
rparen
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 3
rcurly
semicolon
var: goal
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 0
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 10
rcurly
semicolon
RelSpec {  SRs ;  PRs ;  TSs  
 Assume false
 name res : 
 params :
 Type Base {var_v0:Ty_int | true} 
 Assume false
 name bar : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 ) 
 Assume false
 name foo : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 ) 
 Assume false
 name foo' : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 ) 
 Assume false
 name c2 : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 ) 
 Assume false
 name c2' : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h, res ) ==(sel)( , h, res ) >c  } 
 } 
 ) 
 Assume false
 name c4 : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (30) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 ) 
 Assume false
 name c5 : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 ) 
 Assume false
 name baz : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 ) 
 Assume false
 name c3' : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (8) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 ) 
 Assume false
 name goal : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 );  Formulas  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
c3'
baz
c5
c4
c2'
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************0
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (8) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1 --->  Ty_heap  
 var__temp_v2 --->  Ty_int  
 var__temp_h'3 --->  Ty_heap  
 var__temp_v_err4 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h1, res ) > (8) AND 
 	 Rel (sel)( , var__temp_h1, res ) > (8) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3, res ) ==(var__temp_v2) AND 
 	 Rel (sel)( , var__temp_h'3, res ) ==((sel)( , var__temp_h1, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3, res ) ==(var__temp_v2) AND 
 	 Rel (sel)( , var__temp_h'3, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1 T0)
(declare-const var__temp_v2 Int)
(declare-const |var__temp_h'3| T0)
(declare-const var__temp_v_err4 T1)
(declare-const err T14)

solver 
 (declare-sort T0)
(declare-fun sel (T0 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'3| () T0)
(declare-fun var__temp_v2 () Int)
(declare-fun var__temp_h1 () T0)
(assert true)
(assert (let ((a!1 (=> (= (sel var__temp_h1 res) 0) (not (> (sel var__temp_h1 res) 8))))
      (a!2 (and (= (sel |var__temp_h'3| res) var__temp_v2)
                (= (sel |var__temp_h'3| res) (+ (sel var__temp_h1 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'3| res) var__temp_v2)
                    (= (sel |var__temp_h'3| res) 10)))))
(let ((a!4 (=> (not (> (sel var__temp_h1 res) 8)) a!3)))
  (not (and a!1 a!4))))))

***************Selection Failed************c3'
 *********************Enumeration Iteration*****************1
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h5 --->  Ty_heap  
 var__temp_v6 --->  Ty_int  
 var__temp_h'7 --->  Ty_heap  
 var__temp_v_err8 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h5, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h5, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h5, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'7, res ) ==(var__temp_v6) AND 
 	 Rel (sel)( , var__temp_h'7, res ) ==((sel)( , var__temp_h5, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'7, res ) ==(var__temp_v6) AND 
 	 Rel (sel)( , var__temp_h'7, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h5 T17)
(declare-const var__temp_v6 Int)
(declare-const |var__temp_h'7| T17)
(declare-const var__temp_v_err8 T18)
(declare-const err T31)

solver 
 (declare-sort T17)
(declare-fun sel (T17 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'7| () T17)
(declare-fun var__temp_v6 () Int)
(declare-fun var__temp_h5 () T17)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'7| res) var__temp_v6)
                (= (sel |var__temp_h'7| res) (+ (sel var__temp_h5 res) 3)))))
(let ((a!2 (=> a!1
               (and (= (sel |var__temp_h'7| res) var__temp_v6)
                    (= (sel |var__temp_h'7| res) 10)))))
(let ((a!3 (and (=> (= (sel var__temp_h5 res) 0) (= (sel var__temp_h5 res) 7))
                (=> (= (sel var__temp_h5 res) 7) a!2))))
  (not a!3)))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************2
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h9 --->  Ty_heap  
 var__temp_v10 --->  Ty_int  
 var__temp_h'11 --->  Ty_heap  
 var__temp_v_err12 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h9, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h9, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h9, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'11, res ) ==(var__temp_v10) AND 
 	 Rel (sel)( , var__temp_h'11, res ) ==((sel)( , var__temp_h9, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'11, res ) ==(var__temp_v10) AND 
 	 Rel (sel)( , var__temp_h'11, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h9 T34)
(declare-const var__temp_v10 Int)
(declare-const |var__temp_h'11| T34)
(declare-const var__temp_v_err12 T35)
(declare-const err T48)

solver 
 (declare-sort T34)
(declare-fun sel (T34 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'11| () T34)
(declare-fun var__temp_v10 () Int)
(declare-fun var__temp_h9 () T34)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'11| res) var__temp_v10)
                (= (sel |var__temp_h'11| res) (+ (sel var__temp_h9 res) 5)))))
(let ((a!2 (=> a!1
               (and (= (sel |var__temp_h'11| res) var__temp_v10)
                    (= (sel |var__temp_h'11| res) 10)))))
(let ((a!3 (and (=> (= (sel var__temp_h9 res) 0) (= (sel var__temp_h9 res) 7))
                (=> (= (sel var__temp_h9 res) 7) a!2))))
  (not a!3)))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************3
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (30) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h13 --->  Ty_heap  
 var__temp_v14 --->  Ty_int  
 var__temp_h'15 --->  Ty_heap  
 var__temp_v_err16 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h13, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h13, res ) > (30) AND 
 	 Rel (sel)( , var__temp_h13, res ) > (30) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'15, res ) ==(var__temp_v14) AND 
 	 Rel (sel)( , var__temp_h'15, res ) ==((sel)( , var__temp_h13, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'15, res ) ==(var__temp_v14) AND 
 	 Rel (sel)( , var__temp_h'15, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h13 T51)
(declare-const var__temp_v14 Int)
(declare-const |var__temp_h'15| T51)
(declare-const var__temp_v_err16 T52)
(declare-const err T65)

solver 
 (declare-sort T51)
(declare-fun sel (T51 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'15| () T51)
(declare-fun var__temp_v14 () Int)
(declare-fun var__temp_h13 () T51)
(assert true)
(assert (let ((a!1 (=> (= (sel var__temp_h13 res) 0)
               (not (> (sel var__temp_h13 res) 30))))
      (a!2 (and (= (sel |var__temp_h'15| res) var__temp_v14)
                (= (sel |var__temp_h'15| res) (+ (sel var__temp_h13 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'15| res) var__temp_v14)
                    (= (sel |var__temp_h'15| res) 10)))))
(let ((a!4 (=> (not (> (sel var__temp_h13 res) 30)) a!3)))
  (not (and a!1 a!4))))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************4
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h, res ) ==(sel)( , h, res ) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h, res ) ==(sel)( , h, res ) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h17 --->  Ty_heap  
 var__temp_v18 --->  Ty_int  
 var__temp_h'19 --->  Ty_heap  
 var__temp_v_err20 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h17, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h17, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h17, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'19, res ) ==(var__temp_v18) AND 
 	 Rel (sel)( , var__temp_h17, res ) ==(sel)( , var__temp_h17, res ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'19, res ) ==(var__temp_v18) AND 
 	 Rel (sel)( , var__temp_h'19, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h17 T68)
(declare-const var__temp_v18 Int)
(declare-const |var__temp_h'19| T68)
(declare-const var__temp_v_err20 T69)
(declare-const err T82)

solver 
 (declare-sort T68)
(declare-fun sel (T68 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'19| () T68)
(declare-fun var__temp_v18 () Int)
(declare-fun var__temp_h17 () T68)
(assert true)
(assert (let ((a!1 (=> (= (sel var__temp_h17 res) 0)
               (not (> (sel var__temp_h17 res) 20))))
      (a!2 (=> (and (= (sel |var__temp_h'19| res) var__temp_v18)
                    (= (sel var__temp_h17 res) (sel var__temp_h17 res)))
               (and (= (sel |var__temp_h'19| res) var__temp_v18)
                    (= (sel |var__temp_h'19| res) 10)))))
(let ((a!3 (=> (not (> (sel var__temp_h17 res) 20)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************5
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h21 --->  Ty_heap  
 var__temp_v22 --->  Ty_int  
 var__temp_h'23 --->  Ty_heap  
 var__temp_v_err24 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h21, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h21, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h21, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'23, res ) ==(var__temp_v22) AND 
 	 Rel (sel)( , var__temp_h'23, res ) ==((sel)( , var__temp_h21, res ) + (10)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'23, res ) ==(var__temp_v22) AND 
 	 Rel (sel)( , var__temp_h'23, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h21 T85)
(declare-const var__temp_v22 Int)
(declare-const |var__temp_h'23| T85)
(declare-const var__temp_v_err24 T86)
(declare-const err T99)

solver 
 (declare-sort T85)
(declare-fun sel (T85 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'23| () T85)
(declare-fun var__temp_v22 () Int)
(declare-fun var__temp_h21 () T85)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'23| res) var__temp_v22)
                (= (sel |var__temp_h'23| res) (+ (sel var__temp_h21 res) 10)))))
(let ((a!2 (=> a!1
               (and (= (sel |var__temp_h'23| res) var__temp_v22)
                    (= (sel |var__temp_h'23| res) 10)))))
(let ((a!3 (and (=> (= (sel var__temp_h21 res) 0) (> (sel var__temp_h21 res) 4))
                (=> (> (sel var__temp_h21 res) 4) a!2))))
  (not a!3)))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************6
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h25 --->  Ty_heap  
 var__temp_v26 --->  Ty_int  
 var__temp_h'27 --->  Ty_heap  
 var__temp_v_err28 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h25, res ) ==(0) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'27, res ) ==(var__temp_v26) AND 
 	 Base var__temp_v26 = 20 => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'27, res ) ==(var__temp_v26) AND 
 	 Rel (sel)( , var__temp_h'27, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h25 T102)
(declare-const var__temp_v26 Int)
(declare-const |var__temp_h'27| T102)
(declare-const var__temp_v_err28 T103)
(declare-const err T116)
    (declare-const |20| Int)
  
solver 
 (declare-sort T102)
(declare-fun |20| () Int)
(declare-fun sel (T102 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'27| () T102)
(declare-fun var__temp_v26 () Int)
(declare-fun var__temp_h25 () T102)
(assert true)
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel |var__temp_h'27| res) var__temp_v26)
                    (= var__temp_v26 |20|))
               (and (= (sel |var__temp_h'27| res) var__temp_v26)
                    (= (sel |var__temp_h'27| res) 10)))))
(let ((a!2 (and (=> (= (sel var__temp_h25 res) 0) true) (=> true a!1))))
  (not a!2))))

***************Selection Failed************foo'
 *********************Enumeration Iteration*****************7
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h29 --->  Ty_heap  
 var__temp_v30 --->  Ty_int  
 var__temp_h'31 --->  Ty_heap  
 var__temp_v_err32 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h29, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h29, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h29, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'31, res ) ==(var__temp_v30) AND 
 	 Base var__temp_v30 = 5 => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'31, res ) ==(var__temp_v30) AND 
 	 Rel (sel)( , var__temp_h'31, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h29 T119)
(declare-const var__temp_v30 Int)
(declare-const |var__temp_h'31| T119)
(declare-const var__temp_v_err32 T120)
(declare-const err T133)
    (declare-const |5| Int)
  
solver 
 (declare-sort T119)
(declare-fun |5| () Int)
(declare-fun sel (T119 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'31| () T119)
(declare-fun var__temp_v30 () Int)
(declare-fun var__temp_h29 () T119)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel |var__temp_h'31| res) var__temp_v30)
                    (= var__temp_v30 |5|))
               (and (= (sel |var__temp_h'31| res) var__temp_v30)
                    (= (sel |var__temp_h'31| res) 10)))))
(let ((a!2 (and (=> (= (sel var__temp_h29 res) 0) (= (sel var__temp_h29 res) 0))
                (=> (= (sel var__temp_h29 res) 0) a!1))))
  (not a!2))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************8
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h33 --->  Ty_heap  
 var__temp_v34 --->  Ty_int  
 var__temp_h'35 --->  Ty_heap  
 var__temp_v_err36 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h33, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h33, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h33, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'35, res ) ==(var__temp_v34) AND 
 	 Rel (sel)( , var__temp_h'35, res ) ==((sel)( , var__temp_h33, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'35, res ) ==(var__temp_v34) AND 
 	 Rel (sel)( , var__temp_h'35, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h33 T136)
(declare-const var__temp_v34 Int)
(declare-const |var__temp_h'35| T136)
(declare-const var__temp_v_err36 T137)
(declare-const err T150)

solver 
 (declare-sort T136)
(declare-fun sel (T136 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'35| () T136)
(declare-fun var__temp_v34 () Int)
(declare-fun var__temp_h33 () T136)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'35| res) var__temp_v34)
                (= (sel |var__temp_h'35| res) (+ (sel var__temp_h33 res) 2)))))
(let ((a!2 (=> a!1
               (and (= (sel |var__temp_h'35| res) var__temp_v34)
                    (= (sel |var__temp_h'35| res) 10)))))
(let ((a!3 (and (=> (= (sel var__temp_h33 res) 0) (= (sel var__temp_h33 res) 5))
                (=> (= (sel var__temp_h33 res) 5) a!2))))
  (not a!3)))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************9
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {v:Ty_int | true}
isynthesizeConstApp
Spec Base {v:Ty_int | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Terms
esynthesizeBind
PARTIAL PATH
SUB 
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {var_v37:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c3'
baz
c5
c4
c2'
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************10
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (8) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {var_v37:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h38 --->  Ty_heap  
 var__temp_v39 --->  Ty_int  
 var__temp_h'40 --->  Ty_heap  
 var__temp_v_err41 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h38, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h38, res ) > (8) AND 
 	 Rel (sel)( , var__temp_h38, res ) > (8) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'40, res ) ==(var__temp_v39) AND 
 	 Rel (sel)( , var__temp_h'40, res ) ==((sel)( , var__temp_h38, res ) + (3)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h38 T153)
(declare-const var__temp_v39 Int)
(declare-const |var__temp_h'40| T153)
(declare-const var__temp_v_err41 T154)
(declare-const err T167)

solver 
 (declare-sort T153)
(declare-fun sel (T153 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h38 () T153)
(declare-fun |var__temp_h'40| () T153)
(declare-fun var__temp_v39 () Int)
(assert true)
(assert (let ((a!1 (=> (= (sel var__temp_h38 res) 0)
               (not (> (sel var__temp_h38 res) 8))))
      (a!2 (and (= (sel |var__temp_h'40| res) var__temp_v39)
                (= (sel |var__temp_h'40| res) (+ (sel var__temp_h38 res) 3)))))
(let ((a!3 (=> (not (> (sel var__temp_h38 res) 8)) (=> a!2 true))))
  (not (and a!1 a!3)))))

***************Selection Successful************c3'
PARTIAL PATH NEW
NEW 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i43 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i43 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i43, res ) ==(v)
 	 , (sel)( , var_h_i43, res ) ==((sel)( , var_h42, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v44:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i43 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c4
c2'
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************11
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i43 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i43, res ) ==(v)
 	 , (sel)( , var_h_i43, res ) ==((sel)( , var_h42, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v44:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i43 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h45 --->  Ty_heap  
 var__temp_v46 --->  Ty_int  
 var__temp_h'47 --->  Ty_heap  
 var__temp_v_err48 --->  error  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h45, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h45, res ) ==((sel)( , var_h42, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h45, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h45, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'47, res ) ==(var__temp_v46) AND 
 	 Rel (sel)( , var__temp_h'47, res ) ==((sel)( , var__temp_h45, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'47, res ) ==(var__temp_v46) AND 
 	 Rel (sel)( , var__temp_h'47, res ) ==(10)
 
VC_END(declare-const var_h_i43 T170)
(declare-const var_h42 T170)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h45 T170)
(declare-const var__temp_v46 Int)
(declare-const |var__temp_h'47| T170)
(declare-const var__temp_v_err48 T171)
(declare-const var_h42 T170)
(declare-const err T184)

solver 
 (declare-sort T170)
(declare-fun sel (T170 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T170)
(declare-fun |var__temp_h'47| () T170)
(declare-fun var__temp_v46 () Int)
(declare-fun var__temp_h45 () T170)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h45 res) v)
                (= (sel var__temp_h45 res) (+ (sel var_h42 res) 3))))
      (a!2 (and (= (sel |var__temp_h'47| res) var__temp_v46)
                (= (sel |var__temp_h'47| res) (+ (sel var__temp_h45 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'47| res) var__temp_v46)
                    (= (sel |var__temp_h'47| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h45 res) 7))
                (=> (= (sel var__temp_h45 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************12
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i43 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i43, res ) ==(v)
 	 , (sel)( , var_h_i43, res ) ==((sel)( , var_h42, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v44:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i43 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h49 --->  Ty_heap  
 var__temp_v50 --->  Ty_int  
 var__temp_h'51 --->  Ty_heap  
 var__temp_v_err52 --->  error  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h49, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h49, res ) ==((sel)( , var_h42, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h49, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h49, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'51, res ) ==(var__temp_v50) AND 
 	 Rel (sel)( , var__temp_h'51, res ) ==((sel)( , var__temp_h49, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'51, res ) ==(var__temp_v50) AND 
 	 Rel (sel)( , var__temp_h'51, res ) ==(10)
 
VC_END(declare-const var_h_i43 T187)
(declare-const var_h42 T187)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h49 T187)
(declare-const var__temp_v50 Int)
(declare-const |var__temp_h'51| T187)
(declare-const var__temp_v_err52 T188)
(declare-const var_h42 T187)
(declare-const err T201)

solver 
 (declare-sort T187)
(declare-fun sel (T187 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T187)
(declare-fun |var__temp_h'51| () T187)
(declare-fun var__temp_v50 () Int)
(declare-fun var__temp_h49 () T187)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h49 res) v)
                (= (sel var__temp_h49 res) (+ (sel var_h42 res) 3))))
      (a!2 (and (= (sel |var__temp_h'51| res) var__temp_v50)
                (= (sel |var__temp_h'51| res) (+ (sel var__temp_h49 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'51| res) var__temp_v50)
                    (= (sel |var__temp_h'51| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h49 res) 7))
                (=> (= (sel var__temp_h49 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************13
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (30) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i43 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i43, res ) ==(v)
 	 , (sel)( , var_h_i43, res ) ==((sel)( , var_h42, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v44:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i43 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h53 --->  Ty_heap  
 var__temp_v54 --->  Ty_int  
 var__temp_h'55 --->  Ty_heap  
 var__temp_v_err56 --->  error  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h53, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h53, res ) ==((sel)( , var_h42, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h53, res ) > (30) AND 
 	 Rel (sel)( , var__temp_h53, res ) > (30) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'55, res ) ==(var__temp_v54) AND 
 	 Rel (sel)( , var__temp_h'55, res ) ==((sel)( , var__temp_h53, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'55, res ) ==(var__temp_v54) AND 
 	 Rel (sel)( , var__temp_h'55, res ) ==(10)
 
VC_END(declare-const var_h_i43 T204)
(declare-const var_h42 T204)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h53 T204)
(declare-const var__temp_v54 Int)
(declare-const |var__temp_h'55| T204)
(declare-const var__temp_v_err56 T205)
(declare-const var_h42 T204)
(declare-const err T218)

solver 
 (declare-sort T204)
(declare-fun sel (T204 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T204)
(declare-fun |var__temp_h'55| () T204)
(declare-fun var__temp_v54 () Int)
(declare-fun var__temp_h53 () T204)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h53 res) v)
                (= (sel var__temp_h53 res) (+ (sel var_h42 res) 3))))
      (a!3 (and (= (sel |var__temp_h'55| res) var__temp_v54)
                (= (sel |var__temp_h'55| res) (+ (sel var__temp_h53 res) 5)))))
(let ((a!2 (=> a!1 (not (> (sel var__temp_h53 res) 30))))
      (a!4 (=> a!3
               (and (= (sel |var__temp_h'55| res) var__temp_v54)
                    (= (sel |var__temp_h'55| res) 10)))))
(let ((a!5 (=> (not (> (sel var__temp_h53 res) 30)) a!4)))
  (not (and a!2 a!5))))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************14
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h, res ) ==(sel)( , h, res ) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i43 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i43, res ) ==(v)
 	 , (sel)( , var_h_i43, res ) ==((sel)( , var_h42, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v44:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i43 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h, res ) ==(sel)( , h, res ) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h57 --->  Ty_heap  
 var__temp_v58 --->  Ty_int  
 var__temp_h'59 --->  Ty_heap  
 var__temp_v_err60 --->  error  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h57, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h57, res ) ==((sel)( , var_h42, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h57, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h57, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'59, res ) ==(var__temp_v58) AND 
 	 Rel (sel)( , var__temp_h57, res ) ==(sel)( , var__temp_h57, res ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'59, res ) ==(var__temp_v58) AND 
 	 Rel (sel)( , var__temp_h'59, res ) ==(10)
 
VC_END(declare-const var_h_i43 T221)
(declare-const var_h42 T221)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h57 T221)
(declare-const var__temp_v58 Int)
(declare-const |var__temp_h'59| T221)
(declare-const var__temp_v_err60 T222)
(declare-const var_h42 T221)
(declare-const err T235)

solver 
 (declare-sort T221)
(declare-fun sel (T221 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T221)
(declare-fun |var__temp_h'59| () T221)
(declare-fun var__temp_v58 () Int)
(declare-fun var__temp_h57 () T221)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h57 res) v)
                (= (sel var__temp_h57 res) (+ (sel var_h42 res) 3))))
      (a!3 (=> (and (= (sel |var__temp_h'59| res) var__temp_v58)
                    (= (sel var__temp_h57 res) (sel var__temp_h57 res)))
               (and (= (sel |var__temp_h'59| res) var__temp_v58)
                    (= (sel |var__temp_h'59| res) 10)))))
(let ((a!2 (=> a!1 (not (> (sel var__temp_h57 res) 20))))
      (a!4 (=> (not (> (sel var__temp_h57 res) 20)) a!3)))
  (not (and a!2 a!4)))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************15
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i43 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i43, res ) ==(v)
 	 , (sel)( , var_h_i43, res ) ==((sel)( , var_h42, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v44:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i43 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h61 --->  Ty_heap  
 var__temp_v62 --->  Ty_int  
 var__temp_h'63 --->  Ty_heap  
 var__temp_v_err64 --->  error  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h61, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h61, res ) ==((sel)( , var_h42, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h61, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h61, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'63, res ) ==(var__temp_v62) AND 
 	 Rel (sel)( , var__temp_h'63, res ) ==((sel)( , var__temp_h61, res ) + (10)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'63, res ) ==(var__temp_v62) AND 
 	 Rel (sel)( , var__temp_h'63, res ) ==(10)
 
VC_END(declare-const var_h_i43 T238)
(declare-const var_h42 T238)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h61 T238)
(declare-const var__temp_v62 Int)
(declare-const |var__temp_h'63| T238)
(declare-const var__temp_v_err64 T239)
(declare-const var_h42 T238)
(declare-const err T252)

solver 
 (declare-sort T238)
(declare-fun sel (T238 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T238)
(declare-fun |var__temp_h'63| () T238)
(declare-fun var__temp_v62 () Int)
(declare-fun var__temp_h61 () T238)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h61 res) v)
                (= (sel var__temp_h61 res) (+ (sel var_h42 res) 3))))
      (a!2 (and (= (sel |var__temp_h'63| res) var__temp_v62)
                (= (sel |var__temp_h'63| res) (+ (sel var__temp_h61 res) 10)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'63| res) var__temp_v62)
                    (= (sel |var__temp_h'63| res) 10)))))
(let ((a!4 (and (=> a!1 (> (sel var__temp_h61 res) 4))
                (=> (> (sel var__temp_h61 res) 4) a!3))))
  (not a!4)))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************16
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i43 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i43, res ) ==(v)
 	 , (sel)( , var_h_i43, res ) ==((sel)( , var_h42, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v44:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i43 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h65 --->  Ty_heap  
 var__temp_v66 --->  Ty_int  
 var__temp_h'67 --->  Ty_heap  
 var__temp_v_err68 --->  error  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h65, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h65, res ) ==((sel)( , var_h42, res ) + (3)) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'67, res ) ==(var__temp_v66) AND 
 	 Base var__temp_v66 = 20 => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'67, res ) ==(var__temp_v66) AND 
 	 Rel (sel)( , var__temp_h'67, res ) ==(10)
 
VC_END(declare-const var_h_i43 T255)
(declare-const var_h42 T255)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h65 T255)
(declare-const var__temp_v66 Int)
(declare-const |var__temp_h'67| T255)
(declare-const var__temp_v_err68 T256)
(declare-const var_h42 T255)
(declare-const err T269)
    (declare-const |20| Int)
  
solver 
 (declare-sort T255)
(declare-fun sel (T255 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T255)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'67| () T255)
(declare-fun var__temp_v66 () Int)
(declare-fun var__temp_h65 () T255)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (and (= (sel var__temp_h65 res) v)
                (= (sel var__temp_h65 res) (+ (sel var_h42 res) 3))))
      (a!2 (=> (and (= (sel |var__temp_h'67| res) var__temp_v66)
                    (= var__temp_v66 |20|))
               (and (= (sel |var__temp_h'67| res) var__temp_v66)
                    (= (sel |var__temp_h'67| res) 10)))))
  (not (and (=> a!1 true) (=> true a!2)))))

***************Selection Failed************foo'
 *********************Enumeration Iteration*****************17
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i43 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i43, res ) ==(v)
 	 , (sel)( , var_h_i43, res ) ==((sel)( , var_h42, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v44:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i43 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h69 --->  Ty_heap  
 var__temp_v70 --->  Ty_int  
 var__temp_h'71 --->  Ty_heap  
 var__temp_v_err72 --->  error  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h69, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h69, res ) ==((sel)( , var_h42, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h69, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h69, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'71, res ) ==(var__temp_v70) AND 
 	 Base var__temp_v70 = 5 => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'71, res ) ==(var__temp_v70) AND 
 	 Rel (sel)( , var__temp_h'71, res ) ==(10)
 
VC_END(declare-const var_h_i43 T272)
(declare-const var_h42 T272)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h69 T272)
(declare-const var__temp_v70 Int)
(declare-const |var__temp_h'71| T272)
(declare-const var__temp_v_err72 T273)
(declare-const var_h42 T272)
(declare-const err T286)
    (declare-const |5| Int)
  
solver 
 (declare-sort T272)
(declare-fun sel (T272 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T272)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'71| () T272)
(declare-fun var__temp_v70 () Int)
(declare-fun var__temp_h69 () T272)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h69 res) v)
                (= (sel var__temp_h69 res) (+ (sel var_h42 res) 3))))
      (a!2 (=> (and (= (sel |var__temp_h'71| res) var__temp_v70)
                    (= var__temp_v70 |5|))
               (and (= (sel |var__temp_h'71| res) var__temp_v70)
                    (= (sel |var__temp_h'71| res) 10)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h69 res) 0))
                (=> (= (sel var__temp_h69 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************18
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i43 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i43, res ) ==(v)
 	 , (sel)( , var_h_i43, res ) ==((sel)( , var_h42, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v44:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i43 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h73 --->  Ty_heap  
 var__temp_v74 --->  Ty_int  
 var__temp_h'75 --->  Ty_heap  
 var__temp_v_err76 --->  error  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h73, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h73, res ) ==((sel)( , var_h42, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h73, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h73, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'75, res ) ==(var__temp_v74) AND 
 	 Rel (sel)( , var__temp_h'75, res ) ==((sel)( , var__temp_h73, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'75, res ) ==(var__temp_v74) AND 
 	 Rel (sel)( , var__temp_h'75, res ) ==(10)
 
VC_END(declare-const var_h_i43 T289)
(declare-const var_h42 T289)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h73 T289)
(declare-const var__temp_v74 Int)
(declare-const |var__temp_h'75| T289)
(declare-const var__temp_v_err76 T290)
(declare-const var_h42 T289)
(declare-const err T303)

solver 
 (declare-sort T289)
(declare-fun sel (T289 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T289)
(declare-fun |var__temp_h'75| () T289)
(declare-fun var__temp_v74 () Int)
(declare-fun var__temp_h73 () T289)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h73 res) v)
                (= (sel var__temp_h73 res) (+ (sel var_h42 res) 3))))
      (a!2 (and (= (sel |var__temp_h'75| res) var__temp_v74)
                (= (sel |var__temp_h'75| res) (+ (sel var__temp_h73 res) 2)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'75| res) var__temp_v74)
                    (= (sel |var__temp_h'75| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h73 res) 5))
                (=> (= (sel var__temp_h73 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************19
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v44:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v44:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i43 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i43, res ) ==(v)
 	 , (sel)( , var_h_i43, res ) ==((sel)( , var_h42, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v77:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c4
c2'
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************20
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i43 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i43, res ) ==(v)
 	 , (sel)( , var_h_i43, res ) ==((sel)( , var_h42, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v77:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h78 --->  Ty_heap  
 var__temp_v79 --->  Ty_int  
 var__temp_h'80 --->  Ty_heap  
 var__temp_v_err81 --->  error  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h78, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h78, res ) ==((sel)( , var_h42, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h78, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h78, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'80, res ) ==(var__temp_v79) AND 
 	 Rel (sel)( , var__temp_h'80, res ) ==((sel)( , var__temp_h78, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i43 T306)
(declare-const var_h42 T306)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h78 T306)
(declare-const var__temp_v79 Int)
(declare-const |var__temp_h'80| T306)
(declare-const var__temp_v_err81 T307)
(declare-const var_h42 T306)
(declare-const err T320)

solver 
 (declare-sort T306)
(declare-fun sel (T306 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T306)
(declare-fun var__temp_h78 () T306)
(declare-fun |var__temp_h'80| () T306)
(declare-fun var__temp_v79 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h78 res) v)
                (= (sel var__temp_h78 res) (+ (sel var_h42 res) 3))))
      (a!2 (and (= (sel |var__temp_h'80| res) var__temp_v79)
                (= (sel |var__temp_h'80| res) (+ (sel var__temp_h78 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h78 res) 7))
                (=> (= (sel var__temp_h78 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************21
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i43 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i43, res ) ==(v)
 	 , (sel)( , var_h_i43, res ) ==((sel)( , var_h42, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v77:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h82 --->  Ty_heap  
 var__temp_v83 --->  Ty_int  
 var__temp_h'84 --->  Ty_heap  
 var__temp_v_err85 --->  error  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h82, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h82, res ) ==((sel)( , var_h42, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h82, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h82, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'84, res ) ==(var__temp_v83) AND 
 	 Rel (sel)( , var__temp_h'84, res ) ==((sel)( , var__temp_h82, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i43 T323)
(declare-const var_h42 T323)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h82 T323)
(declare-const var__temp_v83 Int)
(declare-const |var__temp_h'84| T323)
(declare-const var__temp_v_err85 T324)
(declare-const var_h42 T323)
(declare-const err T337)

solver 
 (declare-sort T323)
(declare-fun sel (T323 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T323)
(declare-fun var__temp_h82 () T323)
(declare-fun |var__temp_h'84| () T323)
(declare-fun var__temp_v83 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h82 res) v)
                (= (sel var__temp_h82 res) (+ (sel var_h42 res) 3))))
      (a!2 (and (= (sel |var__temp_h'84| res) var__temp_v83)
                (= (sel |var__temp_h'84| res) (+ (sel var__temp_h82 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h82 res) 7))
                (=> (= (sel var__temp_h82 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************22
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (30) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i43 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i43, res ) ==(v)
 	 , (sel)( , var_h_i43, res ) ==((sel)( , var_h42, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v77:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h86 --->  Ty_heap  
 var__temp_v87 --->  Ty_int  
 var__temp_h'88 --->  Ty_heap  
 var__temp_v_err89 --->  error  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h86, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h86, res ) ==((sel)( , var_h42, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h86, res ) > (30) AND 
 	 Rel (sel)( , var__temp_h86, res ) > (30) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'88, res ) ==(var__temp_v87) AND 
 	 Rel (sel)( , var__temp_h'88, res ) ==((sel)( , var__temp_h86, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i43 T340)
(declare-const var_h42 T340)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h86 T340)
(declare-const var__temp_v87 Int)
(declare-const |var__temp_h'88| T340)
(declare-const var__temp_v_err89 T341)
(declare-const var_h42 T340)
(declare-const err T354)

solver 
 (declare-sort T340)
(declare-fun sel (T340 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T340)
(declare-fun var__temp_h86 () T340)
(declare-fun |var__temp_h'88| () T340)
(declare-fun var__temp_v87 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h86 res) v)
                (= (sel var__temp_h86 res) (+ (sel var_h42 res) 3))))
      (a!3 (and (= (sel |var__temp_h'88| res) var__temp_v87)
                (= (sel |var__temp_h'88| res) (+ (sel var__temp_h86 res) 5)))))
(let ((a!2 (=> a!1 (not (> (sel var__temp_h86 res) 30))))
      (a!4 (=> (not (> (sel var__temp_h86 res) 30)) (=> a!3 true))))
  (not (and a!2 a!4)))))

***************Selection Successful************c4
PARTIAL PATH NEW
NEW 	 --c3'	 --c4
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i91 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i91 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i91, res ) ==(v)
 	 , (sel)( , var_h_i91, res ) ==((sel)( , var_h90, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v92:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i91 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************23
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i91 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i91, res ) ==(v)
 	 , (sel)( , var_h_i91, res ) ==((sel)( , var_h90, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v92:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i91 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h93 --->  Ty_heap  
 var__temp_v94 --->  Ty_int  
 var__temp_h'95 --->  Ty_heap  
 var__temp_v_err96 --->  error  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h93, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h93, res ) ==((sel)( , var_h90, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h93, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h93, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'95, res ) ==(var__temp_v94) AND 
 	 Rel (sel)( , var__temp_h'95, res ) ==((sel)( , var__temp_h93, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'95, res ) ==(var__temp_v94) AND 
 	 Rel (sel)( , var__temp_h'95, res ) ==(10)
 
VC_END(declare-const var_h_i91 T357)
(declare-const var_h90 T357)
(declare-const v Int)
(declare-const var_h_i43 T357)
(declare-const var_h42 T357)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h93 T357)
(declare-const var__temp_v94 Int)
(declare-const |var__temp_h'95| T357)
(declare-const var__temp_v_err96 T358)
(declare-const var_h90 T357)
(declare-const var_h42 T357)
(declare-const err T371)

solver 
 (declare-sort T357)
(declare-fun sel (T357 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T357)
(declare-fun var_h42 () T357)
(declare-fun |var__temp_h'95| () T357)
(declare-fun var__temp_v94 () Int)
(declare-fun var__temp_h93 () T357)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h93 res) v)
                (= (sel var__temp_h93 res) (+ (sel var_h90 res) 5))))
      (a!2 (and (= (sel |var__temp_h'95| res) var__temp_v94)
                (= (sel |var__temp_h'95| res) (+ (sel var__temp_h93 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'95| res) var__temp_v94)
                    (= (sel |var__temp_h'95| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h93 res) 7))
                (=> (= (sel var__temp_h93 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************24
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i91 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i91, res ) ==(v)
 	 , (sel)( , var_h_i91, res ) ==((sel)( , var_h90, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v92:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i91 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h97 --->  Ty_heap  
 var__temp_v98 --->  Ty_int  
 var__temp_h'99 --->  Ty_heap  
 var__temp_v_err100 --->  error  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h97, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h97, res ) ==((sel)( , var_h90, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h97, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h97, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'99, res ) ==(var__temp_v98) AND 
 	 Rel (sel)( , var__temp_h'99, res ) ==((sel)( , var__temp_h97, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'99, res ) ==(var__temp_v98) AND 
 	 Rel (sel)( , var__temp_h'99, res ) ==(10)
 
VC_END(declare-const var_h_i91 T374)
(declare-const var_h90 T374)
(declare-const v Int)
(declare-const var_h_i43 T374)
(declare-const var_h42 T374)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h97 T374)
(declare-const var__temp_v98 Int)
(declare-const |var__temp_h'99| T374)
(declare-const var__temp_v_err100 T375)
(declare-const var_h90 T374)
(declare-const var_h42 T374)
(declare-const err T388)

solver 
 (declare-sort T374)
(declare-fun sel (T374 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T374)
(declare-fun var_h42 () T374)
(declare-fun |var__temp_h'99| () T374)
(declare-fun var__temp_v98 () Int)
(declare-fun var__temp_h97 () T374)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h97 res) v)
                (= (sel var__temp_h97 res) (+ (sel var_h90 res) 5))))
      (a!2 (and (= (sel |var__temp_h'99| res) var__temp_v98)
                (= (sel |var__temp_h'99| res) (+ (sel var__temp_h97 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'99| res) var__temp_v98)
                    (= (sel |var__temp_h'99| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h97 res) 7))
                (=> (= (sel var__temp_h97 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************25
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h, res ) ==(sel)( , h, res ) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i91 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i91, res ) ==(v)
 	 , (sel)( , var_h_i91, res ) ==((sel)( , var_h90, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v92:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i91 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h, res ) ==(sel)( , h, res ) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h101 --->  Ty_heap  
 var__temp_v102 --->  Ty_int  
 var__temp_h'103 --->  Ty_heap  
 var__temp_v_err104 --->  error  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h101, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h101, res ) ==((sel)( , var_h90, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h101, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h101, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'103, res ) ==(var__temp_v102) AND 
 	 Rel (sel)( , var__temp_h101, res ) ==(sel)( , var__temp_h101, res ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'103, res ) ==(var__temp_v102) AND 
 	 Rel (sel)( , var__temp_h'103, res ) ==(10)
 
VC_END(declare-const var_h_i91 T391)
(declare-const var_h90 T391)
(declare-const v Int)
(declare-const var_h_i43 T391)
(declare-const var_h42 T391)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h101 T391)
(declare-const var__temp_v102 Int)
(declare-const |var__temp_h'103| T391)
(declare-const var__temp_v_err104 T392)
(declare-const var_h90 T391)
(declare-const var_h42 T391)
(declare-const err T405)

solver 
 (declare-sort T391)
(declare-fun sel (T391 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T391)
(declare-fun var_h42 () T391)
(declare-fun |var__temp_h'103| () T391)
(declare-fun var__temp_v102 () Int)
(declare-fun var__temp_h101 () T391)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h101 res) v)
                (= (sel var__temp_h101 res) (+ (sel var_h90 res) 5))))
      (a!3 (=> (and (= (sel |var__temp_h'103| res) var__temp_v102)
                    (= (sel var__temp_h101 res) (sel var__temp_h101 res)))
               (and (= (sel |var__temp_h'103| res) var__temp_v102)
                    (= (sel |var__temp_h'103| res) 10)))))
(let ((a!2 (=> a!1 (not (> (sel var__temp_h101 res) 20))))
      (a!4 (=> (not (> (sel var__temp_h101 res) 20)) a!3)))
  (not (and a!2 a!4)))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************26
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i91 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i91, res ) ==(v)
 	 , (sel)( , var_h_i91, res ) ==((sel)( , var_h90, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v92:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i91 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h105 --->  Ty_heap  
 var__temp_v106 --->  Ty_int  
 var__temp_h'107 --->  Ty_heap  
 var__temp_v_err108 --->  error  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h105, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h105, res ) ==((sel)( , var_h90, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h105, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h105, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'107, res ) ==(var__temp_v106) AND 
 	 Rel (sel)( , var__temp_h'107, res ) ==((sel)( , var__temp_h105, res ) + (10)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'107, res ) ==(var__temp_v106) AND 
 	 Rel (sel)( , var__temp_h'107, res ) ==(10)
 
VC_END(declare-const var_h_i91 T408)
(declare-const var_h90 T408)
(declare-const v Int)
(declare-const var_h_i43 T408)
(declare-const var_h42 T408)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h105 T408)
(declare-const var__temp_v106 Int)
(declare-const |var__temp_h'107| T408)
(declare-const var__temp_v_err108 T409)
(declare-const var_h90 T408)
(declare-const var_h42 T408)
(declare-const err T422)

solver 
 (declare-sort T408)
(declare-fun sel (T408 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T408)
(declare-fun var_h42 () T408)
(declare-fun |var__temp_h'107| () T408)
(declare-fun var__temp_v106 () Int)
(declare-fun var__temp_h105 () T408)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h105 res) v)
                (= (sel var__temp_h105 res) (+ (sel var_h90 res) 5))))
      (a!2 (and (= (sel |var__temp_h'107| res) var__temp_v106)
                (= (sel |var__temp_h'107| res) (+ (sel var__temp_h105 res) 10)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'107| res) var__temp_v106)
                    (= (sel |var__temp_h'107| res) 10)))))
(let ((a!4 (and (=> a!1 (> (sel var__temp_h105 res) 4))
                (=> (> (sel var__temp_h105 res) 4) a!3))))
  (not a!4)))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************27
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i91 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i91, res ) ==(v)
 	 , (sel)( , var_h_i91, res ) ==((sel)( , var_h90, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v92:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i91 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h109 --->  Ty_heap  
 var__temp_v110 --->  Ty_int  
 var__temp_h'111 --->  Ty_heap  
 var__temp_v_err112 --->  error  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h109, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h109, res ) ==((sel)( , var_h90, res ) + (5)) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'111, res ) ==(var__temp_v110) AND 
 	 Base var__temp_v110 = 20 => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'111, res ) ==(var__temp_v110) AND 
 	 Rel (sel)( , var__temp_h'111, res ) ==(10)
 
VC_END(declare-const var_h_i91 T425)
(declare-const var_h90 T425)
(declare-const v Int)
(declare-const var_h_i43 T425)
(declare-const var_h42 T425)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h109 T425)
(declare-const var__temp_v110 Int)
(declare-const |var__temp_h'111| T425)
(declare-const var__temp_v_err112 T426)
(declare-const var_h90 T425)
(declare-const var_h42 T425)
(declare-const err T439)
    (declare-const |20| Int)
  
solver 
 (declare-sort T425)
(declare-fun sel (T425 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T425)
(declare-fun var_h42 () T425)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'111| () T425)
(declare-fun var__temp_v110 () Int)
(declare-fun var__temp_h109 () T425)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (and (= (sel var__temp_h109 res) v)
                (= (sel var__temp_h109 res) (+ (sel var_h90 res) 5))))
      (a!2 (=> (and (= (sel |var__temp_h'111| res) var__temp_v110)
                    (= var__temp_v110 |20|))
               (and (= (sel |var__temp_h'111| res) var__temp_v110)
                    (= (sel |var__temp_h'111| res) 10)))))
  (not (and (=> a!1 true) (=> true a!2)))))

***************Selection Failed************foo'
 *********************Enumeration Iteration*****************28
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i91 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i91, res ) ==(v)
 	 , (sel)( , var_h_i91, res ) ==((sel)( , var_h90, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v92:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i91 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h113 --->  Ty_heap  
 var__temp_v114 --->  Ty_int  
 var__temp_h'115 --->  Ty_heap  
 var__temp_v_err116 --->  error  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h113, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h113, res ) ==((sel)( , var_h90, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h113, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h113, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'115, res ) ==(var__temp_v114) AND 
 	 Base var__temp_v114 = 5 => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'115, res ) ==(var__temp_v114) AND 
 	 Rel (sel)( , var__temp_h'115, res ) ==(10)
 
VC_END(declare-const var_h_i91 T442)
(declare-const var_h90 T442)
(declare-const v Int)
(declare-const var_h_i43 T442)
(declare-const var_h42 T442)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h113 T442)
(declare-const var__temp_v114 Int)
(declare-const |var__temp_h'115| T442)
(declare-const var__temp_v_err116 T443)
(declare-const var_h90 T442)
(declare-const var_h42 T442)
(declare-const err T456)
    (declare-const |5| Int)
  
solver 
 (declare-sort T442)
(declare-fun sel (T442 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T442)
(declare-fun var_h42 () T442)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'115| () T442)
(declare-fun var__temp_v114 () Int)
(declare-fun var__temp_h113 () T442)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h113 res) v)
                (= (sel var__temp_h113 res) (+ (sel var_h90 res) 5))))
      (a!2 (=> (and (= (sel |var__temp_h'115| res) var__temp_v114)
                    (= var__temp_v114 |5|))
               (and (= (sel |var__temp_h'115| res) var__temp_v114)
                    (= (sel |var__temp_h'115| res) 10)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h113 res) 0))
                (=> (= (sel var__temp_h113 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************29
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i91 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i91, res ) ==(v)
 	 , (sel)( , var_h_i91, res ) ==((sel)( , var_h90, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v92:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i91 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h117 --->  Ty_heap  
 var__temp_v118 --->  Ty_int  
 var__temp_h'119 --->  Ty_heap  
 var__temp_v_err120 --->  error  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h117, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h117, res ) ==((sel)( , var_h90, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h117, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h117, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'119, res ) ==(var__temp_v118) AND 
 	 Rel (sel)( , var__temp_h'119, res ) ==((sel)( , var__temp_h117, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'119, res ) ==(var__temp_v118) AND 
 	 Rel (sel)( , var__temp_h'119, res ) ==(10)
 
VC_END(declare-const var_h_i91 T459)
(declare-const var_h90 T459)
(declare-const v Int)
(declare-const var_h_i43 T459)
(declare-const var_h42 T459)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h117 T459)
(declare-const var__temp_v118 Int)
(declare-const |var__temp_h'119| T459)
(declare-const var__temp_v_err120 T460)
(declare-const var_h90 T459)
(declare-const var_h42 T459)
(declare-const err T473)

solver 
 (declare-sort T459)
(declare-fun sel (T459 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T459)
(declare-fun var_h42 () T459)
(declare-fun |var__temp_h'119| () T459)
(declare-fun var__temp_v118 () Int)
(declare-fun var__temp_h117 () T459)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h117 res) v)
                (= (sel var__temp_h117 res) (+ (sel var_h90 res) 5))))
      (a!2 (and (= (sel |var__temp_h'119| res) var__temp_v118)
                (= (sel |var__temp_h'119| res) (+ (sel var__temp_h117 res) 2)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'119| res) var__temp_v118)
                    (= (sel |var__temp_h'119| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h117 res) 5))
                (=> (= (sel var__temp_h117 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************30
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v92:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v92:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i91 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i91, res ) ==(v)
 	 , (sel)( , var_h_i91, res ) ==((sel)( , var_h90, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v121:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************31
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i91 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i91, res ) ==(v)
 	 , (sel)( , var_h_i91, res ) ==((sel)( , var_h90, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v121:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h122 --->  Ty_heap  
 var__temp_v123 --->  Ty_int  
 var__temp_h'124 --->  Ty_heap  
 var__temp_v_err125 --->  error  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h122, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h122, res ) ==((sel)( , var_h90, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h122, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h122, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'124, res ) ==(var__temp_v123) AND 
 	 Rel (sel)( , var__temp_h'124, res ) ==((sel)( , var__temp_h122, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i91 T476)
(declare-const var_h90 T476)
(declare-const v Int)
(declare-const var_h_i43 T476)
(declare-const var_h42 T476)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h122 T476)
(declare-const var__temp_v123 Int)
(declare-const |var__temp_h'124| T476)
(declare-const var__temp_v_err125 T477)
(declare-const var_h90 T476)
(declare-const var_h42 T476)
(declare-const err T490)

solver 
 (declare-sort T476)
(declare-fun sel (T476 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T476)
(declare-fun var_h42 () T476)
(declare-fun var__temp_h122 () T476)
(declare-fun |var__temp_h'124| () T476)
(declare-fun var__temp_v123 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h122 res) v)
                (= (sel var__temp_h122 res) (+ (sel var_h90 res) 5))))
      (a!2 (and (= (sel |var__temp_h'124| res) var__temp_v123)
                (= (sel |var__temp_h'124| res) (+ (sel var__temp_h122 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h122 res) 7))
                (=> (= (sel var__temp_h122 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************32
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i91 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i91, res ) ==(v)
 	 , (sel)( , var_h_i91, res ) ==((sel)( , var_h90, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v121:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h126 --->  Ty_heap  
 var__temp_v127 --->  Ty_int  
 var__temp_h'128 --->  Ty_heap  
 var__temp_v_err129 --->  error  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h126, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h126, res ) ==((sel)( , var_h90, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h126, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h126, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'128, res ) ==(var__temp_v127) AND 
 	 Rel (sel)( , var__temp_h'128, res ) ==((sel)( , var__temp_h126, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i91 T493)
(declare-const var_h90 T493)
(declare-const v Int)
(declare-const var_h_i43 T493)
(declare-const var_h42 T493)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h126 T493)
(declare-const var__temp_v127 Int)
(declare-const |var__temp_h'128| T493)
(declare-const var__temp_v_err129 T494)
(declare-const var_h90 T493)
(declare-const var_h42 T493)
(declare-const err T507)

solver 
 (declare-sort T493)
(declare-fun sel (T493 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T493)
(declare-fun var_h42 () T493)
(declare-fun var__temp_h126 () T493)
(declare-fun |var__temp_h'128| () T493)
(declare-fun var__temp_v127 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h126 res) v)
                (= (sel var__temp_h126 res) (+ (sel var_h90 res) 5))))
      (a!2 (and (= (sel |var__temp_h'128| res) var__temp_v127)
                (= (sel |var__temp_h'128| res) (+ (sel var__temp_h126 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h126 res) 7))
                (=> (= (sel var__temp_h126 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************33
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h, res ) ==(sel)( , h, res ) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i91 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i91, res ) ==(v)
 	 , (sel)( , var_h_i91, res ) ==((sel)( , var_h90, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v121:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h, res ) ==(sel)( , h, res ) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h130 --->  Ty_heap  
 var__temp_v131 --->  Ty_int  
 var__temp_h'132 --->  Ty_heap  
 var__temp_v_err133 --->  error  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h130, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h130, res ) ==((sel)( , var_h90, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h130, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h130, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'132, res ) ==(var__temp_v131) AND 
 	 Rel (sel)( , var__temp_h130, res ) ==(sel)( , var__temp_h130, res ) => 
 	 True
 
VC_END(declare-const var_h_i91 T510)
(declare-const var_h90 T510)
(declare-const v Int)
(declare-const var_h_i43 T510)
(declare-const var_h42 T510)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h130 T510)
(declare-const var__temp_v131 Int)
(declare-const |var__temp_h'132| T510)
(declare-const var__temp_v_err133 T511)
(declare-const var_h90 T510)
(declare-const var_h42 T510)
(declare-const err T524)

solver 
 (declare-sort T510)
(declare-fun sel (T510 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T510)
(declare-fun var_h42 () T510)
(declare-fun var__temp_h130 () T510)
(declare-fun var__temp_v131 () Int)
(declare-fun |var__temp_h'132| () T510)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h130 res) v)
                (= (sel var__temp_h130 res) (+ (sel var_h90 res) 5))))
      (a!3 (=> (and (= (sel |var__temp_h'132| res) var__temp_v131)
                    (= (sel var__temp_h130 res) (sel var__temp_h130 res)))
               true)))
(let ((a!2 (=> a!1 (not (> (sel var__temp_h130 res) 20))))
      (a!4 (=> (not (> (sel var__temp_h130 res) 20)) a!3)))
  (not (and a!2 a!4)))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************34
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i91 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i91, res ) ==(v)
 	 , (sel)( , var_h_i91, res ) ==((sel)( , var_h90, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v121:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h134 --->  Ty_heap  
 var__temp_v135 --->  Ty_int  
 var__temp_h'136 --->  Ty_heap  
 var__temp_v_err137 --->  error  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h134, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h134, res ) ==((sel)( , var_h90, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h134, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h134, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'136, res ) ==(var__temp_v135) AND 
 	 Rel (sel)( , var__temp_h'136, res ) ==((sel)( , var__temp_h134, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i91 T527)
(declare-const var_h90 T527)
(declare-const v Int)
(declare-const var_h_i43 T527)
(declare-const var_h42 T527)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h134 T527)
(declare-const var__temp_v135 Int)
(declare-const |var__temp_h'136| T527)
(declare-const var__temp_v_err137 T528)
(declare-const var_h90 T527)
(declare-const var_h42 T527)
(declare-const err T541)

solver 
 (declare-sort T527)
(declare-fun sel (T527 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T527)
(declare-fun var_h42 () T527)
(declare-fun var__temp_h134 () T527)
(declare-fun |var__temp_h'136| () T527)
(declare-fun var__temp_v135 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h134 res) v)
                (= (sel var__temp_h134 res) (+ (sel var_h90 res) 5))))
      (a!2 (and (= (sel |var__temp_h'136| res) var__temp_v135)
                (= (sel |var__temp_h'136| res) (+ (sel var__temp_h134 res) 10)))))
(let ((a!3 (and (=> a!1 (> (sel var__temp_h134 res) 4))
                (=> (> (sel var__temp_h134 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************35
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i91 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i91, res ) ==(v)
 	 , (sel)( , var_h_i91, res ) ==((sel)( , var_h90, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v121:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h138 --->  Ty_heap  
 var__temp_v139 --->  Ty_int  
 var__temp_h'140 --->  Ty_heap  
 var__temp_v_err141 --->  error  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h138, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h138, res ) ==((sel)( , var_h90, res ) + (5)) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'140, res ) ==(var__temp_v139) AND 
 	 Base var__temp_v139 = 20 => 
 	 True
 
VC_END(declare-const var_h_i91 T544)
(declare-const var_h90 T544)
(declare-const v Int)
(declare-const var_h_i43 T544)
(declare-const var_h42 T544)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h138 T544)
(declare-const var__temp_v139 Int)
(declare-const |var__temp_h'140| T544)
(declare-const var__temp_v_err141 T545)
(declare-const var_h90 T544)
(declare-const var_h42 T544)
(declare-const err T558)
    (declare-const |20| Int)
  
solver 
 (declare-sort T544)
(declare-fun sel (T544 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T544)
(declare-fun var_h42 () T544)
(declare-fun |20| () Int)
(declare-fun var__temp_v139 () Int)
(declare-fun |var__temp_h'140| () T544)
(declare-fun var__temp_h138 () T544)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (and (= (sel var__temp_h138 res) v)
                (= (sel var__temp_h138 res) (+ (sel var_h90 res) 5))))
      (a!2 (=> (and (= (sel |var__temp_h'140| res) var__temp_v139)
                    (= var__temp_v139 |20|))
               true)))
  (not (and (=> a!1 true) (=> true a!2)))))

***************Selection Successful************foo'
PARTIAL PATH NEW
NEW 	 --c3'	 --c4	 --foo'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i143 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i143 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i143, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v144:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i143 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
foo
bar
 *********************Enumeration Iteration*****************36
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i143 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i143, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v144:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i143 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h145 --->  Ty_heap  
 var__temp_v146 --->  Ty_int  
 var__temp_h'147 --->  Ty_heap  
 var__temp_v_err148 --->  error  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h145, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h145, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h145, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'147, res ) ==(var__temp_v146) AND 
 	 Rel (sel)( , var__temp_h'147, res ) ==((sel)( , var__temp_h145, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'147, res ) ==(var__temp_v146) AND 
 	 Rel (sel)( , var__temp_h'147, res ) ==(10)
 
VC_END(declare-const var_h_i143 T561)
(declare-const var_h142 T561)
(declare-const v Int)
(declare-const var_h_i91 T561)
(declare-const var_h90 T561)
(declare-const v Int)
(declare-const var_h_i43 T561)
(declare-const var_h42 T561)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h145 T561)
(declare-const var__temp_v146 Int)
(declare-const |var__temp_h'147| T561)
(declare-const var__temp_v_err148 T562)
(declare-const var_h142 T561)
(declare-const var_h90 T561)
(declare-const var_h42 T561)
(declare-const err T575)
    (declare-const |20| Int)
  
solver 
 (declare-sort T561)
(declare-fun sel (T561 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T561)
(declare-fun var_h42 () T561)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'147| () T561)
(declare-fun var__temp_v146 () Int)
(declare-fun var__temp_h145 () T561)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h145 res) v) (= v |20|))
               (= (sel var__temp_h145 res) 7)))
      (a!2 (and (= (sel |var__temp_h'147| res) var__temp_v146)
                (= (sel |var__temp_h'147| res) (+ (sel var__temp_h145 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'147| res) var__temp_v146)
                    (= (sel |var__temp_h'147| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h145 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************37
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i143 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i143, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v144:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i143 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h149 --->  Ty_heap  
 var__temp_v150 --->  Ty_int  
 var__temp_h'151 --->  Ty_heap  
 var__temp_v_err152 --->  error  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h149, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h149, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h149, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'151, res ) ==(var__temp_v150) AND 
 	 Rel (sel)( , var__temp_h'151, res ) ==((sel)( , var__temp_h149, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'151, res ) ==(var__temp_v150) AND 
 	 Rel (sel)( , var__temp_h'151, res ) ==(10)
 
VC_END(declare-const var_h_i143 T578)
(declare-const var_h142 T578)
(declare-const v Int)
(declare-const var_h_i91 T578)
(declare-const var_h90 T578)
(declare-const v Int)
(declare-const var_h_i43 T578)
(declare-const var_h42 T578)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h149 T578)
(declare-const var__temp_v150 Int)
(declare-const |var__temp_h'151| T578)
(declare-const var__temp_v_err152 T579)
(declare-const var_h142 T578)
(declare-const var_h90 T578)
(declare-const var_h42 T578)
(declare-const err T592)
    (declare-const |20| Int)
  
solver 
 (declare-sort T578)
(declare-fun sel (T578 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T578)
(declare-fun var_h42 () T578)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'151| () T578)
(declare-fun var__temp_v150 () Int)
(declare-fun var__temp_h149 () T578)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h149 res) v) (= v |20|))
               (= (sel var__temp_h149 res) 7)))
      (a!2 (and (= (sel |var__temp_h'151| res) var__temp_v150)
                (= (sel |var__temp_h'151| res) (+ (sel var__temp_h149 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'151| res) var__temp_v150)
                    (= (sel |var__temp_h'151| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h149 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************38
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h, res ) ==(sel)( , h, res ) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i143 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i143, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v144:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i143 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h, res ) ==(sel)( , h, res ) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h153 --->  Ty_heap  
 var__temp_v154 --->  Ty_int  
 var__temp_h'155 --->  Ty_heap  
 var__temp_v_err156 --->  error  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h153, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h153, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h153, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'155, res ) ==(var__temp_v154) AND 
 	 Rel (sel)( , var__temp_h153, res ) ==(sel)( , var__temp_h153, res ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'155, res ) ==(var__temp_v154) AND 
 	 Rel (sel)( , var__temp_h'155, res ) ==(10)
 
VC_END(declare-const var_h_i143 T595)
(declare-const var_h142 T595)
(declare-const v Int)
(declare-const var_h_i91 T595)
(declare-const var_h90 T595)
(declare-const v Int)
(declare-const var_h_i43 T595)
(declare-const var_h42 T595)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h153 T595)
(declare-const var__temp_v154 Int)
(declare-const |var__temp_h'155| T595)
(declare-const var__temp_v_err156 T596)
(declare-const var_h142 T595)
(declare-const var_h90 T595)
(declare-const var_h42 T595)
(declare-const err T609)
    (declare-const |20| Int)
  
solver 
 (declare-sort T595)
(declare-fun sel (T595 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T595)
(declare-fun var_h42 () T595)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'155| () T595)
(declare-fun var__temp_v154 () Int)
(declare-fun var__temp_h153 () T595)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h153 res) v) (= v |20|))
               (not (> (sel var__temp_h153 res) 20))))
      (a!2 (=> (and (= (sel |var__temp_h'155| res) var__temp_v154)
                    (= (sel var__temp_h153 res) (sel var__temp_h153 res)))
               (and (= (sel |var__temp_h'155| res) var__temp_v154)
                    (= (sel |var__temp_h'155| res) 10)))))
(let ((a!3 (=> (not (> (sel var__temp_h153 res) 20)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************39
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i143 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i143, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v144:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i143 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h157 --->  Ty_heap  
 var__temp_v158 --->  Ty_int  
 var__temp_h'159 --->  Ty_heap  
 var__temp_v_err160 --->  error  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h157, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h157, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h157, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'159, res ) ==(var__temp_v158) AND 
 	 Rel (sel)( , var__temp_h'159, res ) ==((sel)( , var__temp_h157, res ) + (10)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'159, res ) ==(var__temp_v158) AND 
 	 Rel (sel)( , var__temp_h'159, res ) ==(10)
 
VC_END(declare-const var_h_i143 T612)
(declare-const var_h142 T612)
(declare-const v Int)
(declare-const var_h_i91 T612)
(declare-const var_h90 T612)
(declare-const v Int)
(declare-const var_h_i43 T612)
(declare-const var_h42 T612)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h157 T612)
(declare-const var__temp_v158 Int)
(declare-const |var__temp_h'159| T612)
(declare-const var__temp_v_err160 T613)
(declare-const var_h142 T612)
(declare-const var_h90 T612)
(declare-const var_h42 T612)
(declare-const err T626)
    (declare-const |20| Int)
  
solver 
 (declare-sort T612)
(declare-fun sel (T612 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T612)
(declare-fun var_h42 () T612)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'159| () T612)
(declare-fun var__temp_v158 () Int)
(declare-fun var__temp_h157 () T612)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h157 res) v) (= v |20|))
               (> (sel var__temp_h157 res) 4)))
      (a!2 (and (= (sel |var__temp_h'159| res) var__temp_v158)
                (= (sel |var__temp_h'159| res) (+ (sel var__temp_h157 res) 10)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'159| res) var__temp_v158)
                    (= (sel |var__temp_h'159| res) 10)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h157 res) 4) a!3))))
  (not a!4)))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************40
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i143 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i143, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v144:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i143 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h161 --->  Ty_heap  
 var__temp_v162 --->  Ty_int  
 var__temp_h'163 --->  Ty_heap  
 var__temp_v_err164 --->  error  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h161, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h161, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h161, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'163, res ) ==(var__temp_v162) AND 
 	 Base var__temp_v162 = 5 => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'163, res ) ==(var__temp_v162) AND 
 	 Rel (sel)( , var__temp_h'163, res ) ==(10)
 
VC_END(declare-const var_h_i143 T629)
(declare-const var_h142 T629)
(declare-const v Int)
(declare-const var_h_i91 T629)
(declare-const var_h90 T629)
(declare-const v Int)
(declare-const var_h_i43 T629)
(declare-const var_h42 T629)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h161 T629)
(declare-const var__temp_v162 Int)
(declare-const |var__temp_h'163| T629)
(declare-const var__temp_v_err164 T630)
(declare-const var_h142 T629)
(declare-const var_h90 T629)
(declare-const var_h42 T629)
(declare-const err T643)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T629)
(declare-fun sel (T629 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T629)
(declare-fun var_h42 () T629)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'163| () T629)
(declare-fun var__temp_v162 () Int)
(declare-fun var__temp_h161 () T629)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h161 res) v) (= v |20|))
               (= (sel var__temp_h161 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'163| res) var__temp_v162)
                    (= var__temp_v162 |5|))
               (and (= (sel |var__temp_h'163| res) var__temp_v162)
                    (= (sel |var__temp_h'163| res) 10)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h161 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************41
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i143 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i143, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v144:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i143 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h165 --->  Ty_heap  
 var__temp_v166 --->  Ty_int  
 var__temp_h'167 --->  Ty_heap  
 var__temp_v_err168 --->  error  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h165, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h165, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h165, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'167, res ) ==(var__temp_v166) AND 
 	 Rel (sel)( , var__temp_h'167, res ) ==((sel)( , var__temp_h165, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'167, res ) ==(var__temp_v166) AND 
 	 Rel (sel)( , var__temp_h'167, res ) ==(10)
 
VC_END(declare-const var_h_i143 T646)
(declare-const var_h142 T646)
(declare-const v Int)
(declare-const var_h_i91 T646)
(declare-const var_h90 T646)
(declare-const v Int)
(declare-const var_h_i43 T646)
(declare-const var_h42 T646)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h165 T646)
(declare-const var__temp_v166 Int)
(declare-const |var__temp_h'167| T646)
(declare-const var__temp_v_err168 T647)
(declare-const var_h142 T646)
(declare-const var_h90 T646)
(declare-const var_h42 T646)
(declare-const err T660)
    (declare-const |20| Int)
  
solver 
 (declare-sort T646)
(declare-fun sel (T646 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T646)
(declare-fun var_h42 () T646)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'167| () T646)
(declare-fun var__temp_v166 () Int)
(declare-fun var__temp_h165 () T646)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h165 res) v) (= v |20|))
               (= (sel var__temp_h165 res) 5)))
      (a!2 (and (= (sel |var__temp_h'167| res) var__temp_v166)
                (= (sel |var__temp_h'167| res) (+ (sel var__temp_h165 res) 2)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'167| res) var__temp_v166)
                    (= (sel |var__temp_h'167| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h165 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************42
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v144:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v144:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfoo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --c4	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i143 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i143, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v169:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
foo
bar
 *********************Enumeration Iteration*****************43
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i143 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i143, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v169:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h170 --->  Ty_heap  
 var__temp_v171 --->  Ty_int  
 var__temp_h'172 --->  Ty_heap  
 var__temp_v_err173 --->  error  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h170, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h170, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h170, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'172, res ) ==(var__temp_v171) AND 
 	 Rel (sel)( , var__temp_h'172, res ) ==((sel)( , var__temp_h170, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i143 T663)
(declare-const var_h142 T663)
(declare-const v Int)
(declare-const var_h_i91 T663)
(declare-const var_h90 T663)
(declare-const v Int)
(declare-const var_h_i43 T663)
(declare-const var_h42 T663)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h170 T663)
(declare-const var__temp_v171 Int)
(declare-const |var__temp_h'172| T663)
(declare-const var__temp_v_err173 T664)
(declare-const var_h142 T663)
(declare-const var_h90 T663)
(declare-const var_h42 T663)
(declare-const err T677)
    (declare-const |20| Int)
  
solver 
 (declare-sort T663)
(declare-fun sel (T663 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T663)
(declare-fun var_h42 () T663)
(declare-fun |20| () Int)
(declare-fun var__temp_h170 () T663)
(declare-fun |var__temp_h'172| () T663)
(declare-fun var__temp_v171 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h170 res) v) (= v |20|))
               (= (sel var__temp_h170 res) 7)))
      (a!2 (and (= (sel |var__temp_h'172| res) var__temp_v171)
                (= (sel |var__temp_h'172| res) (+ (sel var__temp_h170 res) 3)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h170 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************44
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i143 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i143, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v169:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h174 --->  Ty_heap  
 var__temp_v175 --->  Ty_int  
 var__temp_h'176 --->  Ty_heap  
 var__temp_v_err177 --->  error  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h174, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h174, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h174, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'176, res ) ==(var__temp_v175) AND 
 	 Rel (sel)( , var__temp_h'176, res ) ==((sel)( , var__temp_h174, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i143 T680)
(declare-const var_h142 T680)
(declare-const v Int)
(declare-const var_h_i91 T680)
(declare-const var_h90 T680)
(declare-const v Int)
(declare-const var_h_i43 T680)
(declare-const var_h42 T680)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h174 T680)
(declare-const var__temp_v175 Int)
(declare-const |var__temp_h'176| T680)
(declare-const var__temp_v_err177 T681)
(declare-const var_h142 T680)
(declare-const var_h90 T680)
(declare-const var_h42 T680)
(declare-const err T694)
    (declare-const |20| Int)
  
solver 
 (declare-sort T680)
(declare-fun sel (T680 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T680)
(declare-fun var_h42 () T680)
(declare-fun |20| () Int)
(declare-fun var__temp_h174 () T680)
(declare-fun |var__temp_h'176| () T680)
(declare-fun var__temp_v175 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h174 res) v) (= v |20|))
               (= (sel var__temp_h174 res) 7)))
      (a!2 (and (= (sel |var__temp_h'176| res) var__temp_v175)
                (= (sel |var__temp_h'176| res) (+ (sel var__temp_h174 res) 5)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h174 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************45
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h, res ) ==(sel)( , h, res ) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i143 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i143, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v169:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h, res ) ==(sel)( , h, res ) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h178 --->  Ty_heap  
 var__temp_v179 --->  Ty_int  
 var__temp_h'180 --->  Ty_heap  
 var__temp_v_err181 --->  error  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h178, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h178, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h178, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'180, res ) ==(var__temp_v179) AND 
 	 Rel (sel)( , var__temp_h178, res ) ==(sel)( , var__temp_h178, res ) => 
 	 True
 
VC_END(declare-const var_h_i143 T697)
(declare-const var_h142 T697)
(declare-const v Int)
(declare-const var_h_i91 T697)
(declare-const var_h90 T697)
(declare-const v Int)
(declare-const var_h_i43 T697)
(declare-const var_h42 T697)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h178 T697)
(declare-const var__temp_v179 Int)
(declare-const |var__temp_h'180| T697)
(declare-const var__temp_v_err181 T698)
(declare-const var_h142 T697)
(declare-const var_h90 T697)
(declare-const var_h42 T697)
(declare-const err T711)
    (declare-const |20| Int)
  
solver 
 (declare-sort T697)
(declare-fun sel (T697 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T697)
(declare-fun var_h42 () T697)
(declare-fun |20| () Int)
(declare-fun var__temp_h178 () T697)
(declare-fun var__temp_v179 () Int)
(declare-fun |var__temp_h'180| () T697)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h178 res) v) (= v |20|))
               (not (> (sel var__temp_h178 res) 20))))
      (a!2 (=> (and (= (sel |var__temp_h'180| res) var__temp_v179)
                    (= (sel var__temp_h178 res) (sel var__temp_h178 res)))
               true)))
(let ((a!3 (=> (not (> (sel var__temp_h178 res) 20)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Successful************c2'
PARTIAL PATH NEW
NEW 	 --c3'	 --c4	 --foo'	 --c2'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i183 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i183 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i183, res ) ==(v)
 	 , (sel)( , var_h182, res ) ==(sel)( , var_h182, res ) >c  } 
 } 
 
                                                RET :  Base {var_v184:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i183 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************46
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i183 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i183, res ) ==(v)
 	 , (sel)( , var_h182, res ) ==(sel)( , var_h182, res ) >c  } 
 } 
 
                                                RET :  Base {var_v184:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i183 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i183 --->  Ty_heap  
 var_h182 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h185 --->  Ty_heap  
 var__temp_v186 --->  Ty_int  
 var__temp_h'187 --->  Ty_heap  
 var__temp_v_err188 --->  error  
 var_h182 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h182, res ) > (20) AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h185, res ) ==(v) AND 
 	 Rel (sel)( , var_h182, res ) ==(sel)( , var_h182, res ) => 
 	 Rel (sel)( , var__temp_h185, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h185, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'187, res ) ==(var__temp_v186) AND 
 	 Rel (sel)( , var__temp_h'187, res ) ==((sel)( , var__temp_h185, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'187, res ) ==(var__temp_v186) AND 
 	 Rel (sel)( , var__temp_h'187, res ) ==(10)
 
VC_END(declare-const var_h_i183 T714)
(declare-const var_h182 T714)
(declare-const v Int)
(declare-const var_h_i143 T714)
(declare-const var_h142 T714)
(declare-const v Int)
(declare-const var_h_i91 T714)
(declare-const var_h90 T714)
(declare-const v Int)
(declare-const var_h_i43 T714)
(declare-const var_h42 T714)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h185 T714)
(declare-const var__temp_v186 Int)
(declare-const |var__temp_h'187| T714)
(declare-const var__temp_v_err188 T715)
(declare-const var_h182 T714)
(declare-const var_h142 T714)
(declare-const var_h90 T714)
(declare-const var_h42 T714)
(declare-const err T728)

solver 
 (declare-sort T714)
(declare-fun sel (T714 Int) Int)
(declare-fun res () Int)
(declare-fun var_h182 () T714)
(declare-fun var_h90 () T714)
(declare-fun var_h42 () T714)
(declare-fun |var__temp_h'187| () T714)
(declare-fun var__temp_v186 () Int)
(declare-fun var__temp_h185 () T714)
(declare-fun v () Int)
(assert (not (> (sel var_h182 res) 20)))
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h185 res) v)
                    (= (sel var_h182 res) (sel var_h182 res)))
               (= (sel var__temp_h185 res) 7)))
      (a!2 (and (= (sel |var__temp_h'187| res) var__temp_v186)
                (= (sel |var__temp_h'187| res) (+ (sel var__temp_h185 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'187| res) var__temp_v186)
                    (= (sel |var__temp_h'187| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h185 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************47
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i183 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i183, res ) ==(v)
 	 , (sel)( , var_h182, res ) ==(sel)( , var_h182, res ) >c  } 
 } 
 
                                                RET :  Base {var_v184:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i183 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i183 --->  Ty_heap  
 var_h182 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h189 --->  Ty_heap  
 var__temp_v190 --->  Ty_int  
 var__temp_h'191 --->  Ty_heap  
 var__temp_v_err192 --->  error  
 var_h182 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h182, res ) > (20) AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h189, res ) ==(v) AND 
 	 Rel (sel)( , var_h182, res ) ==(sel)( , var_h182, res ) => 
 	 Rel (sel)( , var__temp_h189, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h189, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'191, res ) ==(var__temp_v190) AND 
 	 Rel (sel)( , var__temp_h'191, res ) ==((sel)( , var__temp_h189, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'191, res ) ==(var__temp_v190) AND 
 	 Rel (sel)( , var__temp_h'191, res ) ==(10)
 
VC_END(declare-const var_h_i183 T731)
(declare-const var_h182 T731)
(declare-const v Int)
(declare-const var_h_i143 T731)
(declare-const var_h142 T731)
(declare-const v Int)
(declare-const var_h_i91 T731)
(declare-const var_h90 T731)
(declare-const v Int)
(declare-const var_h_i43 T731)
(declare-const var_h42 T731)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h189 T731)
(declare-const var__temp_v190 Int)
(declare-const |var__temp_h'191| T731)
(declare-const var__temp_v_err192 T732)
(declare-const var_h182 T731)
(declare-const var_h142 T731)
(declare-const var_h90 T731)
(declare-const var_h42 T731)
(declare-const err T745)

solver 
 (declare-sort T731)
(declare-fun sel (T731 Int) Int)
(declare-fun res () Int)
(declare-fun var_h182 () T731)
(declare-fun var_h90 () T731)
(declare-fun var_h42 () T731)
(declare-fun |var__temp_h'191| () T731)
(declare-fun var__temp_v190 () Int)
(declare-fun var__temp_h189 () T731)
(declare-fun v () Int)
(assert (not (> (sel var_h182 res) 20)))
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h189 res) v)
                    (= (sel var_h182 res) (sel var_h182 res)))
               (= (sel var__temp_h189 res) 7)))
      (a!2 (and (= (sel |var__temp_h'191| res) var__temp_v190)
                (= (sel |var__temp_h'191| res) (+ (sel var__temp_h189 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'191| res) var__temp_v190)
                    (= (sel |var__temp_h'191| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h189 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************48
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i183 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i183, res ) ==(v)
 	 , (sel)( , var_h182, res ) ==(sel)( , var_h182, res ) >c  } 
 } 
 
                                                RET :  Base {var_v184:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i183 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i183 --->  Ty_heap  
 var_h182 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h193 --->  Ty_heap  
 var__temp_v194 --->  Ty_int  
 var__temp_h'195 --->  Ty_heap  
 var__temp_v_err196 --->  error  
 var_h182 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h182, res ) > (20) AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h193, res ) ==(v) AND 
 	 Rel (sel)( , var_h182, res ) ==(sel)( , var_h182, res ) => 
 	 Rel (sel)( , var__temp_h193, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h193, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'195, res ) ==(var__temp_v194) AND 
 	 Rel (sel)( , var__temp_h'195, res ) ==((sel)( , var__temp_h193, res ) + (10)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'195, res ) ==(var__temp_v194) AND 
 	 Rel (sel)( , var__temp_h'195, res ) ==(10)
 
VC_END(declare-const var_h_i183 T748)
(declare-const var_h182 T748)
(declare-const v Int)
(declare-const var_h_i143 T748)
(declare-const var_h142 T748)
(declare-const v Int)
(declare-const var_h_i91 T748)
(declare-const var_h90 T748)
(declare-const v Int)
(declare-const var_h_i43 T748)
(declare-const var_h42 T748)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h193 T748)
(declare-const var__temp_v194 Int)
(declare-const |var__temp_h'195| T748)
(declare-const var__temp_v_err196 T749)
(declare-const var_h182 T748)
(declare-const var_h142 T748)
(declare-const var_h90 T748)
(declare-const var_h42 T748)
(declare-const err T762)

solver 
 (declare-sort T748)
(declare-fun sel (T748 Int) Int)
(declare-fun res () Int)
(declare-fun var_h182 () T748)
(declare-fun var_h90 () T748)
(declare-fun var_h42 () T748)
(declare-fun |var__temp_h'195| () T748)
(declare-fun var__temp_v194 () Int)
(declare-fun var__temp_h193 () T748)
(declare-fun v () Int)
(assert (not (> (sel var_h182 res) 20)))
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h193 res) v)
                    (= (sel var_h182 res) (sel var_h182 res)))
               (> (sel var__temp_h193 res) 4)))
      (a!2 (and (= (sel |var__temp_h'195| res) var__temp_v194)
                (= (sel |var__temp_h'195| res) (+ (sel var__temp_h193 res) 10)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'195| res) var__temp_v194)
                    (= (sel |var__temp_h'195| res) 10)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h193 res) 4) a!3))))
  (not a!4)))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************49
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i183 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i183, res ) ==(v)
 	 , (sel)( , var_h182, res ) ==(sel)( , var_h182, res ) >c  } 
 } 
 
                                                RET :  Base {var_v184:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i183 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i183 --->  Ty_heap  
 var_h182 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h197 --->  Ty_heap  
 var__temp_v198 --->  Ty_int  
 var__temp_h'199 --->  Ty_heap  
 var__temp_v_err200 --->  error  
 var_h182 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h182, res ) > (20) AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h197, res ) ==(v) AND 
 	 Rel (sel)( , var_h182, res ) ==(sel)( , var_h182, res ) => 
 	 Rel (sel)( , var__temp_h197, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h197, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'199, res ) ==(var__temp_v198) AND 
 	 Base var__temp_v198 = 5 => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'199, res ) ==(var__temp_v198) AND 
 	 Rel (sel)( , var__temp_h'199, res ) ==(10)
 
VC_END(declare-const var_h_i183 T765)
(declare-const var_h182 T765)
(declare-const v Int)
(declare-const var_h_i143 T765)
(declare-const var_h142 T765)
(declare-const v Int)
(declare-const var_h_i91 T765)
(declare-const var_h90 T765)
(declare-const v Int)
(declare-const var_h_i43 T765)
(declare-const var_h42 T765)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h197 T765)
(declare-const var__temp_v198 Int)
(declare-const |var__temp_h'199| T765)
(declare-const var__temp_v_err200 T766)
(declare-const var_h182 T765)
(declare-const var_h142 T765)
(declare-const var_h90 T765)
(declare-const var_h42 T765)
(declare-const err T779)
    (declare-const |5| Int)
  
solver 
 (declare-sort T765)
(declare-fun sel (T765 Int) Int)
(declare-fun res () Int)
(declare-fun var_h182 () T765)
(declare-fun var_h90 () T765)
(declare-fun var_h42 () T765)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'199| () T765)
(declare-fun var__temp_v198 () Int)
(declare-fun var__temp_h197 () T765)
(declare-fun v () Int)
(assert (not (> (sel var_h182 res) 20)))
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h197 res) v)
                    (= (sel var_h182 res) (sel var_h182 res)))
               (= (sel var__temp_h197 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'199| res) var__temp_v198)
                    (= var__temp_v198 |5|))
               (and (= (sel |var__temp_h'199| res) var__temp_v198)
                    (= (sel |var__temp_h'199| res) 10)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h197 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************50
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i183 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i183, res ) ==(v)
 	 , (sel)( , var_h182, res ) ==(sel)( , var_h182, res ) >c  } 
 } 
 
                                                RET :  Base {var_v184:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i183 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i183 --->  Ty_heap  
 var_h182 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h201 --->  Ty_heap  
 var__temp_v202 --->  Ty_int  
 var__temp_h'203 --->  Ty_heap  
 var__temp_v_err204 --->  error  
 var_h182 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h182, res ) > (20) AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h201, res ) ==(v) AND 
 	 Rel (sel)( , var_h182, res ) ==(sel)( , var_h182, res ) => 
 	 Rel (sel)( , var__temp_h201, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h201, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'203, res ) ==(var__temp_v202) AND 
 	 Rel (sel)( , var__temp_h'203, res ) ==((sel)( , var__temp_h201, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'203, res ) ==(var__temp_v202) AND 
 	 Rel (sel)( , var__temp_h'203, res ) ==(10)
 
VC_END(declare-const var_h_i183 T782)
(declare-const var_h182 T782)
(declare-const v Int)
(declare-const var_h_i143 T782)
(declare-const var_h142 T782)
(declare-const v Int)
(declare-const var_h_i91 T782)
(declare-const var_h90 T782)
(declare-const v Int)
(declare-const var_h_i43 T782)
(declare-const var_h42 T782)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h201 T782)
(declare-const var__temp_v202 Int)
(declare-const |var__temp_h'203| T782)
(declare-const var__temp_v_err204 T783)
(declare-const var_h182 T782)
(declare-const var_h142 T782)
(declare-const var_h90 T782)
(declare-const var_h42 T782)
(declare-const err T796)

solver 
 (declare-sort T782)
(declare-fun sel (T782 Int) Int)
(declare-fun res () Int)
(declare-fun var_h182 () T782)
(declare-fun var_h90 () T782)
(declare-fun var_h42 () T782)
(declare-fun |var__temp_h'203| () T782)
(declare-fun var__temp_v202 () Int)
(declare-fun var__temp_h201 () T782)
(declare-fun v () Int)
(assert (not (> (sel var_h182 res) 20)))
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h201 res) v)
                    (= (sel var_h182 res) (sel var_h182 res)))
               (= (sel var__temp_h201 res) 5)))
      (a!2 (and (= (sel |var__temp_h'203| res) var__temp_v202)
                (= (sel |var__temp_h'203| res) (+ (sel var__temp_h201 res) 2)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'203| res) var__temp_v202)
                    (= (sel |var__temp_h'203| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h201 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************51
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v184:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v184:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --c4	 --foo'	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i183 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i183, res ) ==(v)
 	 , (sel)( , var_h182, res ) ==(sel)( , var_h182, res ) >c  } 
 } 
 
                                                RET :  Base {var_v205:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************52
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i183 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i183, res ) ==(v)
 	 , (sel)( , var_h182, res ) ==(sel)( , var_h182, res ) >c  } 
 } 
 
                                                RET :  Base {var_v205:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i183 --->  Ty_heap  
 var_h182 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h206 --->  Ty_heap  
 var__temp_v207 --->  Ty_int  
 var__temp_h'208 --->  Ty_heap  
 var__temp_v_err209 --->  error  
 var_h182 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h182, res ) > (20) AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h206, res ) ==(v) AND 
 	 Rel (sel)( , var_h182, res ) ==(sel)( , var_h182, res ) => 
 	 Rel (sel)( , var__temp_h206, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h206, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'208, res ) ==(var__temp_v207) AND 
 	 Rel (sel)( , var__temp_h'208, res ) ==((sel)( , var__temp_h206, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i183 T799)
(declare-const var_h182 T799)
(declare-const v Int)
(declare-const var_h_i143 T799)
(declare-const var_h142 T799)
(declare-const v Int)
(declare-const var_h_i91 T799)
(declare-const var_h90 T799)
(declare-const v Int)
(declare-const var_h_i43 T799)
(declare-const var_h42 T799)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h206 T799)
(declare-const var__temp_v207 Int)
(declare-const |var__temp_h'208| T799)
(declare-const var__temp_v_err209 T800)
(declare-const var_h182 T799)
(declare-const var_h142 T799)
(declare-const var_h90 T799)
(declare-const var_h42 T799)
(declare-const err T813)

solver 
 (declare-sort T799)
(declare-fun sel (T799 Int) Int)
(declare-fun res () Int)
(declare-fun var_h182 () T799)
(declare-fun var_h90 () T799)
(declare-fun var_h42 () T799)
(declare-fun var__temp_h206 () T799)
(declare-fun |var__temp_h'208| () T799)
(declare-fun var__temp_v207 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h182 res) 20)))
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h206 res) v)
                    (= (sel var_h182 res) (sel var_h182 res)))
               (= (sel var__temp_h206 res) 7)))
      (a!2 (and (= (sel |var__temp_h'208| res) var__temp_v207)
                (= (sel |var__temp_h'208| res) (+ (sel var__temp_h206 res) 3)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h206 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************53
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i183 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i183, res ) ==(v)
 	 , (sel)( , var_h182, res ) ==(sel)( , var_h182, res ) >c  } 
 } 
 
                                                RET :  Base {var_v205:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i183 --->  Ty_heap  
 var_h182 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h210 --->  Ty_heap  
 var__temp_v211 --->  Ty_int  
 var__temp_h'212 --->  Ty_heap  
 var__temp_v_err213 --->  error  
 var_h182 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h182, res ) > (20) AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h210, res ) ==(v) AND 
 	 Rel (sel)( , var_h182, res ) ==(sel)( , var_h182, res ) => 
 	 Rel (sel)( , var__temp_h210, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h210, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'212, res ) ==(var__temp_v211) AND 
 	 Rel (sel)( , var__temp_h'212, res ) ==((sel)( , var__temp_h210, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i183 T816)
(declare-const var_h182 T816)
(declare-const v Int)
(declare-const var_h_i143 T816)
(declare-const var_h142 T816)
(declare-const v Int)
(declare-const var_h_i91 T816)
(declare-const var_h90 T816)
(declare-const v Int)
(declare-const var_h_i43 T816)
(declare-const var_h42 T816)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h210 T816)
(declare-const var__temp_v211 Int)
(declare-const |var__temp_h'212| T816)
(declare-const var__temp_v_err213 T817)
(declare-const var_h182 T816)
(declare-const var_h142 T816)
(declare-const var_h90 T816)
(declare-const var_h42 T816)
(declare-const err T830)

solver 
 (declare-sort T816)
(declare-fun sel (T816 Int) Int)
(declare-fun res () Int)
(declare-fun var_h182 () T816)
(declare-fun var_h90 () T816)
(declare-fun var_h42 () T816)
(declare-fun var__temp_h210 () T816)
(declare-fun |var__temp_h'212| () T816)
(declare-fun var__temp_v211 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h182 res) 20)))
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h210 res) v)
                    (= (sel var_h182 res) (sel var_h182 res)))
               (= (sel var__temp_h210 res) 7)))
      (a!2 (and (= (sel |var__temp_h'212| res) var__temp_v211)
                (= (sel |var__temp_h'212| res) (+ (sel var__temp_h210 res) 5)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h210 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************54
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i183 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i183, res ) ==(v)
 	 , (sel)( , var_h182, res ) ==(sel)( , var_h182, res ) >c  } 
 } 
 
                                                RET :  Base {var_v205:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i183 --->  Ty_heap  
 var_h182 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h214 --->  Ty_heap  
 var__temp_v215 --->  Ty_int  
 var__temp_h'216 --->  Ty_heap  
 var__temp_v_err217 --->  error  
 var_h182 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h182, res ) > (20) AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h214, res ) ==(v) AND 
 	 Rel (sel)( , var_h182, res ) ==(sel)( , var_h182, res ) => 
 	 Rel (sel)( , var__temp_h214, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h214, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'216, res ) ==(var__temp_v215) AND 
 	 Rel (sel)( , var__temp_h'216, res ) ==((sel)( , var__temp_h214, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i183 T833)
(declare-const var_h182 T833)
(declare-const v Int)
(declare-const var_h_i143 T833)
(declare-const var_h142 T833)
(declare-const v Int)
(declare-const var_h_i91 T833)
(declare-const var_h90 T833)
(declare-const v Int)
(declare-const var_h_i43 T833)
(declare-const var_h42 T833)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h214 T833)
(declare-const var__temp_v215 Int)
(declare-const |var__temp_h'216| T833)
(declare-const var__temp_v_err217 T834)
(declare-const var_h182 T833)
(declare-const var_h142 T833)
(declare-const var_h90 T833)
(declare-const var_h42 T833)
(declare-const err T847)

solver 
 (declare-sort T833)
(declare-fun sel (T833 Int) Int)
(declare-fun res () Int)
(declare-fun var_h182 () T833)
(declare-fun var_h90 () T833)
(declare-fun var_h42 () T833)
(declare-fun var__temp_h214 () T833)
(declare-fun |var__temp_h'216| () T833)
(declare-fun var__temp_v215 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h182 res) 20)))
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h214 res) v)
                    (= (sel var_h182 res) (sel var_h182 res)))
               (> (sel var__temp_h214 res) 4)))
      (a!2 (and (= (sel |var__temp_h'216| res) var__temp_v215)
                (= (sel |var__temp_h'216| res) (+ (sel var__temp_h214 res) 10)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h214 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************55
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i183 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i183, res ) ==(v)
 	 , (sel)( , var_h182, res ) ==(sel)( , var_h182, res ) >c  } 
 } 
 
                                                RET :  Base {var_v205:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i183 --->  Ty_heap  
 var_h182 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h218 --->  Ty_heap  
 var__temp_v219 --->  Ty_int  
 var__temp_h'220 --->  Ty_heap  
 var__temp_v_err221 --->  error  
 var_h182 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h182, res ) > (20) AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h218, res ) ==(v) AND 
 	 Rel (sel)( , var_h182, res ) ==(sel)( , var_h182, res ) => 
 	 Rel (sel)( , var__temp_h218, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h218, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'220, res ) ==(var__temp_v219) AND 
 	 Base var__temp_v219 = 5 => 
 	 True
 
VC_END(declare-const var_h_i183 T850)
(declare-const var_h182 T850)
(declare-const v Int)
(declare-const var_h_i143 T850)
(declare-const var_h142 T850)
(declare-const v Int)
(declare-const var_h_i91 T850)
(declare-const var_h90 T850)
(declare-const v Int)
(declare-const var_h_i43 T850)
(declare-const var_h42 T850)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h218 T850)
(declare-const var__temp_v219 Int)
(declare-const |var__temp_h'220| T850)
(declare-const var__temp_v_err221 T851)
(declare-const var_h182 T850)
(declare-const var_h142 T850)
(declare-const var_h90 T850)
(declare-const var_h42 T850)
(declare-const err T864)
    (declare-const |5| Int)
  
solver 
 (declare-sort T850)
(declare-fun sel (T850 Int) Int)
(declare-fun res () Int)
(declare-fun var_h182 () T850)
(declare-fun var_h90 () T850)
(declare-fun var_h42 () T850)
(declare-fun |5| () Int)
(declare-fun var__temp_v219 () Int)
(declare-fun |var__temp_h'220| () T850)
(declare-fun var__temp_h218 () T850)
(declare-fun v () Int)
(assert (not (> (sel var_h182 res) 20)))
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h218 res) v)
                    (= (sel var_h182 res) (sel var_h182 res)))
               (= (sel var__temp_h218 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'220| res) var__temp_v219)
                    (= var__temp_v219 |5|))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h218 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************56
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i183 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i183, res ) ==(v)
 	 , (sel)( , var_h182, res ) ==(sel)( , var_h182, res ) >c  } 
 } 
 
                                                RET :  Base {var_v205:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i183 --->  Ty_heap  
 var_h182 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h222 --->  Ty_heap  
 var__temp_v223 --->  Ty_int  
 var__temp_h'224 --->  Ty_heap  
 var__temp_v_err225 --->  error  
 var_h182 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h182, res ) > (20) AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h222, res ) ==(v) AND 
 	 Rel (sel)( , var_h182, res ) ==(sel)( , var_h182, res ) => 
 	 Rel (sel)( , var__temp_h222, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h222, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'224, res ) ==(var__temp_v223) AND 
 	 Rel (sel)( , var__temp_h'224, res ) ==((sel)( , var__temp_h222, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i183 T867)
(declare-const var_h182 T867)
(declare-const v Int)
(declare-const var_h_i143 T867)
(declare-const var_h142 T867)
(declare-const v Int)
(declare-const var_h_i91 T867)
(declare-const var_h90 T867)
(declare-const v Int)
(declare-const var_h_i43 T867)
(declare-const var_h42 T867)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h222 T867)
(declare-const var__temp_v223 Int)
(declare-const |var__temp_h'224| T867)
(declare-const var__temp_v_err225 T868)
(declare-const var_h182 T867)
(declare-const var_h142 T867)
(declare-const var_h90 T867)
(declare-const var_h42 T867)
(declare-const err T881)

solver 
 (declare-sort T867)
(declare-fun sel (T867 Int) Int)
(declare-fun res () Int)
(declare-fun var_h182 () T867)
(declare-fun var_h90 () T867)
(declare-fun var_h42 () T867)
(declare-fun var__temp_h222 () T867)
(declare-fun |var__temp_h'224| () T867)
(declare-fun var__temp_v223 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h182 res) 20)))
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h222 res) v)
                    (= (sel var_h182 res) (sel var_h182 res)))
               (= (sel var__temp_h222 res) 5)))
      (a!2 (and (= (sel |var__temp_h'224| res) var__temp_v223)
                (= (sel |var__temp_h'224| res) (+ (sel var__temp_h222 res) 2)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h222 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************57
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2'
PARTIAL PATH
SUB 	 --c3'	 --c4	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i143 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i143, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v226:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************58
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i143 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i143, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v226:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h227 --->  Ty_heap  
 var__temp_v228 --->  Ty_int  
 var__temp_h'229 --->  Ty_heap  
 var__temp_v_err230 --->  error  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h227, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h227, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h227, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'229, res ) ==(var__temp_v228) AND 
 	 Rel (sel)( , var__temp_h'229, res ) ==((sel)( , var__temp_h227, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i143 T884)
(declare-const var_h142 T884)
(declare-const v Int)
(declare-const var_h_i91 T884)
(declare-const var_h90 T884)
(declare-const v Int)
(declare-const var_h_i43 T884)
(declare-const var_h42 T884)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h227 T884)
(declare-const var__temp_v228 Int)
(declare-const |var__temp_h'229| T884)
(declare-const var__temp_v_err230 T885)
(declare-const var_h142 T884)
(declare-const var_h90 T884)
(declare-const var_h42 T884)
(declare-const err T898)
    (declare-const |20| Int)
  
solver 
 (declare-sort T884)
(declare-fun sel (T884 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T884)
(declare-fun var_h42 () T884)
(declare-fun |20| () Int)
(declare-fun var__temp_h227 () T884)
(declare-fun |var__temp_h'229| () T884)
(declare-fun var__temp_v228 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h227 res) v) (= v |20|))
               (= (sel var__temp_h227 res) 7)))
      (a!2 (and (= (sel |var__temp_h'229| res) var__temp_v228)
                (= (sel |var__temp_h'229| res) (+ (sel var__temp_h227 res) 3)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h227 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************59
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i143 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i143, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v226:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h231 --->  Ty_heap  
 var__temp_v232 --->  Ty_int  
 var__temp_h'233 --->  Ty_heap  
 var__temp_v_err234 --->  error  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h231, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h231, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h231, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'233, res ) ==(var__temp_v232) AND 
 	 Rel (sel)( , var__temp_h'233, res ) ==((sel)( , var__temp_h231, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i143 T901)
(declare-const var_h142 T901)
(declare-const v Int)
(declare-const var_h_i91 T901)
(declare-const var_h90 T901)
(declare-const v Int)
(declare-const var_h_i43 T901)
(declare-const var_h42 T901)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h231 T901)
(declare-const var__temp_v232 Int)
(declare-const |var__temp_h'233| T901)
(declare-const var__temp_v_err234 T902)
(declare-const var_h142 T901)
(declare-const var_h90 T901)
(declare-const var_h42 T901)
(declare-const err T915)
    (declare-const |20| Int)
  
solver 
 (declare-sort T901)
(declare-fun sel (T901 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T901)
(declare-fun var_h42 () T901)
(declare-fun |20| () Int)
(declare-fun var__temp_h231 () T901)
(declare-fun |var__temp_h'233| () T901)
(declare-fun var__temp_v232 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h231 res) v) (= v |20|))
               (= (sel var__temp_h231 res) 7)))
      (a!2 (and (= (sel |var__temp_h'233| res) var__temp_v232)
                (= (sel |var__temp_h'233| res) (+ (sel var__temp_h231 res) 5)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h231 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************60
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i143 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i143, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v226:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h235 --->  Ty_heap  
 var__temp_v236 --->  Ty_int  
 var__temp_h'237 --->  Ty_heap  
 var__temp_v_err238 --->  error  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h235, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h235, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h235, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'237, res ) ==(var__temp_v236) AND 
 	 Rel (sel)( , var__temp_h'237, res ) ==((sel)( , var__temp_h235, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i143 T918)
(declare-const var_h142 T918)
(declare-const v Int)
(declare-const var_h_i91 T918)
(declare-const var_h90 T918)
(declare-const v Int)
(declare-const var_h_i43 T918)
(declare-const var_h42 T918)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h235 T918)
(declare-const var__temp_v236 Int)
(declare-const |var__temp_h'237| T918)
(declare-const var__temp_v_err238 T919)
(declare-const var_h142 T918)
(declare-const var_h90 T918)
(declare-const var_h42 T918)
(declare-const err T932)
    (declare-const |20| Int)
  
solver 
 (declare-sort T918)
(declare-fun sel (T918 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T918)
(declare-fun var_h42 () T918)
(declare-fun |20| () Int)
(declare-fun var__temp_h235 () T918)
(declare-fun |var__temp_h'237| () T918)
(declare-fun var__temp_v236 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h235 res) v) (= v |20|))
               (> (sel var__temp_h235 res) 4)))
      (a!2 (and (= (sel |var__temp_h'237| res) var__temp_v236)
                (= (sel |var__temp_h'237| res) (+ (sel var__temp_h235 res) 10)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h235 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c2
PARTIAL PATH NEW
NEW 	 --c3'	 --c4	 --foo'	 --c2
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i240 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i240 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i240, res ) ==(v)
 	 , (sel)( , var_h_i240, res ) ==((sel)( , var_h239, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v241:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i240 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************61
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i240 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i240, res ) ==(v)
 	 , (sel)( , var_h_i240, res ) ==((sel)( , var_h239, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v241:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i240 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i240 --->  Ty_heap  
 var_h239 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h242 --->  Ty_heap  
 var__temp_v243 --->  Ty_int  
 var__temp_h'244 --->  Ty_heap  
 var__temp_v_err245 --->  error  
 var_h239 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h239, res ) > (4) AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h242, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h242, res ) ==((sel)( , var_h239, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h242, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h242, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'244, res ) ==(var__temp_v243) AND 
 	 Rel (sel)( , var__temp_h'244, res ) ==((sel)( , var__temp_h242, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'244, res ) ==(var__temp_v243) AND 
 	 Rel (sel)( , var__temp_h'244, res ) ==(10)
 
VC_END(declare-const var_h_i240 T935)
(declare-const var_h239 T935)
(declare-const v Int)
(declare-const var_h_i143 T935)
(declare-const var_h142 T935)
(declare-const v Int)
(declare-const var_h_i91 T935)
(declare-const var_h90 T935)
(declare-const v Int)
(declare-const var_h_i43 T935)
(declare-const var_h42 T935)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h242 T935)
(declare-const var__temp_v243 Int)
(declare-const |var__temp_h'244| T935)
(declare-const var__temp_v_err245 T936)
(declare-const var_h239 T935)
(declare-const var_h142 T935)
(declare-const var_h90 T935)
(declare-const var_h42 T935)
(declare-const err T949)

solver 
 (declare-sort T935)
(declare-fun sel (T935 Int) Int)
(declare-fun res () Int)
(declare-fun var_h239 () T935)
(declare-fun var_h90 () T935)
(declare-fun var_h42 () T935)
(declare-fun |var__temp_h'244| () T935)
(declare-fun var__temp_v243 () Int)
(declare-fun var__temp_h242 () T935)
(declare-fun v () Int)
(assert (> (sel var_h239 res) 4))
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h242 res) v)
                (= (sel var__temp_h242 res) (+ (sel var_h239 res) 10))))
      (a!2 (and (= (sel |var__temp_h'244| res) var__temp_v243)
                (= (sel |var__temp_h'244| res) (+ (sel var__temp_h242 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'244| res) var__temp_v243)
                    (= (sel |var__temp_h'244| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h242 res) 7))
                (=> (= (sel var__temp_h242 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************62
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i240 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i240, res ) ==(v)
 	 , (sel)( , var_h_i240, res ) ==((sel)( , var_h239, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v241:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i240 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i240 --->  Ty_heap  
 var_h239 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h246 --->  Ty_heap  
 var__temp_v247 --->  Ty_int  
 var__temp_h'248 --->  Ty_heap  
 var__temp_v_err249 --->  error  
 var_h239 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h239, res ) > (4) AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h246, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h246, res ) ==((sel)( , var_h239, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h246, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h246, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'248, res ) ==(var__temp_v247) AND 
 	 Rel (sel)( , var__temp_h'248, res ) ==((sel)( , var__temp_h246, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'248, res ) ==(var__temp_v247) AND 
 	 Rel (sel)( , var__temp_h'248, res ) ==(10)
 
VC_END(declare-const var_h_i240 T952)
(declare-const var_h239 T952)
(declare-const v Int)
(declare-const var_h_i143 T952)
(declare-const var_h142 T952)
(declare-const v Int)
(declare-const var_h_i91 T952)
(declare-const var_h90 T952)
(declare-const v Int)
(declare-const var_h_i43 T952)
(declare-const var_h42 T952)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h246 T952)
(declare-const var__temp_v247 Int)
(declare-const |var__temp_h'248| T952)
(declare-const var__temp_v_err249 T953)
(declare-const var_h239 T952)
(declare-const var_h142 T952)
(declare-const var_h90 T952)
(declare-const var_h42 T952)
(declare-const err T966)

solver 
 (declare-sort T952)
(declare-fun sel (T952 Int) Int)
(declare-fun res () Int)
(declare-fun var_h239 () T952)
(declare-fun var_h90 () T952)
(declare-fun var_h42 () T952)
(declare-fun |var__temp_h'248| () T952)
(declare-fun var__temp_v247 () Int)
(declare-fun var__temp_h246 () T952)
(declare-fun v () Int)
(assert (> (sel var_h239 res) 4))
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h246 res) v)
                (= (sel var__temp_h246 res) (+ (sel var_h239 res) 10))))
      (a!2 (and (= (sel |var__temp_h'248| res) var__temp_v247)
                (= (sel |var__temp_h'248| res) (+ (sel var__temp_h246 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'248| res) var__temp_v247)
                    (= (sel |var__temp_h'248| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h246 res) 7))
                (=> (= (sel var__temp_h246 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************63
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i240 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i240, res ) ==(v)
 	 , (sel)( , var_h_i240, res ) ==((sel)( , var_h239, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v241:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i240 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i240 --->  Ty_heap  
 var_h239 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h250 --->  Ty_heap  
 var__temp_v251 --->  Ty_int  
 var__temp_h'252 --->  Ty_heap  
 var__temp_v_err253 --->  error  
 var_h239 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h239, res ) > (4) AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h250, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h250, res ) ==((sel)( , var_h239, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h250, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h250, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'252, res ) ==(var__temp_v251) AND 
 	 Base var__temp_v251 = 5 => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'252, res ) ==(var__temp_v251) AND 
 	 Rel (sel)( , var__temp_h'252, res ) ==(10)
 
VC_END(declare-const var_h_i240 T969)
(declare-const var_h239 T969)
(declare-const v Int)
(declare-const var_h_i143 T969)
(declare-const var_h142 T969)
(declare-const v Int)
(declare-const var_h_i91 T969)
(declare-const var_h90 T969)
(declare-const v Int)
(declare-const var_h_i43 T969)
(declare-const var_h42 T969)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h250 T969)
(declare-const var__temp_v251 Int)
(declare-const |var__temp_h'252| T969)
(declare-const var__temp_v_err253 T970)
(declare-const var_h239 T969)
(declare-const var_h142 T969)
(declare-const var_h90 T969)
(declare-const var_h42 T969)
(declare-const err T983)
    (declare-const |5| Int)
  
solver 
 (declare-sort T969)
(declare-fun sel (T969 Int) Int)
(declare-fun res () Int)
(declare-fun var_h239 () T969)
(declare-fun var_h90 () T969)
(declare-fun var_h42 () T969)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'252| () T969)
(declare-fun var__temp_v251 () Int)
(declare-fun var__temp_h250 () T969)
(declare-fun v () Int)
(assert (> (sel var_h239 res) 4))
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h250 res) v)
                (= (sel var__temp_h250 res) (+ (sel var_h239 res) 10))))
      (a!2 (=> (and (= (sel |var__temp_h'252| res) var__temp_v251)
                    (= var__temp_v251 |5|))
               (and (= (sel |var__temp_h'252| res) var__temp_v251)
                    (= (sel |var__temp_h'252| res) 10)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h250 res) 0))
                (=> (= (sel var__temp_h250 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************64
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i240 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i240, res ) ==(v)
 	 , (sel)( , var_h_i240, res ) ==((sel)( , var_h239, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v241:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i240 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i240 --->  Ty_heap  
 var_h239 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h254 --->  Ty_heap  
 var__temp_v255 --->  Ty_int  
 var__temp_h'256 --->  Ty_heap  
 var__temp_v_err257 --->  error  
 var_h239 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h239, res ) > (4) AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h254, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h254, res ) ==((sel)( , var_h239, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h254, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h254, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'256, res ) ==(var__temp_v255) AND 
 	 Rel (sel)( , var__temp_h'256, res ) ==((sel)( , var__temp_h254, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'256, res ) ==(var__temp_v255) AND 
 	 Rel (sel)( , var__temp_h'256, res ) ==(10)
 
VC_END(declare-const var_h_i240 T986)
(declare-const var_h239 T986)
(declare-const v Int)
(declare-const var_h_i143 T986)
(declare-const var_h142 T986)
(declare-const v Int)
(declare-const var_h_i91 T986)
(declare-const var_h90 T986)
(declare-const v Int)
(declare-const var_h_i43 T986)
(declare-const var_h42 T986)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h254 T986)
(declare-const var__temp_v255 Int)
(declare-const |var__temp_h'256| T986)
(declare-const var__temp_v_err257 T987)
(declare-const var_h239 T986)
(declare-const var_h142 T986)
(declare-const var_h90 T986)
(declare-const var_h42 T986)
(declare-const err T1000)

solver 
 (declare-sort T986)
(declare-fun sel (T986 Int) Int)
(declare-fun res () Int)
(declare-fun var_h239 () T986)
(declare-fun var_h90 () T986)
(declare-fun var_h42 () T986)
(declare-fun |var__temp_h'256| () T986)
(declare-fun var__temp_v255 () Int)
(declare-fun var__temp_h254 () T986)
(declare-fun v () Int)
(assert (> (sel var_h239 res) 4))
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h254 res) v)
                (= (sel var__temp_h254 res) (+ (sel var_h239 res) 10))))
      (a!2 (and (= (sel |var__temp_h'256| res) var__temp_v255)
                (= (sel |var__temp_h'256| res) (+ (sel var__temp_h254 res) 2)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'256| res) var__temp_v255)
                    (= (sel |var__temp_h'256| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h254 res) 5))
                (=> (= (sel var__temp_h254 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************65
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v241:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v241:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2c2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --c4	 --foo'	 --c2
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i240 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i240, res ) ==(v)
 	 , (sel)( , var_h_i240, res ) ==((sel)( , var_h239, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v258:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************66
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i240 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i240, res ) ==(v)
 	 , (sel)( , var_h_i240, res ) ==((sel)( , var_h239, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v258:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i240 --->  Ty_heap  
 var_h239 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h259 --->  Ty_heap  
 var__temp_v260 --->  Ty_int  
 var__temp_h'261 --->  Ty_heap  
 var__temp_v_err262 --->  error  
 var_h239 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h239, res ) > (4) AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h259, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h259, res ) ==((sel)( , var_h239, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h259, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h259, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'261, res ) ==(var__temp_v260) AND 
 	 Rel (sel)( , var__temp_h'261, res ) ==((sel)( , var__temp_h259, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i240 T1003)
(declare-const var_h239 T1003)
(declare-const v Int)
(declare-const var_h_i143 T1003)
(declare-const var_h142 T1003)
(declare-const v Int)
(declare-const var_h_i91 T1003)
(declare-const var_h90 T1003)
(declare-const v Int)
(declare-const var_h_i43 T1003)
(declare-const var_h42 T1003)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h259 T1003)
(declare-const var__temp_v260 Int)
(declare-const |var__temp_h'261| T1003)
(declare-const var__temp_v_err262 T1004)
(declare-const var_h239 T1003)
(declare-const var_h142 T1003)
(declare-const var_h90 T1003)
(declare-const var_h42 T1003)
(declare-const err T1017)

solver 
 (declare-sort T1003)
(declare-fun sel (T1003 Int) Int)
(declare-fun res () Int)
(declare-fun var_h239 () T1003)
(declare-fun var_h90 () T1003)
(declare-fun var_h42 () T1003)
(declare-fun var__temp_h259 () T1003)
(declare-fun |var__temp_h'261| () T1003)
(declare-fun var__temp_v260 () Int)
(declare-fun v () Int)
(assert (> (sel var_h239 res) 4))
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h259 res) v)
                (= (sel var__temp_h259 res) (+ (sel var_h239 res) 10))))
      (a!2 (and (= (sel |var__temp_h'261| res) var__temp_v260)
                (= (sel |var__temp_h'261| res) (+ (sel var__temp_h259 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h259 res) 7))
                (=> (= (sel var__temp_h259 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************67
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i240 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i240, res ) ==(v)
 	 , (sel)( , var_h_i240, res ) ==((sel)( , var_h239, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v258:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i240 --->  Ty_heap  
 var_h239 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h263 --->  Ty_heap  
 var__temp_v264 --->  Ty_int  
 var__temp_h'265 --->  Ty_heap  
 var__temp_v_err266 --->  error  
 var_h239 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h239, res ) > (4) AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h263, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h263, res ) ==((sel)( , var_h239, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h263, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h263, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'265, res ) ==(var__temp_v264) AND 
 	 Rel (sel)( , var__temp_h'265, res ) ==((sel)( , var__temp_h263, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i240 T1020)
(declare-const var_h239 T1020)
(declare-const v Int)
(declare-const var_h_i143 T1020)
(declare-const var_h142 T1020)
(declare-const v Int)
(declare-const var_h_i91 T1020)
(declare-const var_h90 T1020)
(declare-const v Int)
(declare-const var_h_i43 T1020)
(declare-const var_h42 T1020)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h263 T1020)
(declare-const var__temp_v264 Int)
(declare-const |var__temp_h'265| T1020)
(declare-const var__temp_v_err266 T1021)
(declare-const var_h239 T1020)
(declare-const var_h142 T1020)
(declare-const var_h90 T1020)
(declare-const var_h42 T1020)
(declare-const err T1034)

solver 
 (declare-sort T1020)
(declare-fun sel (T1020 Int) Int)
(declare-fun res () Int)
(declare-fun var_h239 () T1020)
(declare-fun var_h90 () T1020)
(declare-fun var_h42 () T1020)
(declare-fun var__temp_h263 () T1020)
(declare-fun |var__temp_h'265| () T1020)
(declare-fun var__temp_v264 () Int)
(declare-fun v () Int)
(assert (> (sel var_h239 res) 4))
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h263 res) v)
                (= (sel var__temp_h263 res) (+ (sel var_h239 res) 10))))
      (a!2 (and (= (sel |var__temp_h'265| res) var__temp_v264)
                (= (sel |var__temp_h'265| res) (+ (sel var__temp_h263 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h263 res) 7))
                (=> (= (sel var__temp_h263 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************68
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i240 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i240, res ) ==(v)
 	 , (sel)( , var_h_i240, res ) ==((sel)( , var_h239, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v258:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i240 --->  Ty_heap  
 var_h239 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h267 --->  Ty_heap  
 var__temp_v268 --->  Ty_int  
 var__temp_h'269 --->  Ty_heap  
 var__temp_v_err270 --->  error  
 var_h239 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h239, res ) > (4) AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h267, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h267, res ) ==((sel)( , var_h239, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h267, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h267, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'269, res ) ==(var__temp_v268) AND 
 	 Base var__temp_v268 = 5 => 
 	 True
 
VC_END(declare-const var_h_i240 T1037)
(declare-const var_h239 T1037)
(declare-const v Int)
(declare-const var_h_i143 T1037)
(declare-const var_h142 T1037)
(declare-const v Int)
(declare-const var_h_i91 T1037)
(declare-const var_h90 T1037)
(declare-const v Int)
(declare-const var_h_i43 T1037)
(declare-const var_h42 T1037)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h267 T1037)
(declare-const var__temp_v268 Int)
(declare-const |var__temp_h'269| T1037)
(declare-const var__temp_v_err270 T1038)
(declare-const var_h239 T1037)
(declare-const var_h142 T1037)
(declare-const var_h90 T1037)
(declare-const var_h42 T1037)
(declare-const err T1051)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1037)
(declare-fun sel (T1037 Int) Int)
(declare-fun res () Int)
(declare-fun var_h239 () T1037)
(declare-fun var_h90 () T1037)
(declare-fun var_h42 () T1037)
(declare-fun |5| () Int)
(declare-fun var__temp_v268 () Int)
(declare-fun |var__temp_h'269| () T1037)
(declare-fun var__temp_h267 () T1037)
(declare-fun v () Int)
(assert (> (sel var_h239 res) 4))
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h267 res) v)
                (= (sel var__temp_h267 res) (+ (sel var_h239 res) 10))))
      (a!2 (=> (and (= (sel |var__temp_h'269| res) var__temp_v268)
                    (= var__temp_v268 |5|))
               true)))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h267 res) 0))
                (=> (= (sel var__temp_h267 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************69
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i240 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i240, res ) ==(v)
 	 , (sel)( , var_h_i240, res ) ==((sel)( , var_h239, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v258:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i240 --->  Ty_heap  
 var_h239 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h271 --->  Ty_heap  
 var__temp_v272 --->  Ty_int  
 var__temp_h'273 --->  Ty_heap  
 var__temp_v_err274 --->  error  
 var_h239 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h239, res ) > (4) AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h271, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h271, res ) ==((sel)( , var_h239, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h271, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h271, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'273, res ) ==(var__temp_v272) AND 
 	 Rel (sel)( , var__temp_h'273, res ) ==((sel)( , var__temp_h271, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i240 T1054)
(declare-const var_h239 T1054)
(declare-const v Int)
(declare-const var_h_i143 T1054)
(declare-const var_h142 T1054)
(declare-const v Int)
(declare-const var_h_i91 T1054)
(declare-const var_h90 T1054)
(declare-const v Int)
(declare-const var_h_i43 T1054)
(declare-const var_h42 T1054)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h271 T1054)
(declare-const var__temp_v272 Int)
(declare-const |var__temp_h'273| T1054)
(declare-const var__temp_v_err274 T1055)
(declare-const var_h239 T1054)
(declare-const var_h142 T1054)
(declare-const var_h90 T1054)
(declare-const var_h42 T1054)
(declare-const err T1068)

solver 
 (declare-sort T1054)
(declare-fun sel (T1054 Int) Int)
(declare-fun res () Int)
(declare-fun var_h239 () T1054)
(declare-fun var_h90 () T1054)
(declare-fun var_h42 () T1054)
(declare-fun var__temp_h271 () T1054)
(declare-fun |var__temp_h'273| () T1054)
(declare-fun var__temp_v272 () Int)
(declare-fun v () Int)
(assert (> (sel var_h239 res) 4))
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h271 res) v)
                (= (sel var__temp_h271 res) (+ (sel var_h239 res) 10))))
      (a!2 (and (= (sel |var__temp_h'273| res) var__temp_v272)
                (= (sel |var__temp_h'273| res) (+ (sel var__temp_h271 res) 2)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h271 res) 5))
                (=> (= (sel var__temp_h271 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************70
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 	 --c3'	 --c4	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i143 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i143, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v275:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************71
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i143 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i143, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v275:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h276 --->  Ty_heap  
 var__temp_v277 --->  Ty_int  
 var__temp_h'278 --->  Ty_heap  
 var__temp_v_err279 --->  error  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h276, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h276, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h276, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'278, res ) ==(var__temp_v277) AND 
 	 Rel (sel)( , var__temp_h'278, res ) ==((sel)( , var__temp_h276, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i143 T1071)
(declare-const var_h142 T1071)
(declare-const v Int)
(declare-const var_h_i91 T1071)
(declare-const var_h90 T1071)
(declare-const v Int)
(declare-const var_h_i43 T1071)
(declare-const var_h42 T1071)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h276 T1071)
(declare-const var__temp_v277 Int)
(declare-const |var__temp_h'278| T1071)
(declare-const var__temp_v_err279 T1072)
(declare-const var_h142 T1071)
(declare-const var_h90 T1071)
(declare-const var_h42 T1071)
(declare-const err T1085)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1071)
(declare-fun sel (T1071 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T1071)
(declare-fun var_h42 () T1071)
(declare-fun |20| () Int)
(declare-fun var__temp_h276 () T1071)
(declare-fun |var__temp_h'278| () T1071)
(declare-fun var__temp_v277 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h276 res) v) (= v |20|))
               (= (sel var__temp_h276 res) 7)))
      (a!2 (and (= (sel |var__temp_h'278| res) var__temp_v277)
                (= (sel |var__temp_h'278| res) (+ (sel var__temp_h276 res) 3)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h276 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************72
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i143 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i143, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v275:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h280 --->  Ty_heap  
 var__temp_v281 --->  Ty_int  
 var__temp_h'282 --->  Ty_heap  
 var__temp_v_err283 --->  error  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h280, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h280, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h280, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'282, res ) ==(var__temp_v281) AND 
 	 Rel (sel)( , var__temp_h'282, res ) ==((sel)( , var__temp_h280, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i143 T1088)
(declare-const var_h142 T1088)
(declare-const v Int)
(declare-const var_h_i91 T1088)
(declare-const var_h90 T1088)
(declare-const v Int)
(declare-const var_h_i43 T1088)
(declare-const var_h42 T1088)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h280 T1088)
(declare-const var__temp_v281 Int)
(declare-const |var__temp_h'282| T1088)
(declare-const var__temp_v_err283 T1089)
(declare-const var_h142 T1088)
(declare-const var_h90 T1088)
(declare-const var_h42 T1088)
(declare-const err T1102)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1088)
(declare-fun sel (T1088 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T1088)
(declare-fun var_h42 () T1088)
(declare-fun |20| () Int)
(declare-fun var__temp_h280 () T1088)
(declare-fun |var__temp_h'282| () T1088)
(declare-fun var__temp_v281 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h280 res) v) (= v |20|))
               (= (sel var__temp_h280 res) 7)))
      (a!2 (and (= (sel |var__temp_h'282| res) var__temp_v281)
                (= (sel |var__temp_h'282| res) (+ (sel var__temp_h280 res) 5)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h280 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************73
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i143 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i143, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v275:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h284 --->  Ty_heap  
 var__temp_v285 --->  Ty_int  
 var__temp_h'286 --->  Ty_heap  
 var__temp_v_err287 --->  error  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h284, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h284, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h284, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'286, res ) ==(var__temp_v285) AND 
 	 Base var__temp_v285 = 5 => 
 	 True
 
VC_END(declare-const var_h_i143 T1105)
(declare-const var_h142 T1105)
(declare-const v Int)
(declare-const var_h_i91 T1105)
(declare-const var_h90 T1105)
(declare-const v Int)
(declare-const var_h_i43 T1105)
(declare-const var_h42 T1105)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h284 T1105)
(declare-const var__temp_v285 Int)
(declare-const |var__temp_h'286| T1105)
(declare-const var__temp_v_err287 T1106)
(declare-const var_h142 T1105)
(declare-const var_h90 T1105)
(declare-const var_h42 T1105)
(declare-const err T1119)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T1105)
(declare-fun sel (T1105 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T1105)
(declare-fun var_h42 () T1105)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_v285 () Int)
(declare-fun |var__temp_h'286| () T1105)
(declare-fun var__temp_h284 () T1105)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h284 res) v) (= v |20|))
               (= (sel var__temp_h284 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'286| res) var__temp_v285)
                    (= var__temp_v285 |5|))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h284 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************74
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i143 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i143, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v275:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i143 --->  Ty_heap  
 var_h142 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h288 --->  Ty_heap  
 var__temp_v289 --->  Ty_int  
 var__temp_h'290 --->  Ty_heap  
 var__temp_v_err291 --->  error  
 var_h142 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h288, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h288, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h288, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'290, res ) ==(var__temp_v289) AND 
 	 Rel (sel)( , var__temp_h'290, res ) ==((sel)( , var__temp_h288, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i143 T1122)
(declare-const var_h142 T1122)
(declare-const v Int)
(declare-const var_h_i91 T1122)
(declare-const var_h90 T1122)
(declare-const v Int)
(declare-const var_h_i43 T1122)
(declare-const var_h42 T1122)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h288 T1122)
(declare-const var__temp_v289 Int)
(declare-const |var__temp_h'290| T1122)
(declare-const var__temp_v_err291 T1123)
(declare-const var_h142 T1122)
(declare-const var_h90 T1122)
(declare-const var_h42 T1122)
(declare-const err T1136)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1122)
(declare-fun sel (T1122 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T1122)
(declare-fun var_h42 () T1122)
(declare-fun |20| () Int)
(declare-fun var__temp_h288 () T1122)
(declare-fun |var__temp_h'290| () T1122)
(declare-fun var__temp_v289 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h288 res) v) (= v |20|))
               (= (sel var__temp_h288 res) 5)))
      (a!2 (and (= (sel |var__temp_h'290| res) var__temp_v289)
                (= (sel |var__temp_h'290| res) (+ (sel var__temp_h288 res) 2)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h288 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************75
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 	 --c3'	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i91 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i91, res ) ==(v)
 	 , (sel)( , var_h_i91, res ) ==((sel)( , var_h90, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v292:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
foo
bar
 *********************Enumeration Iteration*****************76
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i91 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i91, res ) ==(v)
 	 , (sel)( , var_h_i91, res ) ==((sel)( , var_h90, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v292:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h293 --->  Ty_heap  
 var__temp_v294 --->  Ty_int  
 var__temp_h'295 --->  Ty_heap  
 var__temp_v_err296 --->  error  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h293, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h293, res ) ==((sel)( , var_h90, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h293, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h293, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'295, res ) ==(var__temp_v294) AND 
 	 Rel (sel)( , var__temp_h'295, res ) ==((sel)( , var__temp_h293, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i91 T1139)
(declare-const var_h90 T1139)
(declare-const v Int)
(declare-const var_h_i43 T1139)
(declare-const var_h42 T1139)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h293 T1139)
(declare-const var__temp_v294 Int)
(declare-const |var__temp_h'295| T1139)
(declare-const var__temp_v_err296 T1140)
(declare-const var_h90 T1139)
(declare-const var_h42 T1139)
(declare-const err T1153)

solver 
 (declare-sort T1139)
(declare-fun sel (T1139 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T1139)
(declare-fun var_h42 () T1139)
(declare-fun var__temp_h293 () T1139)
(declare-fun |var__temp_h'295| () T1139)
(declare-fun var__temp_v294 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h293 res) v)
                (= (sel var__temp_h293 res) (+ (sel var_h90 res) 5))))
      (a!2 (and (= (sel |var__temp_h'295| res) var__temp_v294)
                (= (sel |var__temp_h'295| res) (+ (sel var__temp_h293 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h293 res) 7))
                (=> (= (sel var__temp_h293 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************77
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i91 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i91, res ) ==(v)
 	 , (sel)( , var_h_i91, res ) ==((sel)( , var_h90, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v292:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h297 --->  Ty_heap  
 var__temp_v298 --->  Ty_int  
 var__temp_h'299 --->  Ty_heap  
 var__temp_v_err300 --->  error  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h297, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h297, res ) ==((sel)( , var_h90, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h297, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h297, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'299, res ) ==(var__temp_v298) AND 
 	 Rel (sel)( , var__temp_h'299, res ) ==((sel)( , var__temp_h297, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i91 T1156)
(declare-const var_h90 T1156)
(declare-const v Int)
(declare-const var_h_i43 T1156)
(declare-const var_h42 T1156)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h297 T1156)
(declare-const var__temp_v298 Int)
(declare-const |var__temp_h'299| T1156)
(declare-const var__temp_v_err300 T1157)
(declare-const var_h90 T1156)
(declare-const var_h42 T1156)
(declare-const err T1170)

solver 
 (declare-sort T1156)
(declare-fun sel (T1156 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T1156)
(declare-fun var_h42 () T1156)
(declare-fun var__temp_h297 () T1156)
(declare-fun |var__temp_h'299| () T1156)
(declare-fun var__temp_v298 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h297 res) v)
                (= (sel var__temp_h297 res) (+ (sel var_h90 res) 5))))
      (a!2 (and (= (sel |var__temp_h'299| res) var__temp_v298)
                (= (sel |var__temp_h'299| res) (+ (sel var__temp_h297 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h297 res) 7))
                (=> (= (sel var__temp_h297 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************78
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h, res ) ==(sel)( , h, res ) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i91 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i91, res ) ==(v)
 	 , (sel)( , var_h_i91, res ) ==((sel)( , var_h90, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v292:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h, res ) ==(sel)( , h, res ) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h301 --->  Ty_heap  
 var__temp_v302 --->  Ty_int  
 var__temp_h'303 --->  Ty_heap  
 var__temp_v_err304 --->  error  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h301, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h301, res ) ==((sel)( , var_h90, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h301, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h301, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'303, res ) ==(var__temp_v302) AND 
 	 Rel (sel)( , var__temp_h301, res ) ==(sel)( , var__temp_h301, res ) => 
 	 True
 
VC_END(declare-const var_h_i91 T1173)
(declare-const var_h90 T1173)
(declare-const v Int)
(declare-const var_h_i43 T1173)
(declare-const var_h42 T1173)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h301 T1173)
(declare-const var__temp_v302 Int)
(declare-const |var__temp_h'303| T1173)
(declare-const var__temp_v_err304 T1174)
(declare-const var_h90 T1173)
(declare-const var_h42 T1173)
(declare-const err T1187)

solver 
 (declare-sort T1173)
(declare-fun sel (T1173 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T1173)
(declare-fun var_h42 () T1173)
(declare-fun var__temp_h301 () T1173)
(declare-fun var__temp_v302 () Int)
(declare-fun |var__temp_h'303| () T1173)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h301 res) v)
                (= (sel var__temp_h301 res) (+ (sel var_h90 res) 5))))
      (a!3 (=> (and (= (sel |var__temp_h'303| res) var__temp_v302)
                    (= (sel var__temp_h301 res) (sel var__temp_h301 res)))
               true)))
(let ((a!2 (=> a!1 (not (> (sel var__temp_h301 res) 20))))
      (a!4 (=> (not (> (sel var__temp_h301 res) 20)) a!3)))
  (not (and a!2 a!4)))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************79
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i91 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i91, res ) ==(v)
 	 , (sel)( , var_h_i91, res ) ==((sel)( , var_h90, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v292:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h305 --->  Ty_heap  
 var__temp_v306 --->  Ty_int  
 var__temp_h'307 --->  Ty_heap  
 var__temp_v_err308 --->  error  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h305, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h305, res ) ==((sel)( , var_h90, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h305, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h305, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'307, res ) ==(var__temp_v306) AND 
 	 Rel (sel)( , var__temp_h'307, res ) ==((sel)( , var__temp_h305, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i91 T1190)
(declare-const var_h90 T1190)
(declare-const v Int)
(declare-const var_h_i43 T1190)
(declare-const var_h42 T1190)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h305 T1190)
(declare-const var__temp_v306 Int)
(declare-const |var__temp_h'307| T1190)
(declare-const var__temp_v_err308 T1191)
(declare-const var_h90 T1190)
(declare-const var_h42 T1190)
(declare-const err T1204)

solver 
 (declare-sort T1190)
(declare-fun sel (T1190 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T1190)
(declare-fun var_h42 () T1190)
(declare-fun var__temp_h305 () T1190)
(declare-fun |var__temp_h'307| () T1190)
(declare-fun var__temp_v306 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h305 res) v)
                (= (sel var__temp_h305 res) (+ (sel var_h90 res) 5))))
      (a!2 (and (= (sel |var__temp_h'307| res) var__temp_v306)
                (= (sel |var__temp_h'307| res) (+ (sel var__temp_h305 res) 10)))))
(let ((a!3 (and (=> a!1 (> (sel var__temp_h305 res) 4))
                (=> (> (sel var__temp_h305 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************80
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i91 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i91, res ) ==(v)
 	 , (sel)( , var_h_i91, res ) ==((sel)( , var_h90, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v292:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h309 --->  Ty_heap  
 var__temp_v310 --->  Ty_int  
 var__temp_h'311 --->  Ty_heap  
 var__temp_v_err312 --->  error  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h309, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h309, res ) ==((sel)( , var_h90, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h309, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h309, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'311, res ) ==(var__temp_v310) AND 
 	 Base var__temp_v310 = 5 => 
 	 True
 
VC_END(declare-const var_h_i91 T1207)
(declare-const var_h90 T1207)
(declare-const v Int)
(declare-const var_h_i43 T1207)
(declare-const var_h42 T1207)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h309 T1207)
(declare-const var__temp_v310 Int)
(declare-const |var__temp_h'311| T1207)
(declare-const var__temp_v_err312 T1208)
(declare-const var_h90 T1207)
(declare-const var_h42 T1207)
(declare-const err T1221)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1207)
(declare-fun sel (T1207 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T1207)
(declare-fun var_h42 () T1207)
(declare-fun |5| () Int)
(declare-fun var__temp_v310 () Int)
(declare-fun |var__temp_h'311| () T1207)
(declare-fun var__temp_h309 () T1207)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h309 res) v)
                (= (sel var__temp_h309 res) (+ (sel var_h90 res) 5))))
      (a!2 (=> (and (= (sel |var__temp_h'311| res) var__temp_v310)
                    (= var__temp_v310 |5|))
               true)))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h309 res) 0))
                (=> (= (sel var__temp_h309 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************81
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i91 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i91, res ) ==(v)
 	 , (sel)( , var_h_i91, res ) ==((sel)( , var_h90, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v292:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i91 --->  Ty_heap  
 var_h90 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h313 --->  Ty_heap  
 var__temp_v314 --->  Ty_int  
 var__temp_h'315 --->  Ty_heap  
 var__temp_v_err316 --->  error  
 var_h90 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h90, res ) > (30) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h313, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h313, res ) ==((sel)( , var_h90, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h313, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h313, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'315, res ) ==(var__temp_v314) AND 
 	 Rel (sel)( , var__temp_h'315, res ) ==((sel)( , var__temp_h313, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i91 T1224)
(declare-const var_h90 T1224)
(declare-const v Int)
(declare-const var_h_i43 T1224)
(declare-const var_h42 T1224)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h313 T1224)
(declare-const var__temp_v314 Int)
(declare-const |var__temp_h'315| T1224)
(declare-const var__temp_v_err316 T1225)
(declare-const var_h90 T1224)
(declare-const var_h42 T1224)
(declare-const err T1238)

solver 
 (declare-sort T1224)
(declare-fun sel (T1224 Int) Int)
(declare-fun res () Int)
(declare-fun var_h90 () T1224)
(declare-fun var_h42 () T1224)
(declare-fun var__temp_h313 () T1224)
(declare-fun |var__temp_h'315| () T1224)
(declare-fun var__temp_v314 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h90 res) 30)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h313 res) v)
                (= (sel var__temp_h313 res) (+ (sel var_h90 res) 5))))
      (a!2 (and (= (sel |var__temp_h'315| res) var__temp_v314)
                (= (sel |var__temp_h'315| res) (+ (sel var__temp_h313 res) 2)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h313 res) 5))
                (=> (= (sel var__temp_h313 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************82
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo'
PARTIAL PATH
SUB 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i43 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i43, res ) ==(v)
 	 , (sel)( , var_h_i43, res ) ==((sel)( , var_h42, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v317:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************83
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i43 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i43, res ) ==(v)
 	 , (sel)( , var_h_i43, res ) ==((sel)( , var_h42, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v317:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h318 --->  Ty_heap  
 var__temp_v319 --->  Ty_int  
 var__temp_h'320 --->  Ty_heap  
 var__temp_v_err321 --->  error  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h318, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h318, res ) ==((sel)( , var_h42, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h318, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h318, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'320, res ) ==(var__temp_v319) AND 
 	 Rel (sel)( , var__temp_h'320, res ) ==((sel)( , var__temp_h318, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i43 T1241)
(declare-const var_h42 T1241)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h318 T1241)
(declare-const var__temp_v319 Int)
(declare-const |var__temp_h'320| T1241)
(declare-const var__temp_v_err321 T1242)
(declare-const var_h42 T1241)
(declare-const err T1255)

solver 
 (declare-sort T1241)
(declare-fun sel (T1241 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T1241)
(declare-fun var__temp_h318 () T1241)
(declare-fun |var__temp_h'320| () T1241)
(declare-fun var__temp_v319 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h318 res) v)
                (= (sel var__temp_h318 res) (+ (sel var_h42 res) 3))))
      (a!2 (and (= (sel |var__temp_h'320| res) var__temp_v319)
                (= (sel |var__temp_h'320| res) (+ (sel var__temp_h318 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h318 res) 7))
                (=> (= (sel var__temp_h318 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************84
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i43 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i43, res ) ==(v)
 	 , (sel)( , var_h_i43, res ) ==((sel)( , var_h42, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v317:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h322 --->  Ty_heap  
 var__temp_v323 --->  Ty_int  
 var__temp_h'324 --->  Ty_heap  
 var__temp_v_err325 --->  error  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h322, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h322, res ) ==((sel)( , var_h42, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h322, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h322, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'324, res ) ==(var__temp_v323) AND 
 	 Rel (sel)( , var__temp_h'324, res ) ==((sel)( , var__temp_h322, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i43 T1258)
(declare-const var_h42 T1258)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h322 T1258)
(declare-const var__temp_v323 Int)
(declare-const |var__temp_h'324| T1258)
(declare-const var__temp_v_err325 T1259)
(declare-const var_h42 T1258)
(declare-const err T1272)

solver 
 (declare-sort T1258)
(declare-fun sel (T1258 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T1258)
(declare-fun var__temp_h322 () T1258)
(declare-fun |var__temp_h'324| () T1258)
(declare-fun var__temp_v323 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h322 res) v)
                (= (sel var__temp_h322 res) (+ (sel var_h42 res) 3))))
      (a!2 (and (= (sel |var__temp_h'324| res) var__temp_v323)
                (= (sel |var__temp_h'324| res) (+ (sel var__temp_h322 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h322 res) 7))
                (=> (= (sel var__temp_h322 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************85
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h, res ) ==(sel)( , h, res ) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i43 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i43, res ) ==(v)
 	 , (sel)( , var_h_i43, res ) ==((sel)( , var_h42, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v317:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h, res ) ==(sel)( , h, res ) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h326 --->  Ty_heap  
 var__temp_v327 --->  Ty_int  
 var__temp_h'328 --->  Ty_heap  
 var__temp_v_err329 --->  error  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h326, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h326, res ) ==((sel)( , var_h42, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h326, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h326, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'328, res ) ==(var__temp_v327) AND 
 	 Rel (sel)( , var__temp_h326, res ) ==(sel)( , var__temp_h326, res ) => 
 	 True
 
VC_END(declare-const var_h_i43 T1275)
(declare-const var_h42 T1275)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h326 T1275)
(declare-const var__temp_v327 Int)
(declare-const |var__temp_h'328| T1275)
(declare-const var__temp_v_err329 T1276)
(declare-const var_h42 T1275)
(declare-const err T1289)

solver 
 (declare-sort T1275)
(declare-fun sel (T1275 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T1275)
(declare-fun var__temp_h326 () T1275)
(declare-fun var__temp_v327 () Int)
(declare-fun |var__temp_h'328| () T1275)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h326 res) v)
                (= (sel var__temp_h326 res) (+ (sel var_h42 res) 3))))
      (a!3 (=> (and (= (sel |var__temp_h'328| res) var__temp_v327)
                    (= (sel var__temp_h326 res) (sel var__temp_h326 res)))
               true)))
(let ((a!2 (=> a!1 (not (> (sel var__temp_h326 res) 20))))
      (a!4 (=> (not (> (sel var__temp_h326 res) 20)) a!3)))
  (not (and a!2 a!4)))))

***************Selection Successful************c2'
PARTIAL PATH NEW
NEW 	 --c3'	 --c2'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i331 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) >c  } 
 } 
 
                                                RET :  Base {var_v332:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i331 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************86
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) >c  } 
 } 
 
                                                RET :  Base {var_v332:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i331 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h333 --->  Ty_heap  
 var__temp_v334 --->  Ty_int  
 var__temp_h'335 --->  Ty_heap  
 var__temp_v_err336 --->  error  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h333, res ) ==(v) AND 
 	 Rel (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) => 
 	 Rel (sel)( , var__temp_h333, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h333, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'335, res ) ==(var__temp_v334) AND 
 	 Rel (sel)( , var__temp_h'335, res ) ==((sel)( , var__temp_h333, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'335, res ) ==(var__temp_v334) AND 
 	 Rel (sel)( , var__temp_h'335, res ) ==(10)
 
VC_END(declare-const var_h_i331 T1292)
(declare-const var_h330 T1292)
(declare-const v Int)
(declare-const var_h_i43 T1292)
(declare-const var_h42 T1292)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h333 T1292)
(declare-const var__temp_v334 Int)
(declare-const |var__temp_h'335| T1292)
(declare-const var__temp_v_err336 T1293)
(declare-const var_h330 T1292)
(declare-const var_h42 T1292)
(declare-const err T1306)

solver 
 (declare-sort T1292)
(declare-fun sel (T1292 Int) Int)
(declare-fun res () Int)
(declare-fun var_h330 () T1292)
(declare-fun var_h42 () T1292)
(declare-fun |var__temp_h'335| () T1292)
(declare-fun var__temp_v334 () Int)
(declare-fun var__temp_h333 () T1292)
(declare-fun v () Int)
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h333 res) v)
                    (= (sel var_h330 res) (sel var_h330 res)))
               (= (sel var__temp_h333 res) 7)))
      (a!2 (and (= (sel |var__temp_h'335| res) var__temp_v334)
                (= (sel |var__temp_h'335| res) (+ (sel var__temp_h333 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'335| res) var__temp_v334)
                    (= (sel |var__temp_h'335| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h333 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************87
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) >c  } 
 } 
 
                                                RET :  Base {var_v332:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i331 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h337 --->  Ty_heap  
 var__temp_v338 --->  Ty_int  
 var__temp_h'339 --->  Ty_heap  
 var__temp_v_err340 --->  error  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h337, res ) ==(v) AND 
 	 Rel (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) => 
 	 Rel (sel)( , var__temp_h337, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h337, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'339, res ) ==(var__temp_v338) AND 
 	 Rel (sel)( , var__temp_h'339, res ) ==((sel)( , var__temp_h337, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'339, res ) ==(var__temp_v338) AND 
 	 Rel (sel)( , var__temp_h'339, res ) ==(10)
 
VC_END(declare-const var_h_i331 T1309)
(declare-const var_h330 T1309)
(declare-const v Int)
(declare-const var_h_i43 T1309)
(declare-const var_h42 T1309)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h337 T1309)
(declare-const var__temp_v338 Int)
(declare-const |var__temp_h'339| T1309)
(declare-const var__temp_v_err340 T1310)
(declare-const var_h330 T1309)
(declare-const var_h42 T1309)
(declare-const err T1323)

solver 
 (declare-sort T1309)
(declare-fun sel (T1309 Int) Int)
(declare-fun res () Int)
(declare-fun var_h330 () T1309)
(declare-fun var_h42 () T1309)
(declare-fun |var__temp_h'339| () T1309)
(declare-fun var__temp_v338 () Int)
(declare-fun var__temp_h337 () T1309)
(declare-fun v () Int)
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h337 res) v)
                    (= (sel var_h330 res) (sel var_h330 res)))
               (= (sel var__temp_h337 res) 7)))
      (a!2 (and (= (sel |var__temp_h'339| res) var__temp_v338)
                (= (sel |var__temp_h'339| res) (+ (sel var__temp_h337 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'339| res) var__temp_v338)
                    (= (sel |var__temp_h'339| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h337 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************88
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) >c  } 
 } 
 
                                                RET :  Base {var_v332:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i331 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h341 --->  Ty_heap  
 var__temp_v342 --->  Ty_int  
 var__temp_h'343 --->  Ty_heap  
 var__temp_v_err344 --->  error  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h341, res ) ==(v) AND 
 	 Rel (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) => 
 	 Rel (sel)( , var__temp_h341, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h341, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'343, res ) ==(var__temp_v342) AND 
 	 Rel (sel)( , var__temp_h'343, res ) ==((sel)( , var__temp_h341, res ) + (10)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'343, res ) ==(var__temp_v342) AND 
 	 Rel (sel)( , var__temp_h'343, res ) ==(10)
 
VC_END(declare-const var_h_i331 T1326)
(declare-const var_h330 T1326)
(declare-const v Int)
(declare-const var_h_i43 T1326)
(declare-const var_h42 T1326)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h341 T1326)
(declare-const var__temp_v342 Int)
(declare-const |var__temp_h'343| T1326)
(declare-const var__temp_v_err344 T1327)
(declare-const var_h330 T1326)
(declare-const var_h42 T1326)
(declare-const err T1340)

solver 
 (declare-sort T1326)
(declare-fun sel (T1326 Int) Int)
(declare-fun res () Int)
(declare-fun var_h330 () T1326)
(declare-fun var_h42 () T1326)
(declare-fun |var__temp_h'343| () T1326)
(declare-fun var__temp_v342 () Int)
(declare-fun var__temp_h341 () T1326)
(declare-fun v () Int)
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h341 res) v)
                    (= (sel var_h330 res) (sel var_h330 res)))
               (> (sel var__temp_h341 res) 4)))
      (a!2 (and (= (sel |var__temp_h'343| res) var__temp_v342)
                (= (sel |var__temp_h'343| res) (+ (sel var__temp_h341 res) 10)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'343| res) var__temp_v342)
                    (= (sel |var__temp_h'343| res) 10)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h341 res) 4) a!3))))
  (not a!4)))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************89
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) >c  } 
 } 
 
                                                RET :  Base {var_v332:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i331 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h345 --->  Ty_heap  
 var__temp_v346 --->  Ty_int  
 var__temp_h'347 --->  Ty_heap  
 var__temp_v_err348 --->  error  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h345, res ) ==(v) AND 
 	 Rel (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'347, res ) ==(var__temp_v346) AND 
 	 Base var__temp_v346 = 20 => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'347, res ) ==(var__temp_v346) AND 
 	 Rel (sel)( , var__temp_h'347, res ) ==(10)
 
VC_END(declare-const var_h_i331 T1343)
(declare-const var_h330 T1343)
(declare-const v Int)
(declare-const var_h_i43 T1343)
(declare-const var_h42 T1343)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h345 T1343)
(declare-const var__temp_v346 Int)
(declare-const |var__temp_h'347| T1343)
(declare-const var__temp_v_err348 T1344)
(declare-const var_h330 T1343)
(declare-const var_h42 T1343)
(declare-const err T1357)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1343)
(declare-fun sel (T1343 Int) Int)
(declare-fun res () Int)
(declare-fun var_h330 () T1343)
(declare-fun var_h42 () T1343)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'347| () T1343)
(declare-fun var__temp_v346 () Int)
(declare-fun v () Int)
(declare-fun var__temp_h345 () T1343)
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h345 res) v)
                    (= (sel var_h330 res) (sel var_h330 res)))
               true))
      (a!2 (=> (and (= (sel |var__temp_h'347| res) var__temp_v346)
                    (= var__temp_v346 |20|))
               (and (= (sel |var__temp_h'347| res) var__temp_v346)
                    (= (sel |var__temp_h'347| res) 10)))))
  (not (and a!1 (=> true a!2)))))

***************Selection Failed************foo'
 *********************Enumeration Iteration*****************90
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) >c  } 
 } 
 
                                                RET :  Base {var_v332:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i331 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h349 --->  Ty_heap  
 var__temp_v350 --->  Ty_int  
 var__temp_h'351 --->  Ty_heap  
 var__temp_v_err352 --->  error  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h349, res ) ==(v) AND 
 	 Rel (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) => 
 	 Rel (sel)( , var__temp_h349, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h349, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'351, res ) ==(var__temp_v350) AND 
 	 Base var__temp_v350 = 5 => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'351, res ) ==(var__temp_v350) AND 
 	 Rel (sel)( , var__temp_h'351, res ) ==(10)
 
VC_END(declare-const var_h_i331 T1360)
(declare-const var_h330 T1360)
(declare-const v Int)
(declare-const var_h_i43 T1360)
(declare-const var_h42 T1360)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h349 T1360)
(declare-const var__temp_v350 Int)
(declare-const |var__temp_h'351| T1360)
(declare-const var__temp_v_err352 T1361)
(declare-const var_h330 T1360)
(declare-const var_h42 T1360)
(declare-const err T1374)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1360)
(declare-fun sel (T1360 Int) Int)
(declare-fun res () Int)
(declare-fun var_h330 () T1360)
(declare-fun var_h42 () T1360)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'351| () T1360)
(declare-fun var__temp_v350 () Int)
(declare-fun var__temp_h349 () T1360)
(declare-fun v () Int)
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h349 res) v)
                    (= (sel var_h330 res) (sel var_h330 res)))
               (= (sel var__temp_h349 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'351| res) var__temp_v350)
                    (= var__temp_v350 |5|))
               (and (= (sel |var__temp_h'351| res) var__temp_v350)
                    (= (sel |var__temp_h'351| res) 10)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h349 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************91
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) >c  } 
 } 
 
                                                RET :  Base {var_v332:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i331 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h353 --->  Ty_heap  
 var__temp_v354 --->  Ty_int  
 var__temp_h'355 --->  Ty_heap  
 var__temp_v_err356 --->  error  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h353, res ) ==(v) AND 
 	 Rel (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) => 
 	 Rel (sel)( , var__temp_h353, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h353, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'355, res ) ==(var__temp_v354) AND 
 	 Rel (sel)( , var__temp_h'355, res ) ==((sel)( , var__temp_h353, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'355, res ) ==(var__temp_v354) AND 
 	 Rel (sel)( , var__temp_h'355, res ) ==(10)
 
VC_END(declare-const var_h_i331 T1377)
(declare-const var_h330 T1377)
(declare-const v Int)
(declare-const var_h_i43 T1377)
(declare-const var_h42 T1377)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h353 T1377)
(declare-const var__temp_v354 Int)
(declare-const |var__temp_h'355| T1377)
(declare-const var__temp_v_err356 T1378)
(declare-const var_h330 T1377)
(declare-const var_h42 T1377)
(declare-const err T1391)

solver 
 (declare-sort T1377)
(declare-fun sel (T1377 Int) Int)
(declare-fun res () Int)
(declare-fun var_h330 () T1377)
(declare-fun var_h42 () T1377)
(declare-fun |var__temp_h'355| () T1377)
(declare-fun var__temp_v354 () Int)
(declare-fun var__temp_h353 () T1377)
(declare-fun v () Int)
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h353 res) v)
                    (= (sel var_h330 res) (sel var_h330 res)))
               (= (sel var__temp_h353 res) 5)))
      (a!2 (and (= (sel |var__temp_h'355| res) var__temp_v354)
                (= (sel |var__temp_h'355| res) (+ (sel var__temp_h353 res) 2)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'355| res) var__temp_v354)
                    (= (sel |var__temp_h'355| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h353 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************92
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v332:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v332:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) >c  } 
 } 
 
                                                RET :  Base {var_v357:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************93
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) >c  } 
 } 
 
                                                RET :  Base {var_v357:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h358 --->  Ty_heap  
 var__temp_v359 --->  Ty_int  
 var__temp_h'360 --->  Ty_heap  
 var__temp_v_err361 --->  error  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h358, res ) ==(v) AND 
 	 Rel (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) => 
 	 Rel (sel)( , var__temp_h358, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h358, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'360, res ) ==(var__temp_v359) AND 
 	 Rel (sel)( , var__temp_h'360, res ) ==((sel)( , var__temp_h358, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i331 T1394)
(declare-const var_h330 T1394)
(declare-const v Int)
(declare-const var_h_i43 T1394)
(declare-const var_h42 T1394)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h358 T1394)
(declare-const var__temp_v359 Int)
(declare-const |var__temp_h'360| T1394)
(declare-const var__temp_v_err361 T1395)
(declare-const var_h330 T1394)
(declare-const var_h42 T1394)
(declare-const err T1408)

solver 
 (declare-sort T1394)
(declare-fun sel (T1394 Int) Int)
(declare-fun res () Int)
(declare-fun var_h330 () T1394)
(declare-fun var_h42 () T1394)
(declare-fun var__temp_h358 () T1394)
(declare-fun |var__temp_h'360| () T1394)
(declare-fun var__temp_v359 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h358 res) v)
                    (= (sel var_h330 res) (sel var_h330 res)))
               (= (sel var__temp_h358 res) 7)))
      (a!2 (and (= (sel |var__temp_h'360| res) var__temp_v359)
                (= (sel |var__temp_h'360| res) (+ (sel var__temp_h358 res) 3)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h358 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************94
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) >c  } 
 } 
 
                                                RET :  Base {var_v357:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h362 --->  Ty_heap  
 var__temp_v363 --->  Ty_int  
 var__temp_h'364 --->  Ty_heap  
 var__temp_v_err365 --->  error  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h362, res ) ==(v) AND 
 	 Rel (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) => 
 	 Rel (sel)( , var__temp_h362, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h362, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'364, res ) ==(var__temp_v363) AND 
 	 Rel (sel)( , var__temp_h'364, res ) ==((sel)( , var__temp_h362, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i331 T1411)
(declare-const var_h330 T1411)
(declare-const v Int)
(declare-const var_h_i43 T1411)
(declare-const var_h42 T1411)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h362 T1411)
(declare-const var__temp_v363 Int)
(declare-const |var__temp_h'364| T1411)
(declare-const var__temp_v_err365 T1412)
(declare-const var_h330 T1411)
(declare-const var_h42 T1411)
(declare-const err T1425)

solver 
 (declare-sort T1411)
(declare-fun sel (T1411 Int) Int)
(declare-fun res () Int)
(declare-fun var_h330 () T1411)
(declare-fun var_h42 () T1411)
(declare-fun var__temp_h362 () T1411)
(declare-fun |var__temp_h'364| () T1411)
(declare-fun var__temp_v363 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h362 res) v)
                    (= (sel var_h330 res) (sel var_h330 res)))
               (= (sel var__temp_h362 res) 7)))
      (a!2 (and (= (sel |var__temp_h'364| res) var__temp_v363)
                (= (sel |var__temp_h'364| res) (+ (sel var__temp_h362 res) 5)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h362 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************95
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) >c  } 
 } 
 
                                                RET :  Base {var_v357:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h366 --->  Ty_heap  
 var__temp_v367 --->  Ty_int  
 var__temp_h'368 --->  Ty_heap  
 var__temp_v_err369 --->  error  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h366, res ) ==(v) AND 
 	 Rel (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) => 
 	 Rel (sel)( , var__temp_h366, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h366, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'368, res ) ==(var__temp_v367) AND 
 	 Rel (sel)( , var__temp_h'368, res ) ==((sel)( , var__temp_h366, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i331 T1428)
(declare-const var_h330 T1428)
(declare-const v Int)
(declare-const var_h_i43 T1428)
(declare-const var_h42 T1428)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h366 T1428)
(declare-const var__temp_v367 Int)
(declare-const |var__temp_h'368| T1428)
(declare-const var__temp_v_err369 T1429)
(declare-const var_h330 T1428)
(declare-const var_h42 T1428)
(declare-const err T1442)

solver 
 (declare-sort T1428)
(declare-fun sel (T1428 Int) Int)
(declare-fun res () Int)
(declare-fun var_h330 () T1428)
(declare-fun var_h42 () T1428)
(declare-fun var__temp_h366 () T1428)
(declare-fun |var__temp_h'368| () T1428)
(declare-fun var__temp_v367 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h366 res) v)
                    (= (sel var_h330 res) (sel var_h330 res)))
               (> (sel var__temp_h366 res) 4)))
      (a!2 (and (= (sel |var__temp_h'368| res) var__temp_v367)
                (= (sel |var__temp_h'368| res) (+ (sel var__temp_h366 res) 10)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h366 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************96
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) >c  } 
 } 
 
                                                RET :  Base {var_v357:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h370 --->  Ty_heap  
 var__temp_v371 --->  Ty_int  
 var__temp_h'372 --->  Ty_heap  
 var__temp_v_err373 --->  error  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h370, res ) ==(v) AND 
 	 Rel (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'372, res ) ==(var__temp_v371) AND 
 	 Base var__temp_v371 = 20 => 
 	 True
 
VC_END(declare-const var_h_i331 T1445)
(declare-const var_h330 T1445)
(declare-const v Int)
(declare-const var_h_i43 T1445)
(declare-const var_h42 T1445)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h370 T1445)
(declare-const var__temp_v371 Int)
(declare-const |var__temp_h'372| T1445)
(declare-const var__temp_v_err373 T1446)
(declare-const var_h330 T1445)
(declare-const var_h42 T1445)
(declare-const err T1459)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1445)
(declare-fun sel (T1445 Int) Int)
(declare-fun res () Int)
(declare-fun var_h330 () T1445)
(declare-fun var_h42 () T1445)
(declare-fun |20| () Int)
(declare-fun var__temp_v371 () Int)
(declare-fun |var__temp_h'372| () T1445)
(declare-fun v () Int)
(declare-fun var__temp_h370 () T1445)
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h370 res) v)
                    (= (sel var_h330 res) (sel var_h330 res)))
               true))
      (a!2 (=> (and (= (sel |var__temp_h'372| res) var__temp_v371)
                    (= var__temp_v371 |20|))
               true)))
  (not (and a!1 (=> true a!2)))))

***************Selection Successful************foo'
PARTIAL PATH NEW
NEW 	 --c3'	 --c2'	 --foo'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i375 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i375 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i375, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v376:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i375 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************97
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i375 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i375, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v376:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i375 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i375 --->  Ty_heap  
 var_h374 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h377 --->  Ty_heap  
 var__temp_v378 --->  Ty_int  
 var__temp_h'379 --->  Ty_heap  
 var__temp_v_err380 --->  error  
 var_h374 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h377, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h377, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h377, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'379, res ) ==(var__temp_v378) AND 
 	 Rel (sel)( , var__temp_h'379, res ) ==((sel)( , var__temp_h377, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'379, res ) ==(var__temp_v378) AND 
 	 Rel (sel)( , var__temp_h'379, res ) ==(10)
 
VC_END(declare-const var_h_i375 T1462)
(declare-const var_h374 T1462)
(declare-const v Int)
(declare-const var_h_i331 T1462)
(declare-const var_h330 T1462)
(declare-const v Int)
(declare-const var_h_i43 T1462)
(declare-const var_h42 T1462)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h377 T1462)
(declare-const var__temp_v378 Int)
(declare-const |var__temp_h'379| T1462)
(declare-const var__temp_v_err380 T1463)
(declare-const var_h374 T1462)
(declare-const var_h330 T1462)
(declare-const var_h42 T1462)
(declare-const err T1476)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1462)
(declare-fun sel (T1462 Int) Int)
(declare-fun res () Int)
(declare-fun var_h330 () T1462)
(declare-fun var_h42 () T1462)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'379| () T1462)
(declare-fun var__temp_v378 () Int)
(declare-fun var__temp_h377 () T1462)
(declare-fun v () Int)
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h377 res) v) (= v |20|))
               (= (sel var__temp_h377 res) 7)))
      (a!2 (and (= (sel |var__temp_h'379| res) var__temp_v378)
                (= (sel |var__temp_h'379| res) (+ (sel var__temp_h377 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'379| res) var__temp_v378)
                    (= (sel |var__temp_h'379| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h377 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************98
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i375 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i375, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v376:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i375 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i375 --->  Ty_heap  
 var_h374 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h381 --->  Ty_heap  
 var__temp_v382 --->  Ty_int  
 var__temp_h'383 --->  Ty_heap  
 var__temp_v_err384 --->  error  
 var_h374 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h381, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h381, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h381, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'383, res ) ==(var__temp_v382) AND 
 	 Rel (sel)( , var__temp_h'383, res ) ==((sel)( , var__temp_h381, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'383, res ) ==(var__temp_v382) AND 
 	 Rel (sel)( , var__temp_h'383, res ) ==(10)
 
VC_END(declare-const var_h_i375 T1479)
(declare-const var_h374 T1479)
(declare-const v Int)
(declare-const var_h_i331 T1479)
(declare-const var_h330 T1479)
(declare-const v Int)
(declare-const var_h_i43 T1479)
(declare-const var_h42 T1479)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h381 T1479)
(declare-const var__temp_v382 Int)
(declare-const |var__temp_h'383| T1479)
(declare-const var__temp_v_err384 T1480)
(declare-const var_h374 T1479)
(declare-const var_h330 T1479)
(declare-const var_h42 T1479)
(declare-const err T1493)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1479)
(declare-fun sel (T1479 Int) Int)
(declare-fun res () Int)
(declare-fun var_h330 () T1479)
(declare-fun var_h42 () T1479)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'383| () T1479)
(declare-fun var__temp_v382 () Int)
(declare-fun var__temp_h381 () T1479)
(declare-fun v () Int)
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h381 res) v) (= v |20|))
               (= (sel var__temp_h381 res) 7)))
      (a!2 (and (= (sel |var__temp_h'383| res) var__temp_v382)
                (= (sel |var__temp_h'383| res) (+ (sel var__temp_h381 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'383| res) var__temp_v382)
                    (= (sel |var__temp_h'383| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h381 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************99
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i375 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i375, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v376:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i375 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i375 --->  Ty_heap  
 var_h374 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h385 --->  Ty_heap  
 var__temp_v386 --->  Ty_int  
 var__temp_h'387 --->  Ty_heap  
 var__temp_v_err388 --->  error  
 var_h374 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h385, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h385, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h385, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'387, res ) ==(var__temp_v386) AND 
 	 Rel (sel)( , var__temp_h'387, res ) ==((sel)( , var__temp_h385, res ) + (10)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'387, res ) ==(var__temp_v386) AND 
 	 Rel (sel)( , var__temp_h'387, res ) ==(10)
 
VC_END(declare-const var_h_i375 T1496)
(declare-const var_h374 T1496)
(declare-const v Int)
(declare-const var_h_i331 T1496)
(declare-const var_h330 T1496)
(declare-const v Int)
(declare-const var_h_i43 T1496)
(declare-const var_h42 T1496)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h385 T1496)
(declare-const var__temp_v386 Int)
(declare-const |var__temp_h'387| T1496)
(declare-const var__temp_v_err388 T1497)
(declare-const var_h374 T1496)
(declare-const var_h330 T1496)
(declare-const var_h42 T1496)
(declare-const err T1510)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1496)
(declare-fun sel (T1496 Int) Int)
(declare-fun res () Int)
(declare-fun var_h330 () T1496)
(declare-fun var_h42 () T1496)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'387| () T1496)
(declare-fun var__temp_v386 () Int)
(declare-fun var__temp_h385 () T1496)
(declare-fun v () Int)
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h385 res) v) (= v |20|))
               (> (sel var__temp_h385 res) 4)))
      (a!2 (and (= (sel |var__temp_h'387| res) var__temp_v386)
                (= (sel |var__temp_h'387| res) (+ (sel var__temp_h385 res) 10)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'387| res) var__temp_v386)
                    (= (sel |var__temp_h'387| res) 10)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h385 res) 4) a!3))))
  (not a!4)))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************100
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i375 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i375, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v376:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i375 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i375 --->  Ty_heap  
 var_h374 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h389 --->  Ty_heap  
 var__temp_v390 --->  Ty_int  
 var__temp_h'391 --->  Ty_heap  
 var__temp_v_err392 --->  error  
 var_h374 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h389, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h389, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h389, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'391, res ) ==(var__temp_v390) AND 
 	 Base var__temp_v390 = 5 => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'391, res ) ==(var__temp_v390) AND 
 	 Rel (sel)( , var__temp_h'391, res ) ==(10)
 
VC_END(declare-const var_h_i375 T1513)
(declare-const var_h374 T1513)
(declare-const v Int)
(declare-const var_h_i331 T1513)
(declare-const var_h330 T1513)
(declare-const v Int)
(declare-const var_h_i43 T1513)
(declare-const var_h42 T1513)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h389 T1513)
(declare-const var__temp_v390 Int)
(declare-const |var__temp_h'391| T1513)
(declare-const var__temp_v_err392 T1514)
(declare-const var_h374 T1513)
(declare-const var_h330 T1513)
(declare-const var_h42 T1513)
(declare-const err T1527)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T1513)
(declare-fun sel (T1513 Int) Int)
(declare-fun res () Int)
(declare-fun var_h330 () T1513)
(declare-fun var_h42 () T1513)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'391| () T1513)
(declare-fun var__temp_v390 () Int)
(declare-fun var__temp_h389 () T1513)
(declare-fun v () Int)
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h389 res) v) (= v |20|))
               (= (sel var__temp_h389 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'391| res) var__temp_v390)
                    (= var__temp_v390 |5|))
               (and (= (sel |var__temp_h'391| res) var__temp_v390)
                    (= (sel |var__temp_h'391| res) 10)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h389 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************101
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i375 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i375, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v376:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i375 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i375 --->  Ty_heap  
 var_h374 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h393 --->  Ty_heap  
 var__temp_v394 --->  Ty_int  
 var__temp_h'395 --->  Ty_heap  
 var__temp_v_err396 --->  error  
 var_h374 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h393, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h393, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h393, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'395, res ) ==(var__temp_v394) AND 
 	 Rel (sel)( , var__temp_h'395, res ) ==((sel)( , var__temp_h393, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'395, res ) ==(var__temp_v394) AND 
 	 Rel (sel)( , var__temp_h'395, res ) ==(10)
 
VC_END(declare-const var_h_i375 T1530)
(declare-const var_h374 T1530)
(declare-const v Int)
(declare-const var_h_i331 T1530)
(declare-const var_h330 T1530)
(declare-const v Int)
(declare-const var_h_i43 T1530)
(declare-const var_h42 T1530)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h393 T1530)
(declare-const var__temp_v394 Int)
(declare-const |var__temp_h'395| T1530)
(declare-const var__temp_v_err396 T1531)
(declare-const var_h374 T1530)
(declare-const var_h330 T1530)
(declare-const var_h42 T1530)
(declare-const err T1544)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1530)
(declare-fun sel (T1530 Int) Int)
(declare-fun res () Int)
(declare-fun var_h330 () T1530)
(declare-fun var_h42 () T1530)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'395| () T1530)
(declare-fun var__temp_v394 () Int)
(declare-fun var__temp_h393 () T1530)
(declare-fun v () Int)
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h393 res) v) (= v |20|))
               (= (sel var__temp_h393 res) 5)))
      (a!2 (and (= (sel |var__temp_h'395| res) var__temp_v394)
                (= (sel |var__temp_h'395| res) (+ (sel var__temp_h393 res) 2)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'395| res) var__temp_v394)
                    (= (sel |var__temp_h'395| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h393 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************102
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v376:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v376:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --c2'	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i375 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i375, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v397:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************103
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i375 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i375, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v397:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i375 --->  Ty_heap  
 var_h374 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h398 --->  Ty_heap  
 var__temp_v399 --->  Ty_int  
 var__temp_h'400 --->  Ty_heap  
 var__temp_v_err401 --->  error  
 var_h374 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h398, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h398, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h398, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'400, res ) ==(var__temp_v399) AND 
 	 Rel (sel)( , var__temp_h'400, res ) ==((sel)( , var__temp_h398, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i375 T1547)
(declare-const var_h374 T1547)
(declare-const v Int)
(declare-const var_h_i331 T1547)
(declare-const var_h330 T1547)
(declare-const v Int)
(declare-const var_h_i43 T1547)
(declare-const var_h42 T1547)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h398 T1547)
(declare-const var__temp_v399 Int)
(declare-const |var__temp_h'400| T1547)
(declare-const var__temp_v_err401 T1548)
(declare-const var_h374 T1547)
(declare-const var_h330 T1547)
(declare-const var_h42 T1547)
(declare-const err T1561)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1547)
(declare-fun sel (T1547 Int) Int)
(declare-fun res () Int)
(declare-fun var_h330 () T1547)
(declare-fun var_h42 () T1547)
(declare-fun |20| () Int)
(declare-fun var__temp_h398 () T1547)
(declare-fun |var__temp_h'400| () T1547)
(declare-fun var__temp_v399 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h398 res) v) (= v |20|))
               (= (sel var__temp_h398 res) 7)))
      (a!2 (and (= (sel |var__temp_h'400| res) var__temp_v399)
                (= (sel |var__temp_h'400| res) (+ (sel var__temp_h398 res) 3)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h398 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************104
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i375 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i375, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v397:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i375 --->  Ty_heap  
 var_h374 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h402 --->  Ty_heap  
 var__temp_v403 --->  Ty_int  
 var__temp_h'404 --->  Ty_heap  
 var__temp_v_err405 --->  error  
 var_h374 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h402, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h402, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h402, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'404, res ) ==(var__temp_v403) AND 
 	 Rel (sel)( , var__temp_h'404, res ) ==((sel)( , var__temp_h402, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i375 T1564)
(declare-const var_h374 T1564)
(declare-const v Int)
(declare-const var_h_i331 T1564)
(declare-const var_h330 T1564)
(declare-const v Int)
(declare-const var_h_i43 T1564)
(declare-const var_h42 T1564)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h402 T1564)
(declare-const var__temp_v403 Int)
(declare-const |var__temp_h'404| T1564)
(declare-const var__temp_v_err405 T1565)
(declare-const var_h374 T1564)
(declare-const var_h330 T1564)
(declare-const var_h42 T1564)
(declare-const err T1578)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1564)
(declare-fun sel (T1564 Int) Int)
(declare-fun res () Int)
(declare-fun var_h330 () T1564)
(declare-fun var_h42 () T1564)
(declare-fun |20| () Int)
(declare-fun var__temp_h402 () T1564)
(declare-fun |var__temp_h'404| () T1564)
(declare-fun var__temp_v403 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h402 res) v) (= v |20|))
               (= (sel var__temp_h402 res) 7)))
      (a!2 (and (= (sel |var__temp_h'404| res) var__temp_v403)
                (= (sel |var__temp_h'404| res) (+ (sel var__temp_h402 res) 5)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h402 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************105
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i375 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i375, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v397:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i375 --->  Ty_heap  
 var_h374 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h406 --->  Ty_heap  
 var__temp_v407 --->  Ty_int  
 var__temp_h'408 --->  Ty_heap  
 var__temp_v_err409 --->  error  
 var_h374 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h406, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h406, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h406, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'408, res ) ==(var__temp_v407) AND 
 	 Rel (sel)( , var__temp_h'408, res ) ==((sel)( , var__temp_h406, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i375 T1581)
(declare-const var_h374 T1581)
(declare-const v Int)
(declare-const var_h_i331 T1581)
(declare-const var_h330 T1581)
(declare-const v Int)
(declare-const var_h_i43 T1581)
(declare-const var_h42 T1581)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h406 T1581)
(declare-const var__temp_v407 Int)
(declare-const |var__temp_h'408| T1581)
(declare-const var__temp_v_err409 T1582)
(declare-const var_h374 T1581)
(declare-const var_h330 T1581)
(declare-const var_h42 T1581)
(declare-const err T1595)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1581)
(declare-fun sel (T1581 Int) Int)
(declare-fun res () Int)
(declare-fun var_h330 () T1581)
(declare-fun var_h42 () T1581)
(declare-fun |20| () Int)
(declare-fun var__temp_h406 () T1581)
(declare-fun |var__temp_h'408| () T1581)
(declare-fun var__temp_v407 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h406 res) v) (= v |20|))
               (> (sel var__temp_h406 res) 4)))
      (a!2 (and (= (sel |var__temp_h'408| res) var__temp_v407)
                (= (sel |var__temp_h'408| res) (+ (sel var__temp_h406 res) 10)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h406 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c2
PARTIAL PATH NEW
NEW 	 --c3'	 --c2'	 --foo'	 --c2
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i411 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i411 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i411, res ) ==(v)
 	 , (sel)( , var_h_i411, res ) ==((sel)( , var_h410, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v412:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i411 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************106
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i411 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i411, res ) ==(v)
 	 , (sel)( , var_h_i411, res ) ==((sel)( , var_h410, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v412:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i411 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i411 --->  Ty_heap  
 var_h410 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i375 --->  Ty_heap  
 var_h374 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h413 --->  Ty_heap  
 var__temp_v414 --->  Ty_int  
 var__temp_h'415 --->  Ty_heap  
 var__temp_v_err416 --->  error  
 var_h410 --->  Ty_heap  
 var_h374 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h410, res ) > (4) AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h413, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h413, res ) ==((sel)( , var_h410, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h413, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h413, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'415, res ) ==(var__temp_v414) AND 
 	 Rel (sel)( , var__temp_h'415, res ) ==((sel)( , var__temp_h413, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'415, res ) ==(var__temp_v414) AND 
 	 Rel (sel)( , var__temp_h'415, res ) ==(10)
 
VC_END(declare-const var_h_i411 T1598)
(declare-const var_h410 T1598)
(declare-const v Int)
(declare-const var_h_i375 T1598)
(declare-const var_h374 T1598)
(declare-const v Int)
(declare-const var_h_i331 T1598)
(declare-const var_h330 T1598)
(declare-const v Int)
(declare-const var_h_i43 T1598)
(declare-const var_h42 T1598)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h413 T1598)
(declare-const var__temp_v414 Int)
(declare-const |var__temp_h'415| T1598)
(declare-const var__temp_v_err416 T1599)
(declare-const var_h410 T1598)
(declare-const var_h374 T1598)
(declare-const var_h330 T1598)
(declare-const var_h42 T1598)
(declare-const err T1612)

solver 
 (declare-sort T1598)
(declare-fun sel (T1598 Int) Int)
(declare-fun res () Int)
(declare-fun var_h410 () T1598)
(declare-fun var_h330 () T1598)
(declare-fun var_h42 () T1598)
(declare-fun |var__temp_h'415| () T1598)
(declare-fun var__temp_v414 () Int)
(declare-fun var__temp_h413 () T1598)
(declare-fun v () Int)
(assert (> (sel var_h410 res) 4))
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h413 res) v)
                (= (sel var__temp_h413 res) (+ (sel var_h410 res) 10))))
      (a!2 (and (= (sel |var__temp_h'415| res) var__temp_v414)
                (= (sel |var__temp_h'415| res) (+ (sel var__temp_h413 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'415| res) var__temp_v414)
                    (= (sel |var__temp_h'415| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h413 res) 7))
                (=> (= (sel var__temp_h413 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************107
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i411 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i411, res ) ==(v)
 	 , (sel)( , var_h_i411, res ) ==((sel)( , var_h410, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v412:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i411 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i411 --->  Ty_heap  
 var_h410 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i375 --->  Ty_heap  
 var_h374 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h417 --->  Ty_heap  
 var__temp_v418 --->  Ty_int  
 var__temp_h'419 --->  Ty_heap  
 var__temp_v_err420 --->  error  
 var_h410 --->  Ty_heap  
 var_h374 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h410, res ) > (4) AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h417, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h417, res ) ==((sel)( , var_h410, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h417, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h417, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'419, res ) ==(var__temp_v418) AND 
 	 Rel (sel)( , var__temp_h'419, res ) ==((sel)( , var__temp_h417, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'419, res ) ==(var__temp_v418) AND 
 	 Rel (sel)( , var__temp_h'419, res ) ==(10)
 
VC_END(declare-const var_h_i411 T1615)
(declare-const var_h410 T1615)
(declare-const v Int)
(declare-const var_h_i375 T1615)
(declare-const var_h374 T1615)
(declare-const v Int)
(declare-const var_h_i331 T1615)
(declare-const var_h330 T1615)
(declare-const v Int)
(declare-const var_h_i43 T1615)
(declare-const var_h42 T1615)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h417 T1615)
(declare-const var__temp_v418 Int)
(declare-const |var__temp_h'419| T1615)
(declare-const var__temp_v_err420 T1616)
(declare-const var_h410 T1615)
(declare-const var_h374 T1615)
(declare-const var_h330 T1615)
(declare-const var_h42 T1615)
(declare-const err T1629)

solver 
 (declare-sort T1615)
(declare-fun sel (T1615 Int) Int)
(declare-fun res () Int)
(declare-fun var_h410 () T1615)
(declare-fun var_h330 () T1615)
(declare-fun var_h42 () T1615)
(declare-fun |var__temp_h'419| () T1615)
(declare-fun var__temp_v418 () Int)
(declare-fun var__temp_h417 () T1615)
(declare-fun v () Int)
(assert (> (sel var_h410 res) 4))
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h417 res) v)
                (= (sel var__temp_h417 res) (+ (sel var_h410 res) 10))))
      (a!2 (and (= (sel |var__temp_h'419| res) var__temp_v418)
                (= (sel |var__temp_h'419| res) (+ (sel var__temp_h417 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'419| res) var__temp_v418)
                    (= (sel |var__temp_h'419| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h417 res) 7))
                (=> (= (sel var__temp_h417 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************108
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i411 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i411, res ) ==(v)
 	 , (sel)( , var_h_i411, res ) ==((sel)( , var_h410, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v412:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i411 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i411 --->  Ty_heap  
 var_h410 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i375 --->  Ty_heap  
 var_h374 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h421 --->  Ty_heap  
 var__temp_v422 --->  Ty_int  
 var__temp_h'423 --->  Ty_heap  
 var__temp_v_err424 --->  error  
 var_h410 --->  Ty_heap  
 var_h374 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h410, res ) > (4) AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h421, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h421, res ) ==((sel)( , var_h410, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h421, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h421, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'423, res ) ==(var__temp_v422) AND 
 	 Base var__temp_v422 = 5 => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'423, res ) ==(var__temp_v422) AND 
 	 Rel (sel)( , var__temp_h'423, res ) ==(10)
 
VC_END(declare-const var_h_i411 T1632)
(declare-const var_h410 T1632)
(declare-const v Int)
(declare-const var_h_i375 T1632)
(declare-const var_h374 T1632)
(declare-const v Int)
(declare-const var_h_i331 T1632)
(declare-const var_h330 T1632)
(declare-const v Int)
(declare-const var_h_i43 T1632)
(declare-const var_h42 T1632)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h421 T1632)
(declare-const var__temp_v422 Int)
(declare-const |var__temp_h'423| T1632)
(declare-const var__temp_v_err424 T1633)
(declare-const var_h410 T1632)
(declare-const var_h374 T1632)
(declare-const var_h330 T1632)
(declare-const var_h42 T1632)
(declare-const err T1646)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1632)
(declare-fun sel (T1632 Int) Int)
(declare-fun res () Int)
(declare-fun var_h410 () T1632)
(declare-fun var_h330 () T1632)
(declare-fun var_h42 () T1632)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'423| () T1632)
(declare-fun var__temp_v422 () Int)
(declare-fun var__temp_h421 () T1632)
(declare-fun v () Int)
(assert (> (sel var_h410 res) 4))
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h421 res) v)
                (= (sel var__temp_h421 res) (+ (sel var_h410 res) 10))))
      (a!2 (=> (and (= (sel |var__temp_h'423| res) var__temp_v422)
                    (= var__temp_v422 |5|))
               (and (= (sel |var__temp_h'423| res) var__temp_v422)
                    (= (sel |var__temp_h'423| res) 10)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h421 res) 0))
                (=> (= (sel var__temp_h421 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************109
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i411 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i411, res ) ==(v)
 	 , (sel)( , var_h_i411, res ) ==((sel)( , var_h410, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v412:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i411 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i411 --->  Ty_heap  
 var_h410 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i375 --->  Ty_heap  
 var_h374 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h425 --->  Ty_heap  
 var__temp_v426 --->  Ty_int  
 var__temp_h'427 --->  Ty_heap  
 var__temp_v_err428 --->  error  
 var_h410 --->  Ty_heap  
 var_h374 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h410, res ) > (4) AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h425, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h425, res ) ==((sel)( , var_h410, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h425, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h425, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'427, res ) ==(var__temp_v426) AND 
 	 Rel (sel)( , var__temp_h'427, res ) ==((sel)( , var__temp_h425, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'427, res ) ==(var__temp_v426) AND 
 	 Rel (sel)( , var__temp_h'427, res ) ==(10)
 
VC_END(declare-const var_h_i411 T1649)
(declare-const var_h410 T1649)
(declare-const v Int)
(declare-const var_h_i375 T1649)
(declare-const var_h374 T1649)
(declare-const v Int)
(declare-const var_h_i331 T1649)
(declare-const var_h330 T1649)
(declare-const v Int)
(declare-const var_h_i43 T1649)
(declare-const var_h42 T1649)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h425 T1649)
(declare-const var__temp_v426 Int)
(declare-const |var__temp_h'427| T1649)
(declare-const var__temp_v_err428 T1650)
(declare-const var_h410 T1649)
(declare-const var_h374 T1649)
(declare-const var_h330 T1649)
(declare-const var_h42 T1649)
(declare-const err T1663)

solver 
 (declare-sort T1649)
(declare-fun sel (T1649 Int) Int)
(declare-fun res () Int)
(declare-fun var_h410 () T1649)
(declare-fun var_h330 () T1649)
(declare-fun var_h42 () T1649)
(declare-fun |var__temp_h'427| () T1649)
(declare-fun var__temp_v426 () Int)
(declare-fun var__temp_h425 () T1649)
(declare-fun v () Int)
(assert (> (sel var_h410 res) 4))
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h425 res) v)
                (= (sel var__temp_h425 res) (+ (sel var_h410 res) 10))))
      (a!2 (and (= (sel |var__temp_h'427| res) var__temp_v426)
                (= (sel |var__temp_h'427| res) (+ (sel var__temp_h425 res) 2)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'427| res) var__temp_v426)
                    (= (sel |var__temp_h'427| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h425 res) 5))
                (=> (= (sel var__temp_h425 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************110
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v412:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v412:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --c2'	 --foo'	 --c2
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i411 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i411, res ) ==(v)
 	 , (sel)( , var_h_i411, res ) ==((sel)( , var_h410, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v429:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************111
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i411 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i411, res ) ==(v)
 	 , (sel)( , var_h_i411, res ) ==((sel)( , var_h410, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v429:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i411 --->  Ty_heap  
 var_h410 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i375 --->  Ty_heap  
 var_h374 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h430 --->  Ty_heap  
 var__temp_v431 --->  Ty_int  
 var__temp_h'432 --->  Ty_heap  
 var__temp_v_err433 --->  error  
 var_h410 --->  Ty_heap  
 var_h374 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h410, res ) > (4) AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h430, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h430, res ) ==((sel)( , var_h410, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h430, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h430, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'432, res ) ==(var__temp_v431) AND 
 	 Rel (sel)( , var__temp_h'432, res ) ==((sel)( , var__temp_h430, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i411 T1666)
(declare-const var_h410 T1666)
(declare-const v Int)
(declare-const var_h_i375 T1666)
(declare-const var_h374 T1666)
(declare-const v Int)
(declare-const var_h_i331 T1666)
(declare-const var_h330 T1666)
(declare-const v Int)
(declare-const var_h_i43 T1666)
(declare-const var_h42 T1666)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h430 T1666)
(declare-const var__temp_v431 Int)
(declare-const |var__temp_h'432| T1666)
(declare-const var__temp_v_err433 T1667)
(declare-const var_h410 T1666)
(declare-const var_h374 T1666)
(declare-const var_h330 T1666)
(declare-const var_h42 T1666)
(declare-const err T1680)

solver 
 (declare-sort T1666)
(declare-fun sel (T1666 Int) Int)
(declare-fun res () Int)
(declare-fun var_h410 () T1666)
(declare-fun var_h330 () T1666)
(declare-fun var_h42 () T1666)
(declare-fun var__temp_h430 () T1666)
(declare-fun |var__temp_h'432| () T1666)
(declare-fun var__temp_v431 () Int)
(declare-fun v () Int)
(assert (> (sel var_h410 res) 4))
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h430 res) v)
                (= (sel var__temp_h430 res) (+ (sel var_h410 res) 10))))
      (a!2 (and (= (sel |var__temp_h'432| res) var__temp_v431)
                (= (sel |var__temp_h'432| res) (+ (sel var__temp_h430 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h430 res) 7))
                (=> (= (sel var__temp_h430 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************112
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i411 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i411, res ) ==(v)
 	 , (sel)( , var_h_i411, res ) ==((sel)( , var_h410, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v429:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i411 --->  Ty_heap  
 var_h410 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i375 --->  Ty_heap  
 var_h374 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h434 --->  Ty_heap  
 var__temp_v435 --->  Ty_int  
 var__temp_h'436 --->  Ty_heap  
 var__temp_v_err437 --->  error  
 var_h410 --->  Ty_heap  
 var_h374 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h410, res ) > (4) AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h434, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h434, res ) ==((sel)( , var_h410, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h434, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h434, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'436, res ) ==(var__temp_v435) AND 
 	 Rel (sel)( , var__temp_h'436, res ) ==((sel)( , var__temp_h434, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i411 T1683)
(declare-const var_h410 T1683)
(declare-const v Int)
(declare-const var_h_i375 T1683)
(declare-const var_h374 T1683)
(declare-const v Int)
(declare-const var_h_i331 T1683)
(declare-const var_h330 T1683)
(declare-const v Int)
(declare-const var_h_i43 T1683)
(declare-const var_h42 T1683)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h434 T1683)
(declare-const var__temp_v435 Int)
(declare-const |var__temp_h'436| T1683)
(declare-const var__temp_v_err437 T1684)
(declare-const var_h410 T1683)
(declare-const var_h374 T1683)
(declare-const var_h330 T1683)
(declare-const var_h42 T1683)
(declare-const err T1697)

solver 
 (declare-sort T1683)
(declare-fun sel (T1683 Int) Int)
(declare-fun res () Int)
(declare-fun var_h410 () T1683)
(declare-fun var_h330 () T1683)
(declare-fun var_h42 () T1683)
(declare-fun var__temp_h434 () T1683)
(declare-fun |var__temp_h'436| () T1683)
(declare-fun var__temp_v435 () Int)
(declare-fun v () Int)
(assert (> (sel var_h410 res) 4))
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h434 res) v)
                (= (sel var__temp_h434 res) (+ (sel var_h410 res) 10))))
      (a!2 (and (= (sel |var__temp_h'436| res) var__temp_v435)
                (= (sel |var__temp_h'436| res) (+ (sel var__temp_h434 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h434 res) 7))
                (=> (= (sel var__temp_h434 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************113
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i411 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i411, res ) ==(v)
 	 , (sel)( , var_h_i411, res ) ==((sel)( , var_h410, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v429:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i411 --->  Ty_heap  
 var_h410 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i375 --->  Ty_heap  
 var_h374 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h438 --->  Ty_heap  
 var__temp_v439 --->  Ty_int  
 var__temp_h'440 --->  Ty_heap  
 var__temp_v_err441 --->  error  
 var_h410 --->  Ty_heap  
 var_h374 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h410, res ) > (4) AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h438, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h438, res ) ==((sel)( , var_h410, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h438, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h438, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'440, res ) ==(var__temp_v439) AND 
 	 Base var__temp_v439 = 5 => 
 	 True
 
VC_END(declare-const var_h_i411 T1700)
(declare-const var_h410 T1700)
(declare-const v Int)
(declare-const var_h_i375 T1700)
(declare-const var_h374 T1700)
(declare-const v Int)
(declare-const var_h_i331 T1700)
(declare-const var_h330 T1700)
(declare-const v Int)
(declare-const var_h_i43 T1700)
(declare-const var_h42 T1700)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h438 T1700)
(declare-const var__temp_v439 Int)
(declare-const |var__temp_h'440| T1700)
(declare-const var__temp_v_err441 T1701)
(declare-const var_h410 T1700)
(declare-const var_h374 T1700)
(declare-const var_h330 T1700)
(declare-const var_h42 T1700)
(declare-const err T1714)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1700)
(declare-fun sel (T1700 Int) Int)
(declare-fun res () Int)
(declare-fun var_h410 () T1700)
(declare-fun var_h330 () T1700)
(declare-fun var_h42 () T1700)
(declare-fun |5| () Int)
(declare-fun var__temp_v439 () Int)
(declare-fun |var__temp_h'440| () T1700)
(declare-fun var__temp_h438 () T1700)
(declare-fun v () Int)
(assert (> (sel var_h410 res) 4))
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h438 res) v)
                (= (sel var__temp_h438 res) (+ (sel var_h410 res) 10))))
      (a!2 (=> (and (= (sel |var__temp_h'440| res) var__temp_v439)
                    (= var__temp_v439 |5|))
               true)))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h438 res) 0))
                (=> (= (sel var__temp_h438 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************114
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i411 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i411, res ) ==(v)
 	 , (sel)( , var_h_i411, res ) ==((sel)( , var_h410, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v429:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i411 --->  Ty_heap  
 var_h410 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i375 --->  Ty_heap  
 var_h374 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h442 --->  Ty_heap  
 var__temp_v443 --->  Ty_int  
 var__temp_h'444 --->  Ty_heap  
 var__temp_v_err445 --->  error  
 var_h410 --->  Ty_heap  
 var_h374 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h410, res ) > (4) AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h442, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h442, res ) ==((sel)( , var_h410, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h442, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h442, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'444, res ) ==(var__temp_v443) AND 
 	 Rel (sel)( , var__temp_h'444, res ) ==((sel)( , var__temp_h442, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i411 T1717)
(declare-const var_h410 T1717)
(declare-const v Int)
(declare-const var_h_i375 T1717)
(declare-const var_h374 T1717)
(declare-const v Int)
(declare-const var_h_i331 T1717)
(declare-const var_h330 T1717)
(declare-const v Int)
(declare-const var_h_i43 T1717)
(declare-const var_h42 T1717)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h442 T1717)
(declare-const var__temp_v443 Int)
(declare-const |var__temp_h'444| T1717)
(declare-const var__temp_v_err445 T1718)
(declare-const var_h410 T1717)
(declare-const var_h374 T1717)
(declare-const var_h330 T1717)
(declare-const var_h42 T1717)
(declare-const err T1731)

solver 
 (declare-sort T1717)
(declare-fun sel (T1717 Int) Int)
(declare-fun res () Int)
(declare-fun var_h410 () T1717)
(declare-fun var_h330 () T1717)
(declare-fun var_h42 () T1717)
(declare-fun var__temp_h442 () T1717)
(declare-fun |var__temp_h'444| () T1717)
(declare-fun var__temp_v443 () Int)
(declare-fun v () Int)
(assert (> (sel var_h410 res) 4))
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h442 res) v)
                (= (sel var__temp_h442 res) (+ (sel var_h410 res) 10))))
      (a!2 (and (= (sel |var__temp_h'444| res) var__temp_v443)
                (= (sel |var__temp_h'444| res) (+ (sel var__temp_h442 res) 2)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h442 res) 5))
                (=> (= (sel var__temp_h442 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************115
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 	 --c3'	 --c2'	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i375 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i375, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v446:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************116
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i375 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i375, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v446:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i375 --->  Ty_heap  
 var_h374 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h447 --->  Ty_heap  
 var__temp_v448 --->  Ty_int  
 var__temp_h'449 --->  Ty_heap  
 var__temp_v_err450 --->  error  
 var_h374 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h447, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h447, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h447, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'449, res ) ==(var__temp_v448) AND 
 	 Rel (sel)( , var__temp_h'449, res ) ==((sel)( , var__temp_h447, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i375 T1734)
(declare-const var_h374 T1734)
(declare-const v Int)
(declare-const var_h_i331 T1734)
(declare-const var_h330 T1734)
(declare-const v Int)
(declare-const var_h_i43 T1734)
(declare-const var_h42 T1734)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h447 T1734)
(declare-const var__temp_v448 Int)
(declare-const |var__temp_h'449| T1734)
(declare-const var__temp_v_err450 T1735)
(declare-const var_h374 T1734)
(declare-const var_h330 T1734)
(declare-const var_h42 T1734)
(declare-const err T1748)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1734)
(declare-fun sel (T1734 Int) Int)
(declare-fun res () Int)
(declare-fun var_h330 () T1734)
(declare-fun var_h42 () T1734)
(declare-fun |20| () Int)
(declare-fun var__temp_h447 () T1734)
(declare-fun |var__temp_h'449| () T1734)
(declare-fun var__temp_v448 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h447 res) v) (= v |20|))
               (= (sel var__temp_h447 res) 7)))
      (a!2 (and (= (sel |var__temp_h'449| res) var__temp_v448)
                (= (sel |var__temp_h'449| res) (+ (sel var__temp_h447 res) 3)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h447 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************117
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i375 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i375, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v446:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i375 --->  Ty_heap  
 var_h374 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h451 --->  Ty_heap  
 var__temp_v452 --->  Ty_int  
 var__temp_h'453 --->  Ty_heap  
 var__temp_v_err454 --->  error  
 var_h374 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h451, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h451, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h451, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'453, res ) ==(var__temp_v452) AND 
 	 Rel (sel)( , var__temp_h'453, res ) ==((sel)( , var__temp_h451, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i375 T1751)
(declare-const var_h374 T1751)
(declare-const v Int)
(declare-const var_h_i331 T1751)
(declare-const var_h330 T1751)
(declare-const v Int)
(declare-const var_h_i43 T1751)
(declare-const var_h42 T1751)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h451 T1751)
(declare-const var__temp_v452 Int)
(declare-const |var__temp_h'453| T1751)
(declare-const var__temp_v_err454 T1752)
(declare-const var_h374 T1751)
(declare-const var_h330 T1751)
(declare-const var_h42 T1751)
(declare-const err T1765)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1751)
(declare-fun sel (T1751 Int) Int)
(declare-fun res () Int)
(declare-fun var_h330 () T1751)
(declare-fun var_h42 () T1751)
(declare-fun |20| () Int)
(declare-fun var__temp_h451 () T1751)
(declare-fun |var__temp_h'453| () T1751)
(declare-fun var__temp_v452 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h451 res) v) (= v |20|))
               (= (sel var__temp_h451 res) 7)))
      (a!2 (and (= (sel |var__temp_h'453| res) var__temp_v452)
                (= (sel |var__temp_h'453| res) (+ (sel var__temp_h451 res) 5)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h451 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************118
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i375 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i375, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v446:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i375 --->  Ty_heap  
 var_h374 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h455 --->  Ty_heap  
 var__temp_v456 --->  Ty_int  
 var__temp_h'457 --->  Ty_heap  
 var__temp_v_err458 --->  error  
 var_h374 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h455, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h455, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h455, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'457, res ) ==(var__temp_v456) AND 
 	 Base var__temp_v456 = 5 => 
 	 True
 
VC_END(declare-const var_h_i375 T1768)
(declare-const var_h374 T1768)
(declare-const v Int)
(declare-const var_h_i331 T1768)
(declare-const var_h330 T1768)
(declare-const v Int)
(declare-const var_h_i43 T1768)
(declare-const var_h42 T1768)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h455 T1768)
(declare-const var__temp_v456 Int)
(declare-const |var__temp_h'457| T1768)
(declare-const var__temp_v_err458 T1769)
(declare-const var_h374 T1768)
(declare-const var_h330 T1768)
(declare-const var_h42 T1768)
(declare-const err T1782)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T1768)
(declare-fun sel (T1768 Int) Int)
(declare-fun res () Int)
(declare-fun var_h330 () T1768)
(declare-fun var_h42 () T1768)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_v456 () Int)
(declare-fun |var__temp_h'457| () T1768)
(declare-fun var__temp_h455 () T1768)
(declare-fun v () Int)
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h455 res) v) (= v |20|))
               (= (sel var__temp_h455 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'457| res) var__temp_v456)
                    (= var__temp_v456 |5|))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h455 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************119
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i375 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i375, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v446:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i375 --->  Ty_heap  
 var_h374 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h459 --->  Ty_heap  
 var__temp_v460 --->  Ty_int  
 var__temp_h'461 --->  Ty_heap  
 var__temp_v_err462 --->  error  
 var_h374 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h459, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h459, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h459, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'461, res ) ==(var__temp_v460) AND 
 	 Rel (sel)( , var__temp_h'461, res ) ==((sel)( , var__temp_h459, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i375 T1785)
(declare-const var_h374 T1785)
(declare-const v Int)
(declare-const var_h_i331 T1785)
(declare-const var_h330 T1785)
(declare-const v Int)
(declare-const var_h_i43 T1785)
(declare-const var_h42 T1785)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h459 T1785)
(declare-const var__temp_v460 Int)
(declare-const |var__temp_h'461| T1785)
(declare-const var__temp_v_err462 T1786)
(declare-const var_h374 T1785)
(declare-const var_h330 T1785)
(declare-const var_h42 T1785)
(declare-const err T1799)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1785)
(declare-fun sel (T1785 Int) Int)
(declare-fun res () Int)
(declare-fun var_h330 () T1785)
(declare-fun var_h42 () T1785)
(declare-fun |20| () Int)
(declare-fun var__temp_h459 () T1785)
(declare-fun |var__temp_h'461| () T1785)
(declare-fun var__temp_v460 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h459 res) v) (= v |20|))
               (= (sel var__temp_h459 res) 5)))
      (a!2 (and (= (sel |var__temp_h'461| res) var__temp_v460)
                (= (sel |var__temp_h'461| res) (+ (sel var__temp_h459 res) 2)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h459 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************120
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 	 --c3'	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) >c  } 
 } 
 
                                                RET :  Base {var_v463:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************121
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) >c  } 
 } 
 
                                                RET :  Base {var_v463:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h464 --->  Ty_heap  
 var__temp_v465 --->  Ty_int  
 var__temp_h'466 --->  Ty_heap  
 var__temp_v_err467 --->  error  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h464, res ) ==(v) AND 
 	 Rel (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) => 
 	 Rel (sel)( , var__temp_h464, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h464, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'466, res ) ==(var__temp_v465) AND 
 	 Rel (sel)( , var__temp_h'466, res ) ==((sel)( , var__temp_h464, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i331 T1802)
(declare-const var_h330 T1802)
(declare-const v Int)
(declare-const var_h_i43 T1802)
(declare-const var_h42 T1802)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h464 T1802)
(declare-const var__temp_v465 Int)
(declare-const |var__temp_h'466| T1802)
(declare-const var__temp_v_err467 T1803)
(declare-const var_h330 T1802)
(declare-const var_h42 T1802)
(declare-const err T1816)

solver 
 (declare-sort T1802)
(declare-fun sel (T1802 Int) Int)
(declare-fun res () Int)
(declare-fun var_h330 () T1802)
(declare-fun var_h42 () T1802)
(declare-fun var__temp_h464 () T1802)
(declare-fun |var__temp_h'466| () T1802)
(declare-fun var__temp_v465 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h464 res) v)
                    (= (sel var_h330 res) (sel var_h330 res)))
               (= (sel var__temp_h464 res) 7)))
      (a!2 (and (= (sel |var__temp_h'466| res) var__temp_v465)
                (= (sel |var__temp_h'466| res) (+ (sel var__temp_h464 res) 3)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h464 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************122
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) >c  } 
 } 
 
                                                RET :  Base {var_v463:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h468 --->  Ty_heap  
 var__temp_v469 --->  Ty_int  
 var__temp_h'470 --->  Ty_heap  
 var__temp_v_err471 --->  error  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h468, res ) ==(v) AND 
 	 Rel (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) => 
 	 Rel (sel)( , var__temp_h468, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h468, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'470, res ) ==(var__temp_v469) AND 
 	 Rel (sel)( , var__temp_h'470, res ) ==((sel)( , var__temp_h468, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i331 T1819)
(declare-const var_h330 T1819)
(declare-const v Int)
(declare-const var_h_i43 T1819)
(declare-const var_h42 T1819)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h468 T1819)
(declare-const var__temp_v469 Int)
(declare-const |var__temp_h'470| T1819)
(declare-const var__temp_v_err471 T1820)
(declare-const var_h330 T1819)
(declare-const var_h42 T1819)
(declare-const err T1833)

solver 
 (declare-sort T1819)
(declare-fun sel (T1819 Int) Int)
(declare-fun res () Int)
(declare-fun var_h330 () T1819)
(declare-fun var_h42 () T1819)
(declare-fun var__temp_h468 () T1819)
(declare-fun |var__temp_h'470| () T1819)
(declare-fun var__temp_v469 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h468 res) v)
                    (= (sel var_h330 res) (sel var_h330 res)))
               (= (sel var__temp_h468 res) 7)))
      (a!2 (and (= (sel |var__temp_h'470| res) var__temp_v469)
                (= (sel |var__temp_h'470| res) (+ (sel var__temp_h468 res) 5)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h468 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************123
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) >c  } 
 } 
 
                                                RET :  Base {var_v463:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h472 --->  Ty_heap  
 var__temp_v473 --->  Ty_int  
 var__temp_h'474 --->  Ty_heap  
 var__temp_v_err475 --->  error  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h472, res ) ==(v) AND 
 	 Rel (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) => 
 	 Rel (sel)( , var__temp_h472, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h472, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'474, res ) ==(var__temp_v473) AND 
 	 Rel (sel)( , var__temp_h'474, res ) ==((sel)( , var__temp_h472, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i331 T1836)
(declare-const var_h330 T1836)
(declare-const v Int)
(declare-const var_h_i43 T1836)
(declare-const var_h42 T1836)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h472 T1836)
(declare-const var__temp_v473 Int)
(declare-const |var__temp_h'474| T1836)
(declare-const var__temp_v_err475 T1837)
(declare-const var_h330 T1836)
(declare-const var_h42 T1836)
(declare-const err T1850)

solver 
 (declare-sort T1836)
(declare-fun sel (T1836 Int) Int)
(declare-fun res () Int)
(declare-fun var_h330 () T1836)
(declare-fun var_h42 () T1836)
(declare-fun var__temp_h472 () T1836)
(declare-fun |var__temp_h'474| () T1836)
(declare-fun var__temp_v473 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h472 res) v)
                    (= (sel var_h330 res) (sel var_h330 res)))
               (> (sel var__temp_h472 res) 4)))
      (a!2 (and (= (sel |var__temp_h'474| res) var__temp_v473)
                (= (sel |var__temp_h'474| res) (+ (sel var__temp_h472 res) 10)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h472 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************124
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) >c  } 
 } 
 
                                                RET :  Base {var_v463:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h476 --->  Ty_heap  
 var__temp_v477 --->  Ty_int  
 var__temp_h'478 --->  Ty_heap  
 var__temp_v_err479 --->  error  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h476, res ) ==(v) AND 
 	 Rel (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) => 
 	 Rel (sel)( , var__temp_h476, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h476, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'478, res ) ==(var__temp_v477) AND 
 	 Base var__temp_v477 = 5 => 
 	 True
 
VC_END(declare-const var_h_i331 T1853)
(declare-const var_h330 T1853)
(declare-const v Int)
(declare-const var_h_i43 T1853)
(declare-const var_h42 T1853)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h476 T1853)
(declare-const var__temp_v477 Int)
(declare-const |var__temp_h'478| T1853)
(declare-const var__temp_v_err479 T1854)
(declare-const var_h330 T1853)
(declare-const var_h42 T1853)
(declare-const err T1867)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1853)
(declare-fun sel (T1853 Int) Int)
(declare-fun res () Int)
(declare-fun var_h330 () T1853)
(declare-fun var_h42 () T1853)
(declare-fun |5| () Int)
(declare-fun var__temp_v477 () Int)
(declare-fun |var__temp_h'478| () T1853)
(declare-fun var__temp_h476 () T1853)
(declare-fun v () Int)
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h476 res) v)
                    (= (sel var_h330 res) (sel var_h330 res)))
               (= (sel var__temp_h476 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'478| res) var__temp_v477)
                    (= var__temp_v477 |5|))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h476 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************125
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) >c  } 
 } 
 
                                                RET :  Base {var_v463:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h480 --->  Ty_heap  
 var__temp_v481 --->  Ty_int  
 var__temp_h'482 --->  Ty_heap  
 var__temp_v_err483 --->  error  
 var_h330 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) > (20) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h480, res ) ==(v) AND 
 	 Rel (sel)( , var_h330, res ) ==(sel)( , var_h330, res ) => 
 	 Rel (sel)( , var__temp_h480, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h480, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'482, res ) ==(var__temp_v481) AND 
 	 Rel (sel)( , var__temp_h'482, res ) ==((sel)( , var__temp_h480, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i331 T1870)
(declare-const var_h330 T1870)
(declare-const v Int)
(declare-const var_h_i43 T1870)
(declare-const var_h42 T1870)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h480 T1870)
(declare-const var__temp_v481 Int)
(declare-const |var__temp_h'482| T1870)
(declare-const var__temp_v_err483 T1871)
(declare-const var_h330 T1870)
(declare-const var_h42 T1870)
(declare-const err T1884)

solver 
 (declare-sort T1870)
(declare-fun sel (T1870 Int) Int)
(declare-fun res () Int)
(declare-fun var_h330 () T1870)
(declare-fun var_h42 () T1870)
(declare-fun var__temp_h480 () T1870)
(declare-fun |var__temp_h'482| () T1870)
(declare-fun var__temp_v481 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h330 res) 20)))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h480 res) v)
                    (= (sel var_h330 res) (sel var_h330 res)))
               (= (sel var__temp_h480 res) 5)))
      (a!2 (and (= (sel |var__temp_h'482| res) var__temp_v481)
                (= (sel |var__temp_h'482| res) (+ (sel var__temp_h480 res) 2)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h480 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************126
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo'
PARTIAL PATH
SUB 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i43 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i43, res ) ==(v)
 	 , (sel)( , var_h_i43, res ) ==((sel)( , var_h42, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v484:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************127
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i43 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i43, res ) ==(v)
 	 , (sel)( , var_h_i43, res ) ==((sel)( , var_h42, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v484:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h485 --->  Ty_heap  
 var__temp_v486 --->  Ty_int  
 var__temp_h'487 --->  Ty_heap  
 var__temp_v_err488 --->  error  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h485, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h485, res ) ==((sel)( , var_h42, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h485, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h485, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'487, res ) ==(var__temp_v486) AND 
 	 Rel (sel)( , var__temp_h'487, res ) ==((sel)( , var__temp_h485, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i43 T1887)
(declare-const var_h42 T1887)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h485 T1887)
(declare-const var__temp_v486 Int)
(declare-const |var__temp_h'487| T1887)
(declare-const var__temp_v_err488 T1888)
(declare-const var_h42 T1887)
(declare-const err T1901)

solver 
 (declare-sort T1887)
(declare-fun sel (T1887 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T1887)
(declare-fun var__temp_h485 () T1887)
(declare-fun |var__temp_h'487| () T1887)
(declare-fun var__temp_v486 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h485 res) v)
                (= (sel var__temp_h485 res) (+ (sel var_h42 res) 3))))
      (a!2 (and (= (sel |var__temp_h'487| res) var__temp_v486)
                (= (sel |var__temp_h'487| res) (+ (sel var__temp_h485 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h485 res) 7))
                (=> (= (sel var__temp_h485 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************128
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i43 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i43, res ) ==(v)
 	 , (sel)( , var_h_i43, res ) ==((sel)( , var_h42, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v484:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h489 --->  Ty_heap  
 var__temp_v490 --->  Ty_int  
 var__temp_h'491 --->  Ty_heap  
 var__temp_v_err492 --->  error  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h489, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h489, res ) ==((sel)( , var_h42, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h489, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h489, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'491, res ) ==(var__temp_v490) AND 
 	 Rel (sel)( , var__temp_h'491, res ) ==((sel)( , var__temp_h489, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i43 T1904)
(declare-const var_h42 T1904)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h489 T1904)
(declare-const var__temp_v490 Int)
(declare-const |var__temp_h'491| T1904)
(declare-const var__temp_v_err492 T1905)
(declare-const var_h42 T1904)
(declare-const err T1918)

solver 
 (declare-sort T1904)
(declare-fun sel (T1904 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T1904)
(declare-fun var__temp_h489 () T1904)
(declare-fun |var__temp_h'491| () T1904)
(declare-fun var__temp_v490 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h489 res) v)
                (= (sel var__temp_h489 res) (+ (sel var_h42 res) 3))))
      (a!2 (and (= (sel |var__temp_h'491| res) var__temp_v490)
                (= (sel |var__temp_h'491| res) (+ (sel var__temp_h489 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h489 res) 7))
                (=> (= (sel var__temp_h489 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************129
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i43 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i43, res ) ==(v)
 	 , (sel)( , var_h_i43, res ) ==((sel)( , var_h42, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v484:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h493 --->  Ty_heap  
 var__temp_v494 --->  Ty_int  
 var__temp_h'495 --->  Ty_heap  
 var__temp_v_err496 --->  error  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h493, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h493, res ) ==((sel)( , var_h42, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h493, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h493, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'495, res ) ==(var__temp_v494) AND 
 	 Rel (sel)( , var__temp_h'495, res ) ==((sel)( , var__temp_h493, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i43 T1921)
(declare-const var_h42 T1921)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h493 T1921)
(declare-const var__temp_v494 Int)
(declare-const |var__temp_h'495| T1921)
(declare-const var__temp_v_err496 T1922)
(declare-const var_h42 T1921)
(declare-const err T1935)

solver 
 (declare-sort T1921)
(declare-fun sel (T1921 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T1921)
(declare-fun var__temp_h493 () T1921)
(declare-fun |var__temp_h'495| () T1921)
(declare-fun var__temp_v494 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h493 res) v)
                (= (sel var__temp_h493 res) (+ (sel var_h42 res) 3))))
      (a!2 (and (= (sel |var__temp_h'495| res) var__temp_v494)
                (= (sel |var__temp_h'495| res) (+ (sel var__temp_h493 res) 10)))))
(let ((a!3 (and (=> a!1 (> (sel var__temp_h493 res) 4))
                (=> (> (sel var__temp_h493 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************130
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i43 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i43, res ) ==(v)
 	 , (sel)( , var_h_i43, res ) ==((sel)( , var_h42, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v484:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h497 --->  Ty_heap  
 var__temp_v498 --->  Ty_int  
 var__temp_h'499 --->  Ty_heap  
 var__temp_v_err500 --->  error  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h497, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h497, res ) ==((sel)( , var_h42, res ) + (3)) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'499, res ) ==(var__temp_v498) AND 
 	 Base var__temp_v498 = 20 => 
 	 True
 
VC_END(declare-const var_h_i43 T1938)
(declare-const var_h42 T1938)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h497 T1938)
(declare-const var__temp_v498 Int)
(declare-const |var__temp_h'499| T1938)
(declare-const var__temp_v_err500 T1939)
(declare-const var_h42 T1938)
(declare-const err T1952)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1938)
(declare-fun sel (T1938 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T1938)
(declare-fun |20| () Int)
(declare-fun var__temp_v498 () Int)
(declare-fun |var__temp_h'499| () T1938)
(declare-fun var__temp_h497 () T1938)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (and (= (sel var__temp_h497 res) v)
                (= (sel var__temp_h497 res) (+ (sel var_h42 res) 3))))
      (a!2 (=> (and (= (sel |var__temp_h'499| res) var__temp_v498)
                    (= var__temp_v498 |20|))
               true)))
  (not (and (=> a!1 true) (=> true a!2)))))

***************Selection Successful************foo'
PARTIAL PATH NEW
NEW 	 --c3'	 --foo'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i502 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i502 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i502, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v503:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i502 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************131
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i502 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i502, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v503:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i502 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i502 --->  Ty_heap  
 var_h501 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h504 --->  Ty_heap  
 var__temp_v505 --->  Ty_int  
 var__temp_h'506 --->  Ty_heap  
 var__temp_v_err507 --->  error  
 var_h501 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h504, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h504, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h504, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'506, res ) ==(var__temp_v505) AND 
 	 Rel (sel)( , var__temp_h'506, res ) ==((sel)( , var__temp_h504, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'506, res ) ==(var__temp_v505) AND 
 	 Rel (sel)( , var__temp_h'506, res ) ==(10)
 
VC_END(declare-const var_h_i502 T1955)
(declare-const var_h501 T1955)
(declare-const v Int)
(declare-const var_h_i43 T1955)
(declare-const var_h42 T1955)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h504 T1955)
(declare-const var__temp_v505 Int)
(declare-const |var__temp_h'506| T1955)
(declare-const var__temp_v_err507 T1956)
(declare-const var_h501 T1955)
(declare-const var_h42 T1955)
(declare-const err T1969)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1955)
(declare-fun sel (T1955 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T1955)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'506| () T1955)
(declare-fun var__temp_v505 () Int)
(declare-fun var__temp_h504 () T1955)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h504 res) v) (= v |20|))
               (= (sel var__temp_h504 res) 7)))
      (a!2 (and (= (sel |var__temp_h'506| res) var__temp_v505)
                (= (sel |var__temp_h'506| res) (+ (sel var__temp_h504 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'506| res) var__temp_v505)
                    (= (sel |var__temp_h'506| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h504 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************132
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i502 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i502, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v503:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i502 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i502 --->  Ty_heap  
 var_h501 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h508 --->  Ty_heap  
 var__temp_v509 --->  Ty_int  
 var__temp_h'510 --->  Ty_heap  
 var__temp_v_err511 --->  error  
 var_h501 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h508, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h508, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h508, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'510, res ) ==(var__temp_v509) AND 
 	 Rel (sel)( , var__temp_h'510, res ) ==((sel)( , var__temp_h508, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'510, res ) ==(var__temp_v509) AND 
 	 Rel (sel)( , var__temp_h'510, res ) ==(10)
 
VC_END(declare-const var_h_i502 T1972)
(declare-const var_h501 T1972)
(declare-const v Int)
(declare-const var_h_i43 T1972)
(declare-const var_h42 T1972)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h508 T1972)
(declare-const var__temp_v509 Int)
(declare-const |var__temp_h'510| T1972)
(declare-const var__temp_v_err511 T1973)
(declare-const var_h501 T1972)
(declare-const var_h42 T1972)
(declare-const err T1986)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1972)
(declare-fun sel (T1972 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T1972)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'510| () T1972)
(declare-fun var__temp_v509 () Int)
(declare-fun var__temp_h508 () T1972)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h508 res) v) (= v |20|))
               (= (sel var__temp_h508 res) 7)))
      (a!2 (and (= (sel |var__temp_h'510| res) var__temp_v509)
                (= (sel |var__temp_h'510| res) (+ (sel var__temp_h508 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'510| res) var__temp_v509)
                    (= (sel |var__temp_h'510| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h508 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************133
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i502 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i502, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v503:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i502 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i502 --->  Ty_heap  
 var_h501 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h512 --->  Ty_heap  
 var__temp_v513 --->  Ty_int  
 var__temp_h'514 --->  Ty_heap  
 var__temp_v_err515 --->  error  
 var_h501 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h512, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h512, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h512, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'514, res ) ==(var__temp_v513) AND 
 	 Rel (sel)( , var__temp_h'514, res ) ==((sel)( , var__temp_h512, res ) + (10)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'514, res ) ==(var__temp_v513) AND 
 	 Rel (sel)( , var__temp_h'514, res ) ==(10)
 
VC_END(declare-const var_h_i502 T1989)
(declare-const var_h501 T1989)
(declare-const v Int)
(declare-const var_h_i43 T1989)
(declare-const var_h42 T1989)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h512 T1989)
(declare-const var__temp_v513 Int)
(declare-const |var__temp_h'514| T1989)
(declare-const var__temp_v_err515 T1990)
(declare-const var_h501 T1989)
(declare-const var_h42 T1989)
(declare-const err T2003)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1989)
(declare-fun sel (T1989 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T1989)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'514| () T1989)
(declare-fun var__temp_v513 () Int)
(declare-fun var__temp_h512 () T1989)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h512 res) v) (= v |20|))
               (> (sel var__temp_h512 res) 4)))
      (a!2 (and (= (sel |var__temp_h'514| res) var__temp_v513)
                (= (sel |var__temp_h'514| res) (+ (sel var__temp_h512 res) 10)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'514| res) var__temp_v513)
                    (= (sel |var__temp_h'514| res) 10)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h512 res) 4) a!3))))
  (not a!4)))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************134
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i502 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i502, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v503:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i502 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i502 --->  Ty_heap  
 var_h501 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h516 --->  Ty_heap  
 var__temp_v517 --->  Ty_int  
 var__temp_h'518 --->  Ty_heap  
 var__temp_v_err519 --->  error  
 var_h501 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h516, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h516, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h516, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'518, res ) ==(var__temp_v517) AND 
 	 Base var__temp_v517 = 5 => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'518, res ) ==(var__temp_v517) AND 
 	 Rel (sel)( , var__temp_h'518, res ) ==(10)
 
VC_END(declare-const var_h_i502 T2006)
(declare-const var_h501 T2006)
(declare-const v Int)
(declare-const var_h_i43 T2006)
(declare-const var_h42 T2006)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h516 T2006)
(declare-const var__temp_v517 Int)
(declare-const |var__temp_h'518| T2006)
(declare-const var__temp_v_err519 T2007)
(declare-const var_h501 T2006)
(declare-const var_h42 T2006)
(declare-const err T2020)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T2006)
(declare-fun sel (T2006 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T2006)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'518| () T2006)
(declare-fun var__temp_v517 () Int)
(declare-fun var__temp_h516 () T2006)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h516 res) v) (= v |20|))
               (= (sel var__temp_h516 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'518| res) var__temp_v517)
                    (= var__temp_v517 |5|))
               (and (= (sel |var__temp_h'518| res) var__temp_v517)
                    (= (sel |var__temp_h'518| res) 10)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h516 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************135
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i502 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i502, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v503:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i502 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i502 --->  Ty_heap  
 var_h501 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h520 --->  Ty_heap  
 var__temp_v521 --->  Ty_int  
 var__temp_h'522 --->  Ty_heap  
 var__temp_v_err523 --->  error  
 var_h501 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h520, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h520, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h520, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'522, res ) ==(var__temp_v521) AND 
 	 Rel (sel)( , var__temp_h'522, res ) ==((sel)( , var__temp_h520, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'522, res ) ==(var__temp_v521) AND 
 	 Rel (sel)( , var__temp_h'522, res ) ==(10)
 
VC_END(declare-const var_h_i502 T2023)
(declare-const var_h501 T2023)
(declare-const v Int)
(declare-const var_h_i43 T2023)
(declare-const var_h42 T2023)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h520 T2023)
(declare-const var__temp_v521 Int)
(declare-const |var__temp_h'522| T2023)
(declare-const var__temp_v_err523 T2024)
(declare-const var_h501 T2023)
(declare-const var_h42 T2023)
(declare-const err T2037)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2023)
(declare-fun sel (T2023 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T2023)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'522| () T2023)
(declare-fun var__temp_v521 () Int)
(declare-fun var__temp_h520 () T2023)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h520 res) v) (= v |20|))
               (= (sel var__temp_h520 res) 5)))
      (a!2 (and (= (sel |var__temp_h'522| res) var__temp_v521)
                (= (sel |var__temp_h'522| res) (+ (sel var__temp_h520 res) 2)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'522| res) var__temp_v521)
                    (= (sel |var__temp_h'522| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h520 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************136
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v503:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v503:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i502 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i502, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v524:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************137
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i502 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i502, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v524:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i502 --->  Ty_heap  
 var_h501 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h525 --->  Ty_heap  
 var__temp_v526 --->  Ty_int  
 var__temp_h'527 --->  Ty_heap  
 var__temp_v_err528 --->  error  
 var_h501 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h525, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h525, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h525, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'527, res ) ==(var__temp_v526) AND 
 	 Rel (sel)( , var__temp_h'527, res ) ==((sel)( , var__temp_h525, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i502 T2040)
(declare-const var_h501 T2040)
(declare-const v Int)
(declare-const var_h_i43 T2040)
(declare-const var_h42 T2040)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h525 T2040)
(declare-const var__temp_v526 Int)
(declare-const |var__temp_h'527| T2040)
(declare-const var__temp_v_err528 T2041)
(declare-const var_h501 T2040)
(declare-const var_h42 T2040)
(declare-const err T2054)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2040)
(declare-fun sel (T2040 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T2040)
(declare-fun |20| () Int)
(declare-fun var__temp_h525 () T2040)
(declare-fun |var__temp_h'527| () T2040)
(declare-fun var__temp_v526 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h525 res) v) (= v |20|))
               (= (sel var__temp_h525 res) 7)))
      (a!2 (and (= (sel |var__temp_h'527| res) var__temp_v526)
                (= (sel |var__temp_h'527| res) (+ (sel var__temp_h525 res) 3)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h525 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************138
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i502 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i502, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v524:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i502 --->  Ty_heap  
 var_h501 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h529 --->  Ty_heap  
 var__temp_v530 --->  Ty_int  
 var__temp_h'531 --->  Ty_heap  
 var__temp_v_err532 --->  error  
 var_h501 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h529, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h529, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h529, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'531, res ) ==(var__temp_v530) AND 
 	 Rel (sel)( , var__temp_h'531, res ) ==((sel)( , var__temp_h529, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i502 T2057)
(declare-const var_h501 T2057)
(declare-const v Int)
(declare-const var_h_i43 T2057)
(declare-const var_h42 T2057)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h529 T2057)
(declare-const var__temp_v530 Int)
(declare-const |var__temp_h'531| T2057)
(declare-const var__temp_v_err532 T2058)
(declare-const var_h501 T2057)
(declare-const var_h42 T2057)
(declare-const err T2071)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2057)
(declare-fun sel (T2057 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T2057)
(declare-fun |20| () Int)
(declare-fun var__temp_h529 () T2057)
(declare-fun |var__temp_h'531| () T2057)
(declare-fun var__temp_v530 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h529 res) v) (= v |20|))
               (= (sel var__temp_h529 res) 7)))
      (a!2 (and (= (sel |var__temp_h'531| res) var__temp_v530)
                (= (sel |var__temp_h'531| res) (+ (sel var__temp_h529 res) 5)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h529 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************139
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i502 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i502, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v524:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i502 --->  Ty_heap  
 var_h501 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h533 --->  Ty_heap  
 var__temp_v534 --->  Ty_int  
 var__temp_h'535 --->  Ty_heap  
 var__temp_v_err536 --->  error  
 var_h501 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h533, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h533, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h533, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'535, res ) ==(var__temp_v534) AND 
 	 Rel (sel)( , var__temp_h'535, res ) ==((sel)( , var__temp_h533, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i502 T2074)
(declare-const var_h501 T2074)
(declare-const v Int)
(declare-const var_h_i43 T2074)
(declare-const var_h42 T2074)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h533 T2074)
(declare-const var__temp_v534 Int)
(declare-const |var__temp_h'535| T2074)
(declare-const var__temp_v_err536 T2075)
(declare-const var_h501 T2074)
(declare-const var_h42 T2074)
(declare-const err T2088)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2074)
(declare-fun sel (T2074 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T2074)
(declare-fun |20| () Int)
(declare-fun var__temp_h533 () T2074)
(declare-fun |var__temp_h'535| () T2074)
(declare-fun var__temp_v534 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h533 res) v) (= v |20|))
               (> (sel var__temp_h533 res) 4)))
      (a!2 (and (= (sel |var__temp_h'535| res) var__temp_v534)
                (= (sel |var__temp_h'535| res) (+ (sel var__temp_h533 res) 10)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h533 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c2
PARTIAL PATH NEW
NEW 	 --c3'	 --foo'	 --c2
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i538 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i538 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i538, res ) ==(v)
 	 , (sel)( , var_h_i538, res ) ==((sel)( , var_h537, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v539:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i538 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************140
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i538 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i538, res ) ==(v)
 	 , (sel)( , var_h_i538, res ) ==((sel)( , var_h537, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v539:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i538 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i538 --->  Ty_heap  
 var_h537 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i502 --->  Ty_heap  
 var_h501 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h540 --->  Ty_heap  
 var__temp_v541 --->  Ty_int  
 var__temp_h'542 --->  Ty_heap  
 var__temp_v_err543 --->  error  
 var_h537 --->  Ty_heap  
 var_h501 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h537, res ) > (4) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h540, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h540, res ) ==((sel)( , var_h537, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h540, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h540, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'542, res ) ==(var__temp_v541) AND 
 	 Rel (sel)( , var__temp_h'542, res ) ==((sel)( , var__temp_h540, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'542, res ) ==(var__temp_v541) AND 
 	 Rel (sel)( , var__temp_h'542, res ) ==(10)
 
VC_END(declare-const var_h_i538 T2091)
(declare-const var_h537 T2091)
(declare-const v Int)
(declare-const var_h_i502 T2091)
(declare-const var_h501 T2091)
(declare-const v Int)
(declare-const var_h_i43 T2091)
(declare-const var_h42 T2091)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h540 T2091)
(declare-const var__temp_v541 Int)
(declare-const |var__temp_h'542| T2091)
(declare-const var__temp_v_err543 T2092)
(declare-const var_h537 T2091)
(declare-const var_h501 T2091)
(declare-const var_h42 T2091)
(declare-const err T2105)

solver 
 (declare-sort T2091)
(declare-fun sel (T2091 Int) Int)
(declare-fun res () Int)
(declare-fun var_h537 () T2091)
(declare-fun var_h42 () T2091)
(declare-fun |var__temp_h'542| () T2091)
(declare-fun var__temp_v541 () Int)
(declare-fun var__temp_h540 () T2091)
(declare-fun v () Int)
(assert (> (sel var_h537 res) 4))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h540 res) v)
                (= (sel var__temp_h540 res) (+ (sel var_h537 res) 10))))
      (a!2 (and (= (sel |var__temp_h'542| res) var__temp_v541)
                (= (sel |var__temp_h'542| res) (+ (sel var__temp_h540 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'542| res) var__temp_v541)
                    (= (sel |var__temp_h'542| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h540 res) 7))
                (=> (= (sel var__temp_h540 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************141
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i538 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i538, res ) ==(v)
 	 , (sel)( , var_h_i538, res ) ==((sel)( , var_h537, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v539:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i538 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i538 --->  Ty_heap  
 var_h537 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i502 --->  Ty_heap  
 var_h501 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h544 --->  Ty_heap  
 var__temp_v545 --->  Ty_int  
 var__temp_h'546 --->  Ty_heap  
 var__temp_v_err547 --->  error  
 var_h537 --->  Ty_heap  
 var_h501 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h537, res ) > (4) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h544, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h544, res ) ==((sel)( , var_h537, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h544, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h544, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'546, res ) ==(var__temp_v545) AND 
 	 Rel (sel)( , var__temp_h'546, res ) ==((sel)( , var__temp_h544, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'546, res ) ==(var__temp_v545) AND 
 	 Rel (sel)( , var__temp_h'546, res ) ==(10)
 
VC_END(declare-const var_h_i538 T2108)
(declare-const var_h537 T2108)
(declare-const v Int)
(declare-const var_h_i502 T2108)
(declare-const var_h501 T2108)
(declare-const v Int)
(declare-const var_h_i43 T2108)
(declare-const var_h42 T2108)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h544 T2108)
(declare-const var__temp_v545 Int)
(declare-const |var__temp_h'546| T2108)
(declare-const var__temp_v_err547 T2109)
(declare-const var_h537 T2108)
(declare-const var_h501 T2108)
(declare-const var_h42 T2108)
(declare-const err T2122)

solver 
 (declare-sort T2108)
(declare-fun sel (T2108 Int) Int)
(declare-fun res () Int)
(declare-fun var_h537 () T2108)
(declare-fun var_h42 () T2108)
(declare-fun |var__temp_h'546| () T2108)
(declare-fun var__temp_v545 () Int)
(declare-fun var__temp_h544 () T2108)
(declare-fun v () Int)
(assert (> (sel var_h537 res) 4))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h544 res) v)
                (= (sel var__temp_h544 res) (+ (sel var_h537 res) 10))))
      (a!2 (and (= (sel |var__temp_h'546| res) var__temp_v545)
                (= (sel |var__temp_h'546| res) (+ (sel var__temp_h544 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'546| res) var__temp_v545)
                    (= (sel |var__temp_h'546| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h544 res) 7))
                (=> (= (sel var__temp_h544 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************142
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i538 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i538, res ) ==(v)
 	 , (sel)( , var_h_i538, res ) ==((sel)( , var_h537, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v539:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i538 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i538 --->  Ty_heap  
 var_h537 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i502 --->  Ty_heap  
 var_h501 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h548 --->  Ty_heap  
 var__temp_v549 --->  Ty_int  
 var__temp_h'550 --->  Ty_heap  
 var__temp_v_err551 --->  error  
 var_h537 --->  Ty_heap  
 var_h501 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h537, res ) > (4) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h548, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h548, res ) ==((sel)( , var_h537, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h548, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h548, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'550, res ) ==(var__temp_v549) AND 
 	 Base var__temp_v549 = 5 => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'550, res ) ==(var__temp_v549) AND 
 	 Rel (sel)( , var__temp_h'550, res ) ==(10)
 
VC_END(declare-const var_h_i538 T2125)
(declare-const var_h537 T2125)
(declare-const v Int)
(declare-const var_h_i502 T2125)
(declare-const var_h501 T2125)
(declare-const v Int)
(declare-const var_h_i43 T2125)
(declare-const var_h42 T2125)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h548 T2125)
(declare-const var__temp_v549 Int)
(declare-const |var__temp_h'550| T2125)
(declare-const var__temp_v_err551 T2126)
(declare-const var_h537 T2125)
(declare-const var_h501 T2125)
(declare-const var_h42 T2125)
(declare-const err T2139)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2125)
(declare-fun sel (T2125 Int) Int)
(declare-fun res () Int)
(declare-fun var_h537 () T2125)
(declare-fun var_h42 () T2125)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'550| () T2125)
(declare-fun var__temp_v549 () Int)
(declare-fun var__temp_h548 () T2125)
(declare-fun v () Int)
(assert (> (sel var_h537 res) 4))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h548 res) v)
                (= (sel var__temp_h548 res) (+ (sel var_h537 res) 10))))
      (a!2 (=> (and (= (sel |var__temp_h'550| res) var__temp_v549)
                    (= var__temp_v549 |5|))
               (and (= (sel |var__temp_h'550| res) var__temp_v549)
                    (= (sel |var__temp_h'550| res) 10)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h548 res) 0))
                (=> (= (sel var__temp_h548 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************143
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i538 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i538, res ) ==(v)
 	 , (sel)( , var_h_i538, res ) ==((sel)( , var_h537, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v539:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i538 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i538 --->  Ty_heap  
 var_h537 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i502 --->  Ty_heap  
 var_h501 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h552 --->  Ty_heap  
 var__temp_v553 --->  Ty_int  
 var__temp_h'554 --->  Ty_heap  
 var__temp_v_err555 --->  error  
 var_h537 --->  Ty_heap  
 var_h501 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h537, res ) > (4) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h552, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h552, res ) ==((sel)( , var_h537, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h552, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h552, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'554, res ) ==(var__temp_v553) AND 
 	 Rel (sel)( , var__temp_h'554, res ) ==((sel)( , var__temp_h552, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'554, res ) ==(var__temp_v553) AND 
 	 Rel (sel)( , var__temp_h'554, res ) ==(10)
 
VC_END(declare-const var_h_i538 T2142)
(declare-const var_h537 T2142)
(declare-const v Int)
(declare-const var_h_i502 T2142)
(declare-const var_h501 T2142)
(declare-const v Int)
(declare-const var_h_i43 T2142)
(declare-const var_h42 T2142)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h552 T2142)
(declare-const var__temp_v553 Int)
(declare-const |var__temp_h'554| T2142)
(declare-const var__temp_v_err555 T2143)
(declare-const var_h537 T2142)
(declare-const var_h501 T2142)
(declare-const var_h42 T2142)
(declare-const err T2156)

solver 
 (declare-sort T2142)
(declare-fun sel (T2142 Int) Int)
(declare-fun res () Int)
(declare-fun var_h537 () T2142)
(declare-fun var_h42 () T2142)
(declare-fun |var__temp_h'554| () T2142)
(declare-fun var__temp_v553 () Int)
(declare-fun var__temp_h552 () T2142)
(declare-fun v () Int)
(assert (> (sel var_h537 res) 4))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h552 res) v)
                (= (sel var__temp_h552 res) (+ (sel var_h537 res) 10))))
      (a!2 (and (= (sel |var__temp_h'554| res) var__temp_v553)
                (= (sel |var__temp_h'554| res) (+ (sel var__temp_h552 res) 2)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'554| res) var__temp_v553)
                    (= (sel |var__temp_h'554| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h552 res) 5))
                (=> (= (sel var__temp_h552 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************144
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v539:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v539:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --foo'	 --c2
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i538 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i538, res ) ==(v)
 	 , (sel)( , var_h_i538, res ) ==((sel)( , var_h537, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v556:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************145
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i538 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i538, res ) ==(v)
 	 , (sel)( , var_h_i538, res ) ==((sel)( , var_h537, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v556:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i538 --->  Ty_heap  
 var_h537 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i502 --->  Ty_heap  
 var_h501 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h557 --->  Ty_heap  
 var__temp_v558 --->  Ty_int  
 var__temp_h'559 --->  Ty_heap  
 var__temp_v_err560 --->  error  
 var_h537 --->  Ty_heap  
 var_h501 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h537, res ) > (4) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h557, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h557, res ) ==((sel)( , var_h537, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h557, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h557, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'559, res ) ==(var__temp_v558) AND 
 	 Rel (sel)( , var__temp_h'559, res ) ==((sel)( , var__temp_h557, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i538 T2159)
(declare-const var_h537 T2159)
(declare-const v Int)
(declare-const var_h_i502 T2159)
(declare-const var_h501 T2159)
(declare-const v Int)
(declare-const var_h_i43 T2159)
(declare-const var_h42 T2159)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h557 T2159)
(declare-const var__temp_v558 Int)
(declare-const |var__temp_h'559| T2159)
(declare-const var__temp_v_err560 T2160)
(declare-const var_h537 T2159)
(declare-const var_h501 T2159)
(declare-const var_h42 T2159)
(declare-const err T2173)

solver 
 (declare-sort T2159)
(declare-fun sel (T2159 Int) Int)
(declare-fun res () Int)
(declare-fun var_h537 () T2159)
(declare-fun var_h42 () T2159)
(declare-fun var__temp_h557 () T2159)
(declare-fun |var__temp_h'559| () T2159)
(declare-fun var__temp_v558 () Int)
(declare-fun v () Int)
(assert (> (sel var_h537 res) 4))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h557 res) v)
                (= (sel var__temp_h557 res) (+ (sel var_h537 res) 10))))
      (a!2 (and (= (sel |var__temp_h'559| res) var__temp_v558)
                (= (sel |var__temp_h'559| res) (+ (sel var__temp_h557 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h557 res) 7))
                (=> (= (sel var__temp_h557 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************146
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i538 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i538, res ) ==(v)
 	 , (sel)( , var_h_i538, res ) ==((sel)( , var_h537, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v556:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i538 --->  Ty_heap  
 var_h537 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i502 --->  Ty_heap  
 var_h501 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h561 --->  Ty_heap  
 var__temp_v562 --->  Ty_int  
 var__temp_h'563 --->  Ty_heap  
 var__temp_v_err564 --->  error  
 var_h537 --->  Ty_heap  
 var_h501 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h537, res ) > (4) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h561, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h561, res ) ==((sel)( , var_h537, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h561, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h561, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'563, res ) ==(var__temp_v562) AND 
 	 Rel (sel)( , var__temp_h'563, res ) ==((sel)( , var__temp_h561, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i538 T2176)
(declare-const var_h537 T2176)
(declare-const v Int)
(declare-const var_h_i502 T2176)
(declare-const var_h501 T2176)
(declare-const v Int)
(declare-const var_h_i43 T2176)
(declare-const var_h42 T2176)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h561 T2176)
(declare-const var__temp_v562 Int)
(declare-const |var__temp_h'563| T2176)
(declare-const var__temp_v_err564 T2177)
(declare-const var_h537 T2176)
(declare-const var_h501 T2176)
(declare-const var_h42 T2176)
(declare-const err T2190)

solver 
 (declare-sort T2176)
(declare-fun sel (T2176 Int) Int)
(declare-fun res () Int)
(declare-fun var_h537 () T2176)
(declare-fun var_h42 () T2176)
(declare-fun var__temp_h561 () T2176)
(declare-fun |var__temp_h'563| () T2176)
(declare-fun var__temp_v562 () Int)
(declare-fun v () Int)
(assert (> (sel var_h537 res) 4))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h561 res) v)
                (= (sel var__temp_h561 res) (+ (sel var_h537 res) 10))))
      (a!2 (and (= (sel |var__temp_h'563| res) var__temp_v562)
                (= (sel |var__temp_h'563| res) (+ (sel var__temp_h561 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h561 res) 7))
                (=> (= (sel var__temp_h561 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************147
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i538 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i538, res ) ==(v)
 	 , (sel)( , var_h_i538, res ) ==((sel)( , var_h537, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v556:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i538 --->  Ty_heap  
 var_h537 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i502 --->  Ty_heap  
 var_h501 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h565 --->  Ty_heap  
 var__temp_v566 --->  Ty_int  
 var__temp_h'567 --->  Ty_heap  
 var__temp_v_err568 --->  error  
 var_h537 --->  Ty_heap  
 var_h501 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h537, res ) > (4) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h565, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h565, res ) ==((sel)( , var_h537, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h565, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h565, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'567, res ) ==(var__temp_v566) AND 
 	 Base var__temp_v566 = 5 => 
 	 True
 
VC_END(declare-const var_h_i538 T2193)
(declare-const var_h537 T2193)
(declare-const v Int)
(declare-const var_h_i502 T2193)
(declare-const var_h501 T2193)
(declare-const v Int)
(declare-const var_h_i43 T2193)
(declare-const var_h42 T2193)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h565 T2193)
(declare-const var__temp_v566 Int)
(declare-const |var__temp_h'567| T2193)
(declare-const var__temp_v_err568 T2194)
(declare-const var_h537 T2193)
(declare-const var_h501 T2193)
(declare-const var_h42 T2193)
(declare-const err T2207)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2193)
(declare-fun sel (T2193 Int) Int)
(declare-fun res () Int)
(declare-fun var_h537 () T2193)
(declare-fun var_h42 () T2193)
(declare-fun |5| () Int)
(declare-fun var__temp_v566 () Int)
(declare-fun |var__temp_h'567| () T2193)
(declare-fun var__temp_h565 () T2193)
(declare-fun v () Int)
(assert (> (sel var_h537 res) 4))
(assert (not (> (sel var_h42 res) 8)))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h565 res) v)
                (= (sel var__temp_h565 res) (+ (sel var_h537 res) 10))))
      (a!2 (=> (and (= (sel |var__temp_h'567| res) var__temp_v566)
                    (= var__temp_v566 |5|))
               true)))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h565 res) 0))
                (=> (= (sel var__temp_h565 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************148
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i538 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i538, res ) ==(v)
 	 , (sel)( , var_h_i538, res ) ==((sel)( , var_h537, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v556:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i538 --->  Ty_heap  
 var_h537 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i502 --->  Ty_heap  
 var_h501 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h569 --->  Ty_heap  
 var__temp_v570 --->  Ty_int  
 var__temp_h'571 --->  Ty_heap  
 var__temp_v_err572 --->  error  
 var_h537 --->  Ty_heap  
 var_h501 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h537, res ) > (4) AND 
 	 Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h569, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h569, res ) ==((sel)( , var_h537, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h569, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h569, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'571, res ) ==(var__temp_v570) AND 
 	 Rel (sel)( , var__temp_h'571, res ) ==((sel)( , var__temp_h569, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i538 T2210)
(declare-const var_h537 T2210)
(declare-const v Int)
(declare-const var_h_i502 T2210)
(declare-const var_h501 T2210)
(declare-const v Int)
(declare-const var_h_i43 T2210)
(declare-const var_h42 T2210)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h569 T2210)
(declare-const var__temp_v570 Int)
(declare-const |var__temp_h'571| T2210)
(declare-const var__temp_v_err572 T2211)
(declare-const var_h537 T2210)
(declare-const var_h501 T2210)
(declare-const var_h42 T2210)
(declare-const err T2224)

solver 
 (declare-sort T2210)
(declare-fun sel (T2210 Int) Int)
(declare-fun res () Int)
(declare-fun var_h537 () T2210)
(declare-fun var_h42 () T2210)
(declare-fun var__temp_h569 () T2210)
(declare-fun |var__temp_h'571| () T2210)
(declare-fun var__temp_v570 () Int)
(declare-fun v () Int)
(assert (> (sel var_h537 res) 4))
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h569 res) v)
                (= (sel var__temp_h569 res) (+ (sel var_h537 res) 10))))
      (a!2 (and (= (sel |var__temp_h'571| res) var__temp_v570)
                (= (sel |var__temp_h'571| res) (+ (sel var__temp_h569 res) 2)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h569 res) 5))
                (=> (= (sel var__temp_h569 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************149
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 	 --c3'	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i502 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i502, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v573:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************150
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i502 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i502, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v573:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i502 --->  Ty_heap  
 var_h501 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h574 --->  Ty_heap  
 var__temp_v575 --->  Ty_int  
 var__temp_h'576 --->  Ty_heap  
 var__temp_v_err577 --->  error  
 var_h501 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h574, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h574, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h574, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'576, res ) ==(var__temp_v575) AND 
 	 Rel (sel)( , var__temp_h'576, res ) ==((sel)( , var__temp_h574, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i502 T2227)
(declare-const var_h501 T2227)
(declare-const v Int)
(declare-const var_h_i43 T2227)
(declare-const var_h42 T2227)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h574 T2227)
(declare-const var__temp_v575 Int)
(declare-const |var__temp_h'576| T2227)
(declare-const var__temp_v_err577 T2228)
(declare-const var_h501 T2227)
(declare-const var_h42 T2227)
(declare-const err T2241)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2227)
(declare-fun sel (T2227 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T2227)
(declare-fun |20| () Int)
(declare-fun var__temp_h574 () T2227)
(declare-fun |var__temp_h'576| () T2227)
(declare-fun var__temp_v575 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h574 res) v) (= v |20|))
               (= (sel var__temp_h574 res) 7)))
      (a!2 (and (= (sel |var__temp_h'576| res) var__temp_v575)
                (= (sel |var__temp_h'576| res) (+ (sel var__temp_h574 res) 3)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h574 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************151
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i502 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i502, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v573:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i502 --->  Ty_heap  
 var_h501 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h578 --->  Ty_heap  
 var__temp_v579 --->  Ty_int  
 var__temp_h'580 --->  Ty_heap  
 var__temp_v_err581 --->  error  
 var_h501 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h578, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h578, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h578, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'580, res ) ==(var__temp_v579) AND 
 	 Rel (sel)( , var__temp_h'580, res ) ==((sel)( , var__temp_h578, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i502 T2244)
(declare-const var_h501 T2244)
(declare-const v Int)
(declare-const var_h_i43 T2244)
(declare-const var_h42 T2244)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h578 T2244)
(declare-const var__temp_v579 Int)
(declare-const |var__temp_h'580| T2244)
(declare-const var__temp_v_err581 T2245)
(declare-const var_h501 T2244)
(declare-const var_h42 T2244)
(declare-const err T2258)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2244)
(declare-fun sel (T2244 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T2244)
(declare-fun |20| () Int)
(declare-fun var__temp_h578 () T2244)
(declare-fun |var__temp_h'580| () T2244)
(declare-fun var__temp_v579 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h578 res) v) (= v |20|))
               (= (sel var__temp_h578 res) 7)))
      (a!2 (and (= (sel |var__temp_h'580| res) var__temp_v579)
                (= (sel |var__temp_h'580| res) (+ (sel var__temp_h578 res) 5)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h578 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************152
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i502 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i502, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v573:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i502 --->  Ty_heap  
 var_h501 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h582 --->  Ty_heap  
 var__temp_v583 --->  Ty_int  
 var__temp_h'584 --->  Ty_heap  
 var__temp_v_err585 --->  error  
 var_h501 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h582, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h582, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h582, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'584, res ) ==(var__temp_v583) AND 
 	 Base var__temp_v583 = 5 => 
 	 True
 
VC_END(declare-const var_h_i502 T2261)
(declare-const var_h501 T2261)
(declare-const v Int)
(declare-const var_h_i43 T2261)
(declare-const var_h42 T2261)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h582 T2261)
(declare-const var__temp_v583 Int)
(declare-const |var__temp_h'584| T2261)
(declare-const var__temp_v_err585 T2262)
(declare-const var_h501 T2261)
(declare-const var_h42 T2261)
(declare-const err T2275)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T2261)
(declare-fun sel (T2261 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T2261)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_v583 () Int)
(declare-fun |var__temp_h'584| () T2261)
(declare-fun var__temp_h582 () T2261)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h582 res) v) (= v |20|))
               (= (sel var__temp_h582 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'584| res) var__temp_v583)
                    (= var__temp_v583 |5|))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h582 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************153
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i502 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i502, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v573:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i502 --->  Ty_heap  
 var_h501 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h586 --->  Ty_heap  
 var__temp_v587 --->  Ty_int  
 var__temp_h'588 --->  Ty_heap  
 var__temp_v_err589 --->  error  
 var_h501 --->  Ty_heap  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h586, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h586, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h586, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'588, res ) ==(var__temp_v587) AND 
 	 Rel (sel)( , var__temp_h'588, res ) ==((sel)( , var__temp_h586, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i502 T2278)
(declare-const var_h501 T2278)
(declare-const v Int)
(declare-const var_h_i43 T2278)
(declare-const var_h42 T2278)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h586 T2278)
(declare-const var__temp_v587 Int)
(declare-const |var__temp_h'588| T2278)
(declare-const var__temp_v_err589 T2279)
(declare-const var_h501 T2278)
(declare-const var_h42 T2278)
(declare-const err T2292)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2278)
(declare-fun sel (T2278 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T2278)
(declare-fun |20| () Int)
(declare-fun var__temp_h586 () T2278)
(declare-fun |var__temp_h'588| () T2278)
(declare-fun var__temp_v587 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h586 res) v) (= v |20|))
               (= (sel var__temp_h586 res) 5)))
      (a!2 (and (= (sel |var__temp_h'588| res) var__temp_v587)
                (= (sel |var__temp_h'588| res) (+ (sel var__temp_h586 res) 2)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h586 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************154
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i43 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i43, res ) ==(v)
 	 , (sel)( , var_h_i43, res ) ==((sel)( , var_h42, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v590:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************155
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i43 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i43, res ) ==(v)
 	 , (sel)( , var_h_i43, res ) ==((sel)( , var_h42, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v590:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h591 --->  Ty_heap  
 var__temp_v592 --->  Ty_int  
 var__temp_h'593 --->  Ty_heap  
 var__temp_v_err594 --->  error  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h591, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h591, res ) ==((sel)( , var_h42, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h591, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h591, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'593, res ) ==(var__temp_v592) AND 
 	 Rel (sel)( , var__temp_h'593, res ) ==((sel)( , var__temp_h591, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i43 T2295)
(declare-const var_h42 T2295)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h591 T2295)
(declare-const var__temp_v592 Int)
(declare-const |var__temp_h'593| T2295)
(declare-const var__temp_v_err594 T2296)
(declare-const var_h42 T2295)
(declare-const err T2309)

solver 
 (declare-sort T2295)
(declare-fun sel (T2295 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T2295)
(declare-fun var__temp_h591 () T2295)
(declare-fun |var__temp_h'593| () T2295)
(declare-fun var__temp_v592 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h591 res) v)
                (= (sel var__temp_h591 res) (+ (sel var_h42 res) 3))))
      (a!2 (and (= (sel |var__temp_h'593| res) var__temp_v592)
                (= (sel |var__temp_h'593| res) (+ (sel var__temp_h591 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h591 res) 7))
                (=> (= (sel var__temp_h591 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************156
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i43 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i43, res ) ==(v)
 	 , (sel)( , var_h_i43, res ) ==((sel)( , var_h42, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v590:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h595 --->  Ty_heap  
 var__temp_v596 --->  Ty_int  
 var__temp_h'597 --->  Ty_heap  
 var__temp_v_err598 --->  error  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h595, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h595, res ) ==((sel)( , var_h42, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h595, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h595, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'597, res ) ==(var__temp_v596) AND 
 	 Rel (sel)( , var__temp_h'597, res ) ==((sel)( , var__temp_h595, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i43 T2312)
(declare-const var_h42 T2312)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h595 T2312)
(declare-const var__temp_v596 Int)
(declare-const |var__temp_h'597| T2312)
(declare-const var__temp_v_err598 T2313)
(declare-const var_h42 T2312)
(declare-const err T2326)

solver 
 (declare-sort T2312)
(declare-fun sel (T2312 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T2312)
(declare-fun var__temp_h595 () T2312)
(declare-fun |var__temp_h'597| () T2312)
(declare-fun var__temp_v596 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h595 res) v)
                (= (sel var__temp_h595 res) (+ (sel var_h42 res) 3))))
      (a!2 (and (= (sel |var__temp_h'597| res) var__temp_v596)
                (= (sel |var__temp_h'597| res) (+ (sel var__temp_h595 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h595 res) 7))
                (=> (= (sel var__temp_h595 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************157
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i43 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i43, res ) ==(v)
 	 , (sel)( , var_h_i43, res ) ==((sel)( , var_h42, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v590:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h599 --->  Ty_heap  
 var__temp_v600 --->  Ty_int  
 var__temp_h'601 --->  Ty_heap  
 var__temp_v_err602 --->  error  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h599, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h599, res ) ==((sel)( , var_h42, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h599, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h599, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'601, res ) ==(var__temp_v600) AND 
 	 Rel (sel)( , var__temp_h'601, res ) ==((sel)( , var__temp_h599, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i43 T2329)
(declare-const var_h42 T2329)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h599 T2329)
(declare-const var__temp_v600 Int)
(declare-const |var__temp_h'601| T2329)
(declare-const var__temp_v_err602 T2330)
(declare-const var_h42 T2329)
(declare-const err T2343)

solver 
 (declare-sort T2329)
(declare-fun sel (T2329 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T2329)
(declare-fun var__temp_h599 () T2329)
(declare-fun |var__temp_h'601| () T2329)
(declare-fun var__temp_v600 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h599 res) v)
                (= (sel var__temp_h599 res) (+ (sel var_h42 res) 3))))
      (a!2 (and (= (sel |var__temp_h'601| res) var__temp_v600)
                (= (sel |var__temp_h'601| res) (+ (sel var__temp_h599 res) 10)))))
(let ((a!3 (and (=> a!1 (> (sel var__temp_h599 res) 4))
                (=> (> (sel var__temp_h599 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************158
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i43 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i43, res ) ==(v)
 	 , (sel)( , var_h_i43, res ) ==((sel)( , var_h42, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v590:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h603 --->  Ty_heap  
 var__temp_v604 --->  Ty_int  
 var__temp_h'605 --->  Ty_heap  
 var__temp_v_err606 --->  error  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h603, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h603, res ) ==((sel)( , var_h42, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h603, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h603, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'605, res ) ==(var__temp_v604) AND 
 	 Base var__temp_v604 = 5 => 
 	 True
 
VC_END(declare-const var_h_i43 T2346)
(declare-const var_h42 T2346)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h603 T2346)
(declare-const var__temp_v604 Int)
(declare-const |var__temp_h'605| T2346)
(declare-const var__temp_v_err606 T2347)
(declare-const var_h42 T2346)
(declare-const err T2360)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2346)
(declare-fun sel (T2346 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T2346)
(declare-fun |5| () Int)
(declare-fun var__temp_v604 () Int)
(declare-fun |var__temp_h'605| () T2346)
(declare-fun var__temp_h603 () T2346)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h603 res) v)
                (= (sel var__temp_h603 res) (+ (sel var_h42 res) 3))))
      (a!2 (=> (and (= (sel |var__temp_h'605| res) var__temp_v604)
                    (= var__temp_v604 |5|))
               true)))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h603 res) 0))
                (=> (= (sel var__temp_h603 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************159
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i43 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i43, res ) ==(v)
 	 , (sel)( , var_h_i43, res ) ==((sel)( , var_h42, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v590:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i43 --->  Ty_heap  
 var_h42 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h607 --->  Ty_heap  
 var__temp_v608 --->  Ty_int  
 var__temp_h'609 --->  Ty_heap  
 var__temp_v_err610 --->  error  
 var_h42 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h42, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h607, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h607, res ) ==((sel)( , var_h42, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h607, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h607, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'609, res ) ==(var__temp_v608) AND 
 	 Rel (sel)( , var__temp_h'609, res ) ==((sel)( , var__temp_h607, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i43 T2363)
(declare-const var_h42 T2363)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h607 T2363)
(declare-const var__temp_v608 Int)
(declare-const |var__temp_h'609| T2363)
(declare-const var__temp_v_err610 T2364)
(declare-const var_h42 T2363)
(declare-const err T2377)

solver 
 (declare-sort T2363)
(declare-fun sel (T2363 Int) Int)
(declare-fun res () Int)
(declare-fun var_h42 () T2363)
(declare-fun var__temp_h607 () T2363)
(declare-fun |var__temp_h'609| () T2363)
(declare-fun var__temp_v608 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h42 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h607 res) v)
                (= (sel var__temp_h607 res) (+ (sel var_h42 res) 3))))
      (a!2 (and (= (sel |var__temp_h'609| res) var__temp_v608)
                (= (sel |var__temp_h'609| res) (+ (sel var__temp_h607 res) 2)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h607 res) 5))
                (=> (= (sel var__temp_h607 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************160
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo'
PARTIAL PATH
SUB 
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {var_v611:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c4
c2'
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************161
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {var_v611:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h612 --->  Ty_heap  
 var__temp_v613 --->  Ty_int  
 var__temp_h'614 --->  Ty_heap  
 var__temp_v_err615 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h612, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h612, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h612, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'614, res ) ==(var__temp_v613) AND 
 	 Rel (sel)( , var__temp_h'614, res ) ==((sel)( , var__temp_h612, res ) + (3)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h612 T2380)
(declare-const var__temp_v613 Int)
(declare-const |var__temp_h'614| T2380)
(declare-const var__temp_v_err615 T2381)
(declare-const err T2394)

solver 
 (declare-sort T2380)
(declare-fun sel (T2380 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h612 () T2380)
(declare-fun |var__temp_h'614| () T2380)
(declare-fun var__temp_v613 () Int)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'614| res) var__temp_v613)
                (= (sel |var__temp_h'614| res) (+ (sel var__temp_h612 res) 3)))))
(let ((a!2 (and (=> (= (sel var__temp_h612 res) 0)
                    (= (sel var__temp_h612 res) 7))
                (=> (= (sel var__temp_h612 res) 7) (=> a!1 true)))))
  (not a!2))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************162
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {var_v611:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h616 --->  Ty_heap  
 var__temp_v617 --->  Ty_int  
 var__temp_h'618 --->  Ty_heap  
 var__temp_v_err619 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h616, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h616, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h616, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'618, res ) ==(var__temp_v617) AND 
 	 Rel (sel)( , var__temp_h'618, res ) ==((sel)( , var__temp_h616, res ) + (5)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h616 T2397)
(declare-const var__temp_v617 Int)
(declare-const |var__temp_h'618| T2397)
(declare-const var__temp_v_err619 T2398)
(declare-const err T2411)

solver 
 (declare-sort T2397)
(declare-fun sel (T2397 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h616 () T2397)
(declare-fun |var__temp_h'618| () T2397)
(declare-fun var__temp_v617 () Int)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'618| res) var__temp_v617)
                (= (sel |var__temp_h'618| res) (+ (sel var__temp_h616 res) 5)))))
(let ((a!2 (and (=> (= (sel var__temp_h616 res) 0)
                    (= (sel var__temp_h616 res) 7))
                (=> (= (sel var__temp_h616 res) 7) (=> a!1 true)))))
  (not a!2))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************163
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (30) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {var_v611:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h620 --->  Ty_heap  
 var__temp_v621 --->  Ty_int  
 var__temp_h'622 --->  Ty_heap  
 var__temp_v_err623 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h620, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h620, res ) > (30) AND 
 	 Rel (sel)( , var__temp_h620, res ) > (30) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'622, res ) ==(var__temp_v621) AND 
 	 Rel (sel)( , var__temp_h'622, res ) ==((sel)( , var__temp_h620, res ) + (5)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h620 T2414)
(declare-const var__temp_v621 Int)
(declare-const |var__temp_h'622| T2414)
(declare-const var__temp_v_err623 T2415)
(declare-const err T2428)

solver 
 (declare-sort T2414)
(declare-fun sel (T2414 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h620 () T2414)
(declare-fun |var__temp_h'622| () T2414)
(declare-fun var__temp_v621 () Int)
(assert true)
(assert (let ((a!1 (=> (= (sel var__temp_h620 res) 0)
               (not (> (sel var__temp_h620 res) 30))))
      (a!2 (and (= (sel |var__temp_h'622| res) var__temp_v621)
                (= (sel |var__temp_h'622| res) (+ (sel var__temp_h620 res) 5)))))
(let ((a!3 (=> (not (> (sel var__temp_h620 res) 30)) (=> a!2 true))))
  (not (and a!1 a!3)))))

***************Selection Successful************c4
PARTIAL PATH NEW
NEW 	 --c4
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i625 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i625 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i625, res ) ==(v)
 	 , (sel)( , var_h_i625, res ) ==((sel)( , var_h624, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v626:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i625 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************164
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i625 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i625, res ) ==(v)
 	 , (sel)( , var_h_i625, res ) ==((sel)( , var_h624, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v626:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i625 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h627 --->  Ty_heap  
 var__temp_v628 --->  Ty_int  
 var__temp_h'629 --->  Ty_heap  
 var__temp_v_err630 --->  error  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h627, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h627, res ) ==((sel)( , var_h624, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h627, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h627, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'629, res ) ==(var__temp_v628) AND 
 	 Rel (sel)( , var__temp_h'629, res ) ==((sel)( , var__temp_h627, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'629, res ) ==(var__temp_v628) AND 
 	 Rel (sel)( , var__temp_h'629, res ) ==(10)
 
VC_END(declare-const var_h_i625 T2431)
(declare-const var_h624 T2431)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h627 T2431)
(declare-const var__temp_v628 Int)
(declare-const |var__temp_h'629| T2431)
(declare-const var__temp_v_err630 T2432)
(declare-const var_h624 T2431)
(declare-const err T2445)

solver 
 (declare-sort T2431)
(declare-fun sel (T2431 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T2431)
(declare-fun |var__temp_h'629| () T2431)
(declare-fun var__temp_v628 () Int)
(declare-fun var__temp_h627 () T2431)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h627 res) v)
                (= (sel var__temp_h627 res) (+ (sel var_h624 res) 5))))
      (a!2 (and (= (sel |var__temp_h'629| res) var__temp_v628)
                (= (sel |var__temp_h'629| res) (+ (sel var__temp_h627 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'629| res) var__temp_v628)
                    (= (sel |var__temp_h'629| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h627 res) 7))
                (=> (= (sel var__temp_h627 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************165
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i625 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i625, res ) ==(v)
 	 , (sel)( , var_h_i625, res ) ==((sel)( , var_h624, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v626:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i625 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h631 --->  Ty_heap  
 var__temp_v632 --->  Ty_int  
 var__temp_h'633 --->  Ty_heap  
 var__temp_v_err634 --->  error  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h631, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h631, res ) ==((sel)( , var_h624, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h631, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h631, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'633, res ) ==(var__temp_v632) AND 
 	 Rel (sel)( , var__temp_h'633, res ) ==((sel)( , var__temp_h631, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'633, res ) ==(var__temp_v632) AND 
 	 Rel (sel)( , var__temp_h'633, res ) ==(10)
 
VC_END(declare-const var_h_i625 T2448)
(declare-const var_h624 T2448)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h631 T2448)
(declare-const var__temp_v632 Int)
(declare-const |var__temp_h'633| T2448)
(declare-const var__temp_v_err634 T2449)
(declare-const var_h624 T2448)
(declare-const err T2462)

solver 
 (declare-sort T2448)
(declare-fun sel (T2448 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T2448)
(declare-fun |var__temp_h'633| () T2448)
(declare-fun var__temp_v632 () Int)
(declare-fun var__temp_h631 () T2448)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h631 res) v)
                (= (sel var__temp_h631 res) (+ (sel var_h624 res) 5))))
      (a!2 (and (= (sel |var__temp_h'633| res) var__temp_v632)
                (= (sel |var__temp_h'633| res) (+ (sel var__temp_h631 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'633| res) var__temp_v632)
                    (= (sel |var__temp_h'633| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h631 res) 7))
                (=> (= (sel var__temp_h631 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************166
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h, res ) ==(sel)( , h, res ) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i625 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i625, res ) ==(v)
 	 , (sel)( , var_h_i625, res ) ==((sel)( , var_h624, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v626:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i625 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h, res ) ==(sel)( , h, res ) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h635 --->  Ty_heap  
 var__temp_v636 --->  Ty_int  
 var__temp_h'637 --->  Ty_heap  
 var__temp_v_err638 --->  error  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h635, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h635, res ) ==((sel)( , var_h624, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h635, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h635, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'637, res ) ==(var__temp_v636) AND 
 	 Rel (sel)( , var__temp_h635, res ) ==(sel)( , var__temp_h635, res ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'637, res ) ==(var__temp_v636) AND 
 	 Rel (sel)( , var__temp_h'637, res ) ==(10)
 
VC_END(declare-const var_h_i625 T2465)
(declare-const var_h624 T2465)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h635 T2465)
(declare-const var__temp_v636 Int)
(declare-const |var__temp_h'637| T2465)
(declare-const var__temp_v_err638 T2466)
(declare-const var_h624 T2465)
(declare-const err T2479)

solver 
 (declare-sort T2465)
(declare-fun sel (T2465 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T2465)
(declare-fun |var__temp_h'637| () T2465)
(declare-fun var__temp_v636 () Int)
(declare-fun var__temp_h635 () T2465)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h635 res) v)
                (= (sel var__temp_h635 res) (+ (sel var_h624 res) 5))))
      (a!3 (=> (and (= (sel |var__temp_h'637| res) var__temp_v636)
                    (= (sel var__temp_h635 res) (sel var__temp_h635 res)))
               (and (= (sel |var__temp_h'637| res) var__temp_v636)
                    (= (sel |var__temp_h'637| res) 10)))))
(let ((a!2 (=> a!1 (not (> (sel var__temp_h635 res) 20))))
      (a!4 (=> (not (> (sel var__temp_h635 res) 20)) a!3)))
  (not (and a!2 a!4)))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************167
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i625 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i625, res ) ==(v)
 	 , (sel)( , var_h_i625, res ) ==((sel)( , var_h624, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v626:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i625 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h639 --->  Ty_heap  
 var__temp_v640 --->  Ty_int  
 var__temp_h'641 --->  Ty_heap  
 var__temp_v_err642 --->  error  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h639, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h639, res ) ==((sel)( , var_h624, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h639, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h639, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'641, res ) ==(var__temp_v640) AND 
 	 Rel (sel)( , var__temp_h'641, res ) ==((sel)( , var__temp_h639, res ) + (10)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'641, res ) ==(var__temp_v640) AND 
 	 Rel (sel)( , var__temp_h'641, res ) ==(10)
 
VC_END(declare-const var_h_i625 T2482)
(declare-const var_h624 T2482)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h639 T2482)
(declare-const var__temp_v640 Int)
(declare-const |var__temp_h'641| T2482)
(declare-const var__temp_v_err642 T2483)
(declare-const var_h624 T2482)
(declare-const err T2496)

solver 
 (declare-sort T2482)
(declare-fun sel (T2482 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T2482)
(declare-fun |var__temp_h'641| () T2482)
(declare-fun var__temp_v640 () Int)
(declare-fun var__temp_h639 () T2482)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h639 res) v)
                (= (sel var__temp_h639 res) (+ (sel var_h624 res) 5))))
      (a!2 (and (= (sel |var__temp_h'641| res) var__temp_v640)
                (= (sel |var__temp_h'641| res) (+ (sel var__temp_h639 res) 10)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'641| res) var__temp_v640)
                    (= (sel |var__temp_h'641| res) 10)))))
(let ((a!4 (and (=> a!1 (> (sel var__temp_h639 res) 4))
                (=> (> (sel var__temp_h639 res) 4) a!3))))
  (not a!4)))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************168
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i625 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i625, res ) ==(v)
 	 , (sel)( , var_h_i625, res ) ==((sel)( , var_h624, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v626:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i625 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h643 --->  Ty_heap  
 var__temp_v644 --->  Ty_int  
 var__temp_h'645 --->  Ty_heap  
 var__temp_v_err646 --->  error  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h643, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h643, res ) ==((sel)( , var_h624, res ) + (5)) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'645, res ) ==(var__temp_v644) AND 
 	 Base var__temp_v644 = 20 => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'645, res ) ==(var__temp_v644) AND 
 	 Rel (sel)( , var__temp_h'645, res ) ==(10)
 
VC_END(declare-const var_h_i625 T2499)
(declare-const var_h624 T2499)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h643 T2499)
(declare-const var__temp_v644 Int)
(declare-const |var__temp_h'645| T2499)
(declare-const var__temp_v_err646 T2500)
(declare-const var_h624 T2499)
(declare-const err T2513)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2499)
(declare-fun sel (T2499 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T2499)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'645| () T2499)
(declare-fun var__temp_v644 () Int)
(declare-fun var__temp_h643 () T2499)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (and (= (sel var__temp_h643 res) v)
                (= (sel var__temp_h643 res) (+ (sel var_h624 res) 5))))
      (a!2 (=> (and (= (sel |var__temp_h'645| res) var__temp_v644)
                    (= var__temp_v644 |20|))
               (and (= (sel |var__temp_h'645| res) var__temp_v644)
                    (= (sel |var__temp_h'645| res) 10)))))
  (not (and (=> a!1 true) (=> true a!2)))))

***************Selection Failed************foo'
 *********************Enumeration Iteration*****************169
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i625 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i625, res ) ==(v)
 	 , (sel)( , var_h_i625, res ) ==((sel)( , var_h624, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v626:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i625 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h647 --->  Ty_heap  
 var__temp_v648 --->  Ty_int  
 var__temp_h'649 --->  Ty_heap  
 var__temp_v_err650 --->  error  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h647, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h647, res ) ==((sel)( , var_h624, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h647, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h647, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'649, res ) ==(var__temp_v648) AND 
 	 Base var__temp_v648 = 5 => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'649, res ) ==(var__temp_v648) AND 
 	 Rel (sel)( , var__temp_h'649, res ) ==(10)
 
VC_END(declare-const var_h_i625 T2516)
(declare-const var_h624 T2516)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h647 T2516)
(declare-const var__temp_v648 Int)
(declare-const |var__temp_h'649| T2516)
(declare-const var__temp_v_err650 T2517)
(declare-const var_h624 T2516)
(declare-const err T2530)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2516)
(declare-fun sel (T2516 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T2516)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'649| () T2516)
(declare-fun var__temp_v648 () Int)
(declare-fun var__temp_h647 () T2516)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h647 res) v)
                (= (sel var__temp_h647 res) (+ (sel var_h624 res) 5))))
      (a!2 (=> (and (= (sel |var__temp_h'649| res) var__temp_v648)
                    (= var__temp_v648 |5|))
               (and (= (sel |var__temp_h'649| res) var__temp_v648)
                    (= (sel |var__temp_h'649| res) 10)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h647 res) 0))
                (=> (= (sel var__temp_h647 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************170
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i625 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i625, res ) ==(v)
 	 , (sel)( , var_h_i625, res ) ==((sel)( , var_h624, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v626:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i625 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h651 --->  Ty_heap  
 var__temp_v652 --->  Ty_int  
 var__temp_h'653 --->  Ty_heap  
 var__temp_v_err654 --->  error  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h651, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h651, res ) ==((sel)( , var_h624, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h651, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h651, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'653, res ) ==(var__temp_v652) AND 
 	 Rel (sel)( , var__temp_h'653, res ) ==((sel)( , var__temp_h651, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'653, res ) ==(var__temp_v652) AND 
 	 Rel (sel)( , var__temp_h'653, res ) ==(10)
 
VC_END(declare-const var_h_i625 T2533)
(declare-const var_h624 T2533)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h651 T2533)
(declare-const var__temp_v652 Int)
(declare-const |var__temp_h'653| T2533)
(declare-const var__temp_v_err654 T2534)
(declare-const var_h624 T2533)
(declare-const err T2547)

solver 
 (declare-sort T2533)
(declare-fun sel (T2533 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T2533)
(declare-fun |var__temp_h'653| () T2533)
(declare-fun var__temp_v652 () Int)
(declare-fun var__temp_h651 () T2533)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h651 res) v)
                (= (sel var__temp_h651 res) (+ (sel var_h624 res) 5))))
      (a!2 (and (= (sel |var__temp_h'653| res) var__temp_v652)
                (= (sel |var__temp_h'653| res) (+ (sel var__temp_h651 res) 2)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'653| res) var__temp_v652)
                    (= (sel |var__temp_h'653| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h651 res) 5))
                (=> (= (sel var__temp_h651 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************171
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v626:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v626:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i625 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i625, res ) ==(v)
 	 , (sel)( , var_h_i625, res ) ==((sel)( , var_h624, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v655:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************172
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i625 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i625, res ) ==(v)
 	 , (sel)( , var_h_i625, res ) ==((sel)( , var_h624, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v655:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h656 --->  Ty_heap  
 var__temp_v657 --->  Ty_int  
 var__temp_h'658 --->  Ty_heap  
 var__temp_v_err659 --->  error  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h656, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h656, res ) ==((sel)( , var_h624, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h656, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h656, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'658, res ) ==(var__temp_v657) AND 
 	 Rel (sel)( , var__temp_h'658, res ) ==((sel)( , var__temp_h656, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i625 T2550)
(declare-const var_h624 T2550)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h656 T2550)
(declare-const var__temp_v657 Int)
(declare-const |var__temp_h'658| T2550)
(declare-const var__temp_v_err659 T2551)
(declare-const var_h624 T2550)
(declare-const err T2564)

solver 
 (declare-sort T2550)
(declare-fun sel (T2550 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T2550)
(declare-fun var__temp_h656 () T2550)
(declare-fun |var__temp_h'658| () T2550)
(declare-fun var__temp_v657 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h656 res) v)
                (= (sel var__temp_h656 res) (+ (sel var_h624 res) 5))))
      (a!2 (and (= (sel |var__temp_h'658| res) var__temp_v657)
                (= (sel |var__temp_h'658| res) (+ (sel var__temp_h656 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h656 res) 7))
                (=> (= (sel var__temp_h656 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************173
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i625 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i625, res ) ==(v)
 	 , (sel)( , var_h_i625, res ) ==((sel)( , var_h624, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v655:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h660 --->  Ty_heap  
 var__temp_v661 --->  Ty_int  
 var__temp_h'662 --->  Ty_heap  
 var__temp_v_err663 --->  error  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h660, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h660, res ) ==((sel)( , var_h624, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h660, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h660, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'662, res ) ==(var__temp_v661) AND 
 	 Rel (sel)( , var__temp_h'662, res ) ==((sel)( , var__temp_h660, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i625 T2567)
(declare-const var_h624 T2567)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h660 T2567)
(declare-const var__temp_v661 Int)
(declare-const |var__temp_h'662| T2567)
(declare-const var__temp_v_err663 T2568)
(declare-const var_h624 T2567)
(declare-const err T2581)

solver 
 (declare-sort T2567)
(declare-fun sel (T2567 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T2567)
(declare-fun var__temp_h660 () T2567)
(declare-fun |var__temp_h'662| () T2567)
(declare-fun var__temp_v661 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h660 res) v)
                (= (sel var__temp_h660 res) (+ (sel var_h624 res) 5))))
      (a!2 (and (= (sel |var__temp_h'662| res) var__temp_v661)
                (= (sel |var__temp_h'662| res) (+ (sel var__temp_h660 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h660 res) 7))
                (=> (= (sel var__temp_h660 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************174
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h, res ) ==(sel)( , h, res ) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i625 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i625, res ) ==(v)
 	 , (sel)( , var_h_i625, res ) ==((sel)( , var_h624, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v655:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h, res ) ==(sel)( , h, res ) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h664 --->  Ty_heap  
 var__temp_v665 --->  Ty_int  
 var__temp_h'666 --->  Ty_heap  
 var__temp_v_err667 --->  error  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h664, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h664, res ) ==((sel)( , var_h624, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h664, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h664, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'666, res ) ==(var__temp_v665) AND 
 	 Rel (sel)( , var__temp_h664, res ) ==(sel)( , var__temp_h664, res ) => 
 	 True
 
VC_END(declare-const var_h_i625 T2584)
(declare-const var_h624 T2584)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h664 T2584)
(declare-const var__temp_v665 Int)
(declare-const |var__temp_h'666| T2584)
(declare-const var__temp_v_err667 T2585)
(declare-const var_h624 T2584)
(declare-const err T2598)

solver 
 (declare-sort T2584)
(declare-fun sel (T2584 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T2584)
(declare-fun var__temp_h664 () T2584)
(declare-fun var__temp_v665 () Int)
(declare-fun |var__temp_h'666| () T2584)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h664 res) v)
                (= (sel var__temp_h664 res) (+ (sel var_h624 res) 5))))
      (a!3 (=> (and (= (sel |var__temp_h'666| res) var__temp_v665)
                    (= (sel var__temp_h664 res) (sel var__temp_h664 res)))
               true)))
(let ((a!2 (=> a!1 (not (> (sel var__temp_h664 res) 20))))
      (a!4 (=> (not (> (sel var__temp_h664 res) 20)) a!3)))
  (not (and a!2 a!4)))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************175
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i625 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i625, res ) ==(v)
 	 , (sel)( , var_h_i625, res ) ==((sel)( , var_h624, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v655:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h668 --->  Ty_heap  
 var__temp_v669 --->  Ty_int  
 var__temp_h'670 --->  Ty_heap  
 var__temp_v_err671 --->  error  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h668, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h668, res ) ==((sel)( , var_h624, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h668, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h668, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'670, res ) ==(var__temp_v669) AND 
 	 Rel (sel)( , var__temp_h'670, res ) ==((sel)( , var__temp_h668, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i625 T2601)
(declare-const var_h624 T2601)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h668 T2601)
(declare-const var__temp_v669 Int)
(declare-const |var__temp_h'670| T2601)
(declare-const var__temp_v_err671 T2602)
(declare-const var_h624 T2601)
(declare-const err T2615)

solver 
 (declare-sort T2601)
(declare-fun sel (T2601 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T2601)
(declare-fun var__temp_h668 () T2601)
(declare-fun |var__temp_h'670| () T2601)
(declare-fun var__temp_v669 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h668 res) v)
                (= (sel var__temp_h668 res) (+ (sel var_h624 res) 5))))
      (a!2 (and (= (sel |var__temp_h'670| res) var__temp_v669)
                (= (sel |var__temp_h'670| res) (+ (sel var__temp_h668 res) 10)))))
(let ((a!3 (and (=> a!1 (> (sel var__temp_h668 res) 4))
                (=> (> (sel var__temp_h668 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************176
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i625 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i625, res ) ==(v)
 	 , (sel)( , var_h_i625, res ) ==((sel)( , var_h624, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v655:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h672 --->  Ty_heap  
 var__temp_v673 --->  Ty_int  
 var__temp_h'674 --->  Ty_heap  
 var__temp_v_err675 --->  error  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h672, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h672, res ) ==((sel)( , var_h624, res ) + (5)) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'674, res ) ==(var__temp_v673) AND 
 	 Base var__temp_v673 = 20 => 
 	 True
 
VC_END(declare-const var_h_i625 T2618)
(declare-const var_h624 T2618)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h672 T2618)
(declare-const var__temp_v673 Int)
(declare-const |var__temp_h'674| T2618)
(declare-const var__temp_v_err675 T2619)
(declare-const var_h624 T2618)
(declare-const err T2632)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2618)
(declare-fun sel (T2618 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T2618)
(declare-fun |20| () Int)
(declare-fun var__temp_v673 () Int)
(declare-fun |var__temp_h'674| () T2618)
(declare-fun var__temp_h672 () T2618)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (and (= (sel var__temp_h672 res) v)
                (= (sel var__temp_h672 res) (+ (sel var_h624 res) 5))))
      (a!2 (=> (and (= (sel |var__temp_h'674| res) var__temp_v673)
                    (= var__temp_v673 |20|))
               true)))
  (not (and (=> a!1 true) (=> true a!2)))))

***************Selection Successful************foo'
PARTIAL PATH NEW
NEW 	 --c4	 --foo'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i677 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i677 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i677, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v678:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i677 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
foo
bar
 *********************Enumeration Iteration*****************177
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i677 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i677, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v678:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i677 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h679 --->  Ty_heap  
 var__temp_v680 --->  Ty_int  
 var__temp_h'681 --->  Ty_heap  
 var__temp_v_err682 --->  error  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h679, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h679, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h679, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'681, res ) ==(var__temp_v680) AND 
 	 Rel (sel)( , var__temp_h'681, res ) ==((sel)( , var__temp_h679, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'681, res ) ==(var__temp_v680) AND 
 	 Rel (sel)( , var__temp_h'681, res ) ==(10)
 
VC_END(declare-const var_h_i677 T2635)
(declare-const var_h676 T2635)
(declare-const v Int)
(declare-const var_h_i625 T2635)
(declare-const var_h624 T2635)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h679 T2635)
(declare-const var__temp_v680 Int)
(declare-const |var__temp_h'681| T2635)
(declare-const var__temp_v_err682 T2636)
(declare-const var_h676 T2635)
(declare-const var_h624 T2635)
(declare-const err T2649)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2635)
(declare-fun sel (T2635 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T2635)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'681| () T2635)
(declare-fun var__temp_v680 () Int)
(declare-fun var__temp_h679 () T2635)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h679 res) v) (= v |20|))
               (= (sel var__temp_h679 res) 7)))
      (a!2 (and (= (sel |var__temp_h'681| res) var__temp_v680)
                (= (sel |var__temp_h'681| res) (+ (sel var__temp_h679 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'681| res) var__temp_v680)
                    (= (sel |var__temp_h'681| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h679 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************178
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i677 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i677, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v678:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i677 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h683 --->  Ty_heap  
 var__temp_v684 --->  Ty_int  
 var__temp_h'685 --->  Ty_heap  
 var__temp_v_err686 --->  error  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h683, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h683, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h683, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'685, res ) ==(var__temp_v684) AND 
 	 Rel (sel)( , var__temp_h'685, res ) ==((sel)( , var__temp_h683, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'685, res ) ==(var__temp_v684) AND 
 	 Rel (sel)( , var__temp_h'685, res ) ==(10)
 
VC_END(declare-const var_h_i677 T2652)
(declare-const var_h676 T2652)
(declare-const v Int)
(declare-const var_h_i625 T2652)
(declare-const var_h624 T2652)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h683 T2652)
(declare-const var__temp_v684 Int)
(declare-const |var__temp_h'685| T2652)
(declare-const var__temp_v_err686 T2653)
(declare-const var_h676 T2652)
(declare-const var_h624 T2652)
(declare-const err T2666)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2652)
(declare-fun sel (T2652 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T2652)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'685| () T2652)
(declare-fun var__temp_v684 () Int)
(declare-fun var__temp_h683 () T2652)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h683 res) v) (= v |20|))
               (= (sel var__temp_h683 res) 7)))
      (a!2 (and (= (sel |var__temp_h'685| res) var__temp_v684)
                (= (sel |var__temp_h'685| res) (+ (sel var__temp_h683 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'685| res) var__temp_v684)
                    (= (sel |var__temp_h'685| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h683 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************179
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h, res ) ==(sel)( , h, res ) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i677 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i677, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v678:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i677 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h, res ) ==(sel)( , h, res ) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h687 --->  Ty_heap  
 var__temp_v688 --->  Ty_int  
 var__temp_h'689 --->  Ty_heap  
 var__temp_v_err690 --->  error  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h687, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h687, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h687, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'689, res ) ==(var__temp_v688) AND 
 	 Rel (sel)( , var__temp_h687, res ) ==(sel)( , var__temp_h687, res ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'689, res ) ==(var__temp_v688) AND 
 	 Rel (sel)( , var__temp_h'689, res ) ==(10)
 
VC_END(declare-const var_h_i677 T2669)
(declare-const var_h676 T2669)
(declare-const v Int)
(declare-const var_h_i625 T2669)
(declare-const var_h624 T2669)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h687 T2669)
(declare-const var__temp_v688 Int)
(declare-const |var__temp_h'689| T2669)
(declare-const var__temp_v_err690 T2670)
(declare-const var_h676 T2669)
(declare-const var_h624 T2669)
(declare-const err T2683)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2669)
(declare-fun sel (T2669 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T2669)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'689| () T2669)
(declare-fun var__temp_v688 () Int)
(declare-fun var__temp_h687 () T2669)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h687 res) v) (= v |20|))
               (not (> (sel var__temp_h687 res) 20))))
      (a!2 (=> (and (= (sel |var__temp_h'689| res) var__temp_v688)
                    (= (sel var__temp_h687 res) (sel var__temp_h687 res)))
               (and (= (sel |var__temp_h'689| res) var__temp_v688)
                    (= (sel |var__temp_h'689| res) 10)))))
(let ((a!3 (=> (not (> (sel var__temp_h687 res) 20)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************180
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i677 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i677, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v678:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i677 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h691 --->  Ty_heap  
 var__temp_v692 --->  Ty_int  
 var__temp_h'693 --->  Ty_heap  
 var__temp_v_err694 --->  error  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h691, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h691, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h691, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'693, res ) ==(var__temp_v692) AND 
 	 Rel (sel)( , var__temp_h'693, res ) ==((sel)( , var__temp_h691, res ) + (10)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'693, res ) ==(var__temp_v692) AND 
 	 Rel (sel)( , var__temp_h'693, res ) ==(10)
 
VC_END(declare-const var_h_i677 T2686)
(declare-const var_h676 T2686)
(declare-const v Int)
(declare-const var_h_i625 T2686)
(declare-const var_h624 T2686)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h691 T2686)
(declare-const var__temp_v692 Int)
(declare-const |var__temp_h'693| T2686)
(declare-const var__temp_v_err694 T2687)
(declare-const var_h676 T2686)
(declare-const var_h624 T2686)
(declare-const err T2700)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2686)
(declare-fun sel (T2686 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T2686)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'693| () T2686)
(declare-fun var__temp_v692 () Int)
(declare-fun var__temp_h691 () T2686)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h691 res) v) (= v |20|))
               (> (sel var__temp_h691 res) 4)))
      (a!2 (and (= (sel |var__temp_h'693| res) var__temp_v692)
                (= (sel |var__temp_h'693| res) (+ (sel var__temp_h691 res) 10)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'693| res) var__temp_v692)
                    (= (sel |var__temp_h'693| res) 10)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h691 res) 4) a!3))))
  (not a!4)))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************181
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i677 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i677, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v678:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i677 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h695 --->  Ty_heap  
 var__temp_v696 --->  Ty_int  
 var__temp_h'697 --->  Ty_heap  
 var__temp_v_err698 --->  error  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h695, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h695, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h695, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'697, res ) ==(var__temp_v696) AND 
 	 Base var__temp_v696 = 5 => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'697, res ) ==(var__temp_v696) AND 
 	 Rel (sel)( , var__temp_h'697, res ) ==(10)
 
VC_END(declare-const var_h_i677 T2703)
(declare-const var_h676 T2703)
(declare-const v Int)
(declare-const var_h_i625 T2703)
(declare-const var_h624 T2703)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h695 T2703)
(declare-const var__temp_v696 Int)
(declare-const |var__temp_h'697| T2703)
(declare-const var__temp_v_err698 T2704)
(declare-const var_h676 T2703)
(declare-const var_h624 T2703)
(declare-const err T2717)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T2703)
(declare-fun sel (T2703 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T2703)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'697| () T2703)
(declare-fun var__temp_v696 () Int)
(declare-fun var__temp_h695 () T2703)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h695 res) v) (= v |20|))
               (= (sel var__temp_h695 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'697| res) var__temp_v696)
                    (= var__temp_v696 |5|))
               (and (= (sel |var__temp_h'697| res) var__temp_v696)
                    (= (sel |var__temp_h'697| res) 10)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h695 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************182
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i677 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i677, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v678:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i677 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h699 --->  Ty_heap  
 var__temp_v700 --->  Ty_int  
 var__temp_h'701 --->  Ty_heap  
 var__temp_v_err702 --->  error  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h699, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h699, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h699, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'701, res ) ==(var__temp_v700) AND 
 	 Rel (sel)( , var__temp_h'701, res ) ==((sel)( , var__temp_h699, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'701, res ) ==(var__temp_v700) AND 
 	 Rel (sel)( , var__temp_h'701, res ) ==(10)
 
VC_END(declare-const var_h_i677 T2720)
(declare-const var_h676 T2720)
(declare-const v Int)
(declare-const var_h_i625 T2720)
(declare-const var_h624 T2720)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h699 T2720)
(declare-const var__temp_v700 Int)
(declare-const |var__temp_h'701| T2720)
(declare-const var__temp_v_err702 T2721)
(declare-const var_h676 T2720)
(declare-const var_h624 T2720)
(declare-const err T2734)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2720)
(declare-fun sel (T2720 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T2720)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'701| () T2720)
(declare-fun var__temp_v700 () Int)
(declare-fun var__temp_h699 () T2720)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h699 res) v) (= v |20|))
               (= (sel var__temp_h699 res) 5)))
      (a!2 (and (= (sel |var__temp_h'701| res) var__temp_v700)
                (= (sel |var__temp_h'701| res) (+ (sel var__temp_h699 res) 2)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'701| res) var__temp_v700)
                    (= (sel |var__temp_h'701| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h699 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************183
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v678:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v678:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfoo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c4	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i677 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i677, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v703:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
foo
bar
 *********************Enumeration Iteration*****************184
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i677 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i677, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v703:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h704 --->  Ty_heap  
 var__temp_v705 --->  Ty_int  
 var__temp_h'706 --->  Ty_heap  
 var__temp_v_err707 --->  error  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h704, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h704, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h704, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'706, res ) ==(var__temp_v705) AND 
 	 Rel (sel)( , var__temp_h'706, res ) ==((sel)( , var__temp_h704, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i677 T2737)
(declare-const var_h676 T2737)
(declare-const v Int)
(declare-const var_h_i625 T2737)
(declare-const var_h624 T2737)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h704 T2737)
(declare-const var__temp_v705 Int)
(declare-const |var__temp_h'706| T2737)
(declare-const var__temp_v_err707 T2738)
(declare-const var_h676 T2737)
(declare-const var_h624 T2737)
(declare-const err T2751)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2737)
(declare-fun sel (T2737 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T2737)
(declare-fun |20| () Int)
(declare-fun var__temp_h704 () T2737)
(declare-fun |var__temp_h'706| () T2737)
(declare-fun var__temp_v705 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h704 res) v) (= v |20|))
               (= (sel var__temp_h704 res) 7)))
      (a!2 (and (= (sel |var__temp_h'706| res) var__temp_v705)
                (= (sel |var__temp_h'706| res) (+ (sel var__temp_h704 res) 3)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h704 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************185
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i677 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i677, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v703:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h708 --->  Ty_heap  
 var__temp_v709 --->  Ty_int  
 var__temp_h'710 --->  Ty_heap  
 var__temp_v_err711 --->  error  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h708, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h708, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h708, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'710, res ) ==(var__temp_v709) AND 
 	 Rel (sel)( , var__temp_h'710, res ) ==((sel)( , var__temp_h708, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i677 T2754)
(declare-const var_h676 T2754)
(declare-const v Int)
(declare-const var_h_i625 T2754)
(declare-const var_h624 T2754)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h708 T2754)
(declare-const var__temp_v709 Int)
(declare-const |var__temp_h'710| T2754)
(declare-const var__temp_v_err711 T2755)
(declare-const var_h676 T2754)
(declare-const var_h624 T2754)
(declare-const err T2768)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2754)
(declare-fun sel (T2754 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T2754)
(declare-fun |20| () Int)
(declare-fun var__temp_h708 () T2754)
(declare-fun |var__temp_h'710| () T2754)
(declare-fun var__temp_v709 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h708 res) v) (= v |20|))
               (= (sel var__temp_h708 res) 7)))
      (a!2 (and (= (sel |var__temp_h'710| res) var__temp_v709)
                (= (sel |var__temp_h'710| res) (+ (sel var__temp_h708 res) 5)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h708 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************186
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h, res ) ==(sel)( , h, res ) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i677 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i677, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v703:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h, res ) ==(sel)( , h, res ) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h712 --->  Ty_heap  
 var__temp_v713 --->  Ty_int  
 var__temp_h'714 --->  Ty_heap  
 var__temp_v_err715 --->  error  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h712, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h712, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h712, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'714, res ) ==(var__temp_v713) AND 
 	 Rel (sel)( , var__temp_h712, res ) ==(sel)( , var__temp_h712, res ) => 
 	 True
 
VC_END(declare-const var_h_i677 T2771)
(declare-const var_h676 T2771)
(declare-const v Int)
(declare-const var_h_i625 T2771)
(declare-const var_h624 T2771)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h712 T2771)
(declare-const var__temp_v713 Int)
(declare-const |var__temp_h'714| T2771)
(declare-const var__temp_v_err715 T2772)
(declare-const var_h676 T2771)
(declare-const var_h624 T2771)
(declare-const err T2785)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2771)
(declare-fun sel (T2771 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T2771)
(declare-fun |20| () Int)
(declare-fun var__temp_h712 () T2771)
(declare-fun var__temp_v713 () Int)
(declare-fun |var__temp_h'714| () T2771)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h712 res) v) (= v |20|))
               (not (> (sel var__temp_h712 res) 20))))
      (a!2 (=> (and (= (sel |var__temp_h'714| res) var__temp_v713)
                    (= (sel var__temp_h712 res) (sel var__temp_h712 res)))
               true)))
(let ((a!3 (=> (not (> (sel var__temp_h712 res) 20)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Successful************c2'
PARTIAL PATH NEW
NEW 	 --c4	 --foo'	 --c2'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i717 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i717 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i717, res ) ==(v)
 	 , (sel)( , var_h716, res ) ==(sel)( , var_h716, res ) >c  } 
 } 
 
                                                RET :  Base {var_v718:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i717 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************187
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i717 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i717, res ) ==(v)
 	 , (sel)( , var_h716, res ) ==(sel)( , var_h716, res ) >c  } 
 } 
 
                                                RET :  Base {var_v718:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i717 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i717 --->  Ty_heap  
 var_h716 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h719 --->  Ty_heap  
 var__temp_v720 --->  Ty_int  
 var__temp_h'721 --->  Ty_heap  
 var__temp_v_err722 --->  error  
 var_h716 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h716, res ) > (20) AND 
 	 Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h719, res ) ==(v) AND 
 	 Rel (sel)( , var_h716, res ) ==(sel)( , var_h716, res ) => 
 	 Rel (sel)( , var__temp_h719, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h719, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'721, res ) ==(var__temp_v720) AND 
 	 Rel (sel)( , var__temp_h'721, res ) ==((sel)( , var__temp_h719, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'721, res ) ==(var__temp_v720) AND 
 	 Rel (sel)( , var__temp_h'721, res ) ==(10)
 
VC_END(declare-const var_h_i717 T2788)
(declare-const var_h716 T2788)
(declare-const v Int)
(declare-const var_h_i677 T2788)
(declare-const var_h676 T2788)
(declare-const v Int)
(declare-const var_h_i625 T2788)
(declare-const var_h624 T2788)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h719 T2788)
(declare-const var__temp_v720 Int)
(declare-const |var__temp_h'721| T2788)
(declare-const var__temp_v_err722 T2789)
(declare-const var_h716 T2788)
(declare-const var_h676 T2788)
(declare-const var_h624 T2788)
(declare-const err T2802)

solver 
 (declare-sort T2788)
(declare-fun sel (T2788 Int) Int)
(declare-fun res () Int)
(declare-fun var_h716 () T2788)
(declare-fun var_h624 () T2788)
(declare-fun |var__temp_h'721| () T2788)
(declare-fun var__temp_v720 () Int)
(declare-fun var__temp_h719 () T2788)
(declare-fun v () Int)
(assert (not (> (sel var_h716 res) 20)))
(assert (not (> (sel var_h624 res) 30)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h719 res) v)
                    (= (sel var_h716 res) (sel var_h716 res)))
               (= (sel var__temp_h719 res) 7)))
      (a!2 (and (= (sel |var__temp_h'721| res) var__temp_v720)
                (= (sel |var__temp_h'721| res) (+ (sel var__temp_h719 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'721| res) var__temp_v720)
                    (= (sel |var__temp_h'721| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h719 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************188
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i717 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i717, res ) ==(v)
 	 , (sel)( , var_h716, res ) ==(sel)( , var_h716, res ) >c  } 
 } 
 
                                                RET :  Base {var_v718:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i717 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i717 --->  Ty_heap  
 var_h716 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h723 --->  Ty_heap  
 var__temp_v724 --->  Ty_int  
 var__temp_h'725 --->  Ty_heap  
 var__temp_v_err726 --->  error  
 var_h716 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h716, res ) > (20) AND 
 	 Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h723, res ) ==(v) AND 
 	 Rel (sel)( , var_h716, res ) ==(sel)( , var_h716, res ) => 
 	 Rel (sel)( , var__temp_h723, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h723, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'725, res ) ==(var__temp_v724) AND 
 	 Rel (sel)( , var__temp_h'725, res ) ==((sel)( , var__temp_h723, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'725, res ) ==(var__temp_v724) AND 
 	 Rel (sel)( , var__temp_h'725, res ) ==(10)
 
VC_END(declare-const var_h_i717 T2805)
(declare-const var_h716 T2805)
(declare-const v Int)
(declare-const var_h_i677 T2805)
(declare-const var_h676 T2805)
(declare-const v Int)
(declare-const var_h_i625 T2805)
(declare-const var_h624 T2805)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h723 T2805)
(declare-const var__temp_v724 Int)
(declare-const |var__temp_h'725| T2805)
(declare-const var__temp_v_err726 T2806)
(declare-const var_h716 T2805)
(declare-const var_h676 T2805)
(declare-const var_h624 T2805)
(declare-const err T2819)

solver 
 (declare-sort T2805)
(declare-fun sel (T2805 Int) Int)
(declare-fun res () Int)
(declare-fun var_h716 () T2805)
(declare-fun var_h624 () T2805)
(declare-fun |var__temp_h'725| () T2805)
(declare-fun var__temp_v724 () Int)
(declare-fun var__temp_h723 () T2805)
(declare-fun v () Int)
(assert (not (> (sel var_h716 res) 20)))
(assert (not (> (sel var_h624 res) 30)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h723 res) v)
                    (= (sel var_h716 res) (sel var_h716 res)))
               (= (sel var__temp_h723 res) 7)))
      (a!2 (and (= (sel |var__temp_h'725| res) var__temp_v724)
                (= (sel |var__temp_h'725| res) (+ (sel var__temp_h723 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'725| res) var__temp_v724)
                    (= (sel |var__temp_h'725| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h723 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************189
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i717 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i717, res ) ==(v)
 	 , (sel)( , var_h716, res ) ==(sel)( , var_h716, res ) >c  } 
 } 
 
                                                RET :  Base {var_v718:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i717 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i717 --->  Ty_heap  
 var_h716 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h727 --->  Ty_heap  
 var__temp_v728 --->  Ty_int  
 var__temp_h'729 --->  Ty_heap  
 var__temp_v_err730 --->  error  
 var_h716 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h716, res ) > (20) AND 
 	 Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h727, res ) ==(v) AND 
 	 Rel (sel)( , var_h716, res ) ==(sel)( , var_h716, res ) => 
 	 Rel (sel)( , var__temp_h727, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h727, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'729, res ) ==(var__temp_v728) AND 
 	 Rel (sel)( , var__temp_h'729, res ) ==((sel)( , var__temp_h727, res ) + (10)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'729, res ) ==(var__temp_v728) AND 
 	 Rel (sel)( , var__temp_h'729, res ) ==(10)
 
VC_END(declare-const var_h_i717 T2822)
(declare-const var_h716 T2822)
(declare-const v Int)
(declare-const var_h_i677 T2822)
(declare-const var_h676 T2822)
(declare-const v Int)
(declare-const var_h_i625 T2822)
(declare-const var_h624 T2822)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h727 T2822)
(declare-const var__temp_v728 Int)
(declare-const |var__temp_h'729| T2822)
(declare-const var__temp_v_err730 T2823)
(declare-const var_h716 T2822)
(declare-const var_h676 T2822)
(declare-const var_h624 T2822)
(declare-const err T2836)

solver 
 (declare-sort T2822)
(declare-fun sel (T2822 Int) Int)
(declare-fun res () Int)
(declare-fun var_h716 () T2822)
(declare-fun var_h624 () T2822)
(declare-fun |var__temp_h'729| () T2822)
(declare-fun var__temp_v728 () Int)
(declare-fun var__temp_h727 () T2822)
(declare-fun v () Int)
(assert (not (> (sel var_h716 res) 20)))
(assert (not (> (sel var_h624 res) 30)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h727 res) v)
                    (= (sel var_h716 res) (sel var_h716 res)))
               (> (sel var__temp_h727 res) 4)))
      (a!2 (and (= (sel |var__temp_h'729| res) var__temp_v728)
                (= (sel |var__temp_h'729| res) (+ (sel var__temp_h727 res) 10)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'729| res) var__temp_v728)
                    (= (sel |var__temp_h'729| res) 10)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h727 res) 4) a!3))))
  (not a!4)))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************190
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i717 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i717, res ) ==(v)
 	 , (sel)( , var_h716, res ) ==(sel)( , var_h716, res ) >c  } 
 } 
 
                                                RET :  Base {var_v718:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i717 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i717 --->  Ty_heap  
 var_h716 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h731 --->  Ty_heap  
 var__temp_v732 --->  Ty_int  
 var__temp_h'733 --->  Ty_heap  
 var__temp_v_err734 --->  error  
 var_h716 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h716, res ) > (20) AND 
 	 Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h731, res ) ==(v) AND 
 	 Rel (sel)( , var_h716, res ) ==(sel)( , var_h716, res ) => 
 	 Rel (sel)( , var__temp_h731, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h731, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'733, res ) ==(var__temp_v732) AND 
 	 Base var__temp_v732 = 5 => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'733, res ) ==(var__temp_v732) AND 
 	 Rel (sel)( , var__temp_h'733, res ) ==(10)
 
VC_END(declare-const var_h_i717 T2839)
(declare-const var_h716 T2839)
(declare-const v Int)
(declare-const var_h_i677 T2839)
(declare-const var_h676 T2839)
(declare-const v Int)
(declare-const var_h_i625 T2839)
(declare-const var_h624 T2839)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h731 T2839)
(declare-const var__temp_v732 Int)
(declare-const |var__temp_h'733| T2839)
(declare-const var__temp_v_err734 T2840)
(declare-const var_h716 T2839)
(declare-const var_h676 T2839)
(declare-const var_h624 T2839)
(declare-const err T2853)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2839)
(declare-fun sel (T2839 Int) Int)
(declare-fun res () Int)
(declare-fun var_h716 () T2839)
(declare-fun var_h624 () T2839)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'733| () T2839)
(declare-fun var__temp_v732 () Int)
(declare-fun var__temp_h731 () T2839)
(declare-fun v () Int)
(assert (not (> (sel var_h716 res) 20)))
(assert (not (> (sel var_h624 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h731 res) v)
                    (= (sel var_h716 res) (sel var_h716 res)))
               (= (sel var__temp_h731 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'733| res) var__temp_v732)
                    (= var__temp_v732 |5|))
               (and (= (sel |var__temp_h'733| res) var__temp_v732)
                    (= (sel |var__temp_h'733| res) 10)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h731 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************191
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i717 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i717, res ) ==(v)
 	 , (sel)( , var_h716, res ) ==(sel)( , var_h716, res ) >c  } 
 } 
 
                                                RET :  Base {var_v718:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i717 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i717 --->  Ty_heap  
 var_h716 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h735 --->  Ty_heap  
 var__temp_v736 --->  Ty_int  
 var__temp_h'737 --->  Ty_heap  
 var__temp_v_err738 --->  error  
 var_h716 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h716, res ) > (20) AND 
 	 Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h735, res ) ==(v) AND 
 	 Rel (sel)( , var_h716, res ) ==(sel)( , var_h716, res ) => 
 	 Rel (sel)( , var__temp_h735, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h735, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'737, res ) ==(var__temp_v736) AND 
 	 Rel (sel)( , var__temp_h'737, res ) ==((sel)( , var__temp_h735, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'737, res ) ==(var__temp_v736) AND 
 	 Rel (sel)( , var__temp_h'737, res ) ==(10)
 
VC_END(declare-const var_h_i717 T2856)
(declare-const var_h716 T2856)
(declare-const v Int)
(declare-const var_h_i677 T2856)
(declare-const var_h676 T2856)
(declare-const v Int)
(declare-const var_h_i625 T2856)
(declare-const var_h624 T2856)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h735 T2856)
(declare-const var__temp_v736 Int)
(declare-const |var__temp_h'737| T2856)
(declare-const var__temp_v_err738 T2857)
(declare-const var_h716 T2856)
(declare-const var_h676 T2856)
(declare-const var_h624 T2856)
(declare-const err T2870)

solver 
 (declare-sort T2856)
(declare-fun sel (T2856 Int) Int)
(declare-fun res () Int)
(declare-fun var_h716 () T2856)
(declare-fun var_h624 () T2856)
(declare-fun |var__temp_h'737| () T2856)
(declare-fun var__temp_v736 () Int)
(declare-fun var__temp_h735 () T2856)
(declare-fun v () Int)
(assert (not (> (sel var_h716 res) 20)))
(assert (not (> (sel var_h624 res) 30)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h735 res) v)
                    (= (sel var_h716 res) (sel var_h716 res)))
               (= (sel var__temp_h735 res) 5)))
      (a!2 (and (= (sel |var__temp_h'737| res) var__temp_v736)
                (= (sel |var__temp_h'737| res) (+ (sel var__temp_h735 res) 2)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'737| res) var__temp_v736)
                    (= (sel |var__temp_h'737| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h735 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************192
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v718:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v718:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c4	 --foo'	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i717 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i717, res ) ==(v)
 	 , (sel)( , var_h716, res ) ==(sel)( , var_h716, res ) >c  } 
 } 
 
                                                RET :  Base {var_v739:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************193
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i717 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i717, res ) ==(v)
 	 , (sel)( , var_h716, res ) ==(sel)( , var_h716, res ) >c  } 
 } 
 
                                                RET :  Base {var_v739:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i717 --->  Ty_heap  
 var_h716 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h740 --->  Ty_heap  
 var__temp_v741 --->  Ty_int  
 var__temp_h'742 --->  Ty_heap  
 var__temp_v_err743 --->  error  
 var_h716 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h716, res ) > (20) AND 
 	 Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h740, res ) ==(v) AND 
 	 Rel (sel)( , var_h716, res ) ==(sel)( , var_h716, res ) => 
 	 Rel (sel)( , var__temp_h740, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h740, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'742, res ) ==(var__temp_v741) AND 
 	 Rel (sel)( , var__temp_h'742, res ) ==((sel)( , var__temp_h740, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i717 T2873)
(declare-const var_h716 T2873)
(declare-const v Int)
(declare-const var_h_i677 T2873)
(declare-const var_h676 T2873)
(declare-const v Int)
(declare-const var_h_i625 T2873)
(declare-const var_h624 T2873)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h740 T2873)
(declare-const var__temp_v741 Int)
(declare-const |var__temp_h'742| T2873)
(declare-const var__temp_v_err743 T2874)
(declare-const var_h716 T2873)
(declare-const var_h676 T2873)
(declare-const var_h624 T2873)
(declare-const err T2887)

solver 
 (declare-sort T2873)
(declare-fun sel (T2873 Int) Int)
(declare-fun res () Int)
(declare-fun var_h716 () T2873)
(declare-fun var_h624 () T2873)
(declare-fun var__temp_h740 () T2873)
(declare-fun |var__temp_h'742| () T2873)
(declare-fun var__temp_v741 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h716 res) 20)))
(assert (not (> (sel var_h624 res) 30)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h740 res) v)
                    (= (sel var_h716 res) (sel var_h716 res)))
               (= (sel var__temp_h740 res) 7)))
      (a!2 (and (= (sel |var__temp_h'742| res) var__temp_v741)
                (= (sel |var__temp_h'742| res) (+ (sel var__temp_h740 res) 3)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h740 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************194
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i717 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i717, res ) ==(v)
 	 , (sel)( , var_h716, res ) ==(sel)( , var_h716, res ) >c  } 
 } 
 
                                                RET :  Base {var_v739:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i717 --->  Ty_heap  
 var_h716 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h744 --->  Ty_heap  
 var__temp_v745 --->  Ty_int  
 var__temp_h'746 --->  Ty_heap  
 var__temp_v_err747 --->  error  
 var_h716 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h716, res ) > (20) AND 
 	 Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h744, res ) ==(v) AND 
 	 Rel (sel)( , var_h716, res ) ==(sel)( , var_h716, res ) => 
 	 Rel (sel)( , var__temp_h744, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h744, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'746, res ) ==(var__temp_v745) AND 
 	 Rel (sel)( , var__temp_h'746, res ) ==((sel)( , var__temp_h744, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i717 T2890)
(declare-const var_h716 T2890)
(declare-const v Int)
(declare-const var_h_i677 T2890)
(declare-const var_h676 T2890)
(declare-const v Int)
(declare-const var_h_i625 T2890)
(declare-const var_h624 T2890)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h744 T2890)
(declare-const var__temp_v745 Int)
(declare-const |var__temp_h'746| T2890)
(declare-const var__temp_v_err747 T2891)
(declare-const var_h716 T2890)
(declare-const var_h676 T2890)
(declare-const var_h624 T2890)
(declare-const err T2904)

solver 
 (declare-sort T2890)
(declare-fun sel (T2890 Int) Int)
(declare-fun res () Int)
(declare-fun var_h716 () T2890)
(declare-fun var_h624 () T2890)
(declare-fun var__temp_h744 () T2890)
(declare-fun |var__temp_h'746| () T2890)
(declare-fun var__temp_v745 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h716 res) 20)))
(assert (not (> (sel var_h624 res) 30)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h744 res) v)
                    (= (sel var_h716 res) (sel var_h716 res)))
               (= (sel var__temp_h744 res) 7)))
      (a!2 (and (= (sel |var__temp_h'746| res) var__temp_v745)
                (= (sel |var__temp_h'746| res) (+ (sel var__temp_h744 res) 5)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h744 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************195
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i717 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i717, res ) ==(v)
 	 , (sel)( , var_h716, res ) ==(sel)( , var_h716, res ) >c  } 
 } 
 
                                                RET :  Base {var_v739:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i717 --->  Ty_heap  
 var_h716 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h748 --->  Ty_heap  
 var__temp_v749 --->  Ty_int  
 var__temp_h'750 --->  Ty_heap  
 var__temp_v_err751 --->  error  
 var_h716 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h716, res ) > (20) AND 
 	 Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h748, res ) ==(v) AND 
 	 Rel (sel)( , var_h716, res ) ==(sel)( , var_h716, res ) => 
 	 Rel (sel)( , var__temp_h748, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h748, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'750, res ) ==(var__temp_v749) AND 
 	 Rel (sel)( , var__temp_h'750, res ) ==((sel)( , var__temp_h748, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i717 T2907)
(declare-const var_h716 T2907)
(declare-const v Int)
(declare-const var_h_i677 T2907)
(declare-const var_h676 T2907)
(declare-const v Int)
(declare-const var_h_i625 T2907)
(declare-const var_h624 T2907)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h748 T2907)
(declare-const var__temp_v749 Int)
(declare-const |var__temp_h'750| T2907)
(declare-const var__temp_v_err751 T2908)
(declare-const var_h716 T2907)
(declare-const var_h676 T2907)
(declare-const var_h624 T2907)
(declare-const err T2921)

solver 
 (declare-sort T2907)
(declare-fun sel (T2907 Int) Int)
(declare-fun res () Int)
(declare-fun var_h716 () T2907)
(declare-fun var_h624 () T2907)
(declare-fun var__temp_h748 () T2907)
(declare-fun |var__temp_h'750| () T2907)
(declare-fun var__temp_v749 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h716 res) 20)))
(assert (not (> (sel var_h624 res) 30)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h748 res) v)
                    (= (sel var_h716 res) (sel var_h716 res)))
               (> (sel var__temp_h748 res) 4)))
      (a!2 (and (= (sel |var__temp_h'750| res) var__temp_v749)
                (= (sel |var__temp_h'750| res) (+ (sel var__temp_h748 res) 10)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h748 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************196
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i717 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i717, res ) ==(v)
 	 , (sel)( , var_h716, res ) ==(sel)( , var_h716, res ) >c  } 
 } 
 
                                                RET :  Base {var_v739:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i717 --->  Ty_heap  
 var_h716 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h752 --->  Ty_heap  
 var__temp_v753 --->  Ty_int  
 var__temp_h'754 --->  Ty_heap  
 var__temp_v_err755 --->  error  
 var_h716 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h716, res ) > (20) AND 
 	 Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h752, res ) ==(v) AND 
 	 Rel (sel)( , var_h716, res ) ==(sel)( , var_h716, res ) => 
 	 Rel (sel)( , var__temp_h752, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h752, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'754, res ) ==(var__temp_v753) AND 
 	 Base var__temp_v753 = 5 => 
 	 True
 
VC_END(declare-const var_h_i717 T2924)
(declare-const var_h716 T2924)
(declare-const v Int)
(declare-const var_h_i677 T2924)
(declare-const var_h676 T2924)
(declare-const v Int)
(declare-const var_h_i625 T2924)
(declare-const var_h624 T2924)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h752 T2924)
(declare-const var__temp_v753 Int)
(declare-const |var__temp_h'754| T2924)
(declare-const var__temp_v_err755 T2925)
(declare-const var_h716 T2924)
(declare-const var_h676 T2924)
(declare-const var_h624 T2924)
(declare-const err T2938)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2924)
(declare-fun sel (T2924 Int) Int)
(declare-fun res () Int)
(declare-fun var_h716 () T2924)
(declare-fun var_h624 () T2924)
(declare-fun |5| () Int)
(declare-fun var__temp_v753 () Int)
(declare-fun |var__temp_h'754| () T2924)
(declare-fun var__temp_h752 () T2924)
(declare-fun v () Int)
(assert (not (> (sel var_h716 res) 20)))
(assert (not (> (sel var_h624 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h752 res) v)
                    (= (sel var_h716 res) (sel var_h716 res)))
               (= (sel var__temp_h752 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'754| res) var__temp_v753)
                    (= var__temp_v753 |5|))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h752 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************197
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i717 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i717, res ) ==(v)
 	 , (sel)( , var_h716, res ) ==(sel)( , var_h716, res ) >c  } 
 } 
 
                                                RET :  Base {var_v739:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i717 --->  Ty_heap  
 var_h716 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h756 --->  Ty_heap  
 var__temp_v757 --->  Ty_int  
 var__temp_h'758 --->  Ty_heap  
 var__temp_v_err759 --->  error  
 var_h716 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h716, res ) > (20) AND 
 	 Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h756, res ) ==(v) AND 
 	 Rel (sel)( , var_h716, res ) ==(sel)( , var_h716, res ) => 
 	 Rel (sel)( , var__temp_h756, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h756, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'758, res ) ==(var__temp_v757) AND 
 	 Rel (sel)( , var__temp_h'758, res ) ==((sel)( , var__temp_h756, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i717 T2941)
(declare-const var_h716 T2941)
(declare-const v Int)
(declare-const var_h_i677 T2941)
(declare-const var_h676 T2941)
(declare-const v Int)
(declare-const var_h_i625 T2941)
(declare-const var_h624 T2941)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h756 T2941)
(declare-const var__temp_v757 Int)
(declare-const |var__temp_h'758| T2941)
(declare-const var__temp_v_err759 T2942)
(declare-const var_h716 T2941)
(declare-const var_h676 T2941)
(declare-const var_h624 T2941)
(declare-const err T2955)

solver 
 (declare-sort T2941)
(declare-fun sel (T2941 Int) Int)
(declare-fun res () Int)
(declare-fun var_h716 () T2941)
(declare-fun var_h624 () T2941)
(declare-fun var__temp_h756 () T2941)
(declare-fun |var__temp_h'758| () T2941)
(declare-fun var__temp_v757 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h716 res) 20)))
(assert (not (> (sel var_h624 res) 30)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h756 res) v)
                    (= (sel var_h716 res) (sel var_h716 res)))
               (= (sel var__temp_h756 res) 5)))
      (a!2 (and (= (sel |var__temp_h'758| res) var__temp_v757)
                (= (sel |var__temp_h'758| res) (+ (sel var__temp_h756 res) 2)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h756 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************198
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2'
PARTIAL PATH
SUB 	 --c4	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i677 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i677, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v760:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************199
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i677 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i677, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v760:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h761 --->  Ty_heap  
 var__temp_v762 --->  Ty_int  
 var__temp_h'763 --->  Ty_heap  
 var__temp_v_err764 --->  error  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h761, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h761, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h761, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'763, res ) ==(var__temp_v762) AND 
 	 Rel (sel)( , var__temp_h'763, res ) ==((sel)( , var__temp_h761, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i677 T2958)
(declare-const var_h676 T2958)
(declare-const v Int)
(declare-const var_h_i625 T2958)
(declare-const var_h624 T2958)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h761 T2958)
(declare-const var__temp_v762 Int)
(declare-const |var__temp_h'763| T2958)
(declare-const var__temp_v_err764 T2959)
(declare-const var_h676 T2958)
(declare-const var_h624 T2958)
(declare-const err T2972)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2958)
(declare-fun sel (T2958 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T2958)
(declare-fun |20| () Int)
(declare-fun var__temp_h761 () T2958)
(declare-fun |var__temp_h'763| () T2958)
(declare-fun var__temp_v762 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h761 res) v) (= v |20|))
               (= (sel var__temp_h761 res) 7)))
      (a!2 (and (= (sel |var__temp_h'763| res) var__temp_v762)
                (= (sel |var__temp_h'763| res) (+ (sel var__temp_h761 res) 3)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h761 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************200
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i677 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i677, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v760:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h765 --->  Ty_heap  
 var__temp_v766 --->  Ty_int  
 var__temp_h'767 --->  Ty_heap  
 var__temp_v_err768 --->  error  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h765, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h765, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h765, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'767, res ) ==(var__temp_v766) AND 
 	 Rel (sel)( , var__temp_h'767, res ) ==((sel)( , var__temp_h765, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i677 T2975)
(declare-const var_h676 T2975)
(declare-const v Int)
(declare-const var_h_i625 T2975)
(declare-const var_h624 T2975)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h765 T2975)
(declare-const var__temp_v766 Int)
(declare-const |var__temp_h'767| T2975)
(declare-const var__temp_v_err768 T2976)
(declare-const var_h676 T2975)
(declare-const var_h624 T2975)
(declare-const err T2989)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2975)
(declare-fun sel (T2975 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T2975)
(declare-fun |20| () Int)
(declare-fun var__temp_h765 () T2975)
(declare-fun |var__temp_h'767| () T2975)
(declare-fun var__temp_v766 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h765 res) v) (= v |20|))
               (= (sel var__temp_h765 res) 7)))
      (a!2 (and (= (sel |var__temp_h'767| res) var__temp_v766)
                (= (sel |var__temp_h'767| res) (+ (sel var__temp_h765 res) 5)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h765 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************201
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i677 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i677, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v760:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h769 --->  Ty_heap  
 var__temp_v770 --->  Ty_int  
 var__temp_h'771 --->  Ty_heap  
 var__temp_v_err772 --->  error  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h769, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h769, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h769, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'771, res ) ==(var__temp_v770) AND 
 	 Rel (sel)( , var__temp_h'771, res ) ==((sel)( , var__temp_h769, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i677 T2992)
(declare-const var_h676 T2992)
(declare-const v Int)
(declare-const var_h_i625 T2992)
(declare-const var_h624 T2992)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h769 T2992)
(declare-const var__temp_v770 Int)
(declare-const |var__temp_h'771| T2992)
(declare-const var__temp_v_err772 T2993)
(declare-const var_h676 T2992)
(declare-const var_h624 T2992)
(declare-const err T3006)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2992)
(declare-fun sel (T2992 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T2992)
(declare-fun |20| () Int)
(declare-fun var__temp_h769 () T2992)
(declare-fun |var__temp_h'771| () T2992)
(declare-fun var__temp_v770 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h769 res) v) (= v |20|))
               (> (sel var__temp_h769 res) 4)))
      (a!2 (and (= (sel |var__temp_h'771| res) var__temp_v770)
                (= (sel |var__temp_h'771| res) (+ (sel var__temp_h769 res) 10)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h769 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c2
PARTIAL PATH NEW
NEW 	 --c4	 --foo'	 --c2
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i774 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i774 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i774, res ) ==(v)
 	 , (sel)( , var_h_i774, res ) ==((sel)( , var_h773, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v775:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i774 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************202
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i774 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i774, res ) ==(v)
 	 , (sel)( , var_h_i774, res ) ==((sel)( , var_h773, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v775:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i774 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i774 --->  Ty_heap  
 var_h773 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h776 --->  Ty_heap  
 var__temp_v777 --->  Ty_int  
 var__temp_h'778 --->  Ty_heap  
 var__temp_v_err779 --->  error  
 var_h773 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h773, res ) > (4) AND 
 	 Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h776, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h776, res ) ==((sel)( , var_h773, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h776, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h776, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'778, res ) ==(var__temp_v777) AND 
 	 Rel (sel)( , var__temp_h'778, res ) ==((sel)( , var__temp_h776, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'778, res ) ==(var__temp_v777) AND 
 	 Rel (sel)( , var__temp_h'778, res ) ==(10)
 
VC_END(declare-const var_h_i774 T3009)
(declare-const var_h773 T3009)
(declare-const v Int)
(declare-const var_h_i677 T3009)
(declare-const var_h676 T3009)
(declare-const v Int)
(declare-const var_h_i625 T3009)
(declare-const var_h624 T3009)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h776 T3009)
(declare-const var__temp_v777 Int)
(declare-const |var__temp_h'778| T3009)
(declare-const var__temp_v_err779 T3010)
(declare-const var_h773 T3009)
(declare-const var_h676 T3009)
(declare-const var_h624 T3009)
(declare-const err T3023)

solver 
 (declare-sort T3009)
(declare-fun sel (T3009 Int) Int)
(declare-fun res () Int)
(declare-fun var_h773 () T3009)
(declare-fun var_h624 () T3009)
(declare-fun |var__temp_h'778| () T3009)
(declare-fun var__temp_v777 () Int)
(declare-fun var__temp_h776 () T3009)
(declare-fun v () Int)
(assert (> (sel var_h773 res) 4))
(assert (not (> (sel var_h624 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h776 res) v)
                (= (sel var__temp_h776 res) (+ (sel var_h773 res) 10))))
      (a!2 (and (= (sel |var__temp_h'778| res) var__temp_v777)
                (= (sel |var__temp_h'778| res) (+ (sel var__temp_h776 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'778| res) var__temp_v777)
                    (= (sel |var__temp_h'778| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h776 res) 7))
                (=> (= (sel var__temp_h776 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************203
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i774 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i774, res ) ==(v)
 	 , (sel)( , var_h_i774, res ) ==((sel)( , var_h773, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v775:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i774 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i774 --->  Ty_heap  
 var_h773 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h780 --->  Ty_heap  
 var__temp_v781 --->  Ty_int  
 var__temp_h'782 --->  Ty_heap  
 var__temp_v_err783 --->  error  
 var_h773 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h773, res ) > (4) AND 
 	 Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h780, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h780, res ) ==((sel)( , var_h773, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h780, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h780, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'782, res ) ==(var__temp_v781) AND 
 	 Rel (sel)( , var__temp_h'782, res ) ==((sel)( , var__temp_h780, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'782, res ) ==(var__temp_v781) AND 
 	 Rel (sel)( , var__temp_h'782, res ) ==(10)
 
VC_END(declare-const var_h_i774 T3026)
(declare-const var_h773 T3026)
(declare-const v Int)
(declare-const var_h_i677 T3026)
(declare-const var_h676 T3026)
(declare-const v Int)
(declare-const var_h_i625 T3026)
(declare-const var_h624 T3026)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h780 T3026)
(declare-const var__temp_v781 Int)
(declare-const |var__temp_h'782| T3026)
(declare-const var__temp_v_err783 T3027)
(declare-const var_h773 T3026)
(declare-const var_h676 T3026)
(declare-const var_h624 T3026)
(declare-const err T3040)

solver 
 (declare-sort T3026)
(declare-fun sel (T3026 Int) Int)
(declare-fun res () Int)
(declare-fun var_h773 () T3026)
(declare-fun var_h624 () T3026)
(declare-fun |var__temp_h'782| () T3026)
(declare-fun var__temp_v781 () Int)
(declare-fun var__temp_h780 () T3026)
(declare-fun v () Int)
(assert (> (sel var_h773 res) 4))
(assert (not (> (sel var_h624 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h780 res) v)
                (= (sel var__temp_h780 res) (+ (sel var_h773 res) 10))))
      (a!2 (and (= (sel |var__temp_h'782| res) var__temp_v781)
                (= (sel |var__temp_h'782| res) (+ (sel var__temp_h780 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'782| res) var__temp_v781)
                    (= (sel |var__temp_h'782| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h780 res) 7))
                (=> (= (sel var__temp_h780 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************204
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i774 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i774, res ) ==(v)
 	 , (sel)( , var_h_i774, res ) ==((sel)( , var_h773, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v775:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i774 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i774 --->  Ty_heap  
 var_h773 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h784 --->  Ty_heap  
 var__temp_v785 --->  Ty_int  
 var__temp_h'786 --->  Ty_heap  
 var__temp_v_err787 --->  error  
 var_h773 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h773, res ) > (4) AND 
 	 Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h784, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h784, res ) ==((sel)( , var_h773, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h784, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h784, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'786, res ) ==(var__temp_v785) AND 
 	 Base var__temp_v785 = 5 => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'786, res ) ==(var__temp_v785) AND 
 	 Rel (sel)( , var__temp_h'786, res ) ==(10)
 
VC_END(declare-const var_h_i774 T3043)
(declare-const var_h773 T3043)
(declare-const v Int)
(declare-const var_h_i677 T3043)
(declare-const var_h676 T3043)
(declare-const v Int)
(declare-const var_h_i625 T3043)
(declare-const var_h624 T3043)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h784 T3043)
(declare-const var__temp_v785 Int)
(declare-const |var__temp_h'786| T3043)
(declare-const var__temp_v_err787 T3044)
(declare-const var_h773 T3043)
(declare-const var_h676 T3043)
(declare-const var_h624 T3043)
(declare-const err T3057)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3043)
(declare-fun sel (T3043 Int) Int)
(declare-fun res () Int)
(declare-fun var_h773 () T3043)
(declare-fun var_h624 () T3043)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'786| () T3043)
(declare-fun var__temp_v785 () Int)
(declare-fun var__temp_h784 () T3043)
(declare-fun v () Int)
(assert (> (sel var_h773 res) 4))
(assert (not (> (sel var_h624 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h784 res) v)
                (= (sel var__temp_h784 res) (+ (sel var_h773 res) 10))))
      (a!2 (=> (and (= (sel |var__temp_h'786| res) var__temp_v785)
                    (= var__temp_v785 |5|))
               (and (= (sel |var__temp_h'786| res) var__temp_v785)
                    (= (sel |var__temp_h'786| res) 10)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h784 res) 0))
                (=> (= (sel var__temp_h784 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************205
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i774 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i774, res ) ==(v)
 	 , (sel)( , var_h_i774, res ) ==((sel)( , var_h773, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v775:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i774 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i774 --->  Ty_heap  
 var_h773 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h788 --->  Ty_heap  
 var__temp_v789 --->  Ty_int  
 var__temp_h'790 --->  Ty_heap  
 var__temp_v_err791 --->  error  
 var_h773 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h773, res ) > (4) AND 
 	 Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h788, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h788, res ) ==((sel)( , var_h773, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h788, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h788, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'790, res ) ==(var__temp_v789) AND 
 	 Rel (sel)( , var__temp_h'790, res ) ==((sel)( , var__temp_h788, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'790, res ) ==(var__temp_v789) AND 
 	 Rel (sel)( , var__temp_h'790, res ) ==(10)
 
VC_END(declare-const var_h_i774 T3060)
(declare-const var_h773 T3060)
(declare-const v Int)
(declare-const var_h_i677 T3060)
(declare-const var_h676 T3060)
(declare-const v Int)
(declare-const var_h_i625 T3060)
(declare-const var_h624 T3060)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h788 T3060)
(declare-const var__temp_v789 Int)
(declare-const |var__temp_h'790| T3060)
(declare-const var__temp_v_err791 T3061)
(declare-const var_h773 T3060)
(declare-const var_h676 T3060)
(declare-const var_h624 T3060)
(declare-const err T3074)

solver 
 (declare-sort T3060)
(declare-fun sel (T3060 Int) Int)
(declare-fun res () Int)
(declare-fun var_h773 () T3060)
(declare-fun var_h624 () T3060)
(declare-fun |var__temp_h'790| () T3060)
(declare-fun var__temp_v789 () Int)
(declare-fun var__temp_h788 () T3060)
(declare-fun v () Int)
(assert (> (sel var_h773 res) 4))
(assert (not (> (sel var_h624 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h788 res) v)
                (= (sel var__temp_h788 res) (+ (sel var_h773 res) 10))))
      (a!2 (and (= (sel |var__temp_h'790| res) var__temp_v789)
                (= (sel |var__temp_h'790| res) (+ (sel var__temp_h788 res) 2)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'790| res) var__temp_v789)
                    (= (sel |var__temp_h'790| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h788 res) 5))
                (=> (= (sel var__temp_h788 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************206
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v775:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v775:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2c2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c4	 --foo'	 --c2
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i774 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i774, res ) ==(v)
 	 , (sel)( , var_h_i774, res ) ==((sel)( , var_h773, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v792:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************207
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i774 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i774, res ) ==(v)
 	 , (sel)( , var_h_i774, res ) ==((sel)( , var_h773, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v792:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i774 --->  Ty_heap  
 var_h773 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h793 --->  Ty_heap  
 var__temp_v794 --->  Ty_int  
 var__temp_h'795 --->  Ty_heap  
 var__temp_v_err796 --->  error  
 var_h773 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h773, res ) > (4) AND 
 	 Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h793, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h793, res ) ==((sel)( , var_h773, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h793, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h793, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'795, res ) ==(var__temp_v794) AND 
 	 Rel (sel)( , var__temp_h'795, res ) ==((sel)( , var__temp_h793, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i774 T3077)
(declare-const var_h773 T3077)
(declare-const v Int)
(declare-const var_h_i677 T3077)
(declare-const var_h676 T3077)
(declare-const v Int)
(declare-const var_h_i625 T3077)
(declare-const var_h624 T3077)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h793 T3077)
(declare-const var__temp_v794 Int)
(declare-const |var__temp_h'795| T3077)
(declare-const var__temp_v_err796 T3078)
(declare-const var_h773 T3077)
(declare-const var_h676 T3077)
(declare-const var_h624 T3077)
(declare-const err T3091)

solver 
 (declare-sort T3077)
(declare-fun sel (T3077 Int) Int)
(declare-fun res () Int)
(declare-fun var_h773 () T3077)
(declare-fun var_h624 () T3077)
(declare-fun var__temp_h793 () T3077)
(declare-fun |var__temp_h'795| () T3077)
(declare-fun var__temp_v794 () Int)
(declare-fun v () Int)
(assert (> (sel var_h773 res) 4))
(assert (not (> (sel var_h624 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h793 res) v)
                (= (sel var__temp_h793 res) (+ (sel var_h773 res) 10))))
      (a!2 (and (= (sel |var__temp_h'795| res) var__temp_v794)
                (= (sel |var__temp_h'795| res) (+ (sel var__temp_h793 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h793 res) 7))
                (=> (= (sel var__temp_h793 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************208
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i774 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i774, res ) ==(v)
 	 , (sel)( , var_h_i774, res ) ==((sel)( , var_h773, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v792:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i774 --->  Ty_heap  
 var_h773 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h797 --->  Ty_heap  
 var__temp_v798 --->  Ty_int  
 var__temp_h'799 --->  Ty_heap  
 var__temp_v_err800 --->  error  
 var_h773 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h773, res ) > (4) AND 
 	 Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h797, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h797, res ) ==((sel)( , var_h773, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h797, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h797, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'799, res ) ==(var__temp_v798) AND 
 	 Rel (sel)( , var__temp_h'799, res ) ==((sel)( , var__temp_h797, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i774 T3094)
(declare-const var_h773 T3094)
(declare-const v Int)
(declare-const var_h_i677 T3094)
(declare-const var_h676 T3094)
(declare-const v Int)
(declare-const var_h_i625 T3094)
(declare-const var_h624 T3094)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h797 T3094)
(declare-const var__temp_v798 Int)
(declare-const |var__temp_h'799| T3094)
(declare-const var__temp_v_err800 T3095)
(declare-const var_h773 T3094)
(declare-const var_h676 T3094)
(declare-const var_h624 T3094)
(declare-const err T3108)

solver 
 (declare-sort T3094)
(declare-fun sel (T3094 Int) Int)
(declare-fun res () Int)
(declare-fun var_h773 () T3094)
(declare-fun var_h624 () T3094)
(declare-fun var__temp_h797 () T3094)
(declare-fun |var__temp_h'799| () T3094)
(declare-fun var__temp_v798 () Int)
(declare-fun v () Int)
(assert (> (sel var_h773 res) 4))
(assert (not (> (sel var_h624 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h797 res) v)
                (= (sel var__temp_h797 res) (+ (sel var_h773 res) 10))))
      (a!2 (and (= (sel |var__temp_h'799| res) var__temp_v798)
                (= (sel |var__temp_h'799| res) (+ (sel var__temp_h797 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h797 res) 7))
                (=> (= (sel var__temp_h797 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************209
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i774 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i774, res ) ==(v)
 	 , (sel)( , var_h_i774, res ) ==((sel)( , var_h773, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v792:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i774 --->  Ty_heap  
 var_h773 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h801 --->  Ty_heap  
 var__temp_v802 --->  Ty_int  
 var__temp_h'803 --->  Ty_heap  
 var__temp_v_err804 --->  error  
 var_h773 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h773, res ) > (4) AND 
 	 Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h801, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h801, res ) ==((sel)( , var_h773, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h801, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h801, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'803, res ) ==(var__temp_v802) AND 
 	 Base var__temp_v802 = 5 => 
 	 True
 
VC_END(declare-const var_h_i774 T3111)
(declare-const var_h773 T3111)
(declare-const v Int)
(declare-const var_h_i677 T3111)
(declare-const var_h676 T3111)
(declare-const v Int)
(declare-const var_h_i625 T3111)
(declare-const var_h624 T3111)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h801 T3111)
(declare-const var__temp_v802 Int)
(declare-const |var__temp_h'803| T3111)
(declare-const var__temp_v_err804 T3112)
(declare-const var_h773 T3111)
(declare-const var_h676 T3111)
(declare-const var_h624 T3111)
(declare-const err T3125)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3111)
(declare-fun sel (T3111 Int) Int)
(declare-fun res () Int)
(declare-fun var_h773 () T3111)
(declare-fun var_h624 () T3111)
(declare-fun |5| () Int)
(declare-fun var__temp_v802 () Int)
(declare-fun |var__temp_h'803| () T3111)
(declare-fun var__temp_h801 () T3111)
(declare-fun v () Int)
(assert (> (sel var_h773 res) 4))
(assert (not (> (sel var_h624 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h801 res) v)
                (= (sel var__temp_h801 res) (+ (sel var_h773 res) 10))))
      (a!2 (=> (and (= (sel |var__temp_h'803| res) var__temp_v802)
                    (= var__temp_v802 |5|))
               true)))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h801 res) 0))
                (=> (= (sel var__temp_h801 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************210
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i774 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i774, res ) ==(v)
 	 , (sel)( , var_h_i774, res ) ==((sel)( , var_h773, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v792:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i774 --->  Ty_heap  
 var_h773 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h805 --->  Ty_heap  
 var__temp_v806 --->  Ty_int  
 var__temp_h'807 --->  Ty_heap  
 var__temp_v_err808 --->  error  
 var_h773 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h773, res ) > (4) AND 
 	 Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h805, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h805, res ) ==((sel)( , var_h773, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h805, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h805, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'807, res ) ==(var__temp_v806) AND 
 	 Rel (sel)( , var__temp_h'807, res ) ==((sel)( , var__temp_h805, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i774 T3128)
(declare-const var_h773 T3128)
(declare-const v Int)
(declare-const var_h_i677 T3128)
(declare-const var_h676 T3128)
(declare-const v Int)
(declare-const var_h_i625 T3128)
(declare-const var_h624 T3128)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h805 T3128)
(declare-const var__temp_v806 Int)
(declare-const |var__temp_h'807| T3128)
(declare-const var__temp_v_err808 T3129)
(declare-const var_h773 T3128)
(declare-const var_h676 T3128)
(declare-const var_h624 T3128)
(declare-const err T3142)

solver 
 (declare-sort T3128)
(declare-fun sel (T3128 Int) Int)
(declare-fun res () Int)
(declare-fun var_h773 () T3128)
(declare-fun var_h624 () T3128)
(declare-fun var__temp_h805 () T3128)
(declare-fun |var__temp_h'807| () T3128)
(declare-fun var__temp_v806 () Int)
(declare-fun v () Int)
(assert (> (sel var_h773 res) 4))
(assert (not (> (sel var_h624 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h805 res) v)
                (= (sel var__temp_h805 res) (+ (sel var_h773 res) 10))))
      (a!2 (and (= (sel |var__temp_h'807| res) var__temp_v806)
                (= (sel |var__temp_h'807| res) (+ (sel var__temp_h805 res) 2)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h805 res) 5))
                (=> (= (sel var__temp_h805 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************211
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 	 --c4	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i677 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i677, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v809:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************212
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i677 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i677, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v809:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h810 --->  Ty_heap  
 var__temp_v811 --->  Ty_int  
 var__temp_h'812 --->  Ty_heap  
 var__temp_v_err813 --->  error  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h810, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h810, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h810, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'812, res ) ==(var__temp_v811) AND 
 	 Rel (sel)( , var__temp_h'812, res ) ==((sel)( , var__temp_h810, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i677 T3145)
(declare-const var_h676 T3145)
(declare-const v Int)
(declare-const var_h_i625 T3145)
(declare-const var_h624 T3145)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h810 T3145)
(declare-const var__temp_v811 Int)
(declare-const |var__temp_h'812| T3145)
(declare-const var__temp_v_err813 T3146)
(declare-const var_h676 T3145)
(declare-const var_h624 T3145)
(declare-const err T3159)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3145)
(declare-fun sel (T3145 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T3145)
(declare-fun |20| () Int)
(declare-fun var__temp_h810 () T3145)
(declare-fun |var__temp_h'812| () T3145)
(declare-fun var__temp_v811 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h810 res) v) (= v |20|))
               (= (sel var__temp_h810 res) 7)))
      (a!2 (and (= (sel |var__temp_h'812| res) var__temp_v811)
                (= (sel |var__temp_h'812| res) (+ (sel var__temp_h810 res) 3)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h810 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************213
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i677 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i677, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v809:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h814 --->  Ty_heap  
 var__temp_v815 --->  Ty_int  
 var__temp_h'816 --->  Ty_heap  
 var__temp_v_err817 --->  error  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h814, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h814, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h814, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'816, res ) ==(var__temp_v815) AND 
 	 Rel (sel)( , var__temp_h'816, res ) ==((sel)( , var__temp_h814, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i677 T3162)
(declare-const var_h676 T3162)
(declare-const v Int)
(declare-const var_h_i625 T3162)
(declare-const var_h624 T3162)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h814 T3162)
(declare-const var__temp_v815 Int)
(declare-const |var__temp_h'816| T3162)
(declare-const var__temp_v_err817 T3163)
(declare-const var_h676 T3162)
(declare-const var_h624 T3162)
(declare-const err T3176)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3162)
(declare-fun sel (T3162 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T3162)
(declare-fun |20| () Int)
(declare-fun var__temp_h814 () T3162)
(declare-fun |var__temp_h'816| () T3162)
(declare-fun var__temp_v815 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h814 res) v) (= v |20|))
               (= (sel var__temp_h814 res) 7)))
      (a!2 (and (= (sel |var__temp_h'816| res) var__temp_v815)
                (= (sel |var__temp_h'816| res) (+ (sel var__temp_h814 res) 5)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h814 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************214
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i677 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i677, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v809:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h818 --->  Ty_heap  
 var__temp_v819 --->  Ty_int  
 var__temp_h'820 --->  Ty_heap  
 var__temp_v_err821 --->  error  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h818, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h818, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h818, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'820, res ) ==(var__temp_v819) AND 
 	 Base var__temp_v819 = 5 => 
 	 True
 
VC_END(declare-const var_h_i677 T3179)
(declare-const var_h676 T3179)
(declare-const v Int)
(declare-const var_h_i625 T3179)
(declare-const var_h624 T3179)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h818 T3179)
(declare-const var__temp_v819 Int)
(declare-const |var__temp_h'820| T3179)
(declare-const var__temp_v_err821 T3180)
(declare-const var_h676 T3179)
(declare-const var_h624 T3179)
(declare-const err T3193)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T3179)
(declare-fun sel (T3179 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T3179)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_v819 () Int)
(declare-fun |var__temp_h'820| () T3179)
(declare-fun var__temp_h818 () T3179)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h818 res) v) (= v |20|))
               (= (sel var__temp_h818 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'820| res) var__temp_v819)
                    (= var__temp_v819 |5|))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h818 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************215
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i677 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i677, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v809:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i677 --->  Ty_heap  
 var_h676 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h822 --->  Ty_heap  
 var__temp_v823 --->  Ty_int  
 var__temp_h'824 --->  Ty_heap  
 var__temp_v_err825 --->  error  
 var_h676 --->  Ty_heap  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h822, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h822, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h822, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'824, res ) ==(var__temp_v823) AND 
 	 Rel (sel)( , var__temp_h'824, res ) ==((sel)( , var__temp_h822, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i677 T3196)
(declare-const var_h676 T3196)
(declare-const v Int)
(declare-const var_h_i625 T3196)
(declare-const var_h624 T3196)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h822 T3196)
(declare-const var__temp_v823 Int)
(declare-const |var__temp_h'824| T3196)
(declare-const var__temp_v_err825 T3197)
(declare-const var_h676 T3196)
(declare-const var_h624 T3196)
(declare-const err T3210)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3196)
(declare-fun sel (T3196 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T3196)
(declare-fun |20| () Int)
(declare-fun var__temp_h822 () T3196)
(declare-fun |var__temp_h'824| () T3196)
(declare-fun var__temp_v823 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h822 res) v) (= v |20|))
               (= (sel var__temp_h822 res) 5)))
      (a!2 (and (= (sel |var__temp_h'824| res) var__temp_v823)
                (= (sel |var__temp_h'824| res) (+ (sel var__temp_h822 res) 2)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h822 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************216
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i625 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i625, res ) ==(v)
 	 , (sel)( , var_h_i625, res ) ==((sel)( , var_h624, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v826:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
foo
bar
 *********************Enumeration Iteration*****************217
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i625 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i625, res ) ==(v)
 	 , (sel)( , var_h_i625, res ) ==((sel)( , var_h624, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v826:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h827 --->  Ty_heap  
 var__temp_v828 --->  Ty_int  
 var__temp_h'829 --->  Ty_heap  
 var__temp_v_err830 --->  error  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h827, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h827, res ) ==((sel)( , var_h624, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h827, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h827, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'829, res ) ==(var__temp_v828) AND 
 	 Rel (sel)( , var__temp_h'829, res ) ==((sel)( , var__temp_h827, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i625 T3213)
(declare-const var_h624 T3213)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h827 T3213)
(declare-const var__temp_v828 Int)
(declare-const |var__temp_h'829| T3213)
(declare-const var__temp_v_err830 T3214)
(declare-const var_h624 T3213)
(declare-const err T3227)

solver 
 (declare-sort T3213)
(declare-fun sel (T3213 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T3213)
(declare-fun var__temp_h827 () T3213)
(declare-fun |var__temp_h'829| () T3213)
(declare-fun var__temp_v828 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h827 res) v)
                (= (sel var__temp_h827 res) (+ (sel var_h624 res) 5))))
      (a!2 (and (= (sel |var__temp_h'829| res) var__temp_v828)
                (= (sel |var__temp_h'829| res) (+ (sel var__temp_h827 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h827 res) 7))
                (=> (= (sel var__temp_h827 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************218
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i625 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i625, res ) ==(v)
 	 , (sel)( , var_h_i625, res ) ==((sel)( , var_h624, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v826:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h831 --->  Ty_heap  
 var__temp_v832 --->  Ty_int  
 var__temp_h'833 --->  Ty_heap  
 var__temp_v_err834 --->  error  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h831, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h831, res ) ==((sel)( , var_h624, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h831, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h831, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'833, res ) ==(var__temp_v832) AND 
 	 Rel (sel)( , var__temp_h'833, res ) ==((sel)( , var__temp_h831, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i625 T3230)
(declare-const var_h624 T3230)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h831 T3230)
(declare-const var__temp_v832 Int)
(declare-const |var__temp_h'833| T3230)
(declare-const var__temp_v_err834 T3231)
(declare-const var_h624 T3230)
(declare-const err T3244)

solver 
 (declare-sort T3230)
(declare-fun sel (T3230 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T3230)
(declare-fun var__temp_h831 () T3230)
(declare-fun |var__temp_h'833| () T3230)
(declare-fun var__temp_v832 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h831 res) v)
                (= (sel var__temp_h831 res) (+ (sel var_h624 res) 5))))
      (a!2 (and (= (sel |var__temp_h'833| res) var__temp_v832)
                (= (sel |var__temp_h'833| res) (+ (sel var__temp_h831 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h831 res) 7))
                (=> (= (sel var__temp_h831 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************219
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h, res ) ==(sel)( , h, res ) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i625 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i625, res ) ==(v)
 	 , (sel)( , var_h_i625, res ) ==((sel)( , var_h624, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v826:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h, res ) ==(sel)( , h, res ) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h835 --->  Ty_heap  
 var__temp_v836 --->  Ty_int  
 var__temp_h'837 --->  Ty_heap  
 var__temp_v_err838 --->  error  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h835, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h835, res ) ==((sel)( , var_h624, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h835, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h835, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'837, res ) ==(var__temp_v836) AND 
 	 Rel (sel)( , var__temp_h835, res ) ==(sel)( , var__temp_h835, res ) => 
 	 True
 
VC_END(declare-const var_h_i625 T3247)
(declare-const var_h624 T3247)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h835 T3247)
(declare-const var__temp_v836 Int)
(declare-const |var__temp_h'837| T3247)
(declare-const var__temp_v_err838 T3248)
(declare-const var_h624 T3247)
(declare-const err T3261)

solver 
 (declare-sort T3247)
(declare-fun sel (T3247 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T3247)
(declare-fun var__temp_h835 () T3247)
(declare-fun var__temp_v836 () Int)
(declare-fun |var__temp_h'837| () T3247)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h835 res) v)
                (= (sel var__temp_h835 res) (+ (sel var_h624 res) 5))))
      (a!3 (=> (and (= (sel |var__temp_h'837| res) var__temp_v836)
                    (= (sel var__temp_h835 res) (sel var__temp_h835 res)))
               true)))
(let ((a!2 (=> a!1 (not (> (sel var__temp_h835 res) 20))))
      (a!4 (=> (not (> (sel var__temp_h835 res) 20)) a!3)))
  (not (and a!2 a!4)))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************220
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i625 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i625, res ) ==(v)
 	 , (sel)( , var_h_i625, res ) ==((sel)( , var_h624, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v826:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h839 --->  Ty_heap  
 var__temp_v840 --->  Ty_int  
 var__temp_h'841 --->  Ty_heap  
 var__temp_v_err842 --->  error  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h839, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h839, res ) ==((sel)( , var_h624, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h839, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h839, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'841, res ) ==(var__temp_v840) AND 
 	 Rel (sel)( , var__temp_h'841, res ) ==((sel)( , var__temp_h839, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i625 T3264)
(declare-const var_h624 T3264)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h839 T3264)
(declare-const var__temp_v840 Int)
(declare-const |var__temp_h'841| T3264)
(declare-const var__temp_v_err842 T3265)
(declare-const var_h624 T3264)
(declare-const err T3278)

solver 
 (declare-sort T3264)
(declare-fun sel (T3264 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T3264)
(declare-fun var__temp_h839 () T3264)
(declare-fun |var__temp_h'841| () T3264)
(declare-fun var__temp_v840 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h839 res) v)
                (= (sel var__temp_h839 res) (+ (sel var_h624 res) 5))))
      (a!2 (and (= (sel |var__temp_h'841| res) var__temp_v840)
                (= (sel |var__temp_h'841| res) (+ (sel var__temp_h839 res) 10)))))
(let ((a!3 (and (=> a!1 (> (sel var__temp_h839 res) 4))
                (=> (> (sel var__temp_h839 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************221
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i625 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i625, res ) ==(v)
 	 , (sel)( , var_h_i625, res ) ==((sel)( , var_h624, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v826:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h843 --->  Ty_heap  
 var__temp_v844 --->  Ty_int  
 var__temp_h'845 --->  Ty_heap  
 var__temp_v_err846 --->  error  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h843, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h843, res ) ==((sel)( , var_h624, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h843, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h843, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'845, res ) ==(var__temp_v844) AND 
 	 Base var__temp_v844 = 5 => 
 	 True
 
VC_END(declare-const var_h_i625 T3281)
(declare-const var_h624 T3281)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h843 T3281)
(declare-const var__temp_v844 Int)
(declare-const |var__temp_h'845| T3281)
(declare-const var__temp_v_err846 T3282)
(declare-const var_h624 T3281)
(declare-const err T3295)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3281)
(declare-fun sel (T3281 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T3281)
(declare-fun |5| () Int)
(declare-fun var__temp_v844 () Int)
(declare-fun |var__temp_h'845| () T3281)
(declare-fun var__temp_h843 () T3281)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h843 res) v)
                (= (sel var__temp_h843 res) (+ (sel var_h624 res) 5))))
      (a!2 (=> (and (= (sel |var__temp_h'845| res) var__temp_v844)
                    (= var__temp_v844 |5|))
               true)))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h843 res) 0))
                (=> (= (sel var__temp_h843 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************222
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i625 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i625, res ) ==(v)
 	 , (sel)( , var_h_i625, res ) ==((sel)( , var_h624, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v826:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i625 --->  Ty_heap  
 var_h624 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h847 --->  Ty_heap  
 var__temp_v848 --->  Ty_int  
 var__temp_h'849 --->  Ty_heap  
 var__temp_v_err850 --->  error  
 var_h624 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h624, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h847, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h847, res ) ==((sel)( , var_h624, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h847, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h847, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'849, res ) ==(var__temp_v848) AND 
 	 Rel (sel)( , var__temp_h'849, res ) ==((sel)( , var__temp_h847, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i625 T3298)
(declare-const var_h624 T3298)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h847 T3298)
(declare-const var__temp_v848 Int)
(declare-const |var__temp_h'849| T3298)
(declare-const var__temp_v_err850 T3299)
(declare-const var_h624 T3298)
(declare-const err T3312)

solver 
 (declare-sort T3298)
(declare-fun sel (T3298 Int) Int)
(declare-fun res () Int)
(declare-fun var_h624 () T3298)
(declare-fun var__temp_h847 () T3298)
(declare-fun |var__temp_h'849| () T3298)
(declare-fun var__temp_v848 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h624 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h847 res) v)
                (= (sel var__temp_h847 res) (+ (sel var_h624 res) 5))))
      (a!2 (and (= (sel |var__temp_h'849| res) var__temp_v848)
                (= (sel |var__temp_h'849| res) (+ (sel var__temp_h847 res) 2)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h847 res) 5))
                (=> (= (sel var__temp_h847 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************223
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo'
PARTIAL PATH
SUB 
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {var_v851:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************224
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {var_v851:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h852 --->  Ty_heap  
 var__temp_v853 --->  Ty_int  
 var__temp_h'854 --->  Ty_heap  
 var__temp_v_err855 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h852, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h852, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h852, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'854, res ) ==(var__temp_v853) AND 
 	 Rel (sel)( , var__temp_h'854, res ) ==((sel)( , var__temp_h852, res ) + (3)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h852 T3315)
(declare-const var__temp_v853 Int)
(declare-const |var__temp_h'854| T3315)
(declare-const var__temp_v_err855 T3316)
(declare-const err T3329)

solver 
 (declare-sort T3315)
(declare-fun sel (T3315 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h852 () T3315)
(declare-fun |var__temp_h'854| () T3315)
(declare-fun var__temp_v853 () Int)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'854| res) var__temp_v853)
                (= (sel |var__temp_h'854| res) (+ (sel var__temp_h852 res) 3)))))
(let ((a!2 (and (=> (= (sel var__temp_h852 res) 0)
                    (= (sel var__temp_h852 res) 7))
                (=> (= (sel var__temp_h852 res) 7) (=> a!1 true)))))
  (not a!2))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************225
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {var_v851:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h856 --->  Ty_heap  
 var__temp_v857 --->  Ty_int  
 var__temp_h'858 --->  Ty_heap  
 var__temp_v_err859 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h856, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h856, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h856, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'858, res ) ==(var__temp_v857) AND 
 	 Rel (sel)( , var__temp_h'858, res ) ==((sel)( , var__temp_h856, res ) + (5)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h856 T3332)
(declare-const var__temp_v857 Int)
(declare-const |var__temp_h'858| T3332)
(declare-const var__temp_v_err859 T3333)
(declare-const err T3346)

solver 
 (declare-sort T3332)
(declare-fun sel (T3332 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h856 () T3332)
(declare-fun |var__temp_h'858| () T3332)
(declare-fun var__temp_v857 () Int)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'858| res) var__temp_v857)
                (= (sel |var__temp_h'858| res) (+ (sel var__temp_h856 res) 5)))))
(let ((a!2 (and (=> (= (sel var__temp_h856 res) 0)
                    (= (sel var__temp_h856 res) 7))
                (=> (= (sel var__temp_h856 res) 7) (=> a!1 true)))))
  (not a!2))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************226
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h, res ) ==(sel)( , h, res ) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {var_v851:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h, res ) ==(sel)( , h, res ) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h860 --->  Ty_heap  
 var__temp_v861 --->  Ty_int  
 var__temp_h'862 --->  Ty_heap  
 var__temp_v_err863 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h860, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h860, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h860, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'862, res ) ==(var__temp_v861) AND 
 	 Rel (sel)( , var__temp_h860, res ) ==(sel)( , var__temp_h860, res ) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h860 T3349)
(declare-const var__temp_v861 Int)
(declare-const |var__temp_h'862| T3349)
(declare-const var__temp_v_err863 T3350)
(declare-const err T3363)

solver 
 (declare-sort T3349)
(declare-fun sel (T3349 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h860 () T3349)
(declare-fun var__temp_v861 () Int)
(declare-fun |var__temp_h'862| () T3349)
(assert true)
(assert (let ((a!1 (=> (= (sel var__temp_h860 res) 0)
               (not (> (sel var__temp_h860 res) 20))))
      (a!2 (=> (and (= (sel |var__temp_h'862| res) var__temp_v861)
                    (= (sel var__temp_h860 res) (sel var__temp_h860 res)))
               true)))
(let ((a!3 (=> (not (> (sel var__temp_h860 res) 20)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Successful************c2'
PARTIAL PATH NEW
NEW 	 --c2'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i865 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i865, res ) ==(v)
 	 , (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) >c  } 
 } 
 
                                                RET :  Base {var_v866:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i865 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************227
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i865, res ) ==(v)
 	 , (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) >c  } 
 } 
 
                                                RET :  Base {var_v866:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i865 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h867 --->  Ty_heap  
 var__temp_v868 --->  Ty_int  
 var__temp_h'869 --->  Ty_heap  
 var__temp_v_err870 --->  error  
 var_h864 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h867, res ) ==(v) AND 
 	 Rel (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) => 
 	 Rel (sel)( , var__temp_h867, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h867, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'869, res ) ==(var__temp_v868) AND 
 	 Rel (sel)( , var__temp_h'869, res ) ==((sel)( , var__temp_h867, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'869, res ) ==(var__temp_v868) AND 
 	 Rel (sel)( , var__temp_h'869, res ) ==(10)
 
VC_END(declare-const var_h_i865 T3366)
(declare-const var_h864 T3366)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h867 T3366)
(declare-const var__temp_v868 Int)
(declare-const |var__temp_h'869| T3366)
(declare-const var__temp_v_err870 T3367)
(declare-const var_h864 T3366)
(declare-const err T3380)

solver 
 (declare-sort T3366)
(declare-fun sel (T3366 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3366)
(declare-fun |var__temp_h'869| () T3366)
(declare-fun var__temp_v868 () Int)
(declare-fun var__temp_h867 () T3366)
(declare-fun v () Int)
(assert (not (> (sel var_h864 res) 20)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h867 res) v)
                    (= (sel var_h864 res) (sel var_h864 res)))
               (= (sel var__temp_h867 res) 7)))
      (a!2 (and (= (sel |var__temp_h'869| res) var__temp_v868)
                (= (sel |var__temp_h'869| res) (+ (sel var__temp_h867 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'869| res) var__temp_v868)
                    (= (sel |var__temp_h'869| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h867 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************228
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i865, res ) ==(v)
 	 , (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) >c  } 
 } 
 
                                                RET :  Base {var_v866:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i865 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h871 --->  Ty_heap  
 var__temp_v872 --->  Ty_int  
 var__temp_h'873 --->  Ty_heap  
 var__temp_v_err874 --->  error  
 var_h864 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h871, res ) ==(v) AND 
 	 Rel (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) => 
 	 Rel (sel)( , var__temp_h871, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h871, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'873, res ) ==(var__temp_v872) AND 
 	 Rel (sel)( , var__temp_h'873, res ) ==((sel)( , var__temp_h871, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'873, res ) ==(var__temp_v872) AND 
 	 Rel (sel)( , var__temp_h'873, res ) ==(10)
 
VC_END(declare-const var_h_i865 T3383)
(declare-const var_h864 T3383)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h871 T3383)
(declare-const var__temp_v872 Int)
(declare-const |var__temp_h'873| T3383)
(declare-const var__temp_v_err874 T3384)
(declare-const var_h864 T3383)
(declare-const err T3397)

solver 
 (declare-sort T3383)
(declare-fun sel (T3383 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3383)
(declare-fun |var__temp_h'873| () T3383)
(declare-fun var__temp_v872 () Int)
(declare-fun var__temp_h871 () T3383)
(declare-fun v () Int)
(assert (not (> (sel var_h864 res) 20)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h871 res) v)
                    (= (sel var_h864 res) (sel var_h864 res)))
               (= (sel var__temp_h871 res) 7)))
      (a!2 (and (= (sel |var__temp_h'873| res) var__temp_v872)
                (= (sel |var__temp_h'873| res) (+ (sel var__temp_h871 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'873| res) var__temp_v872)
                    (= (sel |var__temp_h'873| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h871 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************229
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i865, res ) ==(v)
 	 , (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) >c  } 
 } 
 
                                                RET :  Base {var_v866:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i865 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h875 --->  Ty_heap  
 var__temp_v876 --->  Ty_int  
 var__temp_h'877 --->  Ty_heap  
 var__temp_v_err878 --->  error  
 var_h864 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h875, res ) ==(v) AND 
 	 Rel (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) => 
 	 Rel (sel)( , var__temp_h875, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h875, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'877, res ) ==(var__temp_v876) AND 
 	 Rel (sel)( , var__temp_h'877, res ) ==((sel)( , var__temp_h875, res ) + (10)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'877, res ) ==(var__temp_v876) AND 
 	 Rel (sel)( , var__temp_h'877, res ) ==(10)
 
VC_END(declare-const var_h_i865 T3400)
(declare-const var_h864 T3400)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h875 T3400)
(declare-const var__temp_v876 Int)
(declare-const |var__temp_h'877| T3400)
(declare-const var__temp_v_err878 T3401)
(declare-const var_h864 T3400)
(declare-const err T3414)

solver 
 (declare-sort T3400)
(declare-fun sel (T3400 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3400)
(declare-fun |var__temp_h'877| () T3400)
(declare-fun var__temp_v876 () Int)
(declare-fun var__temp_h875 () T3400)
(declare-fun v () Int)
(assert (not (> (sel var_h864 res) 20)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h875 res) v)
                    (= (sel var_h864 res) (sel var_h864 res)))
               (> (sel var__temp_h875 res) 4)))
      (a!2 (and (= (sel |var__temp_h'877| res) var__temp_v876)
                (= (sel |var__temp_h'877| res) (+ (sel var__temp_h875 res) 10)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'877| res) var__temp_v876)
                    (= (sel |var__temp_h'877| res) 10)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h875 res) 4) a!3))))
  (not a!4)))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************230
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i865, res ) ==(v)
 	 , (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) >c  } 
 } 
 
                                                RET :  Base {var_v866:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i865 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h879 --->  Ty_heap  
 var__temp_v880 --->  Ty_int  
 var__temp_h'881 --->  Ty_heap  
 var__temp_v_err882 --->  error  
 var_h864 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h879, res ) ==(v) AND 
 	 Rel (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'881, res ) ==(var__temp_v880) AND 
 	 Base var__temp_v880 = 20 => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'881, res ) ==(var__temp_v880) AND 
 	 Rel (sel)( , var__temp_h'881, res ) ==(10)
 
VC_END(declare-const var_h_i865 T3417)
(declare-const var_h864 T3417)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h879 T3417)
(declare-const var__temp_v880 Int)
(declare-const |var__temp_h'881| T3417)
(declare-const var__temp_v_err882 T3418)
(declare-const var_h864 T3417)
(declare-const err T3431)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3417)
(declare-fun sel (T3417 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3417)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'881| () T3417)
(declare-fun var__temp_v880 () Int)
(declare-fun v () Int)
(declare-fun var__temp_h879 () T3417)
(assert (not (> (sel var_h864 res) 20)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h879 res) v)
                    (= (sel var_h864 res) (sel var_h864 res)))
               true))
      (a!2 (=> (and (= (sel |var__temp_h'881| res) var__temp_v880)
                    (= var__temp_v880 |20|))
               (and (= (sel |var__temp_h'881| res) var__temp_v880)
                    (= (sel |var__temp_h'881| res) 10)))))
  (not (and a!1 (=> true a!2)))))

***************Selection Failed************foo'
 *********************Enumeration Iteration*****************231
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i865, res ) ==(v)
 	 , (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) >c  } 
 } 
 
                                                RET :  Base {var_v866:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i865 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h883 --->  Ty_heap  
 var__temp_v884 --->  Ty_int  
 var__temp_h'885 --->  Ty_heap  
 var__temp_v_err886 --->  error  
 var_h864 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h883, res ) ==(v) AND 
 	 Rel (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) => 
 	 Rel (sel)( , var__temp_h883, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h883, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'885, res ) ==(var__temp_v884) AND 
 	 Base var__temp_v884 = 5 => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'885, res ) ==(var__temp_v884) AND 
 	 Rel (sel)( , var__temp_h'885, res ) ==(10)
 
VC_END(declare-const var_h_i865 T3434)
(declare-const var_h864 T3434)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h883 T3434)
(declare-const var__temp_v884 Int)
(declare-const |var__temp_h'885| T3434)
(declare-const var__temp_v_err886 T3435)
(declare-const var_h864 T3434)
(declare-const err T3448)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3434)
(declare-fun sel (T3434 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3434)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'885| () T3434)
(declare-fun var__temp_v884 () Int)
(declare-fun var__temp_h883 () T3434)
(declare-fun v () Int)
(assert (not (> (sel var_h864 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h883 res) v)
                    (= (sel var_h864 res) (sel var_h864 res)))
               (= (sel var__temp_h883 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'885| res) var__temp_v884)
                    (= var__temp_v884 |5|))
               (and (= (sel |var__temp_h'885| res) var__temp_v884)
                    (= (sel |var__temp_h'885| res) 10)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h883 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************232
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i865, res ) ==(v)
 	 , (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) >c  } 
 } 
 
                                                RET :  Base {var_v866:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i865 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h887 --->  Ty_heap  
 var__temp_v888 --->  Ty_int  
 var__temp_h'889 --->  Ty_heap  
 var__temp_v_err890 --->  error  
 var_h864 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h887, res ) ==(v) AND 
 	 Rel (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) => 
 	 Rel (sel)( , var__temp_h887, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h887, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'889, res ) ==(var__temp_v888) AND 
 	 Rel (sel)( , var__temp_h'889, res ) ==((sel)( , var__temp_h887, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'889, res ) ==(var__temp_v888) AND 
 	 Rel (sel)( , var__temp_h'889, res ) ==(10)
 
VC_END(declare-const var_h_i865 T3451)
(declare-const var_h864 T3451)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h887 T3451)
(declare-const var__temp_v888 Int)
(declare-const |var__temp_h'889| T3451)
(declare-const var__temp_v_err890 T3452)
(declare-const var_h864 T3451)
(declare-const err T3465)

solver 
 (declare-sort T3451)
(declare-fun sel (T3451 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3451)
(declare-fun |var__temp_h'889| () T3451)
(declare-fun var__temp_v888 () Int)
(declare-fun var__temp_h887 () T3451)
(declare-fun v () Int)
(assert (not (> (sel var_h864 res) 20)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h887 res) v)
                    (= (sel var_h864 res) (sel var_h864 res)))
               (= (sel var__temp_h887 res) 5)))
      (a!2 (and (= (sel |var__temp_h'889| res) var__temp_v888)
                (= (sel |var__temp_h'889| res) (+ (sel var__temp_h887 res) 2)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'889| res) var__temp_v888)
                    (= (sel |var__temp_h'889| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h887 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************233
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v866:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v866:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i865, res ) ==(v)
 	 , (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) >c  } 
 } 
 
                                                RET :  Base {var_v891:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************234
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i865, res ) ==(v)
 	 , (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) >c  } 
 } 
 
                                                RET :  Base {var_v891:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h892 --->  Ty_heap  
 var__temp_v893 --->  Ty_int  
 var__temp_h'894 --->  Ty_heap  
 var__temp_v_err895 --->  error  
 var_h864 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h892, res ) ==(v) AND 
 	 Rel (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) => 
 	 Rel (sel)( , var__temp_h892, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h892, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'894, res ) ==(var__temp_v893) AND 
 	 Rel (sel)( , var__temp_h'894, res ) ==((sel)( , var__temp_h892, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i865 T3468)
(declare-const var_h864 T3468)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h892 T3468)
(declare-const var__temp_v893 Int)
(declare-const |var__temp_h'894| T3468)
(declare-const var__temp_v_err895 T3469)
(declare-const var_h864 T3468)
(declare-const err T3482)

solver 
 (declare-sort T3468)
(declare-fun sel (T3468 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3468)
(declare-fun var__temp_h892 () T3468)
(declare-fun |var__temp_h'894| () T3468)
(declare-fun var__temp_v893 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h864 res) 20)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h892 res) v)
                    (= (sel var_h864 res) (sel var_h864 res)))
               (= (sel var__temp_h892 res) 7)))
      (a!2 (and (= (sel |var__temp_h'894| res) var__temp_v893)
                (= (sel |var__temp_h'894| res) (+ (sel var__temp_h892 res) 3)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h892 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************235
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i865, res ) ==(v)
 	 , (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) >c  } 
 } 
 
                                                RET :  Base {var_v891:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h896 --->  Ty_heap  
 var__temp_v897 --->  Ty_int  
 var__temp_h'898 --->  Ty_heap  
 var__temp_v_err899 --->  error  
 var_h864 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h896, res ) ==(v) AND 
 	 Rel (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) => 
 	 Rel (sel)( , var__temp_h896, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h896, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'898, res ) ==(var__temp_v897) AND 
 	 Rel (sel)( , var__temp_h'898, res ) ==((sel)( , var__temp_h896, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i865 T3485)
(declare-const var_h864 T3485)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h896 T3485)
(declare-const var__temp_v897 Int)
(declare-const |var__temp_h'898| T3485)
(declare-const var__temp_v_err899 T3486)
(declare-const var_h864 T3485)
(declare-const err T3499)

solver 
 (declare-sort T3485)
(declare-fun sel (T3485 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3485)
(declare-fun var__temp_h896 () T3485)
(declare-fun |var__temp_h'898| () T3485)
(declare-fun var__temp_v897 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h864 res) 20)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h896 res) v)
                    (= (sel var_h864 res) (sel var_h864 res)))
               (= (sel var__temp_h896 res) 7)))
      (a!2 (and (= (sel |var__temp_h'898| res) var__temp_v897)
                (= (sel |var__temp_h'898| res) (+ (sel var__temp_h896 res) 5)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h896 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************236
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i865, res ) ==(v)
 	 , (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) >c  } 
 } 
 
                                                RET :  Base {var_v891:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h900 --->  Ty_heap  
 var__temp_v901 --->  Ty_int  
 var__temp_h'902 --->  Ty_heap  
 var__temp_v_err903 --->  error  
 var_h864 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h900, res ) ==(v) AND 
 	 Rel (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) => 
 	 Rel (sel)( , var__temp_h900, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h900, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'902, res ) ==(var__temp_v901) AND 
 	 Rel (sel)( , var__temp_h'902, res ) ==((sel)( , var__temp_h900, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i865 T3502)
(declare-const var_h864 T3502)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h900 T3502)
(declare-const var__temp_v901 Int)
(declare-const |var__temp_h'902| T3502)
(declare-const var__temp_v_err903 T3503)
(declare-const var_h864 T3502)
(declare-const err T3516)

solver 
 (declare-sort T3502)
(declare-fun sel (T3502 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3502)
(declare-fun var__temp_h900 () T3502)
(declare-fun |var__temp_h'902| () T3502)
(declare-fun var__temp_v901 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h864 res) 20)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h900 res) v)
                    (= (sel var_h864 res) (sel var_h864 res)))
               (> (sel var__temp_h900 res) 4)))
      (a!2 (and (= (sel |var__temp_h'902| res) var__temp_v901)
                (= (sel |var__temp_h'902| res) (+ (sel var__temp_h900 res) 10)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h900 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************237
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i865, res ) ==(v)
 	 , (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) >c  } 
 } 
 
                                                RET :  Base {var_v891:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h904 --->  Ty_heap  
 var__temp_v905 --->  Ty_int  
 var__temp_h'906 --->  Ty_heap  
 var__temp_v_err907 --->  error  
 var_h864 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h904, res ) ==(v) AND 
 	 Rel (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'906, res ) ==(var__temp_v905) AND 
 	 Base var__temp_v905 = 20 => 
 	 True
 
VC_END(declare-const var_h_i865 T3519)
(declare-const var_h864 T3519)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h904 T3519)
(declare-const var__temp_v905 Int)
(declare-const |var__temp_h'906| T3519)
(declare-const var__temp_v_err907 T3520)
(declare-const var_h864 T3519)
(declare-const err T3533)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3519)
(declare-fun sel (T3519 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3519)
(declare-fun |20| () Int)
(declare-fun var__temp_v905 () Int)
(declare-fun |var__temp_h'906| () T3519)
(declare-fun v () Int)
(declare-fun var__temp_h904 () T3519)
(assert (not (> (sel var_h864 res) 20)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h904 res) v)
                    (= (sel var_h864 res) (sel var_h864 res)))
               true))
      (a!2 (=> (and (= (sel |var__temp_h'906| res) var__temp_v905)
                    (= var__temp_v905 |20|))
               true)))
  (not (and a!1 (=> true a!2)))))

***************Selection Successful************foo'
PARTIAL PATH NEW
NEW 	 --c2'	 --foo'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i909 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i909 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i909, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v910:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i909 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************238
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i909 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i909, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v910:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i909 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i909 --->  Ty_heap  
 var_h908 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h911 --->  Ty_heap  
 var__temp_v912 --->  Ty_int  
 var__temp_h'913 --->  Ty_heap  
 var__temp_v_err914 --->  error  
 var_h908 --->  Ty_heap  
 var_h864 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h911, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h911, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h911, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'913, res ) ==(var__temp_v912) AND 
 	 Rel (sel)( , var__temp_h'913, res ) ==((sel)( , var__temp_h911, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'913, res ) ==(var__temp_v912) AND 
 	 Rel (sel)( , var__temp_h'913, res ) ==(10)
 
VC_END(declare-const var_h_i909 T3536)
(declare-const var_h908 T3536)
(declare-const v Int)
(declare-const var_h_i865 T3536)
(declare-const var_h864 T3536)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h911 T3536)
(declare-const var__temp_v912 Int)
(declare-const |var__temp_h'913| T3536)
(declare-const var__temp_v_err914 T3537)
(declare-const var_h908 T3536)
(declare-const var_h864 T3536)
(declare-const err T3550)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3536)
(declare-fun sel (T3536 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3536)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'913| () T3536)
(declare-fun var__temp_v912 () Int)
(declare-fun var__temp_h911 () T3536)
(declare-fun v () Int)
(assert (not (> (sel var_h864 res) 20)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h911 res) v) (= v |20|))
               (= (sel var__temp_h911 res) 7)))
      (a!2 (and (= (sel |var__temp_h'913| res) var__temp_v912)
                (= (sel |var__temp_h'913| res) (+ (sel var__temp_h911 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'913| res) var__temp_v912)
                    (= (sel |var__temp_h'913| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h911 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************239
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i909 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i909, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v910:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i909 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i909 --->  Ty_heap  
 var_h908 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h915 --->  Ty_heap  
 var__temp_v916 --->  Ty_int  
 var__temp_h'917 --->  Ty_heap  
 var__temp_v_err918 --->  error  
 var_h908 --->  Ty_heap  
 var_h864 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h915, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h915, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h915, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'917, res ) ==(var__temp_v916) AND 
 	 Rel (sel)( , var__temp_h'917, res ) ==((sel)( , var__temp_h915, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'917, res ) ==(var__temp_v916) AND 
 	 Rel (sel)( , var__temp_h'917, res ) ==(10)
 
VC_END(declare-const var_h_i909 T3553)
(declare-const var_h908 T3553)
(declare-const v Int)
(declare-const var_h_i865 T3553)
(declare-const var_h864 T3553)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h915 T3553)
(declare-const var__temp_v916 Int)
(declare-const |var__temp_h'917| T3553)
(declare-const var__temp_v_err918 T3554)
(declare-const var_h908 T3553)
(declare-const var_h864 T3553)
(declare-const err T3567)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3553)
(declare-fun sel (T3553 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3553)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'917| () T3553)
(declare-fun var__temp_v916 () Int)
(declare-fun var__temp_h915 () T3553)
(declare-fun v () Int)
(assert (not (> (sel var_h864 res) 20)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h915 res) v) (= v |20|))
               (= (sel var__temp_h915 res) 7)))
      (a!2 (and (= (sel |var__temp_h'917| res) var__temp_v916)
                (= (sel |var__temp_h'917| res) (+ (sel var__temp_h915 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'917| res) var__temp_v916)
                    (= (sel |var__temp_h'917| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h915 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************240
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i909 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i909, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v910:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i909 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i909 --->  Ty_heap  
 var_h908 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h919 --->  Ty_heap  
 var__temp_v920 --->  Ty_int  
 var__temp_h'921 --->  Ty_heap  
 var__temp_v_err922 --->  error  
 var_h908 --->  Ty_heap  
 var_h864 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h919, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h919, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h919, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'921, res ) ==(var__temp_v920) AND 
 	 Rel (sel)( , var__temp_h'921, res ) ==((sel)( , var__temp_h919, res ) + (10)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'921, res ) ==(var__temp_v920) AND 
 	 Rel (sel)( , var__temp_h'921, res ) ==(10)
 
VC_END(declare-const var_h_i909 T3570)
(declare-const var_h908 T3570)
(declare-const v Int)
(declare-const var_h_i865 T3570)
(declare-const var_h864 T3570)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h919 T3570)
(declare-const var__temp_v920 Int)
(declare-const |var__temp_h'921| T3570)
(declare-const var__temp_v_err922 T3571)
(declare-const var_h908 T3570)
(declare-const var_h864 T3570)
(declare-const err T3584)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3570)
(declare-fun sel (T3570 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3570)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'921| () T3570)
(declare-fun var__temp_v920 () Int)
(declare-fun var__temp_h919 () T3570)
(declare-fun v () Int)
(assert (not (> (sel var_h864 res) 20)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h919 res) v) (= v |20|))
               (> (sel var__temp_h919 res) 4)))
      (a!2 (and (= (sel |var__temp_h'921| res) var__temp_v920)
                (= (sel |var__temp_h'921| res) (+ (sel var__temp_h919 res) 10)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'921| res) var__temp_v920)
                    (= (sel |var__temp_h'921| res) 10)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h919 res) 4) a!3))))
  (not a!4)))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************241
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i909 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i909, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v910:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i909 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i909 --->  Ty_heap  
 var_h908 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h923 --->  Ty_heap  
 var__temp_v924 --->  Ty_int  
 var__temp_h'925 --->  Ty_heap  
 var__temp_v_err926 --->  error  
 var_h908 --->  Ty_heap  
 var_h864 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h923, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h923, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h923, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'925, res ) ==(var__temp_v924) AND 
 	 Base var__temp_v924 = 5 => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'925, res ) ==(var__temp_v924) AND 
 	 Rel (sel)( , var__temp_h'925, res ) ==(10)
 
VC_END(declare-const var_h_i909 T3587)
(declare-const var_h908 T3587)
(declare-const v Int)
(declare-const var_h_i865 T3587)
(declare-const var_h864 T3587)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h923 T3587)
(declare-const var__temp_v924 Int)
(declare-const |var__temp_h'925| T3587)
(declare-const var__temp_v_err926 T3588)
(declare-const var_h908 T3587)
(declare-const var_h864 T3587)
(declare-const err T3601)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T3587)
(declare-fun sel (T3587 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3587)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'925| () T3587)
(declare-fun var__temp_v924 () Int)
(declare-fun var__temp_h923 () T3587)
(declare-fun v () Int)
(assert (not (> (sel var_h864 res) 20)))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h923 res) v) (= v |20|))
               (= (sel var__temp_h923 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'925| res) var__temp_v924)
                    (= var__temp_v924 |5|))
               (and (= (sel |var__temp_h'925| res) var__temp_v924)
                    (= (sel |var__temp_h'925| res) 10)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h923 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************242
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i909 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i909, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v910:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i909 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i909 --->  Ty_heap  
 var_h908 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h927 --->  Ty_heap  
 var__temp_v928 --->  Ty_int  
 var__temp_h'929 --->  Ty_heap  
 var__temp_v_err930 --->  error  
 var_h908 --->  Ty_heap  
 var_h864 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h927, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h927, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h927, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'929, res ) ==(var__temp_v928) AND 
 	 Rel (sel)( , var__temp_h'929, res ) ==((sel)( , var__temp_h927, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'929, res ) ==(var__temp_v928) AND 
 	 Rel (sel)( , var__temp_h'929, res ) ==(10)
 
VC_END(declare-const var_h_i909 T3604)
(declare-const var_h908 T3604)
(declare-const v Int)
(declare-const var_h_i865 T3604)
(declare-const var_h864 T3604)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h927 T3604)
(declare-const var__temp_v928 Int)
(declare-const |var__temp_h'929| T3604)
(declare-const var__temp_v_err930 T3605)
(declare-const var_h908 T3604)
(declare-const var_h864 T3604)
(declare-const err T3618)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3604)
(declare-fun sel (T3604 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3604)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'929| () T3604)
(declare-fun var__temp_v928 () Int)
(declare-fun var__temp_h927 () T3604)
(declare-fun v () Int)
(assert (not (> (sel var_h864 res) 20)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h927 res) v) (= v |20|))
               (= (sel var__temp_h927 res) 5)))
      (a!2 (and (= (sel |var__temp_h'929| res) var__temp_v928)
                (= (sel |var__temp_h'929| res) (+ (sel var__temp_h927 res) 2)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'929| res) var__temp_v928)
                    (= (sel |var__temp_h'929| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h927 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************243
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v910:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v910:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c2'	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i909 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i909, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v931:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************244
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i909 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i909, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v931:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i909 --->  Ty_heap  
 var_h908 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h932 --->  Ty_heap  
 var__temp_v933 --->  Ty_int  
 var__temp_h'934 --->  Ty_heap  
 var__temp_v_err935 --->  error  
 var_h908 --->  Ty_heap  
 var_h864 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h932, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h932, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h932, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'934, res ) ==(var__temp_v933) AND 
 	 Rel (sel)( , var__temp_h'934, res ) ==((sel)( , var__temp_h932, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i909 T3621)
(declare-const var_h908 T3621)
(declare-const v Int)
(declare-const var_h_i865 T3621)
(declare-const var_h864 T3621)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h932 T3621)
(declare-const var__temp_v933 Int)
(declare-const |var__temp_h'934| T3621)
(declare-const var__temp_v_err935 T3622)
(declare-const var_h908 T3621)
(declare-const var_h864 T3621)
(declare-const err T3635)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3621)
(declare-fun sel (T3621 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3621)
(declare-fun |20| () Int)
(declare-fun var__temp_h932 () T3621)
(declare-fun |var__temp_h'934| () T3621)
(declare-fun var__temp_v933 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h864 res) 20)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h932 res) v) (= v |20|))
               (= (sel var__temp_h932 res) 7)))
      (a!2 (and (= (sel |var__temp_h'934| res) var__temp_v933)
                (= (sel |var__temp_h'934| res) (+ (sel var__temp_h932 res) 3)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h932 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************245
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i909 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i909, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v931:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i909 --->  Ty_heap  
 var_h908 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h936 --->  Ty_heap  
 var__temp_v937 --->  Ty_int  
 var__temp_h'938 --->  Ty_heap  
 var__temp_v_err939 --->  error  
 var_h908 --->  Ty_heap  
 var_h864 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h936, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h936, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h936, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'938, res ) ==(var__temp_v937) AND 
 	 Rel (sel)( , var__temp_h'938, res ) ==((sel)( , var__temp_h936, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i909 T3638)
(declare-const var_h908 T3638)
(declare-const v Int)
(declare-const var_h_i865 T3638)
(declare-const var_h864 T3638)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h936 T3638)
(declare-const var__temp_v937 Int)
(declare-const |var__temp_h'938| T3638)
(declare-const var__temp_v_err939 T3639)
(declare-const var_h908 T3638)
(declare-const var_h864 T3638)
(declare-const err T3652)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3638)
(declare-fun sel (T3638 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3638)
(declare-fun |20| () Int)
(declare-fun var__temp_h936 () T3638)
(declare-fun |var__temp_h'938| () T3638)
(declare-fun var__temp_v937 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h864 res) 20)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h936 res) v) (= v |20|))
               (= (sel var__temp_h936 res) 7)))
      (a!2 (and (= (sel |var__temp_h'938| res) var__temp_v937)
                (= (sel |var__temp_h'938| res) (+ (sel var__temp_h936 res) 5)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h936 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************246
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i909 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i909, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v931:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i909 --->  Ty_heap  
 var_h908 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h940 --->  Ty_heap  
 var__temp_v941 --->  Ty_int  
 var__temp_h'942 --->  Ty_heap  
 var__temp_v_err943 --->  error  
 var_h908 --->  Ty_heap  
 var_h864 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h940, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h940, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h940, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'942, res ) ==(var__temp_v941) AND 
 	 Rel (sel)( , var__temp_h'942, res ) ==((sel)( , var__temp_h940, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i909 T3655)
(declare-const var_h908 T3655)
(declare-const v Int)
(declare-const var_h_i865 T3655)
(declare-const var_h864 T3655)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h940 T3655)
(declare-const var__temp_v941 Int)
(declare-const |var__temp_h'942| T3655)
(declare-const var__temp_v_err943 T3656)
(declare-const var_h908 T3655)
(declare-const var_h864 T3655)
(declare-const err T3669)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3655)
(declare-fun sel (T3655 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3655)
(declare-fun |20| () Int)
(declare-fun var__temp_h940 () T3655)
(declare-fun |var__temp_h'942| () T3655)
(declare-fun var__temp_v941 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h864 res) 20)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h940 res) v) (= v |20|))
               (> (sel var__temp_h940 res) 4)))
      (a!2 (and (= (sel |var__temp_h'942| res) var__temp_v941)
                (= (sel |var__temp_h'942| res) (+ (sel var__temp_h940 res) 10)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h940 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c2
PARTIAL PATH NEW
NEW 	 --c2'	 --foo'	 --c2
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i945 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i945 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i945, res ) ==(v)
 	 , (sel)( , var_h_i945, res ) ==((sel)( , var_h944, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v946:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i945 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************247
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i945 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i945, res ) ==(v)
 	 , (sel)( , var_h_i945, res ) ==((sel)( , var_h944, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v946:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i945 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i945 --->  Ty_heap  
 var_h944 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i909 --->  Ty_heap  
 var_h908 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h947 --->  Ty_heap  
 var__temp_v948 --->  Ty_int  
 var__temp_h'949 --->  Ty_heap  
 var__temp_v_err950 --->  error  
 var_h944 --->  Ty_heap  
 var_h908 --->  Ty_heap  
 var_h864 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h944, res ) > (4) AND 
 	 Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h947, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h947, res ) ==((sel)( , var_h944, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h947, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h947, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'949, res ) ==(var__temp_v948) AND 
 	 Rel (sel)( , var__temp_h'949, res ) ==((sel)( , var__temp_h947, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'949, res ) ==(var__temp_v948) AND 
 	 Rel (sel)( , var__temp_h'949, res ) ==(10)
 
VC_END(declare-const var_h_i945 T3672)
(declare-const var_h944 T3672)
(declare-const v Int)
(declare-const var_h_i909 T3672)
(declare-const var_h908 T3672)
(declare-const v Int)
(declare-const var_h_i865 T3672)
(declare-const var_h864 T3672)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h947 T3672)
(declare-const var__temp_v948 Int)
(declare-const |var__temp_h'949| T3672)
(declare-const var__temp_v_err950 T3673)
(declare-const var_h944 T3672)
(declare-const var_h908 T3672)
(declare-const var_h864 T3672)
(declare-const err T3686)

solver 
 (declare-sort T3672)
(declare-fun sel (T3672 Int) Int)
(declare-fun res () Int)
(declare-fun var_h944 () T3672)
(declare-fun var_h864 () T3672)
(declare-fun |var__temp_h'949| () T3672)
(declare-fun var__temp_v948 () Int)
(declare-fun var__temp_h947 () T3672)
(declare-fun v () Int)
(assert (> (sel var_h944 res) 4))
(assert (not (> (sel var_h864 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h947 res) v)
                (= (sel var__temp_h947 res) (+ (sel var_h944 res) 10))))
      (a!2 (and (= (sel |var__temp_h'949| res) var__temp_v948)
                (= (sel |var__temp_h'949| res) (+ (sel var__temp_h947 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'949| res) var__temp_v948)
                    (= (sel |var__temp_h'949| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h947 res) 7))
                (=> (= (sel var__temp_h947 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************248
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i945 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i945, res ) ==(v)
 	 , (sel)( , var_h_i945, res ) ==((sel)( , var_h944, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v946:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i945 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i945 --->  Ty_heap  
 var_h944 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i909 --->  Ty_heap  
 var_h908 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h951 --->  Ty_heap  
 var__temp_v952 --->  Ty_int  
 var__temp_h'953 --->  Ty_heap  
 var__temp_v_err954 --->  error  
 var_h944 --->  Ty_heap  
 var_h908 --->  Ty_heap  
 var_h864 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h944, res ) > (4) AND 
 	 Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h951, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h951, res ) ==((sel)( , var_h944, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h951, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h951, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'953, res ) ==(var__temp_v952) AND 
 	 Rel (sel)( , var__temp_h'953, res ) ==((sel)( , var__temp_h951, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'953, res ) ==(var__temp_v952) AND 
 	 Rel (sel)( , var__temp_h'953, res ) ==(10)
 
VC_END(declare-const var_h_i945 T3689)
(declare-const var_h944 T3689)
(declare-const v Int)
(declare-const var_h_i909 T3689)
(declare-const var_h908 T3689)
(declare-const v Int)
(declare-const var_h_i865 T3689)
(declare-const var_h864 T3689)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h951 T3689)
(declare-const var__temp_v952 Int)
(declare-const |var__temp_h'953| T3689)
(declare-const var__temp_v_err954 T3690)
(declare-const var_h944 T3689)
(declare-const var_h908 T3689)
(declare-const var_h864 T3689)
(declare-const err T3703)

solver 
 (declare-sort T3689)
(declare-fun sel (T3689 Int) Int)
(declare-fun res () Int)
(declare-fun var_h944 () T3689)
(declare-fun var_h864 () T3689)
(declare-fun |var__temp_h'953| () T3689)
(declare-fun var__temp_v952 () Int)
(declare-fun var__temp_h951 () T3689)
(declare-fun v () Int)
(assert (> (sel var_h944 res) 4))
(assert (not (> (sel var_h864 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h951 res) v)
                (= (sel var__temp_h951 res) (+ (sel var_h944 res) 10))))
      (a!2 (and (= (sel |var__temp_h'953| res) var__temp_v952)
                (= (sel |var__temp_h'953| res) (+ (sel var__temp_h951 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'953| res) var__temp_v952)
                    (= (sel |var__temp_h'953| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h951 res) 7))
                (=> (= (sel var__temp_h951 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************249
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i945 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i945, res ) ==(v)
 	 , (sel)( , var_h_i945, res ) ==((sel)( , var_h944, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v946:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i945 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i945 --->  Ty_heap  
 var_h944 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i909 --->  Ty_heap  
 var_h908 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h955 --->  Ty_heap  
 var__temp_v956 --->  Ty_int  
 var__temp_h'957 --->  Ty_heap  
 var__temp_v_err958 --->  error  
 var_h944 --->  Ty_heap  
 var_h908 --->  Ty_heap  
 var_h864 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h944, res ) > (4) AND 
 	 Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h955, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h955, res ) ==((sel)( , var_h944, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h955, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h955, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'957, res ) ==(var__temp_v956) AND 
 	 Base var__temp_v956 = 5 => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'957, res ) ==(var__temp_v956) AND 
 	 Rel (sel)( , var__temp_h'957, res ) ==(10)
 
VC_END(declare-const var_h_i945 T3706)
(declare-const var_h944 T3706)
(declare-const v Int)
(declare-const var_h_i909 T3706)
(declare-const var_h908 T3706)
(declare-const v Int)
(declare-const var_h_i865 T3706)
(declare-const var_h864 T3706)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h955 T3706)
(declare-const var__temp_v956 Int)
(declare-const |var__temp_h'957| T3706)
(declare-const var__temp_v_err958 T3707)
(declare-const var_h944 T3706)
(declare-const var_h908 T3706)
(declare-const var_h864 T3706)
(declare-const err T3720)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3706)
(declare-fun sel (T3706 Int) Int)
(declare-fun res () Int)
(declare-fun var_h944 () T3706)
(declare-fun var_h864 () T3706)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'957| () T3706)
(declare-fun var__temp_v956 () Int)
(declare-fun var__temp_h955 () T3706)
(declare-fun v () Int)
(assert (> (sel var_h944 res) 4))
(assert (not (> (sel var_h864 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h955 res) v)
                (= (sel var__temp_h955 res) (+ (sel var_h944 res) 10))))
      (a!2 (=> (and (= (sel |var__temp_h'957| res) var__temp_v956)
                    (= var__temp_v956 |5|))
               (and (= (sel |var__temp_h'957| res) var__temp_v956)
                    (= (sel |var__temp_h'957| res) 10)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h955 res) 0))
                (=> (= (sel var__temp_h955 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************250
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i945 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i945, res ) ==(v)
 	 , (sel)( , var_h_i945, res ) ==((sel)( , var_h944, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v946:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i945 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i945 --->  Ty_heap  
 var_h944 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i909 --->  Ty_heap  
 var_h908 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h959 --->  Ty_heap  
 var__temp_v960 --->  Ty_int  
 var__temp_h'961 --->  Ty_heap  
 var__temp_v_err962 --->  error  
 var_h944 --->  Ty_heap  
 var_h908 --->  Ty_heap  
 var_h864 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h944, res ) > (4) AND 
 	 Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h959, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h959, res ) ==((sel)( , var_h944, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h959, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h959, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'961, res ) ==(var__temp_v960) AND 
 	 Rel (sel)( , var__temp_h'961, res ) ==((sel)( , var__temp_h959, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'961, res ) ==(var__temp_v960) AND 
 	 Rel (sel)( , var__temp_h'961, res ) ==(10)
 
VC_END(declare-const var_h_i945 T3723)
(declare-const var_h944 T3723)
(declare-const v Int)
(declare-const var_h_i909 T3723)
(declare-const var_h908 T3723)
(declare-const v Int)
(declare-const var_h_i865 T3723)
(declare-const var_h864 T3723)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h959 T3723)
(declare-const var__temp_v960 Int)
(declare-const |var__temp_h'961| T3723)
(declare-const var__temp_v_err962 T3724)
(declare-const var_h944 T3723)
(declare-const var_h908 T3723)
(declare-const var_h864 T3723)
(declare-const err T3737)

solver 
 (declare-sort T3723)
(declare-fun sel (T3723 Int) Int)
(declare-fun res () Int)
(declare-fun var_h944 () T3723)
(declare-fun var_h864 () T3723)
(declare-fun |var__temp_h'961| () T3723)
(declare-fun var__temp_v960 () Int)
(declare-fun var__temp_h959 () T3723)
(declare-fun v () Int)
(assert (> (sel var_h944 res) 4))
(assert (not (> (sel var_h864 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h959 res) v)
                (= (sel var__temp_h959 res) (+ (sel var_h944 res) 10))))
      (a!2 (and (= (sel |var__temp_h'961| res) var__temp_v960)
                (= (sel |var__temp_h'961| res) (+ (sel var__temp_h959 res) 2)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'961| res) var__temp_v960)
                    (= (sel |var__temp_h'961| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h959 res) 5))
                (=> (= (sel var__temp_h959 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************251
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v946:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v946:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c2'	 --foo'	 --c2
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i945 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i945, res ) ==(v)
 	 , (sel)( , var_h_i945, res ) ==((sel)( , var_h944, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v963:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************252
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i945 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i945, res ) ==(v)
 	 , (sel)( , var_h_i945, res ) ==((sel)( , var_h944, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v963:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i945 --->  Ty_heap  
 var_h944 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i909 --->  Ty_heap  
 var_h908 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h964 --->  Ty_heap  
 var__temp_v965 --->  Ty_int  
 var__temp_h'966 --->  Ty_heap  
 var__temp_v_err967 --->  error  
 var_h944 --->  Ty_heap  
 var_h908 --->  Ty_heap  
 var_h864 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h944, res ) > (4) AND 
 	 Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h964, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h964, res ) ==((sel)( , var_h944, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h964, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h964, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'966, res ) ==(var__temp_v965) AND 
 	 Rel (sel)( , var__temp_h'966, res ) ==((sel)( , var__temp_h964, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i945 T3740)
(declare-const var_h944 T3740)
(declare-const v Int)
(declare-const var_h_i909 T3740)
(declare-const var_h908 T3740)
(declare-const v Int)
(declare-const var_h_i865 T3740)
(declare-const var_h864 T3740)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h964 T3740)
(declare-const var__temp_v965 Int)
(declare-const |var__temp_h'966| T3740)
(declare-const var__temp_v_err967 T3741)
(declare-const var_h944 T3740)
(declare-const var_h908 T3740)
(declare-const var_h864 T3740)
(declare-const err T3754)

solver 
 (declare-sort T3740)
(declare-fun sel (T3740 Int) Int)
(declare-fun res () Int)
(declare-fun var_h944 () T3740)
(declare-fun var_h864 () T3740)
(declare-fun var__temp_h964 () T3740)
(declare-fun |var__temp_h'966| () T3740)
(declare-fun var__temp_v965 () Int)
(declare-fun v () Int)
(assert (> (sel var_h944 res) 4))
(assert (not (> (sel var_h864 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h964 res) v)
                (= (sel var__temp_h964 res) (+ (sel var_h944 res) 10))))
      (a!2 (and (= (sel |var__temp_h'966| res) var__temp_v965)
                (= (sel |var__temp_h'966| res) (+ (sel var__temp_h964 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h964 res) 7))
                (=> (= (sel var__temp_h964 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************253
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i945 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i945, res ) ==(v)
 	 , (sel)( , var_h_i945, res ) ==((sel)( , var_h944, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v963:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i945 --->  Ty_heap  
 var_h944 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i909 --->  Ty_heap  
 var_h908 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h968 --->  Ty_heap  
 var__temp_v969 --->  Ty_int  
 var__temp_h'970 --->  Ty_heap  
 var__temp_v_err971 --->  error  
 var_h944 --->  Ty_heap  
 var_h908 --->  Ty_heap  
 var_h864 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h944, res ) > (4) AND 
 	 Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h968, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h968, res ) ==((sel)( , var_h944, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h968, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h968, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'970, res ) ==(var__temp_v969) AND 
 	 Rel (sel)( , var__temp_h'970, res ) ==((sel)( , var__temp_h968, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i945 T3757)
(declare-const var_h944 T3757)
(declare-const v Int)
(declare-const var_h_i909 T3757)
(declare-const var_h908 T3757)
(declare-const v Int)
(declare-const var_h_i865 T3757)
(declare-const var_h864 T3757)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h968 T3757)
(declare-const var__temp_v969 Int)
(declare-const |var__temp_h'970| T3757)
(declare-const var__temp_v_err971 T3758)
(declare-const var_h944 T3757)
(declare-const var_h908 T3757)
(declare-const var_h864 T3757)
(declare-const err T3771)

solver 
 (declare-sort T3757)
(declare-fun sel (T3757 Int) Int)
(declare-fun res () Int)
(declare-fun var_h944 () T3757)
(declare-fun var_h864 () T3757)
(declare-fun var__temp_h968 () T3757)
(declare-fun |var__temp_h'970| () T3757)
(declare-fun var__temp_v969 () Int)
(declare-fun v () Int)
(assert (> (sel var_h944 res) 4))
(assert (not (> (sel var_h864 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h968 res) v)
                (= (sel var__temp_h968 res) (+ (sel var_h944 res) 10))))
      (a!2 (and (= (sel |var__temp_h'970| res) var__temp_v969)
                (= (sel |var__temp_h'970| res) (+ (sel var__temp_h968 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h968 res) 7))
                (=> (= (sel var__temp_h968 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************254
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i945 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i945, res ) ==(v)
 	 , (sel)( , var_h_i945, res ) ==((sel)( , var_h944, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v963:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i945 --->  Ty_heap  
 var_h944 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i909 --->  Ty_heap  
 var_h908 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h972 --->  Ty_heap  
 var__temp_v973 --->  Ty_int  
 var__temp_h'974 --->  Ty_heap  
 var__temp_v_err975 --->  error  
 var_h944 --->  Ty_heap  
 var_h908 --->  Ty_heap  
 var_h864 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h944, res ) > (4) AND 
 	 Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h972, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h972, res ) ==((sel)( , var_h944, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h972, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h972, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'974, res ) ==(var__temp_v973) AND 
 	 Base var__temp_v973 = 5 => 
 	 True
 
VC_END(declare-const var_h_i945 T3774)
(declare-const var_h944 T3774)
(declare-const v Int)
(declare-const var_h_i909 T3774)
(declare-const var_h908 T3774)
(declare-const v Int)
(declare-const var_h_i865 T3774)
(declare-const var_h864 T3774)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h972 T3774)
(declare-const var__temp_v973 Int)
(declare-const |var__temp_h'974| T3774)
(declare-const var__temp_v_err975 T3775)
(declare-const var_h944 T3774)
(declare-const var_h908 T3774)
(declare-const var_h864 T3774)
(declare-const err T3788)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3774)
(declare-fun sel (T3774 Int) Int)
(declare-fun res () Int)
(declare-fun var_h944 () T3774)
(declare-fun var_h864 () T3774)
(declare-fun |5| () Int)
(declare-fun var__temp_v973 () Int)
(declare-fun |var__temp_h'974| () T3774)
(declare-fun var__temp_h972 () T3774)
(declare-fun v () Int)
(assert (> (sel var_h944 res) 4))
(assert (not (> (sel var_h864 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h972 res) v)
                (= (sel var__temp_h972 res) (+ (sel var_h944 res) 10))))
      (a!2 (=> (and (= (sel |var__temp_h'974| res) var__temp_v973)
                    (= var__temp_v973 |5|))
               true)))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h972 res) 0))
                (=> (= (sel var__temp_h972 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************255
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i945 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i945, res ) ==(v)
 	 , (sel)( , var_h_i945, res ) ==((sel)( , var_h944, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v963:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i945 --->  Ty_heap  
 var_h944 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i909 --->  Ty_heap  
 var_h908 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h976 --->  Ty_heap  
 var__temp_v977 --->  Ty_int  
 var__temp_h'978 --->  Ty_heap  
 var__temp_v_err979 --->  error  
 var_h944 --->  Ty_heap  
 var_h908 --->  Ty_heap  
 var_h864 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h944, res ) > (4) AND 
 	 Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h976, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h976, res ) ==((sel)( , var_h944, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h976, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h976, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'978, res ) ==(var__temp_v977) AND 
 	 Rel (sel)( , var__temp_h'978, res ) ==((sel)( , var__temp_h976, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i945 T3791)
(declare-const var_h944 T3791)
(declare-const v Int)
(declare-const var_h_i909 T3791)
(declare-const var_h908 T3791)
(declare-const v Int)
(declare-const var_h_i865 T3791)
(declare-const var_h864 T3791)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h976 T3791)
(declare-const var__temp_v977 Int)
(declare-const |var__temp_h'978| T3791)
(declare-const var__temp_v_err979 T3792)
(declare-const var_h944 T3791)
(declare-const var_h908 T3791)
(declare-const var_h864 T3791)
(declare-const err T3805)

solver 
 (declare-sort T3791)
(declare-fun sel (T3791 Int) Int)
(declare-fun res () Int)
(declare-fun var_h944 () T3791)
(declare-fun var_h864 () T3791)
(declare-fun var__temp_h976 () T3791)
(declare-fun |var__temp_h'978| () T3791)
(declare-fun var__temp_v977 () Int)
(declare-fun v () Int)
(assert (> (sel var_h944 res) 4))
(assert (not (> (sel var_h864 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h976 res) v)
                (= (sel var__temp_h976 res) (+ (sel var_h944 res) 10))))
      (a!2 (and (= (sel |var__temp_h'978| res) var__temp_v977)
                (= (sel |var__temp_h'978| res) (+ (sel var__temp_h976 res) 2)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h976 res) 5))
                (=> (= (sel var__temp_h976 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************256
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 	 --c2'	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i909 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i909, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v980:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************257
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i909 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i909, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v980:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i909 --->  Ty_heap  
 var_h908 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h981 --->  Ty_heap  
 var__temp_v982 --->  Ty_int  
 var__temp_h'983 --->  Ty_heap  
 var__temp_v_err984 --->  error  
 var_h908 --->  Ty_heap  
 var_h864 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h981, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h981, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h981, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'983, res ) ==(var__temp_v982) AND 
 	 Rel (sel)( , var__temp_h'983, res ) ==((sel)( , var__temp_h981, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i909 T3808)
(declare-const var_h908 T3808)
(declare-const v Int)
(declare-const var_h_i865 T3808)
(declare-const var_h864 T3808)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h981 T3808)
(declare-const var__temp_v982 Int)
(declare-const |var__temp_h'983| T3808)
(declare-const var__temp_v_err984 T3809)
(declare-const var_h908 T3808)
(declare-const var_h864 T3808)
(declare-const err T3822)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3808)
(declare-fun sel (T3808 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3808)
(declare-fun |20| () Int)
(declare-fun var__temp_h981 () T3808)
(declare-fun |var__temp_h'983| () T3808)
(declare-fun var__temp_v982 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h864 res) 20)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h981 res) v) (= v |20|))
               (= (sel var__temp_h981 res) 7)))
      (a!2 (and (= (sel |var__temp_h'983| res) var__temp_v982)
                (= (sel |var__temp_h'983| res) (+ (sel var__temp_h981 res) 3)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h981 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************258
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i909 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i909, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v980:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i909 --->  Ty_heap  
 var_h908 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h985 --->  Ty_heap  
 var__temp_v986 --->  Ty_int  
 var__temp_h'987 --->  Ty_heap  
 var__temp_v_err988 --->  error  
 var_h908 --->  Ty_heap  
 var_h864 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h985, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h985, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h985, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'987, res ) ==(var__temp_v986) AND 
 	 Rel (sel)( , var__temp_h'987, res ) ==((sel)( , var__temp_h985, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i909 T3825)
(declare-const var_h908 T3825)
(declare-const v Int)
(declare-const var_h_i865 T3825)
(declare-const var_h864 T3825)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h985 T3825)
(declare-const var__temp_v986 Int)
(declare-const |var__temp_h'987| T3825)
(declare-const var__temp_v_err988 T3826)
(declare-const var_h908 T3825)
(declare-const var_h864 T3825)
(declare-const err T3839)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3825)
(declare-fun sel (T3825 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3825)
(declare-fun |20| () Int)
(declare-fun var__temp_h985 () T3825)
(declare-fun |var__temp_h'987| () T3825)
(declare-fun var__temp_v986 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h864 res) 20)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h985 res) v) (= v |20|))
               (= (sel var__temp_h985 res) 7)))
      (a!2 (and (= (sel |var__temp_h'987| res) var__temp_v986)
                (= (sel |var__temp_h'987| res) (+ (sel var__temp_h985 res) 5)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h985 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************259
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i909 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i909, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v980:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i909 --->  Ty_heap  
 var_h908 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h989 --->  Ty_heap  
 var__temp_v990 --->  Ty_int  
 var__temp_h'991 --->  Ty_heap  
 var__temp_v_err992 --->  error  
 var_h908 --->  Ty_heap  
 var_h864 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h989, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h989, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h989, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'991, res ) ==(var__temp_v990) AND 
 	 Base var__temp_v990 = 5 => 
 	 True
 
VC_END(declare-const var_h_i909 T3842)
(declare-const var_h908 T3842)
(declare-const v Int)
(declare-const var_h_i865 T3842)
(declare-const var_h864 T3842)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h989 T3842)
(declare-const var__temp_v990 Int)
(declare-const |var__temp_h'991| T3842)
(declare-const var__temp_v_err992 T3843)
(declare-const var_h908 T3842)
(declare-const var_h864 T3842)
(declare-const err T3856)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T3842)
(declare-fun sel (T3842 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3842)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_v990 () Int)
(declare-fun |var__temp_h'991| () T3842)
(declare-fun var__temp_h989 () T3842)
(declare-fun v () Int)
(assert (not (> (sel var_h864 res) 20)))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h989 res) v) (= v |20|))
               (= (sel var__temp_h989 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'991| res) var__temp_v990)
                    (= var__temp_v990 |5|))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h989 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************260
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i909 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i909, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v980:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i909 --->  Ty_heap  
 var_h908 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h993 --->  Ty_heap  
 var__temp_v994 --->  Ty_int  
 var__temp_h'995 --->  Ty_heap  
 var__temp_v_err996 --->  error  
 var_h908 --->  Ty_heap  
 var_h864 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h993, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h993, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h993, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'995, res ) ==(var__temp_v994) AND 
 	 Rel (sel)( , var__temp_h'995, res ) ==((sel)( , var__temp_h993, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i909 T3859)
(declare-const var_h908 T3859)
(declare-const v Int)
(declare-const var_h_i865 T3859)
(declare-const var_h864 T3859)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h993 T3859)
(declare-const var__temp_v994 Int)
(declare-const |var__temp_h'995| T3859)
(declare-const var__temp_v_err996 T3860)
(declare-const var_h908 T3859)
(declare-const var_h864 T3859)
(declare-const err T3873)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3859)
(declare-fun sel (T3859 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3859)
(declare-fun |20| () Int)
(declare-fun var__temp_h993 () T3859)
(declare-fun |var__temp_h'995| () T3859)
(declare-fun var__temp_v994 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h864 res) 20)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h993 res) v) (= v |20|))
               (= (sel var__temp_h993 res) 5)))
      (a!2 (and (= (sel |var__temp_h'995| res) var__temp_v994)
                (= (sel |var__temp_h'995| res) (+ (sel var__temp_h993 res) 2)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h993 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************261
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i865, res ) ==(v)
 	 , (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) >c  } 
 } 
 
                                                RET :  Base {var_v997:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************262
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i865, res ) ==(v)
 	 , (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) >c  } 
 } 
 
                                                RET :  Base {var_v997:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h998 --->  Ty_heap  
 var__temp_v999 --->  Ty_int  
 var__temp_h'1000 --->  Ty_heap  
 var__temp_v_err1001 --->  error  
 var_h864 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h998, res ) ==(v) AND 
 	 Rel (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) => 
 	 Rel (sel)( , var__temp_h998, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h998, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1000, res ) ==(var__temp_v999) AND 
 	 Rel (sel)( , var__temp_h'1000, res ) ==((sel)( , var__temp_h998, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i865 T3876)
(declare-const var_h864 T3876)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h998 T3876)
(declare-const var__temp_v999 Int)
(declare-const |var__temp_h'1000| T3876)
(declare-const var__temp_v_err1001 T3877)
(declare-const var_h864 T3876)
(declare-const err T3890)

solver 
 (declare-sort T3876)
(declare-fun sel (T3876 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3876)
(declare-fun var__temp_h998 () T3876)
(declare-fun |var__temp_h'1000| () T3876)
(declare-fun var__temp_v999 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h864 res) 20)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h998 res) v)
                    (= (sel var_h864 res) (sel var_h864 res)))
               (= (sel var__temp_h998 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1000| res) var__temp_v999)
                (= (sel |var__temp_h'1000| res) (+ (sel var__temp_h998 res) 3)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h998 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************263
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i865, res ) ==(v)
 	 , (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) >c  } 
 } 
 
                                                RET :  Base {var_v997:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1002 --->  Ty_heap  
 var__temp_v1003 --->  Ty_int  
 var__temp_h'1004 --->  Ty_heap  
 var__temp_v_err1005 --->  error  
 var_h864 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1002, res ) ==(v) AND 
 	 Rel (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) => 
 	 Rel (sel)( , var__temp_h1002, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1002, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1004, res ) ==(var__temp_v1003) AND 
 	 Rel (sel)( , var__temp_h'1004, res ) ==((sel)( , var__temp_h1002, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i865 T3893)
(declare-const var_h864 T3893)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1002 T3893)
(declare-const var__temp_v1003 Int)
(declare-const |var__temp_h'1004| T3893)
(declare-const var__temp_v_err1005 T3894)
(declare-const var_h864 T3893)
(declare-const err T3907)

solver 
 (declare-sort T3893)
(declare-fun sel (T3893 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3893)
(declare-fun var__temp_h1002 () T3893)
(declare-fun |var__temp_h'1004| () T3893)
(declare-fun var__temp_v1003 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h864 res) 20)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1002 res) v)
                    (= (sel var_h864 res) (sel var_h864 res)))
               (= (sel var__temp_h1002 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1004| res) var__temp_v1003)
                (= (sel |var__temp_h'1004| res) (+ (sel var__temp_h1002 res) 5)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1002 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************264
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i865, res ) ==(v)
 	 , (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) >c  } 
 } 
 
                                                RET :  Base {var_v997:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1006 --->  Ty_heap  
 var__temp_v1007 --->  Ty_int  
 var__temp_h'1008 --->  Ty_heap  
 var__temp_v_err1009 --->  error  
 var_h864 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1006, res ) ==(v) AND 
 	 Rel (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) => 
 	 Rel (sel)( , var__temp_h1006, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1006, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1008, res ) ==(var__temp_v1007) AND 
 	 Rel (sel)( , var__temp_h'1008, res ) ==((sel)( , var__temp_h1006, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i865 T3910)
(declare-const var_h864 T3910)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1006 T3910)
(declare-const var__temp_v1007 Int)
(declare-const |var__temp_h'1008| T3910)
(declare-const var__temp_v_err1009 T3911)
(declare-const var_h864 T3910)
(declare-const err T3924)

solver 
 (declare-sort T3910)
(declare-fun sel (T3910 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3910)
(declare-fun var__temp_h1006 () T3910)
(declare-fun |var__temp_h'1008| () T3910)
(declare-fun var__temp_v1007 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h864 res) 20)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1006 res) v)
                    (= (sel var_h864 res) (sel var_h864 res)))
               (> (sel var__temp_h1006 res) 4)))
      (a!2 (and (= (sel |var__temp_h'1008| res) var__temp_v1007)
                (= (sel |var__temp_h'1008| res)
                   (+ (sel var__temp_h1006 res) 10)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h1006 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************265
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i865, res ) ==(v)
 	 , (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) >c  } 
 } 
 
                                                RET :  Base {var_v997:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1010 --->  Ty_heap  
 var__temp_v1011 --->  Ty_int  
 var__temp_h'1012 --->  Ty_heap  
 var__temp_v_err1013 --->  error  
 var_h864 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1010, res ) ==(v) AND 
 	 Rel (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) => 
 	 Rel (sel)( , var__temp_h1010, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h1010, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1012, res ) ==(var__temp_v1011) AND 
 	 Base var__temp_v1011 = 5 => 
 	 True
 
VC_END(declare-const var_h_i865 T3927)
(declare-const var_h864 T3927)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1010 T3927)
(declare-const var__temp_v1011 Int)
(declare-const |var__temp_h'1012| T3927)
(declare-const var__temp_v_err1013 T3928)
(declare-const var_h864 T3927)
(declare-const err T3941)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3927)
(declare-fun sel (T3927 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3927)
(declare-fun |5| () Int)
(declare-fun var__temp_v1011 () Int)
(declare-fun |var__temp_h'1012| () T3927)
(declare-fun var__temp_h1010 () T3927)
(declare-fun v () Int)
(assert (not (> (sel var_h864 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1010 res) v)
                    (= (sel var_h864 res) (sel var_h864 res)))
               (= (sel var__temp_h1010 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'1012| res) var__temp_v1011)
                    (= var__temp_v1011 |5|))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1010 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************266
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i865 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i865, res ) ==(v)
 	 , (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) >c  } 
 } 
 
                                                RET :  Base {var_v997:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i865 --->  Ty_heap  
 var_h864 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1014 --->  Ty_heap  
 var__temp_v1015 --->  Ty_int  
 var__temp_h'1016 --->  Ty_heap  
 var__temp_v_err1017 --->  error  
 var_h864 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h864, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1014, res ) ==(v) AND 
 	 Rel (sel)( , var_h864, res ) ==(sel)( , var_h864, res ) => 
 	 Rel (sel)( , var__temp_h1014, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1014, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1016, res ) ==(var__temp_v1015) AND 
 	 Rel (sel)( , var__temp_h'1016, res ) ==((sel)( , var__temp_h1014, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i865 T3944)
(declare-const var_h864 T3944)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1014 T3944)
(declare-const var__temp_v1015 Int)
(declare-const |var__temp_h'1016| T3944)
(declare-const var__temp_v_err1017 T3945)
(declare-const var_h864 T3944)
(declare-const err T3958)

solver 
 (declare-sort T3944)
(declare-fun sel (T3944 Int) Int)
(declare-fun res () Int)
(declare-fun var_h864 () T3944)
(declare-fun var__temp_h1014 () T3944)
(declare-fun |var__temp_h'1016| () T3944)
(declare-fun var__temp_v1015 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h864 res) 20)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1014 res) v)
                    (= (sel var_h864 res) (sel var_h864 res)))
               (= (sel var__temp_h1014 res) 5)))
      (a!2 (and (= (sel |var__temp_h'1016| res) var__temp_v1015)
                (= (sel |var__temp_h'1016| res) (+ (sel var__temp_h1014 res) 2)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1014 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************267
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo'
PARTIAL PATH
SUB 
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {var_v1018:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************268
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {var_v1018:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1019 --->  Ty_heap  
 var__temp_v1020 --->  Ty_int  
 var__temp_h'1021 --->  Ty_heap  
 var__temp_v_err1022 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1019, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h1019, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1019, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1021, res ) ==(var__temp_v1020) AND 
 	 Rel (sel)( , var__temp_h'1021, res ) ==((sel)( , var__temp_h1019, res ) + (3)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1019 T3961)
(declare-const var__temp_v1020 Int)
(declare-const |var__temp_h'1021| T3961)
(declare-const var__temp_v_err1022 T3962)
(declare-const err T3975)

solver 
 (declare-sort T3961)
(declare-fun sel (T3961 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h1019 () T3961)
(declare-fun |var__temp_h'1021| () T3961)
(declare-fun var__temp_v1020 () Int)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'1021| res) var__temp_v1020)
                (= (sel |var__temp_h'1021| res) (+ (sel var__temp_h1019 res) 3)))))
(let ((a!2 (and (=> (= (sel var__temp_h1019 res) 0)
                    (= (sel var__temp_h1019 res) 7))
                (=> (= (sel var__temp_h1019 res) 7) (=> a!1 true)))))
  (not a!2))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************269
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {var_v1018:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1023 --->  Ty_heap  
 var__temp_v1024 --->  Ty_int  
 var__temp_h'1025 --->  Ty_heap  
 var__temp_v_err1026 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1023, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h1023, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1023, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1025, res ) ==(var__temp_v1024) AND 
 	 Rel (sel)( , var__temp_h'1025, res ) ==((sel)( , var__temp_h1023, res ) + (5)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1023 T3978)
(declare-const var__temp_v1024 Int)
(declare-const |var__temp_h'1025| T3978)
(declare-const var__temp_v_err1026 T3979)
(declare-const err T3992)

solver 
 (declare-sort T3978)
(declare-fun sel (T3978 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h1023 () T3978)
(declare-fun |var__temp_h'1025| () T3978)
(declare-fun var__temp_v1024 () Int)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'1025| res) var__temp_v1024)
                (= (sel |var__temp_h'1025| res) (+ (sel var__temp_h1023 res) 5)))))
(let ((a!2 (and (=> (= (sel var__temp_h1023 res) 0)
                    (= (sel var__temp_h1023 res) 7))
                (=> (= (sel var__temp_h1023 res) 7) (=> a!1 true)))))
  (not a!2))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************270
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {var_v1018:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1027 --->  Ty_heap  
 var__temp_v1028 --->  Ty_int  
 var__temp_h'1029 --->  Ty_heap  
 var__temp_v_err1030 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1027, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h1027, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1027, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1029, res ) ==(var__temp_v1028) AND 
 	 Rel (sel)( , var__temp_h'1029, res ) ==((sel)( , var__temp_h1027, res ) + (10)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1027 T3995)
(declare-const var__temp_v1028 Int)
(declare-const |var__temp_h'1029| T3995)
(declare-const var__temp_v_err1030 T3996)
(declare-const err T4009)

solver 
 (declare-sort T3995)
(declare-fun sel (T3995 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h1027 () T3995)
(declare-fun |var__temp_h'1029| () T3995)
(declare-fun var__temp_v1028 () Int)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'1029| res) var__temp_v1028)
                (= (sel |var__temp_h'1029| res)
                   (+ (sel var__temp_h1027 res) 10)))))
(let ((a!2 (and (=> (= (sel var__temp_h1027 res) 0)
                    (> (sel var__temp_h1027 res) 4))
                (=> (> (sel var__temp_h1027 res) 4) (=> a!1 true)))))
  (not a!2))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************271
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {var_v1018:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1031 --->  Ty_heap  
 var__temp_v1032 --->  Ty_int  
 var__temp_h'1033 --->  Ty_heap  
 var__temp_v_err1034 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1031, res ) ==(0) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1033, res ) ==(var__temp_v1032) AND 
 	 Base var__temp_v1032 = 20 => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1031 T4012)
(declare-const var__temp_v1032 Int)
(declare-const |var__temp_h'1033| T4012)
(declare-const var__temp_v_err1034 T4013)
(declare-const err T4026)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4012)
(declare-fun |20| () Int)
(declare-fun var__temp_v1032 () Int)
(declare-fun sel (T4012 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'1033| () T4012)
(declare-fun var__temp_h1031 () T4012)
(assert true)
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel |var__temp_h'1033| res) var__temp_v1032)
                    (= var__temp_v1032 |20|))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h1031 res) 0) true) (=> true a!1))))
  (not a!2))))

***************Selection Successful************foo'
PARTIAL PATH NEW
NEW 	 --foo'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1036, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1037:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************272
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1036, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1037:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1038 --->  Ty_heap  
 var__temp_v1039 --->  Ty_int  
 var__temp_h'1040 --->  Ty_heap  
 var__temp_v_err1041 --->  error  
 var_h1035 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1038, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h1038, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1038, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1040, res ) ==(var__temp_v1039) AND 
 	 Rel (sel)( , var__temp_h'1040, res ) ==((sel)( , var__temp_h1038, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1040, res ) ==(var__temp_v1039) AND 
 	 Rel (sel)( , var__temp_h'1040, res ) ==(10)
 
VC_END(declare-const var_h_i1036 T4029)
(declare-const var_h1035 T4029)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1038 T4029)
(declare-const var__temp_v1039 Int)
(declare-const |var__temp_h'1040| T4029)
(declare-const var__temp_v_err1041 T4030)
(declare-const var_h1035 T4029)
(declare-const err T4043)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4029)
(declare-fun |20| () Int)
(declare-fun sel (T4029 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'1040| () T4029)
(declare-fun var__temp_v1039 () Int)
(declare-fun var__temp_h1038 () T4029)
(declare-fun v () Int)
(assert true)
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1038 res) v) (= v |20|))
               (= (sel var__temp_h1038 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1040| res) var__temp_v1039)
                (= (sel |var__temp_h'1040| res) (+ (sel var__temp_h1038 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'1040| res) var__temp_v1039)
                    (= (sel |var__temp_h'1040| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1038 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************273
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1036, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1037:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1042 --->  Ty_heap  
 var__temp_v1043 --->  Ty_int  
 var__temp_h'1044 --->  Ty_heap  
 var__temp_v_err1045 --->  error  
 var_h1035 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1042, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h1042, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1042, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1044, res ) ==(var__temp_v1043) AND 
 	 Rel (sel)( , var__temp_h'1044, res ) ==((sel)( , var__temp_h1042, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1044, res ) ==(var__temp_v1043) AND 
 	 Rel (sel)( , var__temp_h'1044, res ) ==(10)
 
VC_END(declare-const var_h_i1036 T4046)
(declare-const var_h1035 T4046)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1042 T4046)
(declare-const var__temp_v1043 Int)
(declare-const |var__temp_h'1044| T4046)
(declare-const var__temp_v_err1045 T4047)
(declare-const var_h1035 T4046)
(declare-const err T4060)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4046)
(declare-fun |20| () Int)
(declare-fun sel (T4046 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'1044| () T4046)
(declare-fun var__temp_v1043 () Int)
(declare-fun var__temp_h1042 () T4046)
(declare-fun v () Int)
(assert true)
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1042 res) v) (= v |20|))
               (= (sel var__temp_h1042 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1044| res) var__temp_v1043)
                (= (sel |var__temp_h'1044| res) (+ (sel var__temp_h1042 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'1044| res) var__temp_v1043)
                    (= (sel |var__temp_h'1044| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1042 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************274
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1036, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1037:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1046 --->  Ty_heap  
 var__temp_v1047 --->  Ty_int  
 var__temp_h'1048 --->  Ty_heap  
 var__temp_v_err1049 --->  error  
 var_h1035 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1046, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h1046, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1046, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1048, res ) ==(var__temp_v1047) AND 
 	 Rel (sel)( , var__temp_h'1048, res ) ==((sel)( , var__temp_h1046, res ) + (10)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1048, res ) ==(var__temp_v1047) AND 
 	 Rel (sel)( , var__temp_h'1048, res ) ==(10)
 
VC_END(declare-const var_h_i1036 T4063)
(declare-const var_h1035 T4063)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1046 T4063)
(declare-const var__temp_v1047 Int)
(declare-const |var__temp_h'1048| T4063)
(declare-const var__temp_v_err1049 T4064)
(declare-const var_h1035 T4063)
(declare-const err T4077)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4063)
(declare-fun |20| () Int)
(declare-fun sel (T4063 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'1048| () T4063)
(declare-fun var__temp_v1047 () Int)
(declare-fun var__temp_h1046 () T4063)
(declare-fun v () Int)
(assert true)
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1046 res) v) (= v |20|))
               (> (sel var__temp_h1046 res) 4)))
      (a!2 (and (= (sel |var__temp_h'1048| res) var__temp_v1047)
                (= (sel |var__temp_h'1048| res)
                   (+ (sel var__temp_h1046 res) 10)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'1048| res) var__temp_v1047)
                    (= (sel |var__temp_h'1048| res) 10)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h1046 res) 4) a!3))))
  (not a!4)))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************275
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1036, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1037:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1050 --->  Ty_heap  
 var__temp_v1051 --->  Ty_int  
 var__temp_h'1052 --->  Ty_heap  
 var__temp_v_err1053 --->  error  
 var_h1035 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1050, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h1050, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h1050, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1052, res ) ==(var__temp_v1051) AND 
 	 Base var__temp_v1051 = 5 => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1052, res ) ==(var__temp_v1051) AND 
 	 Rel (sel)( , var__temp_h'1052, res ) ==(10)
 
VC_END(declare-const var_h_i1036 T4080)
(declare-const var_h1035 T4080)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1050 T4080)
(declare-const var__temp_v1051 Int)
(declare-const |var__temp_h'1052| T4080)
(declare-const var__temp_v_err1053 T4081)
(declare-const var_h1035 T4080)
(declare-const err T4094)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T4080)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun sel (T4080 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'1052| () T4080)
(declare-fun var__temp_v1051 () Int)
(declare-fun var__temp_h1050 () T4080)
(declare-fun v () Int)
(assert true)
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1050 res) v) (= v |20|))
               (= (sel var__temp_h1050 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'1052| res) var__temp_v1051)
                    (= var__temp_v1051 |5|))
               (and (= (sel |var__temp_h'1052| res) var__temp_v1051)
                    (= (sel |var__temp_h'1052| res) 10)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1050 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************276
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1036, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1037:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1054 --->  Ty_heap  
 var__temp_v1055 --->  Ty_int  
 var__temp_h'1056 --->  Ty_heap  
 var__temp_v_err1057 --->  error  
 var_h1035 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1054, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h1054, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1054, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1056, res ) ==(var__temp_v1055) AND 
 	 Rel (sel)( , var__temp_h'1056, res ) ==((sel)( , var__temp_h1054, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1056, res ) ==(var__temp_v1055) AND 
 	 Rel (sel)( , var__temp_h'1056, res ) ==(10)
 
VC_END(declare-const var_h_i1036 T4097)
(declare-const var_h1035 T4097)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1054 T4097)
(declare-const var__temp_v1055 Int)
(declare-const |var__temp_h'1056| T4097)
(declare-const var__temp_v_err1057 T4098)
(declare-const var_h1035 T4097)
(declare-const err T4111)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4097)
(declare-fun |20| () Int)
(declare-fun sel (T4097 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'1056| () T4097)
(declare-fun var__temp_v1055 () Int)
(declare-fun var__temp_h1054 () T4097)
(declare-fun v () Int)
(assert true)
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1054 res) v) (= v |20|))
               (= (sel var__temp_h1054 res) 5)))
      (a!2 (and (= (sel |var__temp_h'1056| res) var__temp_v1055)
                (= (sel |var__temp_h'1056| res) (+ (sel var__temp_h1054 res) 2)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'1056| res) var__temp_v1055)
                    (= (sel |var__temp_h'1056| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1054 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************277
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1037:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1037:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1036, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1058:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************278
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1036, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1058:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1059 --->  Ty_heap  
 var__temp_v1060 --->  Ty_int  
 var__temp_h'1061 --->  Ty_heap  
 var__temp_v_err1062 --->  error  
 var_h1035 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1059, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h1059, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1059, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1061, res ) ==(var__temp_v1060) AND 
 	 Rel (sel)( , var__temp_h'1061, res ) ==((sel)( , var__temp_h1059, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i1036 T4114)
(declare-const var_h1035 T4114)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1059 T4114)
(declare-const var__temp_v1060 Int)
(declare-const |var__temp_h'1061| T4114)
(declare-const var__temp_v_err1062 T4115)
(declare-const var_h1035 T4114)
(declare-const err T4128)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4114)
(declare-fun |20| () Int)
(declare-fun sel (T4114 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h1059 () T4114)
(declare-fun |var__temp_h'1061| () T4114)
(declare-fun var__temp_v1060 () Int)
(declare-fun v () Int)
(assert true)
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1059 res) v) (= v |20|))
               (= (sel var__temp_h1059 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1061| res) var__temp_v1060)
                (= (sel |var__temp_h'1061| res) (+ (sel var__temp_h1059 res) 3)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1059 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************279
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1036, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1058:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1063 --->  Ty_heap  
 var__temp_v1064 --->  Ty_int  
 var__temp_h'1065 --->  Ty_heap  
 var__temp_v_err1066 --->  error  
 var_h1035 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1063, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h1063, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1063, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1065, res ) ==(var__temp_v1064) AND 
 	 Rel (sel)( , var__temp_h'1065, res ) ==((sel)( , var__temp_h1063, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i1036 T4131)
(declare-const var_h1035 T4131)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1063 T4131)
(declare-const var__temp_v1064 Int)
(declare-const |var__temp_h'1065| T4131)
(declare-const var__temp_v_err1066 T4132)
(declare-const var_h1035 T4131)
(declare-const err T4145)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4131)
(declare-fun |20| () Int)
(declare-fun sel (T4131 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h1063 () T4131)
(declare-fun |var__temp_h'1065| () T4131)
(declare-fun var__temp_v1064 () Int)
(declare-fun v () Int)
(assert true)
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1063 res) v) (= v |20|))
               (= (sel var__temp_h1063 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1065| res) var__temp_v1064)
                (= (sel |var__temp_h'1065| res) (+ (sel var__temp_h1063 res) 5)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1063 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************280
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1036, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1058:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1067 --->  Ty_heap  
 var__temp_v1068 --->  Ty_int  
 var__temp_h'1069 --->  Ty_heap  
 var__temp_v_err1070 --->  error  
 var_h1035 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1067, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h1067, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1067, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1069, res ) ==(var__temp_v1068) AND 
 	 Rel (sel)( , var__temp_h'1069, res ) ==((sel)( , var__temp_h1067, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i1036 T4148)
(declare-const var_h1035 T4148)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1067 T4148)
(declare-const var__temp_v1068 Int)
(declare-const |var__temp_h'1069| T4148)
(declare-const var__temp_v_err1070 T4149)
(declare-const var_h1035 T4148)
(declare-const err T4162)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4148)
(declare-fun |20| () Int)
(declare-fun sel (T4148 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h1067 () T4148)
(declare-fun |var__temp_h'1069| () T4148)
(declare-fun var__temp_v1068 () Int)
(declare-fun v () Int)
(assert true)
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1067 res) v) (= v |20|))
               (> (sel var__temp_h1067 res) 4)))
      (a!2 (and (= (sel |var__temp_h'1069| res) var__temp_v1068)
                (= (sel |var__temp_h'1069| res)
                   (+ (sel var__temp_h1067 res) 10)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h1067 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c2
PARTIAL PATH NEW
NEW 	 --foo'	 --c2
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1072 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1072 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1072, res ) ==(v)
 	 , (sel)( , var_h_i1072, res ) ==((sel)( , var_h1071, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v1073:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1072 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************281
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1072 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1072, res ) ==(v)
 	 , (sel)( , var_h_i1072, res ) ==((sel)( , var_h1071, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v1073:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1072 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1072 --->  Ty_heap  
 var_h1071 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1074 --->  Ty_heap  
 var__temp_v1075 --->  Ty_int  
 var__temp_h'1076 --->  Ty_heap  
 var__temp_v_err1077 --->  error  
 var_h1071 --->  Ty_heap  
 var_h1035 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1071, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1074, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1074, res ) ==((sel)( , var_h1071, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1074, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1074, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1076, res ) ==(var__temp_v1075) AND 
 	 Rel (sel)( , var__temp_h'1076, res ) ==((sel)( , var__temp_h1074, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1076, res ) ==(var__temp_v1075) AND 
 	 Rel (sel)( , var__temp_h'1076, res ) ==(10)
 
VC_END(declare-const var_h_i1072 T4165)
(declare-const var_h1071 T4165)
(declare-const v Int)
(declare-const var_h_i1036 T4165)
(declare-const var_h1035 T4165)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1074 T4165)
(declare-const var__temp_v1075 Int)
(declare-const |var__temp_h'1076| T4165)
(declare-const var__temp_v_err1077 T4166)
(declare-const var_h1071 T4165)
(declare-const var_h1035 T4165)
(declare-const err T4179)

solver 
 (declare-sort T4165)
(declare-fun sel (T4165 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1071 () T4165)
(declare-fun |var__temp_h'1076| () T4165)
(declare-fun var__temp_v1075 () Int)
(declare-fun var__temp_h1074 () T4165)
(declare-fun v () Int)
(assert (> (sel var_h1071 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h1074 res) v)
                (= (sel var__temp_h1074 res) (+ (sel var_h1071 res) 10))))
      (a!2 (and (= (sel |var__temp_h'1076| res) var__temp_v1075)
                (= (sel |var__temp_h'1076| res) (+ (sel var__temp_h1074 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'1076| res) var__temp_v1075)
                    (= (sel |var__temp_h'1076| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1074 res) 7))
                (=> (= (sel var__temp_h1074 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************282
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1072 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1072, res ) ==(v)
 	 , (sel)( , var_h_i1072, res ) ==((sel)( , var_h1071, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v1073:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1072 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1072 --->  Ty_heap  
 var_h1071 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1078 --->  Ty_heap  
 var__temp_v1079 --->  Ty_int  
 var__temp_h'1080 --->  Ty_heap  
 var__temp_v_err1081 --->  error  
 var_h1071 --->  Ty_heap  
 var_h1035 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1071, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1078, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1078, res ) ==((sel)( , var_h1071, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1078, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1078, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1080, res ) ==(var__temp_v1079) AND 
 	 Rel (sel)( , var__temp_h'1080, res ) ==((sel)( , var__temp_h1078, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1080, res ) ==(var__temp_v1079) AND 
 	 Rel (sel)( , var__temp_h'1080, res ) ==(10)
 
VC_END(declare-const var_h_i1072 T4182)
(declare-const var_h1071 T4182)
(declare-const v Int)
(declare-const var_h_i1036 T4182)
(declare-const var_h1035 T4182)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1078 T4182)
(declare-const var__temp_v1079 Int)
(declare-const |var__temp_h'1080| T4182)
(declare-const var__temp_v_err1081 T4183)
(declare-const var_h1071 T4182)
(declare-const var_h1035 T4182)
(declare-const err T4196)

solver 
 (declare-sort T4182)
(declare-fun sel (T4182 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1071 () T4182)
(declare-fun |var__temp_h'1080| () T4182)
(declare-fun var__temp_v1079 () Int)
(declare-fun var__temp_h1078 () T4182)
(declare-fun v () Int)
(assert (> (sel var_h1071 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h1078 res) v)
                (= (sel var__temp_h1078 res) (+ (sel var_h1071 res) 10))))
      (a!2 (and (= (sel |var__temp_h'1080| res) var__temp_v1079)
                (= (sel |var__temp_h'1080| res) (+ (sel var__temp_h1078 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'1080| res) var__temp_v1079)
                    (= (sel |var__temp_h'1080| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1078 res) 7))
                (=> (= (sel var__temp_h1078 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************283
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1072 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1072, res ) ==(v)
 	 , (sel)( , var_h_i1072, res ) ==((sel)( , var_h1071, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v1073:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1072 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1072 --->  Ty_heap  
 var_h1071 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1082 --->  Ty_heap  
 var__temp_v1083 --->  Ty_int  
 var__temp_h'1084 --->  Ty_heap  
 var__temp_v_err1085 --->  error  
 var_h1071 --->  Ty_heap  
 var_h1035 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1071, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1082, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1082, res ) ==((sel)( , var_h1071, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1082, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h1082, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1084, res ) ==(var__temp_v1083) AND 
 	 Base var__temp_v1083 = 5 => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1084, res ) ==(var__temp_v1083) AND 
 	 Rel (sel)( , var__temp_h'1084, res ) ==(10)
 
VC_END(declare-const var_h_i1072 T4199)
(declare-const var_h1071 T4199)
(declare-const v Int)
(declare-const var_h_i1036 T4199)
(declare-const var_h1035 T4199)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1082 T4199)
(declare-const var__temp_v1083 Int)
(declare-const |var__temp_h'1084| T4199)
(declare-const var__temp_v_err1085 T4200)
(declare-const var_h1071 T4199)
(declare-const var_h1035 T4199)
(declare-const err T4213)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4199)
(declare-fun sel (T4199 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1071 () T4199)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1084| () T4199)
(declare-fun var__temp_v1083 () Int)
(declare-fun var__temp_h1082 () T4199)
(declare-fun v () Int)
(assert (> (sel var_h1071 res) 4))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h1082 res) v)
                (= (sel var__temp_h1082 res) (+ (sel var_h1071 res) 10))))
      (a!2 (=> (and (= (sel |var__temp_h'1084| res) var__temp_v1083)
                    (= var__temp_v1083 |5|))
               (and (= (sel |var__temp_h'1084| res) var__temp_v1083)
                    (= (sel |var__temp_h'1084| res) 10)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1082 res) 0))
                (=> (= (sel var__temp_h1082 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************284
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1072 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1072, res ) ==(v)
 	 , (sel)( , var_h_i1072, res ) ==((sel)( , var_h1071, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v1073:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1072 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1072 --->  Ty_heap  
 var_h1071 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1086 --->  Ty_heap  
 var__temp_v1087 --->  Ty_int  
 var__temp_h'1088 --->  Ty_heap  
 var__temp_v_err1089 --->  error  
 var_h1071 --->  Ty_heap  
 var_h1035 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1071, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1086, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1086, res ) ==((sel)( , var_h1071, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1086, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1086, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1088, res ) ==(var__temp_v1087) AND 
 	 Rel (sel)( , var__temp_h'1088, res ) ==((sel)( , var__temp_h1086, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1088, res ) ==(var__temp_v1087) AND 
 	 Rel (sel)( , var__temp_h'1088, res ) ==(10)
 
VC_END(declare-const var_h_i1072 T4216)
(declare-const var_h1071 T4216)
(declare-const v Int)
(declare-const var_h_i1036 T4216)
(declare-const var_h1035 T4216)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1086 T4216)
(declare-const var__temp_v1087 Int)
(declare-const |var__temp_h'1088| T4216)
(declare-const var__temp_v_err1089 T4217)
(declare-const var_h1071 T4216)
(declare-const var_h1035 T4216)
(declare-const err T4230)

solver 
 (declare-sort T4216)
(declare-fun sel (T4216 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1071 () T4216)
(declare-fun |var__temp_h'1088| () T4216)
(declare-fun var__temp_v1087 () Int)
(declare-fun var__temp_h1086 () T4216)
(declare-fun v () Int)
(assert (> (sel var_h1071 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h1086 res) v)
                (= (sel var__temp_h1086 res) (+ (sel var_h1071 res) 10))))
      (a!2 (and (= (sel |var__temp_h'1088| res) var__temp_v1087)
                (= (sel |var__temp_h'1088| res) (+ (sel var__temp_h1086 res) 2)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'1088| res) var__temp_v1087)
                    (= (sel |var__temp_h'1088| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1086 res) 5))
                (=> (= (sel var__temp_h1086 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************285
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1073:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1073:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --foo'	 --c2
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1072 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1072, res ) ==(v)
 	 , (sel)( , var_h_i1072, res ) ==((sel)( , var_h1071, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v1090:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************286
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1072 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1072, res ) ==(v)
 	 , (sel)( , var_h_i1072, res ) ==((sel)( , var_h1071, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v1090:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1072 --->  Ty_heap  
 var_h1071 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1091 --->  Ty_heap  
 var__temp_v1092 --->  Ty_int  
 var__temp_h'1093 --->  Ty_heap  
 var__temp_v_err1094 --->  error  
 var_h1071 --->  Ty_heap  
 var_h1035 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1071, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1091, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1091, res ) ==((sel)( , var_h1071, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1091, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1091, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1093, res ) ==(var__temp_v1092) AND 
 	 Rel (sel)( , var__temp_h'1093, res ) ==((sel)( , var__temp_h1091, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i1072 T4233)
(declare-const var_h1071 T4233)
(declare-const v Int)
(declare-const var_h_i1036 T4233)
(declare-const var_h1035 T4233)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1091 T4233)
(declare-const var__temp_v1092 Int)
(declare-const |var__temp_h'1093| T4233)
(declare-const var__temp_v_err1094 T4234)
(declare-const var_h1071 T4233)
(declare-const var_h1035 T4233)
(declare-const err T4247)

solver 
 (declare-sort T4233)
(declare-fun sel (T4233 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1071 () T4233)
(declare-fun var__temp_h1091 () T4233)
(declare-fun |var__temp_h'1093| () T4233)
(declare-fun var__temp_v1092 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1071 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h1091 res) v)
                (= (sel var__temp_h1091 res) (+ (sel var_h1071 res) 10))))
      (a!2 (and (= (sel |var__temp_h'1093| res) var__temp_v1092)
                (= (sel |var__temp_h'1093| res) (+ (sel var__temp_h1091 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1091 res) 7))
                (=> (= (sel var__temp_h1091 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************287
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1072 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1072, res ) ==(v)
 	 , (sel)( , var_h_i1072, res ) ==((sel)( , var_h1071, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v1090:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1072 --->  Ty_heap  
 var_h1071 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1095 --->  Ty_heap  
 var__temp_v1096 --->  Ty_int  
 var__temp_h'1097 --->  Ty_heap  
 var__temp_v_err1098 --->  error  
 var_h1071 --->  Ty_heap  
 var_h1035 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1071, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1095, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1095, res ) ==((sel)( , var_h1071, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1095, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1095, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1097, res ) ==(var__temp_v1096) AND 
 	 Rel (sel)( , var__temp_h'1097, res ) ==((sel)( , var__temp_h1095, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i1072 T4250)
(declare-const var_h1071 T4250)
(declare-const v Int)
(declare-const var_h_i1036 T4250)
(declare-const var_h1035 T4250)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1095 T4250)
(declare-const var__temp_v1096 Int)
(declare-const |var__temp_h'1097| T4250)
(declare-const var__temp_v_err1098 T4251)
(declare-const var_h1071 T4250)
(declare-const var_h1035 T4250)
(declare-const err T4264)

solver 
 (declare-sort T4250)
(declare-fun sel (T4250 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1071 () T4250)
(declare-fun var__temp_h1095 () T4250)
(declare-fun |var__temp_h'1097| () T4250)
(declare-fun var__temp_v1096 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1071 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h1095 res) v)
                (= (sel var__temp_h1095 res) (+ (sel var_h1071 res) 10))))
      (a!2 (and (= (sel |var__temp_h'1097| res) var__temp_v1096)
                (= (sel |var__temp_h'1097| res) (+ (sel var__temp_h1095 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1095 res) 7))
                (=> (= (sel var__temp_h1095 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************288
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1072 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1072, res ) ==(v)
 	 , (sel)( , var_h_i1072, res ) ==((sel)( , var_h1071, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v1090:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1072 --->  Ty_heap  
 var_h1071 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1099 --->  Ty_heap  
 var__temp_v1100 --->  Ty_int  
 var__temp_h'1101 --->  Ty_heap  
 var__temp_v_err1102 --->  error  
 var_h1071 --->  Ty_heap  
 var_h1035 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1071, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1099, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1099, res ) ==((sel)( , var_h1071, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1099, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h1099, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1101, res ) ==(var__temp_v1100) AND 
 	 Base var__temp_v1100 = 5 => 
 	 True
 
VC_END(declare-const var_h_i1072 T4267)
(declare-const var_h1071 T4267)
(declare-const v Int)
(declare-const var_h_i1036 T4267)
(declare-const var_h1035 T4267)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1099 T4267)
(declare-const var__temp_v1100 Int)
(declare-const |var__temp_h'1101| T4267)
(declare-const var__temp_v_err1102 T4268)
(declare-const var_h1071 T4267)
(declare-const var_h1035 T4267)
(declare-const err T4281)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4267)
(declare-fun sel (T4267 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1071 () T4267)
(declare-fun |5| () Int)
(declare-fun var__temp_v1100 () Int)
(declare-fun |var__temp_h'1101| () T4267)
(declare-fun var__temp_h1099 () T4267)
(declare-fun v () Int)
(assert (> (sel var_h1071 res) 4))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h1099 res) v)
                (= (sel var__temp_h1099 res) (+ (sel var_h1071 res) 10))))
      (a!2 (=> (and (= (sel |var__temp_h'1101| res) var__temp_v1100)
                    (= var__temp_v1100 |5|))
               true)))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1099 res) 0))
                (=> (= (sel var__temp_h1099 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************289
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1072 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1072, res ) ==(v)
 	 , (sel)( , var_h_i1072, res ) ==((sel)( , var_h1071, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v1090:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1072 --->  Ty_heap  
 var_h1071 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1103 --->  Ty_heap  
 var__temp_v1104 --->  Ty_int  
 var__temp_h'1105 --->  Ty_heap  
 var__temp_v_err1106 --->  error  
 var_h1071 --->  Ty_heap  
 var_h1035 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1071, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1103, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1103, res ) ==((sel)( , var_h1071, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1103, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1103, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1105, res ) ==(var__temp_v1104) AND 
 	 Rel (sel)( , var__temp_h'1105, res ) ==((sel)( , var__temp_h1103, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i1072 T4284)
(declare-const var_h1071 T4284)
(declare-const v Int)
(declare-const var_h_i1036 T4284)
(declare-const var_h1035 T4284)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1103 T4284)
(declare-const var__temp_v1104 Int)
(declare-const |var__temp_h'1105| T4284)
(declare-const var__temp_v_err1106 T4285)
(declare-const var_h1071 T4284)
(declare-const var_h1035 T4284)
(declare-const err T4298)

solver 
 (declare-sort T4284)
(declare-fun sel (T4284 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1071 () T4284)
(declare-fun var__temp_h1103 () T4284)
(declare-fun |var__temp_h'1105| () T4284)
(declare-fun var__temp_v1104 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1071 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h1103 res) v)
                (= (sel var__temp_h1103 res) (+ (sel var_h1071 res) 10))))
      (a!2 (and (= (sel |var__temp_h'1105| res) var__temp_v1104)
                (= (sel |var__temp_h'1105| res) (+ (sel var__temp_h1103 res) 2)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1103 res) 5))
                (=> (= (sel var__temp_h1103 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************290
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1036, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1107:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************291
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1036, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1107:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1108 --->  Ty_heap  
 var__temp_v1109 --->  Ty_int  
 var__temp_h'1110 --->  Ty_heap  
 var__temp_v_err1111 --->  error  
 var_h1035 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1108, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h1108, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1108, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1110, res ) ==(var__temp_v1109) AND 
 	 Rel (sel)( , var__temp_h'1110, res ) ==((sel)( , var__temp_h1108, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i1036 T4301)
(declare-const var_h1035 T4301)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1108 T4301)
(declare-const var__temp_v1109 Int)
(declare-const |var__temp_h'1110| T4301)
(declare-const var__temp_v_err1111 T4302)
(declare-const var_h1035 T4301)
(declare-const err T4315)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4301)
(declare-fun |20| () Int)
(declare-fun sel (T4301 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h1108 () T4301)
(declare-fun |var__temp_h'1110| () T4301)
(declare-fun var__temp_v1109 () Int)
(declare-fun v () Int)
(assert true)
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1108 res) v) (= v |20|))
               (= (sel var__temp_h1108 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1110| res) var__temp_v1109)
                (= (sel |var__temp_h'1110| res) (+ (sel var__temp_h1108 res) 3)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1108 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************292
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1036, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1107:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1112 --->  Ty_heap  
 var__temp_v1113 --->  Ty_int  
 var__temp_h'1114 --->  Ty_heap  
 var__temp_v_err1115 --->  error  
 var_h1035 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1112, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h1112, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1112, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1114, res ) ==(var__temp_v1113) AND 
 	 Rel (sel)( , var__temp_h'1114, res ) ==((sel)( , var__temp_h1112, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i1036 T4318)
(declare-const var_h1035 T4318)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1112 T4318)
(declare-const var__temp_v1113 Int)
(declare-const |var__temp_h'1114| T4318)
(declare-const var__temp_v_err1115 T4319)
(declare-const var_h1035 T4318)
(declare-const err T4332)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4318)
(declare-fun |20| () Int)
(declare-fun sel (T4318 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h1112 () T4318)
(declare-fun |var__temp_h'1114| () T4318)
(declare-fun var__temp_v1113 () Int)
(declare-fun v () Int)
(assert true)
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1112 res) v) (= v |20|))
               (= (sel var__temp_h1112 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1114| res) var__temp_v1113)
                (= (sel |var__temp_h'1114| res) (+ (sel var__temp_h1112 res) 5)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1112 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************293
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1036, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1107:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1116 --->  Ty_heap  
 var__temp_v1117 --->  Ty_int  
 var__temp_h'1118 --->  Ty_heap  
 var__temp_v_err1119 --->  error  
 var_h1035 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1116, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h1116, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h1116, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1118, res ) ==(var__temp_v1117) AND 
 	 Base var__temp_v1117 = 5 => 
 	 True
 
VC_END(declare-const var_h_i1036 T4335)
(declare-const var_h1035 T4335)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1116 T4335)
(declare-const var__temp_v1117 Int)
(declare-const |var__temp_h'1118| T4335)
(declare-const var__temp_v_err1119 T4336)
(declare-const var_h1035 T4335)
(declare-const err T4349)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T4335)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_v1117 () Int)
(declare-fun sel (T4335 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'1118| () T4335)
(declare-fun var__temp_h1116 () T4335)
(declare-fun v () Int)
(assert true)
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1116 res) v) (= v |20|))
               (= (sel var__temp_h1116 res) 0)))
      (a!2 (=> (and (= (sel |var__temp_h'1118| res) var__temp_v1117)
                    (= var__temp_v1117 |5|))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1116 res) 0) a!2))))
  (not a!3))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************294
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1036, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1107:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1120 --->  Ty_heap  
 var__temp_v1121 --->  Ty_int  
 var__temp_h'1122 --->  Ty_heap  
 var__temp_v_err1123 --->  error  
 var_h1035 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1120, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h1120, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1120, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1122, res ) ==(var__temp_v1121) AND 
 	 Rel (sel)( , var__temp_h'1122, res ) ==((sel)( , var__temp_h1120, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i1036 T4352)
(declare-const var_h1035 T4352)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1120 T4352)
(declare-const var__temp_v1121 Int)
(declare-const |var__temp_h'1122| T4352)
(declare-const var__temp_v_err1123 T4353)
(declare-const var_h1035 T4352)
(declare-const err T4366)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4352)
(declare-fun |20| () Int)
(declare-fun sel (T4352 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h1120 () T4352)
(declare-fun |var__temp_h'1122| () T4352)
(declare-fun var__temp_v1121 () Int)
(declare-fun v () Int)
(assert true)
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1120 res) v) (= v |20|))
               (= (sel var__temp_h1120 res) 5)))
      (a!2 (and (= (sel |var__temp_h'1122| res) var__temp_v1121)
                (= (sel |var__temp_h'1122| res) (+ (sel var__temp_h1120 res) 2)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1120 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************295
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {var_v1124:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************296
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {var_v1124:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1125 --->  Ty_heap  
 var__temp_v1126 --->  Ty_int  
 var__temp_h'1127 --->  Ty_heap  
 var__temp_v_err1128 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1125, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h1125, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1125, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1127, res ) ==(var__temp_v1126) AND 
 	 Rel (sel)( , var__temp_h'1127, res ) ==((sel)( , var__temp_h1125, res ) + (3)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1125 T4369)
(declare-const var__temp_v1126 Int)
(declare-const |var__temp_h'1127| T4369)
(declare-const var__temp_v_err1128 T4370)
(declare-const err T4383)

solver 
 (declare-sort T4369)
(declare-fun sel (T4369 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h1125 () T4369)
(declare-fun |var__temp_h'1127| () T4369)
(declare-fun var__temp_v1126 () Int)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'1127| res) var__temp_v1126)
                (= (sel |var__temp_h'1127| res) (+ (sel var__temp_h1125 res) 3)))))
(let ((a!2 (and (=> (= (sel var__temp_h1125 res) 0)
                    (= (sel var__temp_h1125 res) 7))
                (=> (= (sel var__temp_h1125 res) 7) (=> a!1 true)))))
  (not a!2))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************297
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {var_v1124:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1129 --->  Ty_heap  
 var__temp_v1130 --->  Ty_int  
 var__temp_h'1131 --->  Ty_heap  
 var__temp_v_err1132 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1129, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h1129, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1129, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1131, res ) ==(var__temp_v1130) AND 
 	 Rel (sel)( , var__temp_h'1131, res ) ==((sel)( , var__temp_h1129, res ) + (5)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1129 T4386)
(declare-const var__temp_v1130 Int)
(declare-const |var__temp_h'1131| T4386)
(declare-const var__temp_v_err1132 T4387)
(declare-const err T4400)

solver 
 (declare-sort T4386)
(declare-fun sel (T4386 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h1129 () T4386)
(declare-fun |var__temp_h'1131| () T4386)
(declare-fun var__temp_v1130 () Int)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'1131| res) var__temp_v1130)
                (= (sel |var__temp_h'1131| res) (+ (sel var__temp_h1129 res) 5)))))
(let ((a!2 (and (=> (= (sel var__temp_h1129 res) 0)
                    (= (sel var__temp_h1129 res) 7))
                (=> (= (sel var__temp_h1129 res) 7) (=> a!1 true)))))
  (not a!2))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************298
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {var_v1124:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1133 --->  Ty_heap  
 var__temp_v1134 --->  Ty_int  
 var__temp_h'1135 --->  Ty_heap  
 var__temp_v_err1136 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1133, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h1133, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1133, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1135, res ) ==(var__temp_v1134) AND 
 	 Rel (sel)( , var__temp_h'1135, res ) ==((sel)( , var__temp_h1133, res ) + (10)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1133 T4403)
(declare-const var__temp_v1134 Int)
(declare-const |var__temp_h'1135| T4403)
(declare-const var__temp_v_err1136 T4404)
(declare-const err T4417)

solver 
 (declare-sort T4403)
(declare-fun sel (T4403 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h1133 () T4403)
(declare-fun |var__temp_h'1135| () T4403)
(declare-fun var__temp_v1134 () Int)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'1135| res) var__temp_v1134)
                (= (sel |var__temp_h'1135| res)
                   (+ (sel var__temp_h1133 res) 10)))))
(let ((a!2 (and (=> (= (sel var__temp_h1133 res) 0)
                    (> (sel var__temp_h1133 res) 4))
                (=> (> (sel var__temp_h1133 res) 4) (=> a!1 true)))))
  (not a!2))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************299
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {var_v1124:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1137 --->  Ty_heap  
 var__temp_v1138 --->  Ty_int  
 var__temp_h'1139 --->  Ty_heap  
 var__temp_v_err1140 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1137, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h1137, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h1137, res ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1139, res ) ==(var__temp_v1138) AND 
 	 Base var__temp_v1138 = 5 => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1137 T4420)
(declare-const var__temp_v1138 Int)
(declare-const |var__temp_h'1139| T4420)
(declare-const var__temp_v_err1140 T4421)
(declare-const err T4434)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4420)
(declare-fun |5| () Int)
(declare-fun var__temp_v1138 () Int)
(declare-fun sel (T4420 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'1139| () T4420)
(declare-fun var__temp_h1137 () T4420)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel |var__temp_h'1139| res) var__temp_v1138)
                    (= var__temp_v1138 |5|))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h1137 res) 0)
                    (= (sel var__temp_h1137 res) 0))
                (=> (= (sel var__temp_h1137 res) 0) a!1))))
  (not a!2))))

***************Selection Successful************foo
PARTIAL PATH NEW
NEW 	 --foo
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1142 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1142 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1142, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1143:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1142 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
bar
 *********************Enumeration Iteration*****************300
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1142 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1142, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1143:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1142 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1142 --->  Ty_heap  
 var_h1141 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1144 --->  Ty_heap  
 var__temp_v1145 --->  Ty_int  
 var__temp_h'1146 --->  Ty_heap  
 var__temp_v_err1147 --->  error  
 var_h1141 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1141, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1144, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1144, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1144, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1146, res ) ==(var__temp_v1145) AND 
 	 Rel (sel)( , var__temp_h'1146, res ) ==((sel)( , var__temp_h1144, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1146, res ) ==(var__temp_v1145) AND 
 	 Rel (sel)( , var__temp_h'1146, res ) ==(10)
 
VC_END(declare-const var_h_i1142 T4437)
(declare-const var_h1141 T4437)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1144 T4437)
(declare-const var__temp_v1145 Int)
(declare-const |var__temp_h'1146| T4437)
(declare-const var__temp_v_err1147 T4438)
(declare-const var_h1141 T4437)
(declare-const err T4451)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4437)
(declare-fun sel (T4437 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1141 () T4437)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1146| () T4437)
(declare-fun var__temp_v1145 () Int)
(declare-fun var__temp_h1144 () T4437)
(declare-fun v () Int)
(assert (= (sel var_h1141 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1144 res) v) (= v |5|))
               (= (sel var__temp_h1144 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1146| res) var__temp_v1145)
                (= (sel |var__temp_h'1146| res) (+ (sel var__temp_h1144 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'1146| res) var__temp_v1145)
                    (= (sel |var__temp_h'1146| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1144 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************301
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1142 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1142, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1143:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1142 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1142 --->  Ty_heap  
 var_h1141 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1148 --->  Ty_heap  
 var__temp_v1149 --->  Ty_int  
 var__temp_h'1150 --->  Ty_heap  
 var__temp_v_err1151 --->  error  
 var_h1141 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1141, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1148, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1148, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1148, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1150, res ) ==(var__temp_v1149) AND 
 	 Rel (sel)( , var__temp_h'1150, res ) ==((sel)( , var__temp_h1148, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1150, res ) ==(var__temp_v1149) AND 
 	 Rel (sel)( , var__temp_h'1150, res ) ==(10)
 
VC_END(declare-const var_h_i1142 T4454)
(declare-const var_h1141 T4454)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1148 T4454)
(declare-const var__temp_v1149 Int)
(declare-const |var__temp_h'1150| T4454)
(declare-const var__temp_v_err1151 T4455)
(declare-const var_h1141 T4454)
(declare-const err T4468)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4454)
(declare-fun sel (T4454 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1141 () T4454)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1150| () T4454)
(declare-fun var__temp_v1149 () Int)
(declare-fun var__temp_h1148 () T4454)
(declare-fun v () Int)
(assert (= (sel var_h1141 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1148 res) v) (= v |5|))
               (= (sel var__temp_h1148 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1150| res) var__temp_v1149)
                (= (sel |var__temp_h'1150| res) (+ (sel var__temp_h1148 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'1150| res) var__temp_v1149)
                    (= (sel |var__temp_h'1150| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1148 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************302
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1142 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1142, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1143:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1142 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1142 --->  Ty_heap  
 var_h1141 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1152 --->  Ty_heap  
 var__temp_v1153 --->  Ty_int  
 var__temp_h'1154 --->  Ty_heap  
 var__temp_v_err1155 --->  error  
 var_h1141 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1141, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1152, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1152, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1152, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1154, res ) ==(var__temp_v1153) AND 
 	 Rel (sel)( , var__temp_h'1154, res ) ==((sel)( , var__temp_h1152, res ) + (10)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1154, res ) ==(var__temp_v1153) AND 
 	 Rel (sel)( , var__temp_h'1154, res ) ==(10)
 
VC_END(declare-const var_h_i1142 T4471)
(declare-const var_h1141 T4471)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1152 T4471)
(declare-const var__temp_v1153 Int)
(declare-const |var__temp_h'1154| T4471)
(declare-const var__temp_v_err1155 T4472)
(declare-const var_h1141 T4471)
(declare-const err T4485)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4471)
(declare-fun sel (T4471 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1141 () T4471)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1154| () T4471)
(declare-fun var__temp_v1153 () Int)
(declare-fun var__temp_h1152 () T4471)
(declare-fun v () Int)
(assert (= (sel var_h1141 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1152 res) v) (= v |5|))
               (> (sel var__temp_h1152 res) 4)))
      (a!2 (and (= (sel |var__temp_h'1154| res) var__temp_v1153)
                (= (sel |var__temp_h'1154| res)
                   (+ (sel var__temp_h1152 res) 10)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'1154| res) var__temp_v1153)
                    (= (sel |var__temp_h'1154| res) 10)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h1152 res) 4) a!3))))
  (not a!4)))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************303
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1142 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1142, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1143:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1142 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1142 --->  Ty_heap  
 var_h1141 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1156 --->  Ty_heap  
 var__temp_v1157 --->  Ty_int  
 var__temp_h'1158 --->  Ty_heap  
 var__temp_v_err1159 --->  error  
 var_h1141 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1141, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1156, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1156, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1156, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1158, res ) ==(var__temp_v1157) AND 
 	 Rel (sel)( , var__temp_h'1158, res ) ==((sel)( , var__temp_h1156, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1158, res ) ==(var__temp_v1157) AND 
 	 Rel (sel)( , var__temp_h'1158, res ) ==(10)
 
VC_END(declare-const var_h_i1142 T4488)
(declare-const var_h1141 T4488)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1156 T4488)
(declare-const var__temp_v1157 Int)
(declare-const |var__temp_h'1158| T4488)
(declare-const var__temp_v_err1159 T4489)
(declare-const var_h1141 T4488)
(declare-const err T4502)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4488)
(declare-fun sel (T4488 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1141 () T4488)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1158| () T4488)
(declare-fun var__temp_v1157 () Int)
(declare-fun var__temp_h1156 () T4488)
(declare-fun v () Int)
(assert (= (sel var_h1141 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1156 res) v) (= v |5|))
               (= (sel var__temp_h1156 res) 5)))
      (a!2 (and (= (sel |var__temp_h'1158| res) var__temp_v1157)
                (= (sel |var__temp_h'1158| res) (+ (sel var__temp_h1156 res) 2)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'1158| res) var__temp_v1157)
                    (= (sel |var__temp_h'1158| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1156 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************304
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1143:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1143:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfoofoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --foo
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1142 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1142, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1160:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
bar
 *********************Enumeration Iteration*****************305
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1142 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1142, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1160:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1142 --->  Ty_heap  
 var_h1141 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1161 --->  Ty_heap  
 var__temp_v1162 --->  Ty_int  
 var__temp_h'1163 --->  Ty_heap  
 var__temp_v_err1164 --->  error  
 var_h1141 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1141, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1161, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1161, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1161, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1163, res ) ==(var__temp_v1162) AND 
 	 Rel (sel)( , var__temp_h'1163, res ) ==((sel)( , var__temp_h1161, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i1142 T4505)
(declare-const var_h1141 T4505)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1161 T4505)
(declare-const var__temp_v1162 Int)
(declare-const |var__temp_h'1163| T4505)
(declare-const var__temp_v_err1164 T4506)
(declare-const var_h1141 T4505)
(declare-const err T4519)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4505)
(declare-fun sel (T4505 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1141 () T4505)
(declare-fun |5| () Int)
(declare-fun var__temp_h1161 () T4505)
(declare-fun |var__temp_h'1163| () T4505)
(declare-fun var__temp_v1162 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1141 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1161 res) v) (= v |5|))
               (= (sel var__temp_h1161 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1163| res) var__temp_v1162)
                (= (sel |var__temp_h'1163| res) (+ (sel var__temp_h1161 res) 3)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1161 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************306
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1142 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1142, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1160:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1142 --->  Ty_heap  
 var_h1141 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1165 --->  Ty_heap  
 var__temp_v1166 --->  Ty_int  
 var__temp_h'1167 --->  Ty_heap  
 var__temp_v_err1168 --->  error  
 var_h1141 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1141, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1165, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1165, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1165, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1167, res ) ==(var__temp_v1166) AND 
 	 Rel (sel)( , var__temp_h'1167, res ) ==((sel)( , var__temp_h1165, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i1142 T4522)
(declare-const var_h1141 T4522)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1165 T4522)
(declare-const var__temp_v1166 Int)
(declare-const |var__temp_h'1167| T4522)
(declare-const var__temp_v_err1168 T4523)
(declare-const var_h1141 T4522)
(declare-const err T4536)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4522)
(declare-fun sel (T4522 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1141 () T4522)
(declare-fun |5| () Int)
(declare-fun var__temp_h1165 () T4522)
(declare-fun |var__temp_h'1167| () T4522)
(declare-fun var__temp_v1166 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1141 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1165 res) v) (= v |5|))
               (= (sel var__temp_h1165 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1167| res) var__temp_v1166)
                (= (sel |var__temp_h'1167| res) (+ (sel var__temp_h1165 res) 5)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1165 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************307
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1142 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1142, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1160:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (10)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1142 --->  Ty_heap  
 var_h1141 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1169 --->  Ty_heap  
 var__temp_v1170 --->  Ty_int  
 var__temp_h'1171 --->  Ty_heap  
 var__temp_v_err1172 --->  error  
 var_h1141 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1141, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1169, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1169, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1169, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1171, res ) ==(var__temp_v1170) AND 
 	 Rel (sel)( , var__temp_h'1171, res ) ==((sel)( , var__temp_h1169, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i1142 T4539)
(declare-const var_h1141 T4539)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1169 T4539)
(declare-const var__temp_v1170 Int)
(declare-const |var__temp_h'1171| T4539)
(declare-const var__temp_v_err1172 T4540)
(declare-const var_h1141 T4539)
(declare-const err T4553)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4539)
(declare-fun sel (T4539 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1141 () T4539)
(declare-fun |5| () Int)
(declare-fun var__temp_h1169 () T4539)
(declare-fun |var__temp_h'1171| () T4539)
(declare-fun var__temp_v1170 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1141 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1169 res) v) (= v |5|))
               (> (sel var__temp_h1169 res) 4)))
      (a!2 (and (= (sel |var__temp_h'1171| res) var__temp_v1170)
                (= (sel |var__temp_h'1171| res)
                   (+ (sel var__temp_h1169 res) 10)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h1169 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c2
PARTIAL PATH NEW
NEW 	 --foo	 --c2
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1174 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1174 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1174, res ) ==(v)
 	 , (sel)( , var_h_i1174, res ) ==((sel)( , var_h1173, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v1175:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1174 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************308
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1174 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1174, res ) ==(v)
 	 , (sel)( , var_h_i1174, res ) ==((sel)( , var_h1173, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v1175:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1174 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1174 --->  Ty_heap  
 var_h1173 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1142 --->  Ty_heap  
 var_h1141 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1176 --->  Ty_heap  
 var__temp_v1177 --->  Ty_int  
 var__temp_h'1178 --->  Ty_heap  
 var__temp_v_err1179 --->  error  
 var_h1173 --->  Ty_heap  
 var_h1141 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1173, res ) > (4) AND 
 	 Rel (sel)( , var_h1141, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1176, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1176, res ) ==((sel)( , var_h1173, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1176, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1176, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1178, res ) ==(var__temp_v1177) AND 
 	 Rel (sel)( , var__temp_h'1178, res ) ==((sel)( , var__temp_h1176, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1178, res ) ==(var__temp_v1177) AND 
 	 Rel (sel)( , var__temp_h'1178, res ) ==(10)
 
VC_END(declare-const var_h_i1174 T4556)
(declare-const var_h1173 T4556)
(declare-const v Int)
(declare-const var_h_i1142 T4556)
(declare-const var_h1141 T4556)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1176 T4556)
(declare-const var__temp_v1177 Int)
(declare-const |var__temp_h'1178| T4556)
(declare-const var__temp_v_err1179 T4557)
(declare-const var_h1173 T4556)
(declare-const var_h1141 T4556)
(declare-const err T4570)

solver 
 (declare-sort T4556)
(declare-fun sel (T4556 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1173 () T4556)
(declare-fun var_h1141 () T4556)
(declare-fun |var__temp_h'1178| () T4556)
(declare-fun var__temp_v1177 () Int)
(declare-fun var__temp_h1176 () T4556)
(declare-fun v () Int)
(assert (> (sel var_h1173 res) 4))
(assert (= (sel var_h1141 res) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1176 res) v)
                (= (sel var__temp_h1176 res) (+ (sel var_h1173 res) 10))))
      (a!2 (and (= (sel |var__temp_h'1178| res) var__temp_v1177)
                (= (sel |var__temp_h'1178| res) (+ (sel var__temp_h1176 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'1178| res) var__temp_v1177)
                    (= (sel |var__temp_h'1178| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1176 res) 7))
                (=> (= (sel var__temp_h1176 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************309
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1174 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1174, res ) ==(v)
 	 , (sel)( , var_h_i1174, res ) ==((sel)( , var_h1173, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v1175:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1174 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1174 --->  Ty_heap  
 var_h1173 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1142 --->  Ty_heap  
 var_h1141 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1180 --->  Ty_heap  
 var__temp_v1181 --->  Ty_int  
 var__temp_h'1182 --->  Ty_heap  
 var__temp_v_err1183 --->  error  
 var_h1173 --->  Ty_heap  
 var_h1141 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1173, res ) > (4) AND 
 	 Rel (sel)( , var_h1141, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1180, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1180, res ) ==((sel)( , var_h1173, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1180, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1180, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1182, res ) ==(var__temp_v1181) AND 
 	 Rel (sel)( , var__temp_h'1182, res ) ==((sel)( , var__temp_h1180, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1182, res ) ==(var__temp_v1181) AND 
 	 Rel (sel)( , var__temp_h'1182, res ) ==(10)
 
VC_END(declare-const var_h_i1174 T4573)
(declare-const var_h1173 T4573)
(declare-const v Int)
(declare-const var_h_i1142 T4573)
(declare-const var_h1141 T4573)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1180 T4573)
(declare-const var__temp_v1181 Int)
(declare-const |var__temp_h'1182| T4573)
(declare-const var__temp_v_err1183 T4574)
(declare-const var_h1173 T4573)
(declare-const var_h1141 T4573)
(declare-const err T4587)

solver 
 (declare-sort T4573)
(declare-fun sel (T4573 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1173 () T4573)
(declare-fun var_h1141 () T4573)
(declare-fun |var__temp_h'1182| () T4573)
(declare-fun var__temp_v1181 () Int)
(declare-fun var__temp_h1180 () T4573)
(declare-fun v () Int)
(assert (> (sel var_h1173 res) 4))
(assert (= (sel var_h1141 res) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1180 res) v)
                (= (sel var__temp_h1180 res) (+ (sel var_h1173 res) 10))))
      (a!2 (and (= (sel |var__temp_h'1182| res) var__temp_v1181)
                (= (sel |var__temp_h'1182| res) (+ (sel var__temp_h1180 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'1182| res) var__temp_v1181)
                    (= (sel |var__temp_h'1182| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1180 res) 7))
                (=> (= (sel var__temp_h1180 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************310
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1174 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1174, res ) ==(v)
 	 , (sel)( , var_h_i1174, res ) ==((sel)( , var_h1173, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v1175:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1174 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1174 --->  Ty_heap  
 var_h1173 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1142 --->  Ty_heap  
 var_h1141 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1184 --->  Ty_heap  
 var__temp_v1185 --->  Ty_int  
 var__temp_h'1186 --->  Ty_heap  
 var__temp_v_err1187 --->  error  
 var_h1173 --->  Ty_heap  
 var_h1141 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1173, res ) > (4) AND 
 	 Rel (sel)( , var_h1141, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1184, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1184, res ) ==((sel)( , var_h1173, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1184, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1184, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1186, res ) ==(var__temp_v1185) AND 
 	 Rel (sel)( , var__temp_h'1186, res ) ==((sel)( , var__temp_h1184, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1186, res ) ==(var__temp_v1185) AND 
 	 Rel (sel)( , var__temp_h'1186, res ) ==(10)
 
VC_END(declare-const var_h_i1174 T4590)
(declare-const var_h1173 T4590)
(declare-const v Int)
(declare-const var_h_i1142 T4590)
(declare-const var_h1141 T4590)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1184 T4590)
(declare-const var__temp_v1185 Int)
(declare-const |var__temp_h'1186| T4590)
(declare-const var__temp_v_err1187 T4591)
(declare-const var_h1173 T4590)
(declare-const var_h1141 T4590)
(declare-const err T4604)

solver 
 (declare-sort T4590)
(declare-fun sel (T4590 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1173 () T4590)
(declare-fun var_h1141 () T4590)
(declare-fun |var__temp_h'1186| () T4590)
(declare-fun var__temp_v1185 () Int)
(declare-fun var__temp_h1184 () T4590)
(declare-fun v () Int)
(assert (> (sel var_h1173 res) 4))
(assert (= (sel var_h1141 res) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1184 res) v)
                (= (sel var__temp_h1184 res) (+ (sel var_h1173 res) 10))))
      (a!2 (and (= (sel |var__temp_h'1186| res) var__temp_v1185)
                (= (sel |var__temp_h'1186| res) (+ (sel var__temp_h1184 res) 2)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'1186| res) var__temp_v1185)
                    (= (sel |var__temp_h'1186| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1184 res) 5))
                (=> (= (sel var__temp_h1184 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************311
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1175:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1175:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2foofoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --foo	 --c2
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1174 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1174, res ) ==(v)
 	 , (sel)( , var_h_i1174, res ) ==((sel)( , var_h1173, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v1188:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************312
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1174 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1174, res ) ==(v)
 	 , (sel)( , var_h_i1174, res ) ==((sel)( , var_h1173, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v1188:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1174 --->  Ty_heap  
 var_h1173 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1142 --->  Ty_heap  
 var_h1141 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1189 --->  Ty_heap  
 var__temp_v1190 --->  Ty_int  
 var__temp_h'1191 --->  Ty_heap  
 var__temp_v_err1192 --->  error  
 var_h1173 --->  Ty_heap  
 var_h1141 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1173, res ) > (4) AND 
 	 Rel (sel)( , var_h1141, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1189, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1189, res ) ==((sel)( , var_h1173, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1189, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1189, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1191, res ) ==(var__temp_v1190) AND 
 	 Rel (sel)( , var__temp_h'1191, res ) ==((sel)( , var__temp_h1189, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i1174 T4607)
(declare-const var_h1173 T4607)
(declare-const v Int)
(declare-const var_h_i1142 T4607)
(declare-const var_h1141 T4607)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1189 T4607)
(declare-const var__temp_v1190 Int)
(declare-const |var__temp_h'1191| T4607)
(declare-const var__temp_v_err1192 T4608)
(declare-const var_h1173 T4607)
(declare-const var_h1141 T4607)
(declare-const err T4621)

solver 
 (declare-sort T4607)
(declare-fun sel (T4607 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1173 () T4607)
(declare-fun var_h1141 () T4607)
(declare-fun var__temp_h1189 () T4607)
(declare-fun |var__temp_h'1191| () T4607)
(declare-fun var__temp_v1190 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1173 res) 4))
(assert (= (sel var_h1141 res) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1189 res) v)
                (= (sel var__temp_h1189 res) (+ (sel var_h1173 res) 10))))
      (a!2 (and (= (sel |var__temp_h'1191| res) var__temp_v1190)
                (= (sel |var__temp_h'1191| res) (+ (sel var__temp_h1189 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1189 res) 7))
                (=> (= (sel var__temp_h1189 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************313
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1174 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1174, res ) ==(v)
 	 , (sel)( , var_h_i1174, res ) ==((sel)( , var_h1173, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v1188:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1174 --->  Ty_heap  
 var_h1173 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1142 --->  Ty_heap  
 var_h1141 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1193 --->  Ty_heap  
 var__temp_v1194 --->  Ty_int  
 var__temp_h'1195 --->  Ty_heap  
 var__temp_v_err1196 --->  error  
 var_h1173 --->  Ty_heap  
 var_h1141 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1173, res ) > (4) AND 
 	 Rel (sel)( , var_h1141, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1193, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1193, res ) ==((sel)( , var_h1173, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1193, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1193, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1195, res ) ==(var__temp_v1194) AND 
 	 Rel (sel)( , var__temp_h'1195, res ) ==((sel)( , var__temp_h1193, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i1174 T4624)
(declare-const var_h1173 T4624)
(declare-const v Int)
(declare-const var_h_i1142 T4624)
(declare-const var_h1141 T4624)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1193 T4624)
(declare-const var__temp_v1194 Int)
(declare-const |var__temp_h'1195| T4624)
(declare-const var__temp_v_err1196 T4625)
(declare-const var_h1173 T4624)
(declare-const var_h1141 T4624)
(declare-const err T4638)

solver 
 (declare-sort T4624)
(declare-fun sel (T4624 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1173 () T4624)
(declare-fun var_h1141 () T4624)
(declare-fun var__temp_h1193 () T4624)
(declare-fun |var__temp_h'1195| () T4624)
(declare-fun var__temp_v1194 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1173 res) 4))
(assert (= (sel var_h1141 res) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1193 res) v)
                (= (sel var__temp_h1193 res) (+ (sel var_h1173 res) 10))))
      (a!2 (and (= (sel |var__temp_h'1195| res) var__temp_v1194)
                (= (sel |var__temp_h'1195| res) (+ (sel var__temp_h1193 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1193 res) 7))
                (=> (= (sel var__temp_h1193 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************314
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1174 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1174, res ) ==(v)
 	 , (sel)( , var_h_i1174, res ) ==((sel)( , var_h1173, res ) + (10)) >c  } 
 } 
 
                                                RET :  Base {var_v1188:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1174 --->  Ty_heap  
 var_h1173 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1142 --->  Ty_heap  
 var_h1141 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1197 --->  Ty_heap  
 var__temp_v1198 --->  Ty_int  
 var__temp_h'1199 --->  Ty_heap  
 var__temp_v_err1200 --->  error  
 var_h1173 --->  Ty_heap  
 var_h1141 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1173, res ) > (4) AND 
 	 Rel (sel)( , var_h1141, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1197, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1197, res ) ==((sel)( , var_h1173, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1197, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1197, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1199, res ) ==(var__temp_v1198) AND 
 	 Rel (sel)( , var__temp_h'1199, res ) ==((sel)( , var__temp_h1197, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i1174 T4641)
(declare-const var_h1173 T4641)
(declare-const v Int)
(declare-const var_h_i1142 T4641)
(declare-const var_h1141 T4641)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1197 T4641)
(declare-const var__temp_v1198 Int)
(declare-const |var__temp_h'1199| T4641)
(declare-const var__temp_v_err1200 T4642)
(declare-const var_h1173 T4641)
(declare-const var_h1141 T4641)
(declare-const err T4655)

solver 
 (declare-sort T4641)
(declare-fun sel (T4641 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1173 () T4641)
(declare-fun var_h1141 () T4641)
(declare-fun var__temp_h1197 () T4641)
(declare-fun |var__temp_h'1199| () T4641)
(declare-fun var__temp_v1198 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1173 res) 4))
(assert (= (sel var_h1141 res) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1197 res) v)
                (= (sel var__temp_h1197 res) (+ (sel var_h1173 res) 10))))
      (a!2 (and (= (sel |var__temp_h'1199| res) var__temp_v1198)
                (= (sel |var__temp_h'1199| res) (+ (sel var__temp_h1197 res) 2)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1197 res) 5))
                (=> (= (sel var__temp_h1197 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************315
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 	 --foo
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1142 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1142, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1201:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************316
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1142 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1142, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1201:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1142 --->  Ty_heap  
 var_h1141 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1202 --->  Ty_heap  
 var__temp_v1203 --->  Ty_int  
 var__temp_h'1204 --->  Ty_heap  
 var__temp_v_err1205 --->  error  
 var_h1141 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1141, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1202, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1202, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1202, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1204, res ) ==(var__temp_v1203) AND 
 	 Rel (sel)( , var__temp_h'1204, res ) ==((sel)( , var__temp_h1202, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i1142 T4658)
(declare-const var_h1141 T4658)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1202 T4658)
(declare-const var__temp_v1203 Int)
(declare-const |var__temp_h'1204| T4658)
(declare-const var__temp_v_err1205 T4659)
(declare-const var_h1141 T4658)
(declare-const err T4672)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4658)
(declare-fun sel (T4658 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1141 () T4658)
(declare-fun |5| () Int)
(declare-fun var__temp_h1202 () T4658)
(declare-fun |var__temp_h'1204| () T4658)
(declare-fun var__temp_v1203 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1141 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1202 res) v) (= v |5|))
               (= (sel var__temp_h1202 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1204| res) var__temp_v1203)
                (= (sel |var__temp_h'1204| res) (+ (sel var__temp_h1202 res) 3)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1202 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************317
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1142 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1142, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1201:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1142 --->  Ty_heap  
 var_h1141 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1206 --->  Ty_heap  
 var__temp_v1207 --->  Ty_int  
 var__temp_h'1208 --->  Ty_heap  
 var__temp_v_err1209 --->  error  
 var_h1141 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1141, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1206, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1206, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1206, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1208, res ) ==(var__temp_v1207) AND 
 	 Rel (sel)( , var__temp_h'1208, res ) ==((sel)( , var__temp_h1206, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i1142 T4675)
(declare-const var_h1141 T4675)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1206 T4675)
(declare-const var__temp_v1207 Int)
(declare-const |var__temp_h'1208| T4675)
(declare-const var__temp_v_err1209 T4676)
(declare-const var_h1141 T4675)
(declare-const err T4689)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4675)
(declare-fun sel (T4675 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1141 () T4675)
(declare-fun |5| () Int)
(declare-fun var__temp_h1206 () T4675)
(declare-fun |var__temp_h'1208| () T4675)
(declare-fun var__temp_v1207 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1141 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1206 res) v) (= v |5|))
               (= (sel var__temp_h1206 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1208| res) var__temp_v1207)
                (= (sel |var__temp_h'1208| res) (+ (sel var__temp_h1206 res) 5)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1206 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************318
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1142 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1142, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1201:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1142 --->  Ty_heap  
 var_h1141 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1210 --->  Ty_heap  
 var__temp_v1211 --->  Ty_int  
 var__temp_h'1212 --->  Ty_heap  
 var__temp_v_err1213 --->  error  
 var_h1141 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1141, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1210, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1210, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1210, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1212, res ) ==(var__temp_v1211) AND 
 	 Rel (sel)( , var__temp_h'1212, res ) ==((sel)( , var__temp_h1210, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i1142 T4692)
(declare-const var_h1141 T4692)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1210 T4692)
(declare-const var__temp_v1211 Int)
(declare-const |var__temp_h'1212| T4692)
(declare-const var__temp_v_err1213 T4693)
(declare-const var_h1141 T4692)
(declare-const err T4706)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4692)
(declare-fun sel (T4692 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1141 () T4692)
(declare-fun |5| () Int)
(declare-fun var__temp_h1210 () T4692)
(declare-fun |var__temp_h'1212| () T4692)
(declare-fun var__temp_v1211 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1141 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1210 res) v) (= v |5|))
               (= (sel var__temp_h1210 res) 5)))
      (a!2 (and (= (sel |var__temp_h'1212| res) var__temp_v1211)
                (= (sel |var__temp_h'1212| res) (+ (sel var__temp_h1210 res) 2)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1210 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************bar
PARTIAL PATH NEW
NEW 	 --foo	 --bar
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1215 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1215 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1215, res ) ==(v)
 	 , (sel)( , var_h_i1215, res ) ==((sel)( , var_h1214, res ) + (2)) >c  } 
 } 
 
                                                RET :  Base {var_v1216:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1215 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************319
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1215 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1215, res ) ==(v)
 	 , (sel)( , var_h_i1215, res ) ==((sel)( , var_h1214, res ) + (2)) >c  } 
 } 
 
                                                RET :  Base {var_v1216:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1215 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1215 --->  Ty_heap  
 var_h1214 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1142 --->  Ty_heap  
 var_h1141 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1217 --->  Ty_heap  
 var__temp_v1218 --->  Ty_int  
 var__temp_h'1219 --->  Ty_heap  
 var__temp_v_err1220 --->  error  
 var_h1214 --->  Ty_heap  
 var_h1141 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1214, res ) ==(5) AND 
 	 Rel (sel)( , var_h1141, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1217, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1217, res ) ==((sel)( , var_h1214, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h1217, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1217, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1219, res ) ==(var__temp_v1218) AND 
 	 Rel (sel)( , var__temp_h'1219, res ) ==((sel)( , var__temp_h1217, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1219, res ) ==(var__temp_v1218) AND 
 	 Rel (sel)( , var__temp_h'1219, res ) ==(10)
 
VC_END(declare-const var_h_i1215 T4709)
(declare-const var_h1214 T4709)
(declare-const v Int)
(declare-const var_h_i1142 T4709)
(declare-const var_h1141 T4709)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1217 T4709)
(declare-const var__temp_v1218 Int)
(declare-const |var__temp_h'1219| T4709)
(declare-const var__temp_v_err1220 T4710)
(declare-const var_h1214 T4709)
(declare-const var_h1141 T4709)
(declare-const err T4723)

solver 
 (declare-sort T4709)
(declare-fun sel (T4709 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1214 () T4709)
(declare-fun var_h1141 () T4709)
(declare-fun |var__temp_h'1219| () T4709)
(declare-fun var__temp_v1218 () Int)
(declare-fun var__temp_h1217 () T4709)
(declare-fun v () Int)
(assert (= (sel var_h1214 res) 5))
(assert (= (sel var_h1141 res) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1217 res) v)
                (= (sel var__temp_h1217 res) (+ (sel var_h1214 res) 2))))
      (a!2 (and (= (sel |var__temp_h'1219| res) var__temp_v1218)
                (= (sel |var__temp_h'1219| res) (+ (sel var__temp_h1217 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'1219| res) var__temp_v1218)
                    (= (sel |var__temp_h'1219| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1217 res) 7))
                (=> (= (sel var__temp_h1217 res) 7) a!3))))
  (not a!4)))))

***************Selection Successful************bazSingle Component Enumeration Succeeded
Found e2 in (x <- e1 in e2)
{ 
Eret { 
Evar baz 
 } 
 }
Found e2 in (x <- e1 in e2)
{ 
Ebind Evar v <- { 
Eret { 
Evar bar 
 } 
 } in { 
Eret { 
Evar baz 
 } 
 } 
 }
ENUM ::baz::bar::c5::baz::bar::c5::baz::bar::c5::baz::c2::c5::baz::bar::c2::c5::baz::foo::c2::c5::baz::bar::foo::c5::baz::bar::foo::c5::baz::bar::foo::c5::baz::c2::c5::baz::bar::foo::c2::c5::baz::foo'::c2::c5::baz::bar::foo::c2::c5::baz::bar::foo::c5::baz::bar::foo::c5::baz::bar::foo::c5::baz::c2::c5::baz::bar::foo::c2::c5::baz::foo'::c2::c5::baz::bar::foo::foo'::c2::c5::baz::c2'::c5::baz::bar::foo::c2::c2'::c5::baz::bar::foo::c5::baz::bar::foo::c5::baz::bar::foo::c5::baz::c2::c5::baz::bar::foo::c2::c5::baz::bar::foo::c2::c5::baz::c2'::c5::baz::bar::foo::c2::c2'::c5::baz::foo'::c2::c2'::c5::baz::bar::foo::foo'::c2::c2'::c5::baz::c4::c5::baz::bar::foo::c2::c5::baz::bar::foo::c5::baz::bar::foo::c5::baz::bar::foo::c5::baz::c2::c5::baz::bar::foo::c2::c5::baz::foo'::c2::c5::baz::bar::foo::c2::c5::baz::bar::foo::c5::baz::bar::foo::c5::baz::bar::foo::c5::baz::c2::c5::baz::bar::foo::c2::c5::baz::foo'::c2::c5::baz::bar::foo::foo'::c2::c5::baz::c2'::c5::baz::bar::foo::c2::c2'::c5::baz::bar::foo::c5::baz::bar::foo::c5::baz::bar::foo::c5::baz::c2::c5::baz::bar::foo::c2::c5::baz::bar::foo::c2::c5::baz::c2'::c5::baz::bar::foo::c2::c2'::c5::baz::foo'::c2::c2'::c5::baz::bar::foo::foo'::c2::c2'::c5::baz::c4::c5::baz::bar::foo::foo'::c2::c2'::c4::c5::baz::c3'::bar::foo::foo'::c2::c2'::c4::c5::baz::c3'
SUB 
 	 --foo
 	 --bar
 	 --bar
 	 --fooSuccess : { 
Ebind Evar v <- { 
Eret { 
Evar foo 
 } 
 } in { 
Ebind Evar v <- { 
Eret { 
Evar bar 
 } 
 } in { 
Eret { 
Evar baz 
 } 
 } 
 } 
 }