
 specfile :: synth_tests/eff11.specres : int;
c1 : State  {\(h : heap). true} 
	v : { v : int |  [v=5]} 
	{\(h : heap), (v : int), (h' : heap). sel (h', res) == v /\ [v=5]};


c2 : State  {\(h : heap). sel (h, res) == 5} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == v 
		/\ sel (h', res) == sel (h, res) + 2};


c2' : State  {\(h : heap). sel (h, res) > 4} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == v 
		/\ sel (h', res) == sel (h, res) + 1};


c2'' : State  {\(h : heap). sel (h, res) > 5} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == v 
		/\ sel (h', res) == sel (h, res) + 5};




c4 : State  {\(h : heap). sel (h, res) == 7} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == v 
		/\ sel (h', res) == sel (h, res) + 5};



c5 : State  {\(h : heap). sel (h, res) == 7} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == v 
		/\ sel (h', res) == sel (h, res) + 5};


c3 : State  {\(h : heap). sel (h, res) == 7} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == v 
		/\ sel (h', res) == sel (h, res) + 3};

c3' : State  {\(h : heap). not (sel (h, res) > 8)} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == v 
		/\ sel (h', res) == sel (h, res) + 3};



goal : State  {\(h : heap). true} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == v 
		/\ sel (h', res) == 10};

var: res
whitespace colon
whitespace var: int
semicolon
var: c1
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace truercurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace lbrace
var: v
equalopint: 5
rbrace
rcurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace conjwhitespace lbrace
var: v
equalopint: 5
rbrace
rcurly
semicolon
var: c2
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 5
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 2
rcurly
semicolon
var: c2'
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace lessthanopwhitespace int: 4
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 1
rcurly
semicolon
var: c2''
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace lessthanopwhitespace int: 5
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 5
rcurly
semicolon
var: c4
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 7
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 5
rcurly
semicolon
var: c5
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 7
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 5
rcurly
semicolon
var: c3
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 7
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 3
rcurly
semicolon
var: c3'
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace notwhitespace lparen
var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace lessthanopwhitespace int: 8
rparen
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 3
rcurly
semicolon
var: goal
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace truercurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 10
rcurly
semicolon

 List of components availableHERE>>>HERE 2>>>HERE 3 >>>HERE 4>>>RelSpec {  SRs ;  PRs ;  TSs  
 Assume false
 name res : 
 params :
 Type Base {var_v0:Ty_int | true} 
 Assume false
 name c1 : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 ) 
 Assume false
 name c2 : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 ) 
 Assume false
 name c2' : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (1)) >c  } 
 } 
 ) 
 Assume false
 name c2'' : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 ) 
 Assume false
 name c4 : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 ) 
 Assume false
 name c5 : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 ) 
 Assume false
 name c3 : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 ) 
 Assume false
 name c3' : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (8) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 ) 
 Assume false
 name goal : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 );  Formulas  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
c3'
c3
c5
c4
c2''
c2'
c2
c1
 *********************Enumeration Iteration*****************0
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (8) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1 --->  Ty_heap  
 var__temp_v2 --->  Ty_int  
 var__temp_h'3 --->  Ty_heap  
 var__temp_v_err4 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 True => 
 	 Rel (sel)( , var__temp_h1, res ) > (8) AND 
 	 Rel (sel)( , var__temp_h1, res ) > (8) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3, res ) ==(var__temp_v2) AND 
 	 Rel (sel)( , var__temp_h'3, res ) ==((sel)( , var__temp_h1, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3, res ) ==(var__temp_v2) AND 
 	 Rel (sel)( , var__temp_h'3, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h1 T0)
(declare-const var__temp_v2 Int)
(declare-const |var__temp_h'3| T0)
(declare-const var__temp_v_err4 T1)
(declare-const err T14)

solver 
 (declare-sort T0)
(declare-fun sel (T0 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'3| () T0)
(declare-fun var__temp_v2 () Int)
(declare-fun var__temp_h1 () T0)
(assert true)
(assert (let ((a!1 (=> true (not (> (sel var__temp_h1 res) 8))))
      (a!2 (and (= (sel |var__temp_h'3| res) var__temp_v2)
                (= (sel |var__temp_h'3| res) (+ (sel var__temp_h1 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'3| res) var__temp_v2)
                    (= (sel |var__temp_h'3| res) 10)))))
(let ((a!4 (=> (not (> (sel var__temp_h1 res) 8)) a!3)))
  (not (and a!1 a!4))))))

***************Selection Failed************c3'
 *********************Enumeration Iteration*****************1
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h5 --->  Ty_heap  
 var__temp_v6 --->  Ty_int  
 var__temp_h'7 --->  Ty_heap  
 var__temp_v_err8 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 True => 
 	 Rel (sel)( , var__temp_h5, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h5, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'7, res ) ==(var__temp_v6) AND 
 	 Rel (sel)( , var__temp_h'7, res ) ==((sel)( , var__temp_h5, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'7, res ) ==(var__temp_v6) AND 
 	 Rel (sel)( , var__temp_h'7, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h5 T17)
(declare-const var__temp_v6 Int)
(declare-const |var__temp_h'7| T17)
(declare-const var__temp_v_err8 T18)
(declare-const err T31)

solver 
 (declare-sort T17)
(declare-fun sel (T17 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'7| () T17)
(declare-fun var__temp_v6 () Int)
(declare-fun var__temp_h5 () T17)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'7| res) var__temp_v6)
                (= (sel |var__temp_h'7| res) (+ (sel var__temp_h5 res) 3)))))
(let ((a!2 (=> a!1
               (and (= (sel |var__temp_h'7| res) var__temp_v6)
                    (= (sel |var__temp_h'7| res) 10)))))
(let ((a!3 (and (=> true (= (sel var__temp_h5 res) 7))
                (=> (= (sel var__temp_h5 res) 7) a!2))))
  (not a!3)))))

***************Selection Failed************c3
 *********************Enumeration Iteration*****************2
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h9 --->  Ty_heap  
 var__temp_v10 --->  Ty_int  
 var__temp_h'11 --->  Ty_heap  
 var__temp_v_err12 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 True => 
 	 Rel (sel)( , var__temp_h9, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h9, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'11, res ) ==(var__temp_v10) AND 
 	 Rel (sel)( , var__temp_h'11, res ) ==((sel)( , var__temp_h9, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'11, res ) ==(var__temp_v10) AND 
 	 Rel (sel)( , var__temp_h'11, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h9 T34)
(declare-const var__temp_v10 Int)
(declare-const |var__temp_h'11| T34)
(declare-const var__temp_v_err12 T35)
(declare-const err T48)

solver 
 (declare-sort T34)
(declare-fun sel (T34 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'11| () T34)
(declare-fun var__temp_v10 () Int)
(declare-fun var__temp_h9 () T34)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'11| res) var__temp_v10)
                (= (sel |var__temp_h'11| res) (+ (sel var__temp_h9 res) 5)))))
(let ((a!2 (=> a!1
               (and (= (sel |var__temp_h'11| res) var__temp_v10)
                    (= (sel |var__temp_h'11| res) 10)))))
(let ((a!3 (and (=> true (= (sel var__temp_h9 res) 7))
                (=> (= (sel var__temp_h9 res) 7) a!2))))
  (not a!3)))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************3
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h13 --->  Ty_heap  
 var__temp_v14 --->  Ty_int  
 var__temp_h'15 --->  Ty_heap  
 var__temp_v_err16 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 True => 
 	 Rel (sel)( , var__temp_h13, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h13, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'15, res ) ==(var__temp_v14) AND 
 	 Rel (sel)( , var__temp_h'15, res ) ==((sel)( , var__temp_h13, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'15, res ) ==(var__temp_v14) AND 
 	 Rel (sel)( , var__temp_h'15, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h13 T51)
(declare-const var__temp_v14 Int)
(declare-const |var__temp_h'15| T51)
(declare-const var__temp_v_err16 T52)
(declare-const err T65)

solver 
 (declare-sort T51)
(declare-fun sel (T51 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'15| () T51)
(declare-fun var__temp_v14 () Int)
(declare-fun var__temp_h13 () T51)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'15| res) var__temp_v14)
                (= (sel |var__temp_h'15| res) (+ (sel var__temp_h13 res) 5)))))
(let ((a!2 (=> a!1
               (and (= (sel |var__temp_h'15| res) var__temp_v14)
                    (= (sel |var__temp_h'15| res) 10)))))
(let ((a!3 (and (=> true (= (sel var__temp_h13 res) 7))
                (=> (= (sel var__temp_h13 res) 7) a!2))))
  (not a!3)))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************4
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h17 --->  Ty_heap  
 var__temp_v18 --->  Ty_int  
 var__temp_h'19 --->  Ty_heap  
 var__temp_v_err20 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 True => 
 	 Rel (sel)( , var__temp_h17, res ) > (5) AND 
 	 Rel (sel)( , var__temp_h17, res ) > (5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'19, res ) ==(var__temp_v18) AND 
 	 Rel (sel)( , var__temp_h'19, res ) ==((sel)( , var__temp_h17, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'19, res ) ==(var__temp_v18) AND 
 	 Rel (sel)( , var__temp_h'19, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h17 T68)
(declare-const var__temp_v18 Int)
(declare-const |var__temp_h'19| T68)
(declare-const var__temp_v_err20 T69)
(declare-const err T82)

solver 
 (declare-sort T68)
(declare-fun sel (T68 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'19| () T68)
(declare-fun var__temp_v18 () Int)
(declare-fun var__temp_h17 () T68)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'19| res) var__temp_v18)
                (= (sel |var__temp_h'19| res) (+ (sel var__temp_h17 res) 5)))))
(let ((a!2 (=> a!1
               (and (= (sel |var__temp_h'19| res) var__temp_v18)
                    (= (sel |var__temp_h'19| res) 10)))))
(let ((a!3 (and (=> true (> (sel var__temp_h17 res) 5))
                (=> (> (sel var__temp_h17 res) 5) a!2))))
  (not a!3)))))

***************Selection Failed************c2''
 *********************Enumeration Iteration*****************5
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (1)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (1)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h21 --->  Ty_heap  
 var__temp_v22 --->  Ty_int  
 var__temp_h'23 --->  Ty_heap  
 var__temp_v_err24 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 True => 
 	 Rel (sel)( , var__temp_h21, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h21, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'23, res ) ==(var__temp_v22) AND 
 	 Rel (sel)( , var__temp_h'23, res ) ==((sel)( , var__temp_h21, res ) + (1)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'23, res ) ==(var__temp_v22) AND 
 	 Rel (sel)( , var__temp_h'23, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h21 T85)
(declare-const var__temp_v22 Int)
(declare-const |var__temp_h'23| T85)
(declare-const var__temp_v_err24 T86)
(declare-const err T99)

solver 
 (declare-sort T85)
(declare-fun sel (T85 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'23| () T85)
(declare-fun var__temp_v22 () Int)
(declare-fun var__temp_h21 () T85)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'23| res) var__temp_v22)
                (= (sel |var__temp_h'23| res) (+ (sel var__temp_h21 res) 1)))))
(let ((a!2 (=> a!1
               (and (= (sel |var__temp_h'23| res) var__temp_v22)
                    (= (sel |var__temp_h'23| res) 10)))))
(let ((a!3 (and (=> true (> (sel var__temp_h21 res) 4))
                (=> (> (sel var__temp_h21 res) 4) a!2))))
  (not a!3)))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************6
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h25 --->  Ty_heap  
 var__temp_v26 --->  Ty_int  
 var__temp_h'27 --->  Ty_heap  
 var__temp_v_err28 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 True => 
 	 Rel (sel)( , var__temp_h25, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h25, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'27, res ) ==(var__temp_v26) AND 
 	 Rel (sel)( , var__temp_h'27, res ) ==((sel)( , var__temp_h25, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'27, res ) ==(var__temp_v26) AND 
 	 Rel (sel)( , var__temp_h'27, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h25 T102)
(declare-const var__temp_v26 Int)
(declare-const |var__temp_h'27| T102)
(declare-const var__temp_v_err28 T103)
(declare-const err T116)

solver 
 (declare-sort T102)
(declare-fun sel (T102 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'27| () T102)
(declare-fun var__temp_v26 () Int)
(declare-fun var__temp_h25 () T102)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'27| res) var__temp_v26)
                (= (sel |var__temp_h'27| res) (+ (sel var__temp_h25 res) 2)))))
(let ((a!2 (=> a!1
               (and (= (sel |var__temp_h'27| res) var__temp_v26)
                    (= (sel |var__temp_h'27| res) 10)))))
(let ((a!3 (and (=> true (= (sel var__temp_h25 res) 5))
                (=> (= (sel var__temp_h25 res) 5) a!2))))
  (not a!3)))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************7
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h29 --->  Ty_heap  
 var__temp_v30 --->  Ty_int  
 var__temp_h'31 --->  Ty_heap  
 var__temp_v_err32 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 True => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'31, res ) ==(var__temp_v30) AND 
 	 Base var__temp_v30 = 5 => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'31, res ) ==(var__temp_v30) AND 
 	 Rel (sel)( , var__temp_h'31, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h29 T119)
(declare-const var__temp_v30 Int)
(declare-const |var__temp_h'31| T119)
(declare-const var__temp_v_err32 T120)
(declare-const err T133)
    (declare-const |5| Int)
  
solver 
 (declare-sort T119)
(declare-fun |5| () Int)
(declare-fun sel (T119 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'31| () T119)
(declare-fun var__temp_v30 () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel |var__temp_h'31| res) var__temp_v30)
                    (= var__temp_v30 |5|))
               (and (= (sel |var__temp_h'31| res) var__temp_v30)
                    (= (sel |var__temp_h'31| res) 10)))))
  (not (and (=> true true) (=> true a!1)))))

***************Selection Failed************c1
 *********************Enumeration Iteration*****************8
 Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {v:Ty_int | true}
isynthesizeConstApp
Spec Base {v:Ty_int | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Terms
esynthesizeBind
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {var_v33:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c3'
c3
c5
c4
c2''
c2'
c2
c1
 *********************Enumeration Iteration*****************9
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (8) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {var_v33:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h34 --->  Ty_heap  
 var__temp_v35 --->  Ty_int  
 var__temp_h'36 --->  Ty_heap  
 var__temp_v_err37 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 True => 
 	 Rel (sel)( , var__temp_h34, res ) > (8) AND 
 	 Rel (sel)( , var__temp_h34, res ) > (8) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'36, res ) ==(var__temp_v35) AND 
 	 Rel (sel)( , var__temp_h'36, res ) ==((sel)( , var__temp_h34, res ) + (3)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h34 T136)
(declare-const var__temp_v35 Int)
(declare-const |var__temp_h'36| T136)
(declare-const var__temp_v_err37 T137)
(declare-const err T150)

solver 
 (declare-sort T136)
(declare-fun sel (T136 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h34 () T136)
(declare-fun |var__temp_h'36| () T136)
(declare-fun var__temp_v35 () Int)
(assert true)
(assert (let ((a!1 (=> true (not (> (sel var__temp_h34 res) 8))))
      (a!2 (and (= (sel |var__temp_h'36| res) var__temp_v35)
                (= (sel |var__temp_h'36| res) (+ (sel var__temp_h34 res) 3)))))
(let ((a!3 (=> (not (> (sel var__temp_h34 res) 8)) (=> a!2 true))))
  (not (and a!1 a!3)))))

***************Selection Failed************c3'
 *********************Enumeration Iteration*****************10
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {var_v33:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h38 --->  Ty_heap  
 var__temp_v39 --->  Ty_int  
 var__temp_h'40 --->  Ty_heap  
 var__temp_v_err41 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 True => 
 	 Rel (sel)( , var__temp_h38, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h38, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'40, res ) ==(var__temp_v39) AND 
 	 Rel (sel)( , var__temp_h'40, res ) ==((sel)( , var__temp_h38, res ) + (3)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h38 T153)
(declare-const var__temp_v39 Int)
(declare-const |var__temp_h'40| T153)
(declare-const var__temp_v_err41 T154)
(declare-const err T167)

solver 
 (declare-sort T153)
(declare-fun sel (T153 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h38 () T153)
(declare-fun |var__temp_h'40| () T153)
(declare-fun var__temp_v39 () Int)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'40| res) var__temp_v39)
                (= (sel |var__temp_h'40| res) (+ (sel var__temp_h38 res) 3)))))
(let ((a!2 (and (=> true (= (sel var__temp_h38 res) 7))
                (=> (= (sel var__temp_h38 res) 7) (=> a!1 true)))))
  (not a!2))))

***************Selection Failed************c3
 *********************Enumeration Iteration*****************11
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {var_v33:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h42 --->  Ty_heap  
 var__temp_v43 --->  Ty_int  
 var__temp_h'44 --->  Ty_heap  
 var__temp_v_err45 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 True => 
 	 Rel (sel)( , var__temp_h42, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h42, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'44, res ) ==(var__temp_v43) AND 
 	 Rel (sel)( , var__temp_h'44, res ) ==((sel)( , var__temp_h42, res ) + (5)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h42 T170)
(declare-const var__temp_v43 Int)
(declare-const |var__temp_h'44| T170)
(declare-const var__temp_v_err45 T171)
(declare-const err T184)

solver 
 (declare-sort T170)
(declare-fun sel (T170 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h42 () T170)
(declare-fun |var__temp_h'44| () T170)
(declare-fun var__temp_v43 () Int)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'44| res) var__temp_v43)
                (= (sel |var__temp_h'44| res) (+ (sel var__temp_h42 res) 5)))))
(let ((a!2 (and (=> true (= (sel var__temp_h42 res) 7))
                (=> (= (sel var__temp_h42 res) 7) (=> a!1 true)))))
  (not a!2))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************12
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {var_v33:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h46 --->  Ty_heap  
 var__temp_v47 --->  Ty_int  
 var__temp_h'48 --->  Ty_heap  
 var__temp_v_err49 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 True => 
 	 Rel (sel)( , var__temp_h46, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h46, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'48, res ) ==(var__temp_v47) AND 
 	 Rel (sel)( , var__temp_h'48, res ) ==((sel)( , var__temp_h46, res ) + (5)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h46 T187)
(declare-const var__temp_v47 Int)
(declare-const |var__temp_h'48| T187)
(declare-const var__temp_v_err49 T188)
(declare-const err T201)

solver 
 (declare-sort T187)
(declare-fun sel (T187 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h46 () T187)
(declare-fun |var__temp_h'48| () T187)
(declare-fun var__temp_v47 () Int)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'48| res) var__temp_v47)
                (= (sel |var__temp_h'48| res) (+ (sel var__temp_h46 res) 5)))))
(let ((a!2 (and (=> true (= (sel var__temp_h46 res) 7))
                (=> (= (sel var__temp_h46 res) 7) (=> a!1 true)))))
  (not a!2))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************13
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {var_v33:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h50 --->  Ty_heap  
 var__temp_v51 --->  Ty_int  
 var__temp_h'52 --->  Ty_heap  
 var__temp_v_err53 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 True => 
 	 Rel (sel)( , var__temp_h50, res ) > (5) AND 
 	 Rel (sel)( , var__temp_h50, res ) > (5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'52, res ) ==(var__temp_v51) AND 
 	 Rel (sel)( , var__temp_h'52, res ) ==((sel)( , var__temp_h50, res ) + (5)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h50 T204)
(declare-const var__temp_v51 Int)
(declare-const |var__temp_h'52| T204)
(declare-const var__temp_v_err53 T205)
(declare-const err T218)

solver 
 (declare-sort T204)
(declare-fun sel (T204 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h50 () T204)
(declare-fun |var__temp_h'52| () T204)
(declare-fun var__temp_v51 () Int)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'52| res) var__temp_v51)
                (= (sel |var__temp_h'52| res) (+ (sel var__temp_h50 res) 5)))))
(let ((a!2 (and (=> true (> (sel var__temp_h50 res) 5))
                (=> (> (sel var__temp_h50 res) 5) (=> a!1 true)))))
  (not a!2))))

***************Selection Failed************c2''
 *********************Enumeration Iteration*****************14
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (1)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {var_v33:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (1)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h54 --->  Ty_heap  
 var__temp_v55 --->  Ty_int  
 var__temp_h'56 --->  Ty_heap  
 var__temp_v_err57 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 True => 
 	 Rel (sel)( , var__temp_h54, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h54, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'56, res ) ==(var__temp_v55) AND 
 	 Rel (sel)( , var__temp_h'56, res ) ==((sel)( , var__temp_h54, res ) + (1)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h54 T221)
(declare-const var__temp_v55 Int)
(declare-const |var__temp_h'56| T221)
(declare-const var__temp_v_err57 T222)
(declare-const err T235)

solver 
 (declare-sort T221)
(declare-fun sel (T221 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h54 () T221)
(declare-fun |var__temp_h'56| () T221)
(declare-fun var__temp_v55 () Int)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'56| res) var__temp_v55)
                (= (sel |var__temp_h'56| res) (+ (sel var__temp_h54 res) 1)))))
(let ((a!2 (and (=> true (> (sel var__temp_h54 res) 4))
                (=> (> (sel var__temp_h54 res) 4) (=> a!1 true)))))
  (not a!2))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************15
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {var_v33:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h58 --->  Ty_heap  
 var__temp_v59 --->  Ty_int  
 var__temp_h'60 --->  Ty_heap  
 var__temp_v_err61 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 True => 
 	 Rel (sel)( , var__temp_h58, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h58, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'60, res ) ==(var__temp_v59) AND 
 	 Rel (sel)( , var__temp_h'60, res ) ==((sel)( , var__temp_h58, res ) + (2)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h58 T238)
(declare-const var__temp_v59 Int)
(declare-const |var__temp_h'60| T238)
(declare-const var__temp_v_err61 T239)
(declare-const err T252)

solver 
 (declare-sort T238)
(declare-fun sel (T238 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h58 () T238)
(declare-fun |var__temp_h'60| () T238)
(declare-fun var__temp_v59 () Int)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'60| res) var__temp_v59)
                (= (sel |var__temp_h'60| res) (+ (sel var__temp_h58 res) 2)))))
(let ((a!2 (and (=> true (= (sel var__temp_h58 res) 5))
                (=> (= (sel var__temp_h58 res) 5) (=> a!1 true)))))
  (not a!2))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************16
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {var_v33:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h62 --->  Ty_heap  
 var__temp_v63 --->  Ty_int  
 var__temp_h'64 --->  Ty_heap  
 var__temp_v_err65 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 True => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'64, res ) ==(var__temp_v63) AND 
 	 Base var__temp_v63 = 5 => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h62 T255)
(declare-const var__temp_v63 Int)
(declare-const |var__temp_h'64| T255)
(declare-const var__temp_v_err65 T256)
(declare-const err T269)
    (declare-const |5| Int)
  
solver 
 (declare-sort T255)
(declare-fun |5| () Int)
(declare-fun var__temp_v63 () Int)
(declare-fun sel (T255 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'64| () T255)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel |var__temp_h'64| res) var__temp_v63)
                    (= var__temp_v63 |5|))
               true)))
  (not (and (=> true true) (=> true a!1)))))

***************Selection Successful************c1
EXPLORED::BEFORETerms
EXPLORED::AFTERTermsc1
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i67 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i67 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i67, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v68:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i67 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
c3'
c3
c5
c4
c2''
c2'
c2
 *********************Enumeration Iteration*****************17
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (8) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i67 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i67, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v68:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i67 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h69 --->  Ty_heap  
 var__temp_v70 --->  Ty_int  
 var__temp_h'71 --->  Ty_heap  
 var__temp_v_err72 --->  error  
 var_h66 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h69, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h69, res ) > (8) AND 
 	 Rel (sel)( , var__temp_h69, res ) > (8) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'71, res ) ==(var__temp_v70) AND 
 	 Rel (sel)( , var__temp_h'71, res ) ==((sel)( , var__temp_h69, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'71, res ) ==(var__temp_v70) AND 
 	 Rel (sel)( , var__temp_h'71, res ) ==(10)
 
VC_END(declare-const var_h_i67 T272)
(declare-const var_h66 T272)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h69 T272)
(declare-const var__temp_v70 Int)
(declare-const |var__temp_h'71| T272)
(declare-const var__temp_v_err72 T273)
(declare-const var_h66 T272)
(declare-const err T286)
    (declare-const |5| Int)
  
solver 
 (declare-sort T272)
(declare-fun |5| () Int)
(declare-fun sel (T272 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'71| () T272)
(declare-fun var__temp_v70 () Int)
(declare-fun var__temp_h69 () T272)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h69 res) v) (= v |5|))
               (not (> (sel var__temp_h69 res) 8))))
      (a!2 (and (= (sel |var__temp_h'71| res) var__temp_v70)
                (= (sel |var__temp_h'71| res) (+ (sel var__temp_h69 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'71| res) var__temp_v70)
                    (= (sel |var__temp_h'71| res) 10)))))
(let ((a!4 (=> (not (> (sel var__temp_h69 res) 8)) a!3)))
  (not (and a!1 a!4))))))

***************Selection Failed************c3'
 *********************Enumeration Iteration*****************18
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i67 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i67, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v68:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i67 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h73 --->  Ty_heap  
 var__temp_v74 --->  Ty_int  
 var__temp_h'75 --->  Ty_heap  
 var__temp_v_err76 --->  error  
 var_h66 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h73, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h73, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h73, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'75, res ) ==(var__temp_v74) AND 
 	 Rel (sel)( , var__temp_h'75, res ) ==((sel)( , var__temp_h73, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'75, res ) ==(var__temp_v74) AND 
 	 Rel (sel)( , var__temp_h'75, res ) ==(10)
 
VC_END(declare-const var_h_i67 T289)
(declare-const var_h66 T289)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h73 T289)
(declare-const var__temp_v74 Int)
(declare-const |var__temp_h'75| T289)
(declare-const var__temp_v_err76 T290)
(declare-const var_h66 T289)
(declare-const err T303)
    (declare-const |5| Int)
  
solver 
 (declare-sort T289)
(declare-fun |5| () Int)
(declare-fun sel (T289 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'75| () T289)
(declare-fun var__temp_v74 () Int)
(declare-fun var__temp_h73 () T289)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h73 res) v) (= v |5|))
               (= (sel var__temp_h73 res) 7)))
      (a!2 (and (= (sel |var__temp_h'75| res) var__temp_v74)
                (= (sel |var__temp_h'75| res) (+ (sel var__temp_h73 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'75| res) var__temp_v74)
                    (= (sel |var__temp_h'75| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h73 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c3
 *********************Enumeration Iteration*****************19
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i67 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i67, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v68:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i67 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h77 --->  Ty_heap  
 var__temp_v78 --->  Ty_int  
 var__temp_h'79 --->  Ty_heap  
 var__temp_v_err80 --->  error  
 var_h66 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h77, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h77, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h77, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'79, res ) ==(var__temp_v78) AND 
 	 Rel (sel)( , var__temp_h'79, res ) ==((sel)( , var__temp_h77, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'79, res ) ==(var__temp_v78) AND 
 	 Rel (sel)( , var__temp_h'79, res ) ==(10)
 
VC_END(declare-const var_h_i67 T306)
(declare-const var_h66 T306)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h77 T306)
(declare-const var__temp_v78 Int)
(declare-const |var__temp_h'79| T306)
(declare-const var__temp_v_err80 T307)
(declare-const var_h66 T306)
(declare-const err T320)
    (declare-const |5| Int)
  
solver 
 (declare-sort T306)
(declare-fun |5| () Int)
(declare-fun sel (T306 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'79| () T306)
(declare-fun var__temp_v78 () Int)
(declare-fun var__temp_h77 () T306)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h77 res) v) (= v |5|))
               (= (sel var__temp_h77 res) 7)))
      (a!2 (and (= (sel |var__temp_h'79| res) var__temp_v78)
                (= (sel |var__temp_h'79| res) (+ (sel var__temp_h77 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'79| res) var__temp_v78)
                    (= (sel |var__temp_h'79| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h77 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************20
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i67 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i67, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v68:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i67 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h81 --->  Ty_heap  
 var__temp_v82 --->  Ty_int  
 var__temp_h'83 --->  Ty_heap  
 var__temp_v_err84 --->  error  
 var_h66 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h81, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h81, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h81, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'83, res ) ==(var__temp_v82) AND 
 	 Rel (sel)( , var__temp_h'83, res ) ==((sel)( , var__temp_h81, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'83, res ) ==(var__temp_v82) AND 
 	 Rel (sel)( , var__temp_h'83, res ) ==(10)
 
VC_END(declare-const var_h_i67 T323)
(declare-const var_h66 T323)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h81 T323)
(declare-const var__temp_v82 Int)
(declare-const |var__temp_h'83| T323)
(declare-const var__temp_v_err84 T324)
(declare-const var_h66 T323)
(declare-const err T337)
    (declare-const |5| Int)
  
solver 
 (declare-sort T323)
(declare-fun |5| () Int)
(declare-fun sel (T323 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'83| () T323)
(declare-fun var__temp_v82 () Int)
(declare-fun var__temp_h81 () T323)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h81 res) v) (= v |5|))
               (= (sel var__temp_h81 res) 7)))
      (a!2 (and (= (sel |var__temp_h'83| res) var__temp_v82)
                (= (sel |var__temp_h'83| res) (+ (sel var__temp_h81 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'83| res) var__temp_v82)
                    (= (sel |var__temp_h'83| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h81 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************21
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i67 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i67, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v68:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i67 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h85 --->  Ty_heap  
 var__temp_v86 --->  Ty_int  
 var__temp_h'87 --->  Ty_heap  
 var__temp_v_err88 --->  error  
 var_h66 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h85, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h85, res ) > (5) AND 
 	 Rel (sel)( , var__temp_h85, res ) > (5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'87, res ) ==(var__temp_v86) AND 
 	 Rel (sel)( , var__temp_h'87, res ) ==((sel)( , var__temp_h85, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'87, res ) ==(var__temp_v86) AND 
 	 Rel (sel)( , var__temp_h'87, res ) ==(10)
 
VC_END(declare-const var_h_i67 T340)
(declare-const var_h66 T340)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h85 T340)
(declare-const var__temp_v86 Int)
(declare-const |var__temp_h'87| T340)
(declare-const var__temp_v_err88 T341)
(declare-const var_h66 T340)
(declare-const err T354)
    (declare-const |5| Int)
  
solver 
 (declare-sort T340)
(declare-fun |5| () Int)
(declare-fun sel (T340 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'87| () T340)
(declare-fun var__temp_v86 () Int)
(declare-fun var__temp_h85 () T340)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h85 res) v) (= v |5|))
               (> (sel var__temp_h85 res) 5)))
      (a!2 (and (= (sel |var__temp_h'87| res) var__temp_v86)
                (= (sel |var__temp_h'87| res) (+ (sel var__temp_h85 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'87| res) var__temp_v86)
                    (= (sel |var__temp_h'87| res) 10)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h85 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************c2''
 *********************Enumeration Iteration*****************22
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (1)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i67 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i67, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v68:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i67 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (1)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h89 --->  Ty_heap  
 var__temp_v90 --->  Ty_int  
 var__temp_h'91 --->  Ty_heap  
 var__temp_v_err92 --->  error  
 var_h66 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h89, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h89, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h89, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'91, res ) ==(var__temp_v90) AND 
 	 Rel (sel)( , var__temp_h'91, res ) ==((sel)( , var__temp_h89, res ) + (1)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'91, res ) ==(var__temp_v90) AND 
 	 Rel (sel)( , var__temp_h'91, res ) ==(10)
 
VC_END(declare-const var_h_i67 T357)
(declare-const var_h66 T357)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h89 T357)
(declare-const var__temp_v90 Int)
(declare-const |var__temp_h'91| T357)
(declare-const var__temp_v_err92 T358)
(declare-const var_h66 T357)
(declare-const err T371)
    (declare-const |5| Int)
  
solver 
 (declare-sort T357)
(declare-fun |5| () Int)
(declare-fun sel (T357 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'91| () T357)
(declare-fun var__temp_v90 () Int)
(declare-fun var__temp_h89 () T357)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h89 res) v) (= v |5|))
               (> (sel var__temp_h89 res) 4)))
      (a!2 (and (= (sel |var__temp_h'91| res) var__temp_v90)
                (= (sel |var__temp_h'91| res) (+ (sel var__temp_h89 res) 1)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'91| res) var__temp_v90)
                    (= (sel |var__temp_h'91| res) 10)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h89 res) 4) a!3))))
  (not a!4)))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************23
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i67 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i67, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v68:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i67 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h93 --->  Ty_heap  
 var__temp_v94 --->  Ty_int  
 var__temp_h'95 --->  Ty_heap  
 var__temp_v_err96 --->  error  
 var_h66 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h93, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h93, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h93, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'95, res ) ==(var__temp_v94) AND 
 	 Rel (sel)( , var__temp_h'95, res ) ==((sel)( , var__temp_h93, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'95, res ) ==(var__temp_v94) AND 
 	 Rel (sel)( , var__temp_h'95, res ) ==(10)
 
VC_END(declare-const var_h_i67 T374)
(declare-const var_h66 T374)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h93 T374)
(declare-const var__temp_v94 Int)
(declare-const |var__temp_h'95| T374)
(declare-const var__temp_v_err96 T375)
(declare-const var_h66 T374)
(declare-const err T388)
    (declare-const |5| Int)
  
solver 
 (declare-sort T374)
(declare-fun |5| () Int)
(declare-fun sel (T374 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'95| () T374)
(declare-fun var__temp_v94 () Int)
(declare-fun var__temp_h93 () T374)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h93 res) v) (= v |5|))
               (= (sel var__temp_h93 res) 5)))
      (a!2 (and (= (sel |var__temp_h'95| res) var__temp_v94)
                (= (sel |var__temp_h'95| res) (+ (sel var__temp_h93 res) 2)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'95| res) var__temp_v94)
                    (= (sel |var__temp_h'95| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h93 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************24
 Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v68:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v68:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc1
esynthesizeBind
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i67 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i67, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v97:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c3'
c3
c5
c4
c2''
c2'
c2
 *********************Enumeration Iteration*****************25
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (8) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i67 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i67, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v97:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h98 --->  Ty_heap  
 var__temp_v99 --->  Ty_int  
 var__temp_h'100 --->  Ty_heap  
 var__temp_v_err101 --->  error  
 var_h66 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h98, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h98, res ) > (8) AND 
 	 Rel (sel)( , var__temp_h98, res ) > (8) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'100, res ) ==(var__temp_v99) AND 
 	 Rel (sel)( , var__temp_h'100, res ) ==((sel)( , var__temp_h98, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i67 T391)
(declare-const var_h66 T391)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h98 T391)
(declare-const var__temp_v99 Int)
(declare-const |var__temp_h'100| T391)
(declare-const var__temp_v_err101 T392)
(declare-const var_h66 T391)
(declare-const err T405)
    (declare-const |5| Int)
  
solver 
 (declare-sort T391)
(declare-fun |5| () Int)
(declare-fun sel (T391 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h98 () T391)
(declare-fun |var__temp_h'100| () T391)
(declare-fun var__temp_v99 () Int)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h98 res) v) (= v |5|))
               (not (> (sel var__temp_h98 res) 8))))
      (a!2 (and (= (sel |var__temp_h'100| res) var__temp_v99)
                (= (sel |var__temp_h'100| res) (+ (sel var__temp_h98 res) 3)))))
(let ((a!3 (=> (not (> (sel var__temp_h98 res) 8)) (=> a!2 true))))
  (not (and a!1 a!3)))))

***************Selection Successful************c3'
EXPLORED::BEFORETermsc1
EXPLORED::AFTERTermsc3'c1
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i103 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i103, res ) ==(v)
 	 , (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v104:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i103 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
c3
c5
c4
c2''
c2'
c2
 *********************Enumeration Iteration*****************26
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i103, res ) ==(v)
 	 , (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v104:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i103 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h105 --->  Ty_heap  
 var__temp_v106 --->  Ty_int  
 var__temp_h'107 --->  Ty_heap  
 var__temp_v_err108 --->  error  
 var_h102 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h102, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h105, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h105, res ) ==((sel)( , var_h102, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h105, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h105, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'107, res ) ==(var__temp_v106) AND 
 	 Rel (sel)( , var__temp_h'107, res ) ==((sel)( , var__temp_h105, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'107, res ) ==(var__temp_v106) AND 
 	 Rel (sel)( , var__temp_h'107, res ) ==(10)
 
VC_END(declare-const var_h_i103 T408)
(declare-const var_h102 T408)
(declare-const v Int)
(declare-const var_h_i67 T408)
(declare-const var_h66 T408)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h105 T408)
(declare-const var__temp_v106 Int)
(declare-const |var__temp_h'107| T408)
(declare-const var__temp_v_err108 T409)
(declare-const var_h102 T408)
(declare-const var_h66 T408)
(declare-const err T422)

solver 
 (declare-sort T408)
(declare-fun sel (T408 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T408)
(declare-fun |var__temp_h'107| () T408)
(declare-fun var__temp_v106 () Int)
(declare-fun var__temp_h105 () T408)
(declare-fun v () Int)
(assert (not (> (sel var_h102 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h105 res) v)
                (= (sel var__temp_h105 res) (+ (sel var_h102 res) 3))))
      (a!2 (and (= (sel |var__temp_h'107| res) var__temp_v106)
                (= (sel |var__temp_h'107| res) (+ (sel var__temp_h105 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'107| res) var__temp_v106)
                    (= (sel |var__temp_h'107| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h105 res) 7))
                (=> (= (sel var__temp_h105 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c3
 *********************Enumeration Iteration*****************27
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i103, res ) ==(v)
 	 , (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v104:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i103 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h109 --->  Ty_heap  
 var__temp_v110 --->  Ty_int  
 var__temp_h'111 --->  Ty_heap  
 var__temp_v_err112 --->  error  
 var_h102 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h102, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h109, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h109, res ) ==((sel)( , var_h102, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h109, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h109, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'111, res ) ==(var__temp_v110) AND 
 	 Rel (sel)( , var__temp_h'111, res ) ==((sel)( , var__temp_h109, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'111, res ) ==(var__temp_v110) AND 
 	 Rel (sel)( , var__temp_h'111, res ) ==(10)
 
VC_END(declare-const var_h_i103 T425)
(declare-const var_h102 T425)
(declare-const v Int)
(declare-const var_h_i67 T425)
(declare-const var_h66 T425)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h109 T425)
(declare-const var__temp_v110 Int)
(declare-const |var__temp_h'111| T425)
(declare-const var__temp_v_err112 T426)
(declare-const var_h102 T425)
(declare-const var_h66 T425)
(declare-const err T439)

solver 
 (declare-sort T425)
(declare-fun sel (T425 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T425)
(declare-fun |var__temp_h'111| () T425)
(declare-fun var__temp_v110 () Int)
(declare-fun var__temp_h109 () T425)
(declare-fun v () Int)
(assert (not (> (sel var_h102 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h109 res) v)
                (= (sel var__temp_h109 res) (+ (sel var_h102 res) 3))))
      (a!2 (and (= (sel |var__temp_h'111| res) var__temp_v110)
                (= (sel |var__temp_h'111| res) (+ (sel var__temp_h109 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'111| res) var__temp_v110)
                    (= (sel |var__temp_h'111| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h109 res) 7))
                (=> (= (sel var__temp_h109 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************28
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i103, res ) ==(v)
 	 , (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v104:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i103 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h113 --->  Ty_heap  
 var__temp_v114 --->  Ty_int  
 var__temp_h'115 --->  Ty_heap  
 var__temp_v_err116 --->  error  
 var_h102 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h102, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h113, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h113, res ) ==((sel)( , var_h102, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h113, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h113, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'115, res ) ==(var__temp_v114) AND 
 	 Rel (sel)( , var__temp_h'115, res ) ==((sel)( , var__temp_h113, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'115, res ) ==(var__temp_v114) AND 
 	 Rel (sel)( , var__temp_h'115, res ) ==(10)
 
VC_END(declare-const var_h_i103 T442)
(declare-const var_h102 T442)
(declare-const v Int)
(declare-const var_h_i67 T442)
(declare-const var_h66 T442)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h113 T442)
(declare-const var__temp_v114 Int)
(declare-const |var__temp_h'115| T442)
(declare-const var__temp_v_err116 T443)
(declare-const var_h102 T442)
(declare-const var_h66 T442)
(declare-const err T456)

solver 
 (declare-sort T442)
(declare-fun sel (T442 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T442)
(declare-fun |var__temp_h'115| () T442)
(declare-fun var__temp_v114 () Int)
(declare-fun var__temp_h113 () T442)
(declare-fun v () Int)
(assert (not (> (sel var_h102 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h113 res) v)
                (= (sel var__temp_h113 res) (+ (sel var_h102 res) 3))))
      (a!2 (and (= (sel |var__temp_h'115| res) var__temp_v114)
                (= (sel |var__temp_h'115| res) (+ (sel var__temp_h113 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'115| res) var__temp_v114)
                    (= (sel |var__temp_h'115| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h113 res) 7))
                (=> (= (sel var__temp_h113 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************29
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i103, res ) ==(v)
 	 , (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v104:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i103 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h117 --->  Ty_heap  
 var__temp_v118 --->  Ty_int  
 var__temp_h'119 --->  Ty_heap  
 var__temp_v_err120 --->  error  
 var_h102 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h102, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h117, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h117, res ) ==((sel)( , var_h102, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h117, res ) > (5) AND 
 	 Rel (sel)( , var__temp_h117, res ) > (5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'119, res ) ==(var__temp_v118) AND 
 	 Rel (sel)( , var__temp_h'119, res ) ==((sel)( , var__temp_h117, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'119, res ) ==(var__temp_v118) AND 
 	 Rel (sel)( , var__temp_h'119, res ) ==(10)
 
VC_END(declare-const var_h_i103 T459)
(declare-const var_h102 T459)
(declare-const v Int)
(declare-const var_h_i67 T459)
(declare-const var_h66 T459)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h117 T459)
(declare-const var__temp_v118 Int)
(declare-const |var__temp_h'119| T459)
(declare-const var__temp_v_err120 T460)
(declare-const var_h102 T459)
(declare-const var_h66 T459)
(declare-const err T473)

solver 
 (declare-sort T459)
(declare-fun sel (T459 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T459)
(declare-fun |var__temp_h'119| () T459)
(declare-fun var__temp_v118 () Int)
(declare-fun var__temp_h117 () T459)
(declare-fun v () Int)
(assert (not (> (sel var_h102 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h117 res) v)
                (= (sel var__temp_h117 res) (+ (sel var_h102 res) 3))))
      (a!2 (and (= (sel |var__temp_h'119| res) var__temp_v118)
                (= (sel |var__temp_h'119| res) (+ (sel var__temp_h117 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'119| res) var__temp_v118)
                    (= (sel |var__temp_h'119| res) 10)))))
(let ((a!4 (and (=> a!1 (> (sel var__temp_h117 res) 5))
                (=> (> (sel var__temp_h117 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************c2''
 *********************Enumeration Iteration*****************30
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (1)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i103, res ) ==(v)
 	 , (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v104:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i103 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (1)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h121 --->  Ty_heap  
 var__temp_v122 --->  Ty_int  
 var__temp_h'123 --->  Ty_heap  
 var__temp_v_err124 --->  error  
 var_h102 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h102, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h121, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h121, res ) ==((sel)( , var_h102, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h121, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h121, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'123, res ) ==(var__temp_v122) AND 
 	 Rel (sel)( , var__temp_h'123, res ) ==((sel)( , var__temp_h121, res ) + (1)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'123, res ) ==(var__temp_v122) AND 
 	 Rel (sel)( , var__temp_h'123, res ) ==(10)
 
VC_END(declare-const var_h_i103 T476)
(declare-const var_h102 T476)
(declare-const v Int)
(declare-const var_h_i67 T476)
(declare-const var_h66 T476)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h121 T476)
(declare-const var__temp_v122 Int)
(declare-const |var__temp_h'123| T476)
(declare-const var__temp_v_err124 T477)
(declare-const var_h102 T476)
(declare-const var_h66 T476)
(declare-const err T490)

solver 
 (declare-sort T476)
(declare-fun sel (T476 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T476)
(declare-fun |var__temp_h'123| () T476)
(declare-fun var__temp_v122 () Int)
(declare-fun var__temp_h121 () T476)
(declare-fun v () Int)
(assert (not (> (sel var_h102 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h121 res) v)
                (= (sel var__temp_h121 res) (+ (sel var_h102 res) 3))))
      (a!2 (and (= (sel |var__temp_h'123| res) var__temp_v122)
                (= (sel |var__temp_h'123| res) (+ (sel var__temp_h121 res) 1)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'123| res) var__temp_v122)
                    (= (sel |var__temp_h'123| res) 10)))))
(let ((a!4 (and (=> a!1 (> (sel var__temp_h121 res) 4))
                (=> (> (sel var__temp_h121 res) 4) a!3))))
  (not a!4)))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************31
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i103, res ) ==(v)
 	 , (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v104:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i103 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h125 --->  Ty_heap  
 var__temp_v126 --->  Ty_int  
 var__temp_h'127 --->  Ty_heap  
 var__temp_v_err128 --->  error  
 var_h102 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h102, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h125, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h125, res ) ==((sel)( , var_h102, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h125, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h125, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'127, res ) ==(var__temp_v126) AND 
 	 Rel (sel)( , var__temp_h'127, res ) ==((sel)( , var__temp_h125, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'127, res ) ==(var__temp_v126) AND 
 	 Rel (sel)( , var__temp_h'127, res ) ==(10)
 
VC_END(declare-const var_h_i103 T493)
(declare-const var_h102 T493)
(declare-const v Int)
(declare-const var_h_i67 T493)
(declare-const var_h66 T493)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h125 T493)
(declare-const var__temp_v126 Int)
(declare-const |var__temp_h'127| T493)
(declare-const var__temp_v_err128 T494)
(declare-const var_h102 T493)
(declare-const var_h66 T493)
(declare-const err T507)

solver 
 (declare-sort T493)
(declare-fun sel (T493 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T493)
(declare-fun |var__temp_h'127| () T493)
(declare-fun var__temp_v126 () Int)
(declare-fun var__temp_h125 () T493)
(declare-fun v () Int)
(assert (not (> (sel var_h102 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h125 res) v)
                (= (sel var__temp_h125 res) (+ (sel var_h102 res) 3))))
      (a!2 (and (= (sel |var__temp_h'127| res) var__temp_v126)
                (= (sel |var__temp_h'127| res) (+ (sel var__temp_h125 res) 2)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'127| res) var__temp_v126)
                    (= (sel |var__temp_h'127| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h125 res) 5))
                (=> (= (sel var__temp_h125 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************32
 Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v104:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v104:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc3'c1
esynthesizeBind
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i103, res ) ==(v)
 	 , (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v129:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c3
c5
c4
c2''
c2'
c2
 *********************Enumeration Iteration*****************33
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i103, res ) ==(v)
 	 , (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v129:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h130 --->  Ty_heap  
 var__temp_v131 --->  Ty_int  
 var__temp_h'132 --->  Ty_heap  
 var__temp_v_err133 --->  error  
 var_h102 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h102, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h130, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h130, res ) ==((sel)( , var_h102, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h130, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h130, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'132, res ) ==(var__temp_v131) AND 
 	 Rel (sel)( , var__temp_h'132, res ) ==((sel)( , var__temp_h130, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i103 T510)
(declare-const var_h102 T510)
(declare-const v Int)
(declare-const var_h_i67 T510)
(declare-const var_h66 T510)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h130 T510)
(declare-const var__temp_v131 Int)
(declare-const |var__temp_h'132| T510)
(declare-const var__temp_v_err133 T511)
(declare-const var_h102 T510)
(declare-const var_h66 T510)
(declare-const err T524)

solver 
 (declare-sort T510)
(declare-fun sel (T510 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T510)
(declare-fun var__temp_h130 () T510)
(declare-fun |var__temp_h'132| () T510)
(declare-fun var__temp_v131 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h102 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h130 res) v)
                (= (sel var__temp_h130 res) (+ (sel var_h102 res) 3))))
      (a!2 (and (= (sel |var__temp_h'132| res) var__temp_v131)
                (= (sel |var__temp_h'132| res) (+ (sel var__temp_h130 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h130 res) 7))
                (=> (= (sel var__temp_h130 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c3
 *********************Enumeration Iteration*****************34
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i103, res ) ==(v)
 	 , (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v129:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h134 --->  Ty_heap  
 var__temp_v135 --->  Ty_int  
 var__temp_h'136 --->  Ty_heap  
 var__temp_v_err137 --->  error  
 var_h102 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h102, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h134, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h134, res ) ==((sel)( , var_h102, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h134, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h134, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'136, res ) ==(var__temp_v135) AND 
 	 Rel (sel)( , var__temp_h'136, res ) ==((sel)( , var__temp_h134, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i103 T527)
(declare-const var_h102 T527)
(declare-const v Int)
(declare-const var_h_i67 T527)
(declare-const var_h66 T527)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h134 T527)
(declare-const var__temp_v135 Int)
(declare-const |var__temp_h'136| T527)
(declare-const var__temp_v_err137 T528)
(declare-const var_h102 T527)
(declare-const var_h66 T527)
(declare-const err T541)

solver 
 (declare-sort T527)
(declare-fun sel (T527 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T527)
(declare-fun var__temp_h134 () T527)
(declare-fun |var__temp_h'136| () T527)
(declare-fun var__temp_v135 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h102 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h134 res) v)
                (= (sel var__temp_h134 res) (+ (sel var_h102 res) 3))))
      (a!2 (and (= (sel |var__temp_h'136| res) var__temp_v135)
                (= (sel |var__temp_h'136| res) (+ (sel var__temp_h134 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h134 res) 7))
                (=> (= (sel var__temp_h134 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************35
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i103, res ) ==(v)
 	 , (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v129:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h138 --->  Ty_heap  
 var__temp_v139 --->  Ty_int  
 var__temp_h'140 --->  Ty_heap  
 var__temp_v_err141 --->  error  
 var_h102 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h102, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h138, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h138, res ) ==((sel)( , var_h102, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h138, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h138, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'140, res ) ==(var__temp_v139) AND 
 	 Rel (sel)( , var__temp_h'140, res ) ==((sel)( , var__temp_h138, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i103 T544)
(declare-const var_h102 T544)
(declare-const v Int)
(declare-const var_h_i67 T544)
(declare-const var_h66 T544)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h138 T544)
(declare-const var__temp_v139 Int)
(declare-const |var__temp_h'140| T544)
(declare-const var__temp_v_err141 T545)
(declare-const var_h102 T544)
(declare-const var_h66 T544)
(declare-const err T558)

solver 
 (declare-sort T544)
(declare-fun sel (T544 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T544)
(declare-fun var__temp_h138 () T544)
(declare-fun |var__temp_h'140| () T544)
(declare-fun var__temp_v139 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h102 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h138 res) v)
                (= (sel var__temp_h138 res) (+ (sel var_h102 res) 3))))
      (a!2 (and (= (sel |var__temp_h'140| res) var__temp_v139)
                (= (sel |var__temp_h'140| res) (+ (sel var__temp_h138 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h138 res) 7))
                (=> (= (sel var__temp_h138 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************36
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i103, res ) ==(v)
 	 , (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v129:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h142 --->  Ty_heap  
 var__temp_v143 --->  Ty_int  
 var__temp_h'144 --->  Ty_heap  
 var__temp_v_err145 --->  error  
 var_h102 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h102, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h142, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h142, res ) ==((sel)( , var_h102, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h142, res ) > (5) AND 
 	 Rel (sel)( , var__temp_h142, res ) > (5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'144, res ) ==(var__temp_v143) AND 
 	 Rel (sel)( , var__temp_h'144, res ) ==((sel)( , var__temp_h142, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i103 T561)
(declare-const var_h102 T561)
(declare-const v Int)
(declare-const var_h_i67 T561)
(declare-const var_h66 T561)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h142 T561)
(declare-const var__temp_v143 Int)
(declare-const |var__temp_h'144| T561)
(declare-const var__temp_v_err145 T562)
(declare-const var_h102 T561)
(declare-const var_h66 T561)
(declare-const err T575)

solver 
 (declare-sort T561)
(declare-fun sel (T561 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T561)
(declare-fun var__temp_h142 () T561)
(declare-fun |var__temp_h'144| () T561)
(declare-fun var__temp_v143 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h102 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h142 res) v)
                (= (sel var__temp_h142 res) (+ (sel var_h102 res) 3))))
      (a!2 (and (= (sel |var__temp_h'144| res) var__temp_v143)
                (= (sel |var__temp_h'144| res) (+ (sel var__temp_h142 res) 5)))))
(let ((a!3 (and (=> a!1 (> (sel var__temp_h142 res) 5))
                (=> (> (sel var__temp_h142 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2''
 *********************Enumeration Iteration*****************37
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (1)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i103, res ) ==(v)
 	 , (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v129:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (1)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h146 --->  Ty_heap  
 var__temp_v147 --->  Ty_int  
 var__temp_h'148 --->  Ty_heap  
 var__temp_v_err149 --->  error  
 var_h102 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h102, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h146, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h146, res ) ==((sel)( , var_h102, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h146, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h146, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'148, res ) ==(var__temp_v147) AND 
 	 Rel (sel)( , var__temp_h'148, res ) ==((sel)( , var__temp_h146, res ) + (1)) => 
 	 True
 
VC_END(declare-const var_h_i103 T578)
(declare-const var_h102 T578)
(declare-const v Int)
(declare-const var_h_i67 T578)
(declare-const var_h66 T578)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h146 T578)
(declare-const var__temp_v147 Int)
(declare-const |var__temp_h'148| T578)
(declare-const var__temp_v_err149 T579)
(declare-const var_h102 T578)
(declare-const var_h66 T578)
(declare-const err T592)

solver 
 (declare-sort T578)
(declare-fun sel (T578 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T578)
(declare-fun var__temp_h146 () T578)
(declare-fun |var__temp_h'148| () T578)
(declare-fun var__temp_v147 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h102 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h146 res) v)
                (= (sel var__temp_h146 res) (+ (sel var_h102 res) 3))))
      (a!2 (and (= (sel |var__temp_h'148| res) var__temp_v147)
                (= (sel |var__temp_h'148| res) (+ (sel var__temp_h146 res) 1)))))
(let ((a!3 (and (=> a!1 (> (sel var__temp_h146 res) 4))
                (=> (> (sel var__temp_h146 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************38
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i103, res ) ==(v)
 	 , (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v129:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h150 --->  Ty_heap  
 var__temp_v151 --->  Ty_int  
 var__temp_h'152 --->  Ty_heap  
 var__temp_v_err153 --->  error  
 var_h102 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h102, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h150, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h150, res ) ==((sel)( , var_h102, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h150, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h150, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'152, res ) ==(var__temp_v151) AND 
 	 Rel (sel)( , var__temp_h'152, res ) ==((sel)( , var__temp_h150, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i103 T595)
(declare-const var_h102 T595)
(declare-const v Int)
(declare-const var_h_i67 T595)
(declare-const var_h66 T595)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h150 T595)
(declare-const var__temp_v151 Int)
(declare-const |var__temp_h'152| T595)
(declare-const var__temp_v_err153 T596)
(declare-const var_h102 T595)
(declare-const var_h66 T595)
(declare-const err T609)

solver 
 (declare-sort T595)
(declare-fun sel (T595 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T595)
(declare-fun var__temp_h150 () T595)
(declare-fun |var__temp_h'152| () T595)
(declare-fun var__temp_v151 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h102 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h150 res) v)
                (= (sel var__temp_h150 res) (+ (sel var_h102 res) 3))))
      (a!2 (and (= (sel |var__temp_h'152| res) var__temp_v151)
                (= (sel |var__temp_h'152| res) (+ (sel var__temp_h150 res) 2)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h150 res) 5))
                (=> (= (sel var__temp_h150 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************39
First component finding failed
EXPLORED2 Termsc3'c1
esynthesizeBind
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i103, res ) ==(v)
 	 , (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v154:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c3
c5
c4
c2''
c2'
c2
 *********************Enumeration Iteration*****************40
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i103, res ) ==(v)
 	 , (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v154:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h155 --->  Ty_heap  
 var__temp_v156 --->  Ty_int  
 var__temp_h'157 --->  Ty_heap  
 var__temp_v_err158 --->  error  
 var_h102 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h102, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h155, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h155, res ) ==((sel)( , var_h102, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h155, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h155, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'157, res ) ==(var__temp_v156) AND 
 	 Rel (sel)( , var__temp_h'157, res ) ==((sel)( , var__temp_h155, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i103 T612)
(declare-const var_h102 T612)
(declare-const v Int)
(declare-const var_h_i67 T612)
(declare-const var_h66 T612)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h155 T612)
(declare-const var__temp_v156 Int)
(declare-const |var__temp_h'157| T612)
(declare-const var__temp_v_err158 T613)
(declare-const var_h102 T612)
(declare-const var_h66 T612)
(declare-const err T626)

solver 
 (declare-sort T612)
(declare-fun sel (T612 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T612)
(declare-fun var__temp_h155 () T612)
(declare-fun |var__temp_h'157| () T612)
(declare-fun var__temp_v156 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h102 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h155 res) v)
                (= (sel var__temp_h155 res) (+ (sel var_h102 res) 3))))
      (a!2 (and (= (sel |var__temp_h'157| res) var__temp_v156)
                (= (sel |var__temp_h'157| res) (+ (sel var__temp_h155 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h155 res) 7))
                (=> (= (sel var__temp_h155 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c3
 *********************Enumeration Iteration*****************41
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i103, res ) ==(v)
 	 , (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v154:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h159 --->  Ty_heap  
 var__temp_v160 --->  Ty_int  
 var__temp_h'161 --->  Ty_heap  
 var__temp_v_err162 --->  error  
 var_h102 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h102, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h159, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h159, res ) ==((sel)( , var_h102, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h159, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h159, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'161, res ) ==(var__temp_v160) AND 
 	 Rel (sel)( , var__temp_h'161, res ) ==((sel)( , var__temp_h159, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i103 T629)
(declare-const var_h102 T629)
(declare-const v Int)
(declare-const var_h_i67 T629)
(declare-const var_h66 T629)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h159 T629)
(declare-const var__temp_v160 Int)
(declare-const |var__temp_h'161| T629)
(declare-const var__temp_v_err162 T630)
(declare-const var_h102 T629)
(declare-const var_h66 T629)
(declare-const err T643)

solver 
 (declare-sort T629)
(declare-fun sel (T629 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T629)
(declare-fun var__temp_h159 () T629)
(declare-fun |var__temp_h'161| () T629)
(declare-fun var__temp_v160 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h102 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h159 res) v)
                (= (sel var__temp_h159 res) (+ (sel var_h102 res) 3))))
      (a!2 (and (= (sel |var__temp_h'161| res) var__temp_v160)
                (= (sel |var__temp_h'161| res) (+ (sel var__temp_h159 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h159 res) 7))
                (=> (= (sel var__temp_h159 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************42
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i103, res ) ==(v)
 	 , (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v154:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h163 --->  Ty_heap  
 var__temp_v164 --->  Ty_int  
 var__temp_h'165 --->  Ty_heap  
 var__temp_v_err166 --->  error  
 var_h102 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h102, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h163, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h163, res ) ==((sel)( , var_h102, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h163, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h163, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'165, res ) ==(var__temp_v164) AND 
 	 Rel (sel)( , var__temp_h'165, res ) ==((sel)( , var__temp_h163, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i103 T646)
(declare-const var_h102 T646)
(declare-const v Int)
(declare-const var_h_i67 T646)
(declare-const var_h66 T646)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h163 T646)
(declare-const var__temp_v164 Int)
(declare-const |var__temp_h'165| T646)
(declare-const var__temp_v_err166 T647)
(declare-const var_h102 T646)
(declare-const var_h66 T646)
(declare-const err T660)

solver 
 (declare-sort T646)
(declare-fun sel (T646 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T646)
(declare-fun var__temp_h163 () T646)
(declare-fun |var__temp_h'165| () T646)
(declare-fun var__temp_v164 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h102 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h163 res) v)
                (= (sel var__temp_h163 res) (+ (sel var_h102 res) 3))))
      (a!2 (and (= (sel |var__temp_h'165| res) var__temp_v164)
                (= (sel |var__temp_h'165| res) (+ (sel var__temp_h163 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h163 res) 7))
                (=> (= (sel var__temp_h163 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************43
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i103, res ) ==(v)
 	 , (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v154:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h167 --->  Ty_heap  
 var__temp_v168 --->  Ty_int  
 var__temp_h'169 --->  Ty_heap  
 var__temp_v_err170 --->  error  
 var_h102 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h102, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h167, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h167, res ) ==((sel)( , var_h102, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h167, res ) > (5) AND 
 	 Rel (sel)( , var__temp_h167, res ) > (5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'169, res ) ==(var__temp_v168) AND 
 	 Rel (sel)( , var__temp_h'169, res ) ==((sel)( , var__temp_h167, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i103 T663)
(declare-const var_h102 T663)
(declare-const v Int)
(declare-const var_h_i67 T663)
(declare-const var_h66 T663)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h167 T663)
(declare-const var__temp_v168 Int)
(declare-const |var__temp_h'169| T663)
(declare-const var__temp_v_err170 T664)
(declare-const var_h102 T663)
(declare-const var_h66 T663)
(declare-const err T677)

solver 
 (declare-sort T663)
(declare-fun sel (T663 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T663)
(declare-fun var__temp_h167 () T663)
(declare-fun |var__temp_h'169| () T663)
(declare-fun var__temp_v168 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h102 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h167 res) v)
                (= (sel var__temp_h167 res) (+ (sel var_h102 res) 3))))
      (a!2 (and (= (sel |var__temp_h'169| res) var__temp_v168)
                (= (sel |var__temp_h'169| res) (+ (sel var__temp_h167 res) 5)))))
(let ((a!3 (and (=> a!1 (> (sel var__temp_h167 res) 5))
                (=> (> (sel var__temp_h167 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2''
 *********************Enumeration Iteration*****************44
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (1)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i103, res ) ==(v)
 	 , (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v154:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (1)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h171 --->  Ty_heap  
 var__temp_v172 --->  Ty_int  
 var__temp_h'173 --->  Ty_heap  
 var__temp_v_err174 --->  error  
 var_h102 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h102, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h171, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h171, res ) ==((sel)( , var_h102, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h171, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h171, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'173, res ) ==(var__temp_v172) AND 
 	 Rel (sel)( , var__temp_h'173, res ) ==((sel)( , var__temp_h171, res ) + (1)) => 
 	 True
 
VC_END(declare-const var_h_i103 T680)
(declare-const var_h102 T680)
(declare-const v Int)
(declare-const var_h_i67 T680)
(declare-const var_h66 T680)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h171 T680)
(declare-const var__temp_v172 Int)
(declare-const |var__temp_h'173| T680)
(declare-const var__temp_v_err174 T681)
(declare-const var_h102 T680)
(declare-const var_h66 T680)
(declare-const err T694)

solver 
 (declare-sort T680)
(declare-fun sel (T680 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T680)
(declare-fun var__temp_h171 () T680)
(declare-fun |var__temp_h'173| () T680)
(declare-fun var__temp_v172 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h102 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h171 res) v)
                (= (sel var__temp_h171 res) (+ (sel var_h102 res) 3))))
      (a!2 (and (= (sel |var__temp_h'173| res) var__temp_v172)
                (= (sel |var__temp_h'173| res) (+ (sel var__temp_h171 res) 1)))))
(let ((a!3 (and (=> a!1 (> (sel var__temp_h171 res) 4))
                (=> (> (sel var__temp_h171 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************45
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i103, res ) ==(v)
 	 , (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v154:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h175 --->  Ty_heap  
 var__temp_v176 --->  Ty_int  
 var__temp_h'177 --->  Ty_heap  
 var__temp_v_err178 --->  error  
 var_h102 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h102, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h175, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h175, res ) ==((sel)( , var_h102, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h175, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h175, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'177, res ) ==(var__temp_v176) AND 
 	 Rel (sel)( , var__temp_h'177, res ) ==((sel)( , var__temp_h175, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i103 T697)
(declare-const var_h102 T697)
(declare-const v Int)
(declare-const var_h_i67 T697)
(declare-const var_h66 T697)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h175 T697)
(declare-const var__temp_v176 Int)
(declare-const |var__temp_h'177| T697)
(declare-const var__temp_v_err178 T698)
(declare-const var_h102 T697)
(declare-const var_h66 T697)
(declare-const err T711)

solver 
 (declare-sort T697)
(declare-fun sel (T697 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T697)
(declare-fun var__temp_h175 () T697)
(declare-fun |var__temp_h'177| () T697)
(declare-fun var__temp_v176 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h102 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h175 res) v)
                (= (sel var__temp_h175 res) (+ (sel var_h102 res) 3))))
      (a!2 (and (= (sel |var__temp_h'177| res) var__temp_v176)
                (= (sel |var__temp_h'177| res) (+ (sel var__temp_h175 res) 2)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h175 res) 5))
                (=> (= (sel var__temp_h175 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************46
First component finding failed
{ 
Eret { 
Evar c3' 
 } 
 }
@HERE
EXPLORED::BEFORETermsc3'c1
EXPLORED::AFTERTermsc3'c3'c1
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i103, res ) ==(v)
 	 , (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v179:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c3
c5
c4
c2''
c2'
c2
 *********************Enumeration Iteration*****************47
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i103, res ) ==(v)
 	 , (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v179:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h180 --->  Ty_heap  
 var__temp_v181 --->  Ty_int  
 var__temp_h'182 --->  Ty_heap  
 var__temp_v_err183 --->  error  
 var_h102 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h102, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h180, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h180, res ) ==((sel)( , var_h102, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h180, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h180, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'182, res ) ==(var__temp_v181) AND 
 	 Rel (sel)( , var__temp_h'182, res ) ==((sel)( , var__temp_h180, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i103 T714)
(declare-const var_h102 T714)
(declare-const v Int)
(declare-const var_h_i67 T714)
(declare-const var_h66 T714)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h180 T714)
(declare-const var__temp_v181 Int)
(declare-const |var__temp_h'182| T714)
(declare-const var__temp_v_err183 T715)
(declare-const var_h102 T714)
(declare-const var_h66 T714)
(declare-const err T728)

solver 
 (declare-sort T714)
(declare-fun sel (T714 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T714)
(declare-fun var__temp_h180 () T714)
(declare-fun |var__temp_h'182| () T714)
(declare-fun var__temp_v181 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h102 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h180 res) v)
                (= (sel var__temp_h180 res) (+ (sel var_h102 res) 3))))
      (a!2 (and (= (sel |var__temp_h'182| res) var__temp_v181)
                (= (sel |var__temp_h'182| res) (+ (sel var__temp_h180 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h180 res) 7))
                (=> (= (sel var__temp_h180 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c3
 *********************Enumeration Iteration*****************48
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i103, res ) ==(v)
 	 , (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v179:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h184 --->  Ty_heap  
 var__temp_v185 --->  Ty_int  
 var__temp_h'186 --->  Ty_heap  
 var__temp_v_err187 --->  error  
 var_h102 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h102, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h184, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h184, res ) ==((sel)( , var_h102, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h184, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h184, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'186, res ) ==(var__temp_v185) AND 
 	 Rel (sel)( , var__temp_h'186, res ) ==((sel)( , var__temp_h184, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i103 T731)
(declare-const var_h102 T731)
(declare-const v Int)
(declare-const var_h_i67 T731)
(declare-const var_h66 T731)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h184 T731)
(declare-const var__temp_v185 Int)
(declare-const |var__temp_h'186| T731)
(declare-const var__temp_v_err187 T732)
(declare-const var_h102 T731)
(declare-const var_h66 T731)
(declare-const err T745)

solver 
 (declare-sort T731)
(declare-fun sel (T731 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T731)
(declare-fun var__temp_h184 () T731)
(declare-fun |var__temp_h'186| () T731)
(declare-fun var__temp_v185 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h102 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h184 res) v)
                (= (sel var__temp_h184 res) (+ (sel var_h102 res) 3))))
      (a!2 (and (= (sel |var__temp_h'186| res) var__temp_v185)
                (= (sel |var__temp_h'186| res) (+ (sel var__temp_h184 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h184 res) 7))
                (=> (= (sel var__temp_h184 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************49
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i103, res ) ==(v)
 	 , (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v179:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h188 --->  Ty_heap  
 var__temp_v189 --->  Ty_int  
 var__temp_h'190 --->  Ty_heap  
 var__temp_v_err191 --->  error  
 var_h102 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h102, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h188, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h188, res ) ==((sel)( , var_h102, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h188, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h188, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'190, res ) ==(var__temp_v189) AND 
 	 Rel (sel)( , var__temp_h'190, res ) ==((sel)( , var__temp_h188, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i103 T748)
(declare-const var_h102 T748)
(declare-const v Int)
(declare-const var_h_i67 T748)
(declare-const var_h66 T748)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h188 T748)
(declare-const var__temp_v189 Int)
(declare-const |var__temp_h'190| T748)
(declare-const var__temp_v_err191 T749)
(declare-const var_h102 T748)
(declare-const var_h66 T748)
(declare-const err T762)

solver 
 (declare-sort T748)
(declare-fun sel (T748 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T748)
(declare-fun var__temp_h188 () T748)
(declare-fun |var__temp_h'190| () T748)
(declare-fun var__temp_v189 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h102 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h188 res) v)
                (= (sel var__temp_h188 res) (+ (sel var_h102 res) 3))))
      (a!2 (and (= (sel |var__temp_h'190| res) var__temp_v189)
                (= (sel |var__temp_h'190| res) (+ (sel var__temp_h188 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h188 res) 7))
                (=> (= (sel var__temp_h188 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************50
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i103, res ) ==(v)
 	 , (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v179:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h192 --->  Ty_heap  
 var__temp_v193 --->  Ty_int  
 var__temp_h'194 --->  Ty_heap  
 var__temp_v_err195 --->  error  
 var_h102 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h102, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h192, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h192, res ) ==((sel)( , var_h102, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h192, res ) > (5) AND 
 	 Rel (sel)( , var__temp_h192, res ) > (5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'194, res ) ==(var__temp_v193) AND 
 	 Rel (sel)( , var__temp_h'194, res ) ==((sel)( , var__temp_h192, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i103 T765)
(declare-const var_h102 T765)
(declare-const v Int)
(declare-const var_h_i67 T765)
(declare-const var_h66 T765)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h192 T765)
(declare-const var__temp_v193 Int)
(declare-const |var__temp_h'194| T765)
(declare-const var__temp_v_err195 T766)
(declare-const var_h102 T765)
(declare-const var_h66 T765)
(declare-const err T779)

solver 
 (declare-sort T765)
(declare-fun sel (T765 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T765)
(declare-fun var__temp_h192 () T765)
(declare-fun |var__temp_h'194| () T765)
(declare-fun var__temp_v193 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h102 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h192 res) v)
                (= (sel var__temp_h192 res) (+ (sel var_h102 res) 3))))
      (a!2 (and (= (sel |var__temp_h'194| res) var__temp_v193)
                (= (sel |var__temp_h'194| res) (+ (sel var__temp_h192 res) 5)))))
(let ((a!3 (and (=> a!1 (> (sel var__temp_h192 res) 5))
                (=> (> (sel var__temp_h192 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2''
 *********************Enumeration Iteration*****************51
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (1)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i103, res ) ==(v)
 	 , (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v179:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (1)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h196 --->  Ty_heap  
 var__temp_v197 --->  Ty_int  
 var__temp_h'198 --->  Ty_heap  
 var__temp_v_err199 --->  error  
 var_h102 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h102, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h196, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h196, res ) ==((sel)( , var_h102, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h196, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h196, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'198, res ) ==(var__temp_v197) AND 
 	 Rel (sel)( , var__temp_h'198, res ) ==((sel)( , var__temp_h196, res ) + (1)) => 
 	 True
 
VC_END(declare-const var_h_i103 T782)
(declare-const var_h102 T782)
(declare-const v Int)
(declare-const var_h_i67 T782)
(declare-const var_h66 T782)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h196 T782)
(declare-const var__temp_v197 Int)
(declare-const |var__temp_h'198| T782)
(declare-const var__temp_v_err199 T783)
(declare-const var_h102 T782)
(declare-const var_h66 T782)
(declare-const err T796)

solver 
 (declare-sort T782)
(declare-fun sel (T782 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T782)
(declare-fun var__temp_h196 () T782)
(declare-fun |var__temp_h'198| () T782)
(declare-fun var__temp_v197 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h102 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h196 res) v)
                (= (sel var__temp_h196 res) (+ (sel var_h102 res) 3))))
      (a!2 (and (= (sel |var__temp_h'198| res) var__temp_v197)
                (= (sel |var__temp_h'198| res) (+ (sel var__temp_h196 res) 1)))))
(let ((a!3 (and (=> a!1 (> (sel var__temp_h196 res) 4))
                (=> (> (sel var__temp_h196 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************52
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i103 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i103, res ) ==(v)
 	 , (sel)( , var_h_i103, res ) ==((sel)( , var_h102, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v179:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i103 --->  Ty_heap  
 var_h102 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h200 --->  Ty_heap  
 var__temp_v201 --->  Ty_int  
 var__temp_h'202 --->  Ty_heap  
 var__temp_v_err203 --->  error  
 var_h102 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h102, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h200, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h200, res ) ==((sel)( , var_h102, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h200, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h200, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'202, res ) ==(var__temp_v201) AND 
 	 Rel (sel)( , var__temp_h'202, res ) ==((sel)( , var__temp_h200, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i103 T799)
(declare-const var_h102 T799)
(declare-const v Int)
(declare-const var_h_i67 T799)
(declare-const var_h66 T799)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h200 T799)
(declare-const var__temp_v201 Int)
(declare-const |var__temp_h'202| T799)
(declare-const var__temp_v_err203 T800)
(declare-const var_h102 T799)
(declare-const var_h66 T799)
(declare-const err T813)

solver 
 (declare-sort T799)
(declare-fun sel (T799 Int) Int)
(declare-fun res () Int)
(declare-fun var_h102 () T799)
(declare-fun var__temp_h200 () T799)
(declare-fun |var__temp_h'202| () T799)
(declare-fun var__temp_v201 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h102 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h200 res) v)
                (= (sel var__temp_h200 res) (+ (sel var_h102 res) 3))))
      (a!2 (and (= (sel |var__temp_h'202| res) var__temp_v201)
                (= (sel |var__temp_h'202| res) (+ (sel var__temp_h200 res) 2)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h200 res) 5))
                (=> (= (sel var__temp_h200 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************53
First component finding failed
EXPLORED2 Termsc3'c3'c1
esynthesizeBind
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i67 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i67, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v204:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c3
c5
c4
c2''
c2'
c2
 *********************Enumeration Iteration*****************54
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i67 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i67, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v204:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h205 --->  Ty_heap  
 var__temp_v206 --->  Ty_int  
 var__temp_h'207 --->  Ty_heap  
 var__temp_v_err208 --->  error  
 var_h66 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h205, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h205, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h205, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'207, res ) ==(var__temp_v206) AND 
 	 Rel (sel)( , var__temp_h'207, res ) ==((sel)( , var__temp_h205, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i67 T816)
(declare-const var_h66 T816)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h205 T816)
(declare-const var__temp_v206 Int)
(declare-const |var__temp_h'207| T816)
(declare-const var__temp_v_err208 T817)
(declare-const var_h66 T816)
(declare-const err T830)
    (declare-const |5| Int)
  
solver 
 (declare-sort T816)
(declare-fun |5| () Int)
(declare-fun sel (T816 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h205 () T816)
(declare-fun |var__temp_h'207| () T816)
(declare-fun var__temp_v206 () Int)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h205 res) v) (= v |5|))
               (= (sel var__temp_h205 res) 7)))
      (a!2 (and (= (sel |var__temp_h'207| res) var__temp_v206)
                (= (sel |var__temp_h'207| res) (+ (sel var__temp_h205 res) 3)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h205 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c3
 *********************Enumeration Iteration*****************55
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i67 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i67, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v204:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h209 --->  Ty_heap  
 var__temp_v210 --->  Ty_int  
 var__temp_h'211 --->  Ty_heap  
 var__temp_v_err212 --->  error  
 var_h66 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h209, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h209, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h209, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'211, res ) ==(var__temp_v210) AND 
 	 Rel (sel)( , var__temp_h'211, res ) ==((sel)( , var__temp_h209, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i67 T833)
(declare-const var_h66 T833)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h209 T833)
(declare-const var__temp_v210 Int)
(declare-const |var__temp_h'211| T833)
(declare-const var__temp_v_err212 T834)
(declare-const var_h66 T833)
(declare-const err T847)
    (declare-const |5| Int)
  
solver 
 (declare-sort T833)
(declare-fun |5| () Int)
(declare-fun sel (T833 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h209 () T833)
(declare-fun |var__temp_h'211| () T833)
(declare-fun var__temp_v210 () Int)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h209 res) v) (= v |5|))
               (= (sel var__temp_h209 res) 7)))
      (a!2 (and (= (sel |var__temp_h'211| res) var__temp_v210)
                (= (sel |var__temp_h'211| res) (+ (sel var__temp_h209 res) 5)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h209 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************56
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i67 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i67, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v204:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h213 --->  Ty_heap  
 var__temp_v214 --->  Ty_int  
 var__temp_h'215 --->  Ty_heap  
 var__temp_v_err216 --->  error  
 var_h66 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h213, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h213, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h213, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'215, res ) ==(var__temp_v214) AND 
 	 Rel (sel)( , var__temp_h'215, res ) ==((sel)( , var__temp_h213, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i67 T850)
(declare-const var_h66 T850)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h213 T850)
(declare-const var__temp_v214 Int)
(declare-const |var__temp_h'215| T850)
(declare-const var__temp_v_err216 T851)
(declare-const var_h66 T850)
(declare-const err T864)
    (declare-const |5| Int)
  
solver 
 (declare-sort T850)
(declare-fun |5| () Int)
(declare-fun sel (T850 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h213 () T850)
(declare-fun |var__temp_h'215| () T850)
(declare-fun var__temp_v214 () Int)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h213 res) v) (= v |5|))
               (= (sel var__temp_h213 res) 7)))
      (a!2 (and (= (sel |var__temp_h'215| res) var__temp_v214)
                (= (sel |var__temp_h'215| res) (+ (sel var__temp_h213 res) 5)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h213 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************57
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i67 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i67, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v204:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h217 --->  Ty_heap  
 var__temp_v218 --->  Ty_int  
 var__temp_h'219 --->  Ty_heap  
 var__temp_v_err220 --->  error  
 var_h66 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h217, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h217, res ) > (5) AND 
 	 Rel (sel)( , var__temp_h217, res ) > (5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'219, res ) ==(var__temp_v218) AND 
 	 Rel (sel)( , var__temp_h'219, res ) ==((sel)( , var__temp_h217, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i67 T867)
(declare-const var_h66 T867)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h217 T867)
(declare-const var__temp_v218 Int)
(declare-const |var__temp_h'219| T867)
(declare-const var__temp_v_err220 T868)
(declare-const var_h66 T867)
(declare-const err T881)
    (declare-const |5| Int)
  
solver 
 (declare-sort T867)
(declare-fun |5| () Int)
(declare-fun sel (T867 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h217 () T867)
(declare-fun |var__temp_h'219| () T867)
(declare-fun var__temp_v218 () Int)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h217 res) v) (= v |5|))
               (> (sel var__temp_h217 res) 5)))
      (a!2 (and (= (sel |var__temp_h'219| res) var__temp_v218)
                (= (sel |var__temp_h'219| res) (+ (sel var__temp_h217 res) 5)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h217 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2''
 *********************Enumeration Iteration*****************58
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (1)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i67 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i67, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v204:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (1)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h221 --->  Ty_heap  
 var__temp_v222 --->  Ty_int  
 var__temp_h'223 --->  Ty_heap  
 var__temp_v_err224 --->  error  
 var_h66 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h221, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h221, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h221, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'223, res ) ==(var__temp_v222) AND 
 	 Rel (sel)( , var__temp_h'223, res ) ==((sel)( , var__temp_h221, res ) + (1)) => 
 	 True
 
VC_END(declare-const var_h_i67 T884)
(declare-const var_h66 T884)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h221 T884)
(declare-const var__temp_v222 Int)
(declare-const |var__temp_h'223| T884)
(declare-const var__temp_v_err224 T885)
(declare-const var_h66 T884)
(declare-const err T898)
    (declare-const |5| Int)
  
solver 
 (declare-sort T884)
(declare-fun |5| () Int)
(declare-fun sel (T884 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h221 () T884)
(declare-fun |var__temp_h'223| () T884)
(declare-fun var__temp_v222 () Int)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h221 res) v) (= v |5|))
               (> (sel var__temp_h221 res) 4)))
      (a!2 (and (= (sel |var__temp_h'223| res) var__temp_v222)
                (= (sel |var__temp_h'223| res) (+ (sel var__temp_h221 res) 1)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h221 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c2'
EXPLORED::BEFORETermsc3'c3'c1
EXPLORED::AFTERTermsc2'c3'c3'c1
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i226 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i226 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i226, res ) ==(v)
 	 , (sel)( , var_h_i226, res ) ==((sel)( , var_h225, res ) + (1)) >c  } 
 } 
 
                                                RET :  Base {var_v227:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i226 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
c3
c5
c4
c2''
c2
 *********************Enumeration Iteration*****************59
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i226 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i226, res ) ==(v)
 	 , (sel)( , var_h_i226, res ) ==((sel)( , var_h225, res ) + (1)) >c  } 
 } 
 
                                                RET :  Base {var_v227:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i226 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h228 --->  Ty_heap  
 var__temp_v229 --->  Ty_int  
 var__temp_h'230 --->  Ty_heap  
 var__temp_v_err231 --->  error  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h228, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h228, res ) ==((sel)( , var_h225, res ) + (1)) => 
 	 Rel (sel)( , var__temp_h228, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h228, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'230, res ) ==(var__temp_v229) AND 
 	 Rel (sel)( , var__temp_h'230, res ) ==((sel)( , var__temp_h228, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'230, res ) ==(var__temp_v229) AND 
 	 Rel (sel)( , var__temp_h'230, res ) ==(10)
 
VC_END(declare-const var_h_i226 T901)
(declare-const var_h225 T901)
(declare-const v Int)
(declare-const var_h_i67 T901)
(declare-const var_h66 T901)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h228 T901)
(declare-const var__temp_v229 Int)
(declare-const |var__temp_h'230| T901)
(declare-const var__temp_v_err231 T902)
(declare-const var_h225 T901)
(declare-const var_h66 T901)
(declare-const err T915)

solver 
 (declare-sort T901)
(declare-fun sel (T901 Int) Int)
(declare-fun res () Int)
(declare-fun var_h225 () T901)
(declare-fun |var__temp_h'230| () T901)
(declare-fun var__temp_v229 () Int)
(declare-fun var__temp_h228 () T901)
(declare-fun v () Int)
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h228 res) v)
                (= (sel var__temp_h228 res) (+ (sel var_h225 res) 1))))
      (a!2 (and (= (sel |var__temp_h'230| res) var__temp_v229)
                (= (sel |var__temp_h'230| res) (+ (sel var__temp_h228 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'230| res) var__temp_v229)
                    (= (sel |var__temp_h'230| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h228 res) 7))
                (=> (= (sel var__temp_h228 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c3
 *********************Enumeration Iteration*****************60
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i226 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i226, res ) ==(v)
 	 , (sel)( , var_h_i226, res ) ==((sel)( , var_h225, res ) + (1)) >c  } 
 } 
 
                                                RET :  Base {var_v227:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i226 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h232 --->  Ty_heap  
 var__temp_v233 --->  Ty_int  
 var__temp_h'234 --->  Ty_heap  
 var__temp_v_err235 --->  error  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h232, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h232, res ) ==((sel)( , var_h225, res ) + (1)) => 
 	 Rel (sel)( , var__temp_h232, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h232, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'234, res ) ==(var__temp_v233) AND 
 	 Rel (sel)( , var__temp_h'234, res ) ==((sel)( , var__temp_h232, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'234, res ) ==(var__temp_v233) AND 
 	 Rel (sel)( , var__temp_h'234, res ) ==(10)
 
VC_END(declare-const var_h_i226 T918)
(declare-const var_h225 T918)
(declare-const v Int)
(declare-const var_h_i67 T918)
(declare-const var_h66 T918)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h232 T918)
(declare-const var__temp_v233 Int)
(declare-const |var__temp_h'234| T918)
(declare-const var__temp_v_err235 T919)
(declare-const var_h225 T918)
(declare-const var_h66 T918)
(declare-const err T932)

solver 
 (declare-sort T918)
(declare-fun sel (T918 Int) Int)
(declare-fun res () Int)
(declare-fun var_h225 () T918)
(declare-fun |var__temp_h'234| () T918)
(declare-fun var__temp_v233 () Int)
(declare-fun var__temp_h232 () T918)
(declare-fun v () Int)
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h232 res) v)
                (= (sel var__temp_h232 res) (+ (sel var_h225 res) 1))))
      (a!2 (and (= (sel |var__temp_h'234| res) var__temp_v233)
                (= (sel |var__temp_h'234| res) (+ (sel var__temp_h232 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'234| res) var__temp_v233)
                    (= (sel |var__temp_h'234| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h232 res) 7))
                (=> (= (sel var__temp_h232 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************61
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i226 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i226, res ) ==(v)
 	 , (sel)( , var_h_i226, res ) ==((sel)( , var_h225, res ) + (1)) >c  } 
 } 
 
                                                RET :  Base {var_v227:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i226 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h236 --->  Ty_heap  
 var__temp_v237 --->  Ty_int  
 var__temp_h'238 --->  Ty_heap  
 var__temp_v_err239 --->  error  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h236, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h236, res ) ==((sel)( , var_h225, res ) + (1)) => 
 	 Rel (sel)( , var__temp_h236, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h236, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'238, res ) ==(var__temp_v237) AND 
 	 Rel (sel)( , var__temp_h'238, res ) ==((sel)( , var__temp_h236, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'238, res ) ==(var__temp_v237) AND 
 	 Rel (sel)( , var__temp_h'238, res ) ==(10)
 
VC_END(declare-const var_h_i226 T935)
(declare-const var_h225 T935)
(declare-const v Int)
(declare-const var_h_i67 T935)
(declare-const var_h66 T935)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h236 T935)
(declare-const var__temp_v237 Int)
(declare-const |var__temp_h'238| T935)
(declare-const var__temp_v_err239 T936)
(declare-const var_h225 T935)
(declare-const var_h66 T935)
(declare-const err T949)

solver 
 (declare-sort T935)
(declare-fun sel (T935 Int) Int)
(declare-fun res () Int)
(declare-fun var_h225 () T935)
(declare-fun |var__temp_h'238| () T935)
(declare-fun var__temp_v237 () Int)
(declare-fun var__temp_h236 () T935)
(declare-fun v () Int)
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h236 res) v)
                (= (sel var__temp_h236 res) (+ (sel var_h225 res) 1))))
      (a!2 (and (= (sel |var__temp_h'238| res) var__temp_v237)
                (= (sel |var__temp_h'238| res) (+ (sel var__temp_h236 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'238| res) var__temp_v237)
                    (= (sel |var__temp_h'238| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h236 res) 7))
                (=> (= (sel var__temp_h236 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************62
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i226 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i226, res ) ==(v)
 	 , (sel)( , var_h_i226, res ) ==((sel)( , var_h225, res ) + (1)) >c  } 
 } 
 
                                                RET :  Base {var_v227:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i226 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h240 --->  Ty_heap  
 var__temp_v241 --->  Ty_int  
 var__temp_h'242 --->  Ty_heap  
 var__temp_v_err243 --->  error  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h240, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h240, res ) ==((sel)( , var_h225, res ) + (1)) => 
 	 Rel (sel)( , var__temp_h240, res ) > (5) AND 
 	 Rel (sel)( , var__temp_h240, res ) > (5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'242, res ) ==(var__temp_v241) AND 
 	 Rel (sel)( , var__temp_h'242, res ) ==((sel)( , var__temp_h240, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'242, res ) ==(var__temp_v241) AND 
 	 Rel (sel)( , var__temp_h'242, res ) ==(10)
 
VC_END(declare-const var_h_i226 T952)
(declare-const var_h225 T952)
(declare-const v Int)
(declare-const var_h_i67 T952)
(declare-const var_h66 T952)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h240 T952)
(declare-const var__temp_v241 Int)
(declare-const |var__temp_h'242| T952)
(declare-const var__temp_v_err243 T953)
(declare-const var_h225 T952)
(declare-const var_h66 T952)
(declare-const err T966)

solver 
 (declare-sort T952)
(declare-fun sel (T952 Int) Int)
(declare-fun res () Int)
(declare-fun var_h225 () T952)
(declare-fun |var__temp_h'242| () T952)
(declare-fun var__temp_v241 () Int)
(declare-fun var__temp_h240 () T952)
(declare-fun v () Int)
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h240 res) v)
                (= (sel var__temp_h240 res) (+ (sel var_h225 res) 1))))
      (a!2 (and (= (sel |var__temp_h'242| res) var__temp_v241)
                (= (sel |var__temp_h'242| res) (+ (sel var__temp_h240 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'242| res) var__temp_v241)
                    (= (sel |var__temp_h'242| res) 10)))))
(let ((a!4 (and (=> a!1 (> (sel var__temp_h240 res) 5))
                (=> (> (sel var__temp_h240 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************c2''
 *********************Enumeration Iteration*****************63
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i226 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i226, res ) ==(v)
 	 , (sel)( , var_h_i226, res ) ==((sel)( , var_h225, res ) + (1)) >c  } 
 } 
 
                                                RET :  Base {var_v227:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i226 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h244 --->  Ty_heap  
 var__temp_v245 --->  Ty_int  
 var__temp_h'246 --->  Ty_heap  
 var__temp_v_err247 --->  error  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h244, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h244, res ) ==((sel)( , var_h225, res ) + (1)) => 
 	 Rel (sel)( , var__temp_h244, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h244, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'246, res ) ==(var__temp_v245) AND 
 	 Rel (sel)( , var__temp_h'246, res ) ==((sel)( , var__temp_h244, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'246, res ) ==(var__temp_v245) AND 
 	 Rel (sel)( , var__temp_h'246, res ) ==(10)
 
VC_END(declare-const var_h_i226 T969)
(declare-const var_h225 T969)
(declare-const v Int)
(declare-const var_h_i67 T969)
(declare-const var_h66 T969)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h244 T969)
(declare-const var__temp_v245 Int)
(declare-const |var__temp_h'246| T969)
(declare-const var__temp_v_err247 T970)
(declare-const var_h225 T969)
(declare-const var_h66 T969)
(declare-const err T983)

solver 
 (declare-sort T969)
(declare-fun sel (T969 Int) Int)
(declare-fun res () Int)
(declare-fun var_h225 () T969)
(declare-fun |var__temp_h'246| () T969)
(declare-fun var__temp_v245 () Int)
(declare-fun var__temp_h244 () T969)
(declare-fun v () Int)
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h244 res) v)
                (= (sel var__temp_h244 res) (+ (sel var_h225 res) 1))))
      (a!2 (and (= (sel |var__temp_h'246| res) var__temp_v245)
                (= (sel |var__temp_h'246| res) (+ (sel var__temp_h244 res) 2)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'246| res) var__temp_v245)
                    (= (sel |var__temp_h'246| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h244 res) 5))
                (=> (= (sel var__temp_h244 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************64
 Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v227:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v227:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2'c3'c3'c1
esynthesizeBind
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i226 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i226, res ) ==(v)
 	 , (sel)( , var_h_i226, res ) ==((sel)( , var_h225, res ) + (1)) >c  } 
 } 
 
                                                RET :  Base {var_v248:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c3
c5
c4
c2''
c2
 *********************Enumeration Iteration*****************65
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i226 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i226, res ) ==(v)
 	 , (sel)( , var_h_i226, res ) ==((sel)( , var_h225, res ) + (1)) >c  } 
 } 
 
                                                RET :  Base {var_v248:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h249 --->  Ty_heap  
 var__temp_v250 --->  Ty_int  
 var__temp_h'251 --->  Ty_heap  
 var__temp_v_err252 --->  error  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h249, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h249, res ) ==((sel)( , var_h225, res ) + (1)) => 
 	 Rel (sel)( , var__temp_h249, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h249, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'251, res ) ==(var__temp_v250) AND 
 	 Rel (sel)( , var__temp_h'251, res ) ==((sel)( , var__temp_h249, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i226 T986)
(declare-const var_h225 T986)
(declare-const v Int)
(declare-const var_h_i67 T986)
(declare-const var_h66 T986)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h249 T986)
(declare-const var__temp_v250 Int)
(declare-const |var__temp_h'251| T986)
(declare-const var__temp_v_err252 T987)
(declare-const var_h225 T986)
(declare-const var_h66 T986)
(declare-const err T1000)

solver 
 (declare-sort T986)
(declare-fun sel (T986 Int) Int)
(declare-fun res () Int)
(declare-fun var_h225 () T986)
(declare-fun var__temp_h249 () T986)
(declare-fun |var__temp_h'251| () T986)
(declare-fun var__temp_v250 () Int)
(declare-fun v () Int)
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h249 res) v)
                (= (sel var__temp_h249 res) (+ (sel var_h225 res) 1))))
      (a!2 (and (= (sel |var__temp_h'251| res) var__temp_v250)
                (= (sel |var__temp_h'251| res) (+ (sel var__temp_h249 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h249 res) 7))
                (=> (= (sel var__temp_h249 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c3
 *********************Enumeration Iteration*****************66
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i226 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i226, res ) ==(v)
 	 , (sel)( , var_h_i226, res ) ==((sel)( , var_h225, res ) + (1)) >c  } 
 } 
 
                                                RET :  Base {var_v248:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h253 --->  Ty_heap  
 var__temp_v254 --->  Ty_int  
 var__temp_h'255 --->  Ty_heap  
 var__temp_v_err256 --->  error  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h253, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h253, res ) ==((sel)( , var_h225, res ) + (1)) => 
 	 Rel (sel)( , var__temp_h253, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h253, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'255, res ) ==(var__temp_v254) AND 
 	 Rel (sel)( , var__temp_h'255, res ) ==((sel)( , var__temp_h253, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i226 T1003)
(declare-const var_h225 T1003)
(declare-const v Int)
(declare-const var_h_i67 T1003)
(declare-const var_h66 T1003)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h253 T1003)
(declare-const var__temp_v254 Int)
(declare-const |var__temp_h'255| T1003)
(declare-const var__temp_v_err256 T1004)
(declare-const var_h225 T1003)
(declare-const var_h66 T1003)
(declare-const err T1017)

solver 
 (declare-sort T1003)
(declare-fun sel (T1003 Int) Int)
(declare-fun res () Int)
(declare-fun var_h225 () T1003)
(declare-fun var__temp_h253 () T1003)
(declare-fun |var__temp_h'255| () T1003)
(declare-fun var__temp_v254 () Int)
(declare-fun v () Int)
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h253 res) v)
                (= (sel var__temp_h253 res) (+ (sel var_h225 res) 1))))
      (a!2 (and (= (sel |var__temp_h'255| res) var__temp_v254)
                (= (sel |var__temp_h'255| res) (+ (sel var__temp_h253 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h253 res) 7))
                (=> (= (sel var__temp_h253 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************67
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i226 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i226, res ) ==(v)
 	 , (sel)( , var_h_i226, res ) ==((sel)( , var_h225, res ) + (1)) >c  } 
 } 
 
                                                RET :  Base {var_v248:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h257 --->  Ty_heap  
 var__temp_v258 --->  Ty_int  
 var__temp_h'259 --->  Ty_heap  
 var__temp_v_err260 --->  error  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h257, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h257, res ) ==((sel)( , var_h225, res ) + (1)) => 
 	 Rel (sel)( , var__temp_h257, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h257, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'259, res ) ==(var__temp_v258) AND 
 	 Rel (sel)( , var__temp_h'259, res ) ==((sel)( , var__temp_h257, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i226 T1020)
(declare-const var_h225 T1020)
(declare-const v Int)
(declare-const var_h_i67 T1020)
(declare-const var_h66 T1020)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h257 T1020)
(declare-const var__temp_v258 Int)
(declare-const |var__temp_h'259| T1020)
(declare-const var__temp_v_err260 T1021)
(declare-const var_h225 T1020)
(declare-const var_h66 T1020)
(declare-const err T1034)

solver 
 (declare-sort T1020)
(declare-fun sel (T1020 Int) Int)
(declare-fun res () Int)
(declare-fun var_h225 () T1020)
(declare-fun var__temp_h257 () T1020)
(declare-fun |var__temp_h'259| () T1020)
(declare-fun var__temp_v258 () Int)
(declare-fun v () Int)
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h257 res) v)
                (= (sel var__temp_h257 res) (+ (sel var_h225 res) 1))))
      (a!2 (and (= (sel |var__temp_h'259| res) var__temp_v258)
                (= (sel |var__temp_h'259| res) (+ (sel var__temp_h257 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h257 res) 7))
                (=> (= (sel var__temp_h257 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************68
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i226 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i226, res ) ==(v)
 	 , (sel)( , var_h_i226, res ) ==((sel)( , var_h225, res ) + (1)) >c  } 
 } 
 
                                                RET :  Base {var_v248:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h261 --->  Ty_heap  
 var__temp_v262 --->  Ty_int  
 var__temp_h'263 --->  Ty_heap  
 var__temp_v_err264 --->  error  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h261, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h261, res ) ==((sel)( , var_h225, res ) + (1)) => 
 	 Rel (sel)( , var__temp_h261, res ) > (5) AND 
 	 Rel (sel)( , var__temp_h261, res ) > (5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'263, res ) ==(var__temp_v262) AND 
 	 Rel (sel)( , var__temp_h'263, res ) ==((sel)( , var__temp_h261, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i226 T1037)
(declare-const var_h225 T1037)
(declare-const v Int)
(declare-const var_h_i67 T1037)
(declare-const var_h66 T1037)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h261 T1037)
(declare-const var__temp_v262 Int)
(declare-const |var__temp_h'263| T1037)
(declare-const var__temp_v_err264 T1038)
(declare-const var_h225 T1037)
(declare-const var_h66 T1037)
(declare-const err T1051)

solver 
 (declare-sort T1037)
(declare-fun sel (T1037 Int) Int)
(declare-fun res () Int)
(declare-fun var_h225 () T1037)
(declare-fun var__temp_h261 () T1037)
(declare-fun |var__temp_h'263| () T1037)
(declare-fun var__temp_v262 () Int)
(declare-fun v () Int)
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h261 res) v)
                (= (sel var__temp_h261 res) (+ (sel var_h225 res) 1))))
      (a!2 (and (= (sel |var__temp_h'263| res) var__temp_v262)
                (= (sel |var__temp_h'263| res) (+ (sel var__temp_h261 res) 5)))))
(let ((a!3 (and (=> a!1 (> (sel var__temp_h261 res) 5))
                (=> (> (sel var__temp_h261 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c2''
EXPLORED::BEFORETermsc2'c3'c3'c1
EXPLORED::AFTERTermsc2''c2'c3'c3'c1
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i266 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i266 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i266, res ) ==(v)
 	 , (sel)( , var_h_i266, res ) ==((sel)( , var_h265, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v267:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i266 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
c3
c5
c4
c2
 *********************Enumeration Iteration*****************69
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i266 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i266, res ) ==(v)
 	 , (sel)( , var_h_i266, res ) ==((sel)( , var_h265, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v267:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i266 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i266 --->  Ty_heap  
 var_h265 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h268 --->  Ty_heap  
 var__temp_v269 --->  Ty_int  
 var__temp_h'270 --->  Ty_heap  
 var__temp_v_err271 --->  error  
 var_h265 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h265, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h268, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h268, res ) ==((sel)( , var_h265, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h268, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h268, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'270, res ) ==(var__temp_v269) AND 
 	 Rel (sel)( , var__temp_h'270, res ) ==((sel)( , var__temp_h268, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'270, res ) ==(var__temp_v269) AND 
 	 Rel (sel)( , var__temp_h'270, res ) ==(10)
 
VC_END(declare-const var_h_i266 T1054)
(declare-const var_h265 T1054)
(declare-const v Int)
(declare-const var_h_i226 T1054)
(declare-const var_h225 T1054)
(declare-const v Int)
(declare-const var_h_i67 T1054)
(declare-const var_h66 T1054)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h268 T1054)
(declare-const var__temp_v269 Int)
(declare-const |var__temp_h'270| T1054)
(declare-const var__temp_v_err271 T1055)
(declare-const var_h265 T1054)
(declare-const var_h225 T1054)
(declare-const var_h66 T1054)
(declare-const err T1068)

solver 
 (declare-sort T1054)
(declare-fun sel (T1054 Int) Int)
(declare-fun res () Int)
(declare-fun var_h265 () T1054)
(declare-fun var_h225 () T1054)
(declare-fun |var__temp_h'270| () T1054)
(declare-fun var__temp_v269 () Int)
(declare-fun var__temp_h268 () T1054)
(declare-fun v () Int)
(assert (> (sel var_h265 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h268 res) v)
                (= (sel var__temp_h268 res) (+ (sel var_h265 res) 5))))
      (a!2 (and (= (sel |var__temp_h'270| res) var__temp_v269)
                (= (sel |var__temp_h'270| res) (+ (sel var__temp_h268 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'270| res) var__temp_v269)
                    (= (sel |var__temp_h'270| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h268 res) 7))
                (=> (= (sel var__temp_h268 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c3
 *********************Enumeration Iteration*****************70
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i266 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i266, res ) ==(v)
 	 , (sel)( , var_h_i266, res ) ==((sel)( , var_h265, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v267:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i266 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i266 --->  Ty_heap  
 var_h265 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h272 --->  Ty_heap  
 var__temp_v273 --->  Ty_int  
 var__temp_h'274 --->  Ty_heap  
 var__temp_v_err275 --->  error  
 var_h265 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h265, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h272, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h272, res ) ==((sel)( , var_h265, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h272, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h272, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'274, res ) ==(var__temp_v273) AND 
 	 Rel (sel)( , var__temp_h'274, res ) ==((sel)( , var__temp_h272, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'274, res ) ==(var__temp_v273) AND 
 	 Rel (sel)( , var__temp_h'274, res ) ==(10)
 
VC_END(declare-const var_h_i266 T1071)
(declare-const var_h265 T1071)
(declare-const v Int)
(declare-const var_h_i226 T1071)
(declare-const var_h225 T1071)
(declare-const v Int)
(declare-const var_h_i67 T1071)
(declare-const var_h66 T1071)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h272 T1071)
(declare-const var__temp_v273 Int)
(declare-const |var__temp_h'274| T1071)
(declare-const var__temp_v_err275 T1072)
(declare-const var_h265 T1071)
(declare-const var_h225 T1071)
(declare-const var_h66 T1071)
(declare-const err T1085)

solver 
 (declare-sort T1071)
(declare-fun sel (T1071 Int) Int)
(declare-fun res () Int)
(declare-fun var_h265 () T1071)
(declare-fun var_h225 () T1071)
(declare-fun |var__temp_h'274| () T1071)
(declare-fun var__temp_v273 () Int)
(declare-fun var__temp_h272 () T1071)
(declare-fun v () Int)
(assert (> (sel var_h265 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h272 res) v)
                (= (sel var__temp_h272 res) (+ (sel var_h265 res) 5))))
      (a!2 (and (= (sel |var__temp_h'274| res) var__temp_v273)
                (= (sel |var__temp_h'274| res) (+ (sel var__temp_h272 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'274| res) var__temp_v273)
                    (= (sel |var__temp_h'274| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h272 res) 7))
                (=> (= (sel var__temp_h272 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************71
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i266 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i266, res ) ==(v)
 	 , (sel)( , var_h_i266, res ) ==((sel)( , var_h265, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v267:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i266 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i266 --->  Ty_heap  
 var_h265 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h276 --->  Ty_heap  
 var__temp_v277 --->  Ty_int  
 var__temp_h'278 --->  Ty_heap  
 var__temp_v_err279 --->  error  
 var_h265 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h265, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h276, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h276, res ) ==((sel)( , var_h265, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h276, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h276, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'278, res ) ==(var__temp_v277) AND 
 	 Rel (sel)( , var__temp_h'278, res ) ==((sel)( , var__temp_h276, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'278, res ) ==(var__temp_v277) AND 
 	 Rel (sel)( , var__temp_h'278, res ) ==(10)
 
VC_END(declare-const var_h_i266 T1088)
(declare-const var_h265 T1088)
(declare-const v Int)
(declare-const var_h_i226 T1088)
(declare-const var_h225 T1088)
(declare-const v Int)
(declare-const var_h_i67 T1088)
(declare-const var_h66 T1088)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h276 T1088)
(declare-const var__temp_v277 Int)
(declare-const |var__temp_h'278| T1088)
(declare-const var__temp_v_err279 T1089)
(declare-const var_h265 T1088)
(declare-const var_h225 T1088)
(declare-const var_h66 T1088)
(declare-const err T1102)

solver 
 (declare-sort T1088)
(declare-fun sel (T1088 Int) Int)
(declare-fun res () Int)
(declare-fun var_h265 () T1088)
(declare-fun var_h225 () T1088)
(declare-fun |var__temp_h'278| () T1088)
(declare-fun var__temp_v277 () Int)
(declare-fun var__temp_h276 () T1088)
(declare-fun v () Int)
(assert (> (sel var_h265 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h276 res) v)
                (= (sel var__temp_h276 res) (+ (sel var_h265 res) 5))))
      (a!2 (and (= (sel |var__temp_h'278| res) var__temp_v277)
                (= (sel |var__temp_h'278| res) (+ (sel var__temp_h276 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'278| res) var__temp_v277)
                    (= (sel |var__temp_h'278| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h276 res) 7))
                (=> (= (sel var__temp_h276 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************72
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i266 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i266, res ) ==(v)
 	 , (sel)( , var_h_i266, res ) ==((sel)( , var_h265, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v267:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i266 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i266 --->  Ty_heap  
 var_h265 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h280 --->  Ty_heap  
 var__temp_v281 --->  Ty_int  
 var__temp_h'282 --->  Ty_heap  
 var__temp_v_err283 --->  error  
 var_h265 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h265, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h280, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h280, res ) ==((sel)( , var_h265, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h280, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h280, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'282, res ) ==(var__temp_v281) AND 
 	 Rel (sel)( , var__temp_h'282, res ) ==((sel)( , var__temp_h280, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'282, res ) ==(var__temp_v281) AND 
 	 Rel (sel)( , var__temp_h'282, res ) ==(10)
 
VC_END(declare-const var_h_i266 T1105)
(declare-const var_h265 T1105)
(declare-const v Int)
(declare-const var_h_i226 T1105)
(declare-const var_h225 T1105)
(declare-const v Int)
(declare-const var_h_i67 T1105)
(declare-const var_h66 T1105)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h280 T1105)
(declare-const var__temp_v281 Int)
(declare-const |var__temp_h'282| T1105)
(declare-const var__temp_v_err283 T1106)
(declare-const var_h265 T1105)
(declare-const var_h225 T1105)
(declare-const var_h66 T1105)
(declare-const err T1119)

solver 
 (declare-sort T1105)
(declare-fun sel (T1105 Int) Int)
(declare-fun res () Int)
(declare-fun var_h265 () T1105)
(declare-fun var_h225 () T1105)
(declare-fun |var__temp_h'282| () T1105)
(declare-fun var__temp_v281 () Int)
(declare-fun var__temp_h280 () T1105)
(declare-fun v () Int)
(assert (> (sel var_h265 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h280 res) v)
                (= (sel var__temp_h280 res) (+ (sel var_h265 res) 5))))
      (a!2 (and (= (sel |var__temp_h'282| res) var__temp_v281)
                (= (sel |var__temp_h'282| res) (+ (sel var__temp_h280 res) 2)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'282| res) var__temp_v281)
                    (= (sel |var__temp_h'282| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h280 res) 5))
                (=> (= (sel var__temp_h280 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************73
 Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v267:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v267:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2''c2'c3'c3'c1
esynthesizeBind
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i266 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i266, res ) ==(v)
 	 , (sel)( , var_h_i266, res ) ==((sel)( , var_h265, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v284:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c3
c5
c4
c2
 *********************Enumeration Iteration*****************74
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i266 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i266, res ) ==(v)
 	 , (sel)( , var_h_i266, res ) ==((sel)( , var_h265, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v284:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i266 --->  Ty_heap  
 var_h265 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h285 --->  Ty_heap  
 var__temp_v286 --->  Ty_int  
 var__temp_h'287 --->  Ty_heap  
 var__temp_v_err288 --->  error  
 var_h265 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h265, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h285, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h285, res ) ==((sel)( , var_h265, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h285, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h285, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'287, res ) ==(var__temp_v286) AND 
 	 Rel (sel)( , var__temp_h'287, res ) ==((sel)( , var__temp_h285, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i266 T1122)
(declare-const var_h265 T1122)
(declare-const v Int)
(declare-const var_h_i226 T1122)
(declare-const var_h225 T1122)
(declare-const v Int)
(declare-const var_h_i67 T1122)
(declare-const var_h66 T1122)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h285 T1122)
(declare-const var__temp_v286 Int)
(declare-const |var__temp_h'287| T1122)
(declare-const var__temp_v_err288 T1123)
(declare-const var_h265 T1122)
(declare-const var_h225 T1122)
(declare-const var_h66 T1122)
(declare-const err T1136)

solver 
 (declare-sort T1122)
(declare-fun sel (T1122 Int) Int)
(declare-fun res () Int)
(declare-fun var_h265 () T1122)
(declare-fun var_h225 () T1122)
(declare-fun var__temp_h285 () T1122)
(declare-fun |var__temp_h'287| () T1122)
(declare-fun var__temp_v286 () Int)
(declare-fun v () Int)
(assert (> (sel var_h265 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h285 res) v)
                (= (sel var__temp_h285 res) (+ (sel var_h265 res) 5))))
      (a!2 (and (= (sel |var__temp_h'287| res) var__temp_v286)
                (= (sel |var__temp_h'287| res) (+ (sel var__temp_h285 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h285 res) 7))
                (=> (= (sel var__temp_h285 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c3
 *********************Enumeration Iteration*****************75
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i266 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i266, res ) ==(v)
 	 , (sel)( , var_h_i266, res ) ==((sel)( , var_h265, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v284:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i266 --->  Ty_heap  
 var_h265 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h289 --->  Ty_heap  
 var__temp_v290 --->  Ty_int  
 var__temp_h'291 --->  Ty_heap  
 var__temp_v_err292 --->  error  
 var_h265 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h265, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h289, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h289, res ) ==((sel)( , var_h265, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h289, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h289, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'291, res ) ==(var__temp_v290) AND 
 	 Rel (sel)( , var__temp_h'291, res ) ==((sel)( , var__temp_h289, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i266 T1139)
(declare-const var_h265 T1139)
(declare-const v Int)
(declare-const var_h_i226 T1139)
(declare-const var_h225 T1139)
(declare-const v Int)
(declare-const var_h_i67 T1139)
(declare-const var_h66 T1139)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h289 T1139)
(declare-const var__temp_v290 Int)
(declare-const |var__temp_h'291| T1139)
(declare-const var__temp_v_err292 T1140)
(declare-const var_h265 T1139)
(declare-const var_h225 T1139)
(declare-const var_h66 T1139)
(declare-const err T1153)

solver 
 (declare-sort T1139)
(declare-fun sel (T1139 Int) Int)
(declare-fun res () Int)
(declare-fun var_h265 () T1139)
(declare-fun var_h225 () T1139)
(declare-fun var__temp_h289 () T1139)
(declare-fun |var__temp_h'291| () T1139)
(declare-fun var__temp_v290 () Int)
(declare-fun v () Int)
(assert (> (sel var_h265 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h289 res) v)
                (= (sel var__temp_h289 res) (+ (sel var_h265 res) 5))))
      (a!2 (and (= (sel |var__temp_h'291| res) var__temp_v290)
                (= (sel |var__temp_h'291| res) (+ (sel var__temp_h289 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h289 res) 7))
                (=> (= (sel var__temp_h289 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************76
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i266 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i266, res ) ==(v)
 	 , (sel)( , var_h_i266, res ) ==((sel)( , var_h265, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v284:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i266 --->  Ty_heap  
 var_h265 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h293 --->  Ty_heap  
 var__temp_v294 --->  Ty_int  
 var__temp_h'295 --->  Ty_heap  
 var__temp_v_err296 --->  error  
 var_h265 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h265, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h293, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h293, res ) ==((sel)( , var_h265, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h293, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h293, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'295, res ) ==(var__temp_v294) AND 
 	 Rel (sel)( , var__temp_h'295, res ) ==((sel)( , var__temp_h293, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i266 T1156)
(declare-const var_h265 T1156)
(declare-const v Int)
(declare-const var_h_i226 T1156)
(declare-const var_h225 T1156)
(declare-const v Int)
(declare-const var_h_i67 T1156)
(declare-const var_h66 T1156)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h293 T1156)
(declare-const var__temp_v294 Int)
(declare-const |var__temp_h'295| T1156)
(declare-const var__temp_v_err296 T1157)
(declare-const var_h265 T1156)
(declare-const var_h225 T1156)
(declare-const var_h66 T1156)
(declare-const err T1170)

solver 
 (declare-sort T1156)
(declare-fun sel (T1156 Int) Int)
(declare-fun res () Int)
(declare-fun var_h265 () T1156)
(declare-fun var_h225 () T1156)
(declare-fun var__temp_h293 () T1156)
(declare-fun |var__temp_h'295| () T1156)
(declare-fun var__temp_v294 () Int)
(declare-fun v () Int)
(assert (> (sel var_h265 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h293 res) v)
                (= (sel var__temp_h293 res) (+ (sel var_h265 res) 5))))
      (a!2 (and (= (sel |var__temp_h'295| res) var__temp_v294)
                (= (sel |var__temp_h'295| res) (+ (sel var__temp_h293 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h293 res) 7))
                (=> (= (sel var__temp_h293 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************77
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i266 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i266, res ) ==(v)
 	 , (sel)( , var_h_i266, res ) ==((sel)( , var_h265, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v284:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i266 --->  Ty_heap  
 var_h265 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h297 --->  Ty_heap  
 var__temp_v298 --->  Ty_int  
 var__temp_h'299 --->  Ty_heap  
 var__temp_v_err300 --->  error  
 var_h265 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h265, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h297, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h297, res ) ==((sel)( , var_h265, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h297, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h297, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'299, res ) ==(var__temp_v298) AND 
 	 Rel (sel)( , var__temp_h'299, res ) ==((sel)( , var__temp_h297, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i266 T1173)
(declare-const var_h265 T1173)
(declare-const v Int)
(declare-const var_h_i226 T1173)
(declare-const var_h225 T1173)
(declare-const v Int)
(declare-const var_h_i67 T1173)
(declare-const var_h66 T1173)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h297 T1173)
(declare-const var__temp_v298 Int)
(declare-const |var__temp_h'299| T1173)
(declare-const var__temp_v_err300 T1174)
(declare-const var_h265 T1173)
(declare-const var_h225 T1173)
(declare-const var_h66 T1173)
(declare-const err T1187)

solver 
 (declare-sort T1173)
(declare-fun sel (T1173 Int) Int)
(declare-fun res () Int)
(declare-fun var_h265 () T1173)
(declare-fun var_h225 () T1173)
(declare-fun var__temp_h297 () T1173)
(declare-fun |var__temp_h'299| () T1173)
(declare-fun var__temp_v298 () Int)
(declare-fun v () Int)
(assert (> (sel var_h265 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h297 res) v)
                (= (sel var__temp_h297 res) (+ (sel var_h265 res) 5))))
      (a!2 (and (= (sel |var__temp_h'299| res) var__temp_v298)
                (= (sel |var__temp_h'299| res) (+ (sel var__temp_h297 res) 2)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h297 res) 5))
                (=> (= (sel var__temp_h297 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************78
First component finding failed
EXPLORED2 Termsc2''c2'c3'c3'c1
esynthesizeBind
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i266 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i266, res ) ==(v)
 	 , (sel)( , var_h_i266, res ) ==((sel)( , var_h265, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v301:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c3
c5
c4
c2
 *********************Enumeration Iteration*****************79
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i266 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i266, res ) ==(v)
 	 , (sel)( , var_h_i266, res ) ==((sel)( , var_h265, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v301:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i266 --->  Ty_heap  
 var_h265 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h302 --->  Ty_heap  
 var__temp_v303 --->  Ty_int  
 var__temp_h'304 --->  Ty_heap  
 var__temp_v_err305 --->  error  
 var_h265 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h265, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h302, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h302, res ) ==((sel)( , var_h265, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h302, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h302, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'304, res ) ==(var__temp_v303) AND 
 	 Rel (sel)( , var__temp_h'304, res ) ==((sel)( , var__temp_h302, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i266 T1190)
(declare-const var_h265 T1190)
(declare-const v Int)
(declare-const var_h_i226 T1190)
(declare-const var_h225 T1190)
(declare-const v Int)
(declare-const var_h_i67 T1190)
(declare-const var_h66 T1190)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h302 T1190)
(declare-const var__temp_v303 Int)
(declare-const |var__temp_h'304| T1190)
(declare-const var__temp_v_err305 T1191)
(declare-const var_h265 T1190)
(declare-const var_h225 T1190)
(declare-const var_h66 T1190)
(declare-const err T1204)

solver 
 (declare-sort T1190)
(declare-fun sel (T1190 Int) Int)
(declare-fun res () Int)
(declare-fun var_h265 () T1190)
(declare-fun var_h225 () T1190)
(declare-fun var__temp_h302 () T1190)
(declare-fun |var__temp_h'304| () T1190)
(declare-fun var__temp_v303 () Int)
(declare-fun v () Int)
(assert (> (sel var_h265 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h302 res) v)
                (= (sel var__temp_h302 res) (+ (sel var_h265 res) 5))))
      (a!2 (and (= (sel |var__temp_h'304| res) var__temp_v303)
                (= (sel |var__temp_h'304| res) (+ (sel var__temp_h302 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h302 res) 7))
                (=> (= (sel var__temp_h302 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c3
 *********************Enumeration Iteration*****************80
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i266 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i266, res ) ==(v)
 	 , (sel)( , var_h_i266, res ) ==((sel)( , var_h265, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v301:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i266 --->  Ty_heap  
 var_h265 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h306 --->  Ty_heap  
 var__temp_v307 --->  Ty_int  
 var__temp_h'308 --->  Ty_heap  
 var__temp_v_err309 --->  error  
 var_h265 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h265, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h306, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h306, res ) ==((sel)( , var_h265, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h306, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h306, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'308, res ) ==(var__temp_v307) AND 
 	 Rel (sel)( , var__temp_h'308, res ) ==((sel)( , var__temp_h306, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i266 T1207)
(declare-const var_h265 T1207)
(declare-const v Int)
(declare-const var_h_i226 T1207)
(declare-const var_h225 T1207)
(declare-const v Int)
(declare-const var_h_i67 T1207)
(declare-const var_h66 T1207)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h306 T1207)
(declare-const var__temp_v307 Int)
(declare-const |var__temp_h'308| T1207)
(declare-const var__temp_v_err309 T1208)
(declare-const var_h265 T1207)
(declare-const var_h225 T1207)
(declare-const var_h66 T1207)
(declare-const err T1221)

solver 
 (declare-sort T1207)
(declare-fun sel (T1207 Int) Int)
(declare-fun res () Int)
(declare-fun var_h265 () T1207)
(declare-fun var_h225 () T1207)
(declare-fun var__temp_h306 () T1207)
(declare-fun |var__temp_h'308| () T1207)
(declare-fun var__temp_v307 () Int)
(declare-fun v () Int)
(assert (> (sel var_h265 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h306 res) v)
                (= (sel var__temp_h306 res) (+ (sel var_h265 res) 5))))
      (a!2 (and (= (sel |var__temp_h'308| res) var__temp_v307)
                (= (sel |var__temp_h'308| res) (+ (sel var__temp_h306 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h306 res) 7))
                (=> (= (sel var__temp_h306 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************81
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i266 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i266, res ) ==(v)
 	 , (sel)( , var_h_i266, res ) ==((sel)( , var_h265, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v301:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i266 --->  Ty_heap  
 var_h265 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h310 --->  Ty_heap  
 var__temp_v311 --->  Ty_int  
 var__temp_h'312 --->  Ty_heap  
 var__temp_v_err313 --->  error  
 var_h265 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h265, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h310, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h310, res ) ==((sel)( , var_h265, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h310, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h310, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'312, res ) ==(var__temp_v311) AND 
 	 Rel (sel)( , var__temp_h'312, res ) ==((sel)( , var__temp_h310, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i266 T1224)
(declare-const var_h265 T1224)
(declare-const v Int)
(declare-const var_h_i226 T1224)
(declare-const var_h225 T1224)
(declare-const v Int)
(declare-const var_h_i67 T1224)
(declare-const var_h66 T1224)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h310 T1224)
(declare-const var__temp_v311 Int)
(declare-const |var__temp_h'312| T1224)
(declare-const var__temp_v_err313 T1225)
(declare-const var_h265 T1224)
(declare-const var_h225 T1224)
(declare-const var_h66 T1224)
(declare-const err T1238)

solver 
 (declare-sort T1224)
(declare-fun sel (T1224 Int) Int)
(declare-fun res () Int)
(declare-fun var_h265 () T1224)
(declare-fun var_h225 () T1224)
(declare-fun var__temp_h310 () T1224)
(declare-fun |var__temp_h'312| () T1224)
(declare-fun var__temp_v311 () Int)
(declare-fun v () Int)
(assert (> (sel var_h265 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h310 res) v)
                (= (sel var__temp_h310 res) (+ (sel var_h265 res) 5))))
      (a!2 (and (= (sel |var__temp_h'312| res) var__temp_v311)
                (= (sel |var__temp_h'312| res) (+ (sel var__temp_h310 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h310 res) 7))
                (=> (= (sel var__temp_h310 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************82
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i266 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i266, res ) ==(v)
 	 , (sel)( , var_h_i266, res ) ==((sel)( , var_h265, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v301:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i266 --->  Ty_heap  
 var_h265 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h314 --->  Ty_heap  
 var__temp_v315 --->  Ty_int  
 var__temp_h'316 --->  Ty_heap  
 var__temp_v_err317 --->  error  
 var_h265 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h265, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h314, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h314, res ) ==((sel)( , var_h265, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h314, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h314, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'316, res ) ==(var__temp_v315) AND 
 	 Rel (sel)( , var__temp_h'316, res ) ==((sel)( , var__temp_h314, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i266 T1241)
(declare-const var_h265 T1241)
(declare-const v Int)
(declare-const var_h_i226 T1241)
(declare-const var_h225 T1241)
(declare-const v Int)
(declare-const var_h_i67 T1241)
(declare-const var_h66 T1241)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h314 T1241)
(declare-const var__temp_v315 Int)
(declare-const |var__temp_h'316| T1241)
(declare-const var__temp_v_err317 T1242)
(declare-const var_h265 T1241)
(declare-const var_h225 T1241)
(declare-const var_h66 T1241)
(declare-const err T1255)

solver 
 (declare-sort T1241)
(declare-fun sel (T1241 Int) Int)
(declare-fun res () Int)
(declare-fun var_h265 () T1241)
(declare-fun var_h225 () T1241)
(declare-fun var__temp_h314 () T1241)
(declare-fun |var__temp_h'316| () T1241)
(declare-fun var__temp_v315 () Int)
(declare-fun v () Int)
(assert (> (sel var_h265 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h314 res) v)
                (= (sel var__temp_h314 res) (+ (sel var_h265 res) 5))))
      (a!2 (and (= (sel |var__temp_h'316| res) var__temp_v315)
                (= (sel |var__temp_h'316| res) (+ (sel var__temp_h314 res) 2)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h314 res) 5))
                (=> (= (sel var__temp_h314 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************83
First component finding failed
{ 
Eret { 
Evar c2'' 
 } 
 }
@HERE
EXPLORED::BEFORETermsc2''c2'c3'c3'c1
EXPLORED::AFTERTermsc2''c2''c2'c3'c3'c1
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i266 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i266, res ) ==(v)
 	 , (sel)( , var_h_i266, res ) ==((sel)( , var_h265, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v318:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c3
c5
c4
c2
 *********************Enumeration Iteration*****************84
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i266 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i266, res ) ==(v)
 	 , (sel)( , var_h_i266, res ) ==((sel)( , var_h265, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v318:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i266 --->  Ty_heap  
 var_h265 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h319 --->  Ty_heap  
 var__temp_v320 --->  Ty_int  
 var__temp_h'321 --->  Ty_heap  
 var__temp_v_err322 --->  error  
 var_h265 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h265, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h319, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h319, res ) ==((sel)( , var_h265, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h319, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h319, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'321, res ) ==(var__temp_v320) AND 
 	 Rel (sel)( , var__temp_h'321, res ) ==((sel)( , var__temp_h319, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i266 T1258)
(declare-const var_h265 T1258)
(declare-const v Int)
(declare-const var_h_i226 T1258)
(declare-const var_h225 T1258)
(declare-const v Int)
(declare-const var_h_i67 T1258)
(declare-const var_h66 T1258)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h319 T1258)
(declare-const var__temp_v320 Int)
(declare-const |var__temp_h'321| T1258)
(declare-const var__temp_v_err322 T1259)
(declare-const var_h265 T1258)
(declare-const var_h225 T1258)
(declare-const var_h66 T1258)
(declare-const err T1272)

solver 
 (declare-sort T1258)
(declare-fun sel (T1258 Int) Int)
(declare-fun res () Int)
(declare-fun var_h265 () T1258)
(declare-fun var_h225 () T1258)
(declare-fun var__temp_h319 () T1258)
(declare-fun |var__temp_h'321| () T1258)
(declare-fun var__temp_v320 () Int)
(declare-fun v () Int)
(assert (> (sel var_h265 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h319 res) v)
                (= (sel var__temp_h319 res) (+ (sel var_h265 res) 5))))
      (a!2 (and (= (sel |var__temp_h'321| res) var__temp_v320)
                (= (sel |var__temp_h'321| res) (+ (sel var__temp_h319 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h319 res) 7))
                (=> (= (sel var__temp_h319 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c3
 *********************Enumeration Iteration*****************85
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i266 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i266, res ) ==(v)
 	 , (sel)( , var_h_i266, res ) ==((sel)( , var_h265, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v318:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i266 --->  Ty_heap  
 var_h265 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h323 --->  Ty_heap  
 var__temp_v324 --->  Ty_int  
 var__temp_h'325 --->  Ty_heap  
 var__temp_v_err326 --->  error  
 var_h265 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h265, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h323, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h323, res ) ==((sel)( , var_h265, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h323, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h323, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'325, res ) ==(var__temp_v324) AND 
 	 Rel (sel)( , var__temp_h'325, res ) ==((sel)( , var__temp_h323, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i266 T1275)
(declare-const var_h265 T1275)
(declare-const v Int)
(declare-const var_h_i226 T1275)
(declare-const var_h225 T1275)
(declare-const v Int)
(declare-const var_h_i67 T1275)
(declare-const var_h66 T1275)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h323 T1275)
(declare-const var__temp_v324 Int)
(declare-const |var__temp_h'325| T1275)
(declare-const var__temp_v_err326 T1276)
(declare-const var_h265 T1275)
(declare-const var_h225 T1275)
(declare-const var_h66 T1275)
(declare-const err T1289)

solver 
 (declare-sort T1275)
(declare-fun sel (T1275 Int) Int)
(declare-fun res () Int)
(declare-fun var_h265 () T1275)
(declare-fun var_h225 () T1275)
(declare-fun var__temp_h323 () T1275)
(declare-fun |var__temp_h'325| () T1275)
(declare-fun var__temp_v324 () Int)
(declare-fun v () Int)
(assert (> (sel var_h265 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h323 res) v)
                (= (sel var__temp_h323 res) (+ (sel var_h265 res) 5))))
      (a!2 (and (= (sel |var__temp_h'325| res) var__temp_v324)
                (= (sel |var__temp_h'325| res) (+ (sel var__temp_h323 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h323 res) 7))
                (=> (= (sel var__temp_h323 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************86
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i266 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i266, res ) ==(v)
 	 , (sel)( , var_h_i266, res ) ==((sel)( , var_h265, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v318:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i266 --->  Ty_heap  
 var_h265 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h327 --->  Ty_heap  
 var__temp_v328 --->  Ty_int  
 var__temp_h'329 --->  Ty_heap  
 var__temp_v_err330 --->  error  
 var_h265 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h265, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h327, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h327, res ) ==((sel)( , var_h265, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h327, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h327, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'329, res ) ==(var__temp_v328) AND 
 	 Rel (sel)( , var__temp_h'329, res ) ==((sel)( , var__temp_h327, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i266 T1292)
(declare-const var_h265 T1292)
(declare-const v Int)
(declare-const var_h_i226 T1292)
(declare-const var_h225 T1292)
(declare-const v Int)
(declare-const var_h_i67 T1292)
(declare-const var_h66 T1292)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h327 T1292)
(declare-const var__temp_v328 Int)
(declare-const |var__temp_h'329| T1292)
(declare-const var__temp_v_err330 T1293)
(declare-const var_h265 T1292)
(declare-const var_h225 T1292)
(declare-const var_h66 T1292)
(declare-const err T1306)

solver 
 (declare-sort T1292)
(declare-fun sel (T1292 Int) Int)
(declare-fun res () Int)
(declare-fun var_h265 () T1292)
(declare-fun var_h225 () T1292)
(declare-fun var__temp_h327 () T1292)
(declare-fun |var__temp_h'329| () T1292)
(declare-fun var__temp_v328 () Int)
(declare-fun v () Int)
(assert (> (sel var_h265 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h327 res) v)
                (= (sel var__temp_h327 res) (+ (sel var_h265 res) 5))))
      (a!2 (and (= (sel |var__temp_h'329| res) var__temp_v328)
                (= (sel |var__temp_h'329| res) (+ (sel var__temp_h327 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h327 res) 7))
                (=> (= (sel var__temp_h327 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************87
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i266 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i266, res ) ==(v)
 	 , (sel)( , var_h_i266, res ) ==((sel)( , var_h265, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v318:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i266 --->  Ty_heap  
 var_h265 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h331 --->  Ty_heap  
 var__temp_v332 --->  Ty_int  
 var__temp_h'333 --->  Ty_heap  
 var__temp_v_err334 --->  error  
 var_h265 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h265, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h331, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h331, res ) ==((sel)( , var_h265, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h331, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h331, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'333, res ) ==(var__temp_v332) AND 
 	 Rel (sel)( , var__temp_h'333, res ) ==((sel)( , var__temp_h331, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i266 T1309)
(declare-const var_h265 T1309)
(declare-const v Int)
(declare-const var_h_i226 T1309)
(declare-const var_h225 T1309)
(declare-const v Int)
(declare-const var_h_i67 T1309)
(declare-const var_h66 T1309)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h331 T1309)
(declare-const var__temp_v332 Int)
(declare-const |var__temp_h'333| T1309)
(declare-const var__temp_v_err334 T1310)
(declare-const var_h265 T1309)
(declare-const var_h225 T1309)
(declare-const var_h66 T1309)
(declare-const err T1323)

solver 
 (declare-sort T1309)
(declare-fun sel (T1309 Int) Int)
(declare-fun res () Int)
(declare-fun var_h265 () T1309)
(declare-fun var_h225 () T1309)
(declare-fun var__temp_h331 () T1309)
(declare-fun |var__temp_h'333| () T1309)
(declare-fun var__temp_v332 () Int)
(declare-fun v () Int)
(assert (> (sel var_h265 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h331 res) v)
                (= (sel var__temp_h331 res) (+ (sel var_h265 res) 5))))
      (a!2 (and (= (sel |var__temp_h'333| res) var__temp_v332)
                (= (sel |var__temp_h'333| res) (+ (sel var__temp_h331 res) 2)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h331 res) 5))
                (=> (= (sel var__temp_h331 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************88
First component finding failed
EXPLORED2 Termsc2''c2''c2'c3'c3'c1
esynthesizeBind
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i226 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i226, res ) ==(v)
 	 , (sel)( , var_h_i226, res ) ==((sel)( , var_h225, res ) + (1)) >c  } 
 } 
 
                                                RET :  Base {var_v335:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c3
c5
c4
c2
 *********************Enumeration Iteration*****************89
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i226 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i226, res ) ==(v)
 	 , (sel)( , var_h_i226, res ) ==((sel)( , var_h225, res ) + (1)) >c  } 
 } 
 
                                                RET :  Base {var_v335:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h336 --->  Ty_heap  
 var__temp_v337 --->  Ty_int  
 var__temp_h'338 --->  Ty_heap  
 var__temp_v_err339 --->  error  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h336, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h336, res ) ==((sel)( , var_h225, res ) + (1)) => 
 	 Rel (sel)( , var__temp_h336, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h336, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'338, res ) ==(var__temp_v337) AND 
 	 Rel (sel)( , var__temp_h'338, res ) ==((sel)( , var__temp_h336, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i226 T1326)
(declare-const var_h225 T1326)
(declare-const v Int)
(declare-const var_h_i67 T1326)
(declare-const var_h66 T1326)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h336 T1326)
(declare-const var__temp_v337 Int)
(declare-const |var__temp_h'338| T1326)
(declare-const var__temp_v_err339 T1327)
(declare-const var_h225 T1326)
(declare-const var_h66 T1326)
(declare-const err T1340)

solver 
 (declare-sort T1326)
(declare-fun sel (T1326 Int) Int)
(declare-fun res () Int)
(declare-fun var_h225 () T1326)
(declare-fun var__temp_h336 () T1326)
(declare-fun |var__temp_h'338| () T1326)
(declare-fun var__temp_v337 () Int)
(declare-fun v () Int)
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h336 res) v)
                (= (sel var__temp_h336 res) (+ (sel var_h225 res) 1))))
      (a!2 (and (= (sel |var__temp_h'338| res) var__temp_v337)
                (= (sel |var__temp_h'338| res) (+ (sel var__temp_h336 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h336 res) 7))
                (=> (= (sel var__temp_h336 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c3
 *********************Enumeration Iteration*****************90
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i226 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i226, res ) ==(v)
 	 , (sel)( , var_h_i226, res ) ==((sel)( , var_h225, res ) + (1)) >c  } 
 } 
 
                                                RET :  Base {var_v335:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h340 --->  Ty_heap  
 var__temp_v341 --->  Ty_int  
 var__temp_h'342 --->  Ty_heap  
 var__temp_v_err343 --->  error  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h340, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h340, res ) ==((sel)( , var_h225, res ) + (1)) => 
 	 Rel (sel)( , var__temp_h340, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h340, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'342, res ) ==(var__temp_v341) AND 
 	 Rel (sel)( , var__temp_h'342, res ) ==((sel)( , var__temp_h340, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i226 T1343)
(declare-const var_h225 T1343)
(declare-const v Int)
(declare-const var_h_i67 T1343)
(declare-const var_h66 T1343)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h340 T1343)
(declare-const var__temp_v341 Int)
(declare-const |var__temp_h'342| T1343)
(declare-const var__temp_v_err343 T1344)
(declare-const var_h225 T1343)
(declare-const var_h66 T1343)
(declare-const err T1357)

solver 
 (declare-sort T1343)
(declare-fun sel (T1343 Int) Int)
(declare-fun res () Int)
(declare-fun var_h225 () T1343)
(declare-fun var__temp_h340 () T1343)
(declare-fun |var__temp_h'342| () T1343)
(declare-fun var__temp_v341 () Int)
(declare-fun v () Int)
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h340 res) v)
                (= (sel var__temp_h340 res) (+ (sel var_h225 res) 1))))
      (a!2 (and (= (sel |var__temp_h'342| res) var__temp_v341)
                (= (sel |var__temp_h'342| res) (+ (sel var__temp_h340 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h340 res) 7))
                (=> (= (sel var__temp_h340 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************91
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i226 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i226, res ) ==(v)
 	 , (sel)( , var_h_i226, res ) ==((sel)( , var_h225, res ) + (1)) >c  } 
 } 
 
                                                RET :  Base {var_v335:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h344 --->  Ty_heap  
 var__temp_v345 --->  Ty_int  
 var__temp_h'346 --->  Ty_heap  
 var__temp_v_err347 --->  error  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h344, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h344, res ) ==((sel)( , var_h225, res ) + (1)) => 
 	 Rel (sel)( , var__temp_h344, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h344, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'346, res ) ==(var__temp_v345) AND 
 	 Rel (sel)( , var__temp_h'346, res ) ==((sel)( , var__temp_h344, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i226 T1360)
(declare-const var_h225 T1360)
(declare-const v Int)
(declare-const var_h_i67 T1360)
(declare-const var_h66 T1360)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h344 T1360)
(declare-const var__temp_v345 Int)
(declare-const |var__temp_h'346| T1360)
(declare-const var__temp_v_err347 T1361)
(declare-const var_h225 T1360)
(declare-const var_h66 T1360)
(declare-const err T1374)

solver 
 (declare-sort T1360)
(declare-fun sel (T1360 Int) Int)
(declare-fun res () Int)
(declare-fun var_h225 () T1360)
(declare-fun var__temp_h344 () T1360)
(declare-fun |var__temp_h'346| () T1360)
(declare-fun var__temp_v345 () Int)
(declare-fun v () Int)
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h344 res) v)
                (= (sel var__temp_h344 res) (+ (sel var_h225 res) 1))))
      (a!2 (and (= (sel |var__temp_h'346| res) var__temp_v345)
                (= (sel |var__temp_h'346| res) (+ (sel var__temp_h344 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h344 res) 7))
                (=> (= (sel var__temp_h344 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************92
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i226 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i226, res ) ==(v)
 	 , (sel)( , var_h_i226, res ) ==((sel)( , var_h225, res ) + (1)) >c  } 
 } 
 
                                                RET :  Base {var_v335:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h348 --->  Ty_heap  
 var__temp_v349 --->  Ty_int  
 var__temp_h'350 --->  Ty_heap  
 var__temp_v_err351 --->  error  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h348, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h348, res ) ==((sel)( , var_h225, res ) + (1)) => 
 	 Rel (sel)( , var__temp_h348, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h348, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'350, res ) ==(var__temp_v349) AND 
 	 Rel (sel)( , var__temp_h'350, res ) ==((sel)( , var__temp_h348, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i226 T1377)
(declare-const var_h225 T1377)
(declare-const v Int)
(declare-const var_h_i67 T1377)
(declare-const var_h66 T1377)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h348 T1377)
(declare-const var__temp_v349 Int)
(declare-const |var__temp_h'350| T1377)
(declare-const var__temp_v_err351 T1378)
(declare-const var_h225 T1377)
(declare-const var_h66 T1377)
(declare-const err T1391)

solver 
 (declare-sort T1377)
(declare-fun sel (T1377 Int) Int)
(declare-fun res () Int)
(declare-fun var_h225 () T1377)
(declare-fun var__temp_h348 () T1377)
(declare-fun |var__temp_h'350| () T1377)
(declare-fun var__temp_v349 () Int)
(declare-fun v () Int)
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h348 res) v)
                (= (sel var__temp_h348 res) (+ (sel var_h225 res) 1))))
      (a!2 (and (= (sel |var__temp_h'350| res) var__temp_v349)
                (= (sel |var__temp_h'350| res) (+ (sel var__temp_h348 res) 2)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h348 res) 5))
                (=> (= (sel var__temp_h348 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************93
First component finding failed
{ 
Eret { 
Evar c2' 
 } 
 }
@HERE
EXPLORED::BEFORETermsc2'c3'c3'c1
EXPLORED::AFTERTermsc2'c2'c3'c3'c1
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i226 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i226, res ) ==(v)
 	 , (sel)( , var_h_i226, res ) ==((sel)( , var_h225, res ) + (1)) >c  } 
 } 
 
                                                RET :  Base {var_v352:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c3
c5
c4
c2''
c2
 *********************Enumeration Iteration*****************94
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i226 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i226, res ) ==(v)
 	 , (sel)( , var_h_i226, res ) ==((sel)( , var_h225, res ) + (1)) >c  } 
 } 
 
                                                RET :  Base {var_v352:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h353 --->  Ty_heap  
 var__temp_v354 --->  Ty_int  
 var__temp_h'355 --->  Ty_heap  
 var__temp_v_err356 --->  error  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h353, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h353, res ) ==((sel)( , var_h225, res ) + (1)) => 
 	 Rel (sel)( , var__temp_h353, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h353, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'355, res ) ==(var__temp_v354) AND 
 	 Rel (sel)( , var__temp_h'355, res ) ==((sel)( , var__temp_h353, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i226 T1394)
(declare-const var_h225 T1394)
(declare-const v Int)
(declare-const var_h_i67 T1394)
(declare-const var_h66 T1394)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h353 T1394)
(declare-const var__temp_v354 Int)
(declare-const |var__temp_h'355| T1394)
(declare-const var__temp_v_err356 T1395)
(declare-const var_h225 T1394)
(declare-const var_h66 T1394)
(declare-const err T1408)

solver 
 (declare-sort T1394)
(declare-fun sel (T1394 Int) Int)
(declare-fun res () Int)
(declare-fun var_h225 () T1394)
(declare-fun var__temp_h353 () T1394)
(declare-fun |var__temp_h'355| () T1394)
(declare-fun var__temp_v354 () Int)
(declare-fun v () Int)
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h353 res) v)
                (= (sel var__temp_h353 res) (+ (sel var_h225 res) 1))))
      (a!2 (and (= (sel |var__temp_h'355| res) var__temp_v354)
                (= (sel |var__temp_h'355| res) (+ (sel var__temp_h353 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h353 res) 7))
                (=> (= (sel var__temp_h353 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c3
 *********************Enumeration Iteration*****************95
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i226 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i226, res ) ==(v)
 	 , (sel)( , var_h_i226, res ) ==((sel)( , var_h225, res ) + (1)) >c  } 
 } 
 
                                                RET :  Base {var_v352:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h357 --->  Ty_heap  
 var__temp_v358 --->  Ty_int  
 var__temp_h'359 --->  Ty_heap  
 var__temp_v_err360 --->  error  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h357, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h357, res ) ==((sel)( , var_h225, res ) + (1)) => 
 	 Rel (sel)( , var__temp_h357, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h357, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'359, res ) ==(var__temp_v358) AND 
 	 Rel (sel)( , var__temp_h'359, res ) ==((sel)( , var__temp_h357, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i226 T1411)
(declare-const var_h225 T1411)
(declare-const v Int)
(declare-const var_h_i67 T1411)
(declare-const var_h66 T1411)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h357 T1411)
(declare-const var__temp_v358 Int)
(declare-const |var__temp_h'359| T1411)
(declare-const var__temp_v_err360 T1412)
(declare-const var_h225 T1411)
(declare-const var_h66 T1411)
(declare-const err T1425)

solver 
 (declare-sort T1411)
(declare-fun sel (T1411 Int) Int)
(declare-fun res () Int)
(declare-fun var_h225 () T1411)
(declare-fun var__temp_h357 () T1411)
(declare-fun |var__temp_h'359| () T1411)
(declare-fun var__temp_v358 () Int)
(declare-fun v () Int)
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h357 res) v)
                (= (sel var__temp_h357 res) (+ (sel var_h225 res) 1))))
      (a!2 (and (= (sel |var__temp_h'359| res) var__temp_v358)
                (= (sel |var__temp_h'359| res) (+ (sel var__temp_h357 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h357 res) 7))
                (=> (= (sel var__temp_h357 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************96
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i226 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i226, res ) ==(v)
 	 , (sel)( , var_h_i226, res ) ==((sel)( , var_h225, res ) + (1)) >c  } 
 } 
 
                                                RET :  Base {var_v352:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h361 --->  Ty_heap  
 var__temp_v362 --->  Ty_int  
 var__temp_h'363 --->  Ty_heap  
 var__temp_v_err364 --->  error  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h361, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h361, res ) ==((sel)( , var_h225, res ) + (1)) => 
 	 Rel (sel)( , var__temp_h361, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h361, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'363, res ) ==(var__temp_v362) AND 
 	 Rel (sel)( , var__temp_h'363, res ) ==((sel)( , var__temp_h361, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i226 T1428)
(declare-const var_h225 T1428)
(declare-const v Int)
(declare-const var_h_i67 T1428)
(declare-const var_h66 T1428)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h361 T1428)
(declare-const var__temp_v362 Int)
(declare-const |var__temp_h'363| T1428)
(declare-const var__temp_v_err364 T1429)
(declare-const var_h225 T1428)
(declare-const var_h66 T1428)
(declare-const err T1442)

solver 
 (declare-sort T1428)
(declare-fun sel (T1428 Int) Int)
(declare-fun res () Int)
(declare-fun var_h225 () T1428)
(declare-fun var__temp_h361 () T1428)
(declare-fun |var__temp_h'363| () T1428)
(declare-fun var__temp_v362 () Int)
(declare-fun v () Int)
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h361 res) v)
                (= (sel var__temp_h361 res) (+ (sel var_h225 res) 1))))
      (a!2 (and (= (sel |var__temp_h'363| res) var__temp_v362)
                (= (sel |var__temp_h'363| res) (+ (sel var__temp_h361 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h361 res) 7))
                (=> (= (sel var__temp_h361 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************97
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i226 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i226, res ) ==(v)
 	 , (sel)( , var_h_i226, res ) ==((sel)( , var_h225, res ) + (1)) >c  } 
 } 
 
                                                RET :  Base {var_v352:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h365 --->  Ty_heap  
 var__temp_v366 --->  Ty_int  
 var__temp_h'367 --->  Ty_heap  
 var__temp_v_err368 --->  error  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h365, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h365, res ) ==((sel)( , var_h225, res ) + (1)) => 
 	 Rel (sel)( , var__temp_h365, res ) > (5) AND 
 	 Rel (sel)( , var__temp_h365, res ) > (5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'367, res ) ==(var__temp_v366) AND 
 	 Rel (sel)( , var__temp_h'367, res ) ==((sel)( , var__temp_h365, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i226 T1445)
(declare-const var_h225 T1445)
(declare-const v Int)
(declare-const var_h_i67 T1445)
(declare-const var_h66 T1445)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h365 T1445)
(declare-const var__temp_v366 Int)
(declare-const |var__temp_h'367| T1445)
(declare-const var__temp_v_err368 T1446)
(declare-const var_h225 T1445)
(declare-const var_h66 T1445)
(declare-const err T1459)

solver 
 (declare-sort T1445)
(declare-fun sel (T1445 Int) Int)
(declare-fun res () Int)
(declare-fun var_h225 () T1445)
(declare-fun var__temp_h365 () T1445)
(declare-fun |var__temp_h'367| () T1445)
(declare-fun var__temp_v366 () Int)
(declare-fun v () Int)
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h365 res) v)
                (= (sel var__temp_h365 res) (+ (sel var_h225 res) 1))))
      (a!2 (and (= (sel |var__temp_h'367| res) var__temp_v366)
                (= (sel |var__temp_h'367| res) (+ (sel var__temp_h365 res) 5)))))
(let ((a!3 (and (=> a!1 (> (sel var__temp_h365 res) 5))
                (=> (> (sel var__temp_h365 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c2''
EXPLORED::BEFORETermsc2'c2'c3'c3'c1
EXPLORED::AFTERTermsc2''c2'c2'c3'c3'c1
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i370 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i370 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i370, res ) ==(v)
 	 , (sel)( , var_h_i370, res ) ==((sel)( , var_h369, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v371:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i370 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
c3
c5
c4
c2
 *********************Enumeration Iteration*****************98
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i370 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i370, res ) ==(v)
 	 , (sel)( , var_h_i370, res ) ==((sel)( , var_h369, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v371:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i370 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i370 --->  Ty_heap  
 var_h369 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h372 --->  Ty_heap  
 var__temp_v373 --->  Ty_int  
 var__temp_h'374 --->  Ty_heap  
 var__temp_v_err375 --->  error  
 var_h369 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h369, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h372, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h372, res ) ==((sel)( , var_h369, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h372, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h372, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'374, res ) ==(var__temp_v373) AND 
 	 Rel (sel)( , var__temp_h'374, res ) ==((sel)( , var__temp_h372, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'374, res ) ==(var__temp_v373) AND 
 	 Rel (sel)( , var__temp_h'374, res ) ==(10)
 
VC_END(declare-const var_h_i370 T1462)
(declare-const var_h369 T1462)
(declare-const v Int)
(declare-const var_h_i226 T1462)
(declare-const var_h225 T1462)
(declare-const v Int)
(declare-const var_h_i67 T1462)
(declare-const var_h66 T1462)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h372 T1462)
(declare-const var__temp_v373 Int)
(declare-const |var__temp_h'374| T1462)
(declare-const var__temp_v_err375 T1463)
(declare-const var_h369 T1462)
(declare-const var_h225 T1462)
(declare-const var_h66 T1462)
(declare-const err T1476)

solver 
 (declare-sort T1462)
(declare-fun sel (T1462 Int) Int)
(declare-fun res () Int)
(declare-fun var_h369 () T1462)
(declare-fun var_h225 () T1462)
(declare-fun |var__temp_h'374| () T1462)
(declare-fun var__temp_v373 () Int)
(declare-fun var__temp_h372 () T1462)
(declare-fun v () Int)
(assert (> (sel var_h369 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h372 res) v)
                (= (sel var__temp_h372 res) (+ (sel var_h369 res) 5))))
      (a!2 (and (= (sel |var__temp_h'374| res) var__temp_v373)
                (= (sel |var__temp_h'374| res) (+ (sel var__temp_h372 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'374| res) var__temp_v373)
                    (= (sel |var__temp_h'374| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h372 res) 7))
                (=> (= (sel var__temp_h372 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c3
 *********************Enumeration Iteration*****************99
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i370 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i370, res ) ==(v)
 	 , (sel)( , var_h_i370, res ) ==((sel)( , var_h369, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v371:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i370 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i370 --->  Ty_heap  
 var_h369 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h376 --->  Ty_heap  
 var__temp_v377 --->  Ty_int  
 var__temp_h'378 --->  Ty_heap  
 var__temp_v_err379 --->  error  
 var_h369 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h369, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h376, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h376, res ) ==((sel)( , var_h369, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h376, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h376, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'378, res ) ==(var__temp_v377) AND 
 	 Rel (sel)( , var__temp_h'378, res ) ==((sel)( , var__temp_h376, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'378, res ) ==(var__temp_v377) AND 
 	 Rel (sel)( , var__temp_h'378, res ) ==(10)
 
VC_END(declare-const var_h_i370 T1479)
(declare-const var_h369 T1479)
(declare-const v Int)
(declare-const var_h_i226 T1479)
(declare-const var_h225 T1479)
(declare-const v Int)
(declare-const var_h_i67 T1479)
(declare-const var_h66 T1479)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h376 T1479)
(declare-const var__temp_v377 Int)
(declare-const |var__temp_h'378| T1479)
(declare-const var__temp_v_err379 T1480)
(declare-const var_h369 T1479)
(declare-const var_h225 T1479)
(declare-const var_h66 T1479)
(declare-const err T1493)

solver 
 (declare-sort T1479)
(declare-fun sel (T1479 Int) Int)
(declare-fun res () Int)
(declare-fun var_h369 () T1479)
(declare-fun var_h225 () T1479)
(declare-fun |var__temp_h'378| () T1479)
(declare-fun var__temp_v377 () Int)
(declare-fun var__temp_h376 () T1479)
(declare-fun v () Int)
(assert (> (sel var_h369 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h376 res) v)
                (= (sel var__temp_h376 res) (+ (sel var_h369 res) 5))))
      (a!2 (and (= (sel |var__temp_h'378| res) var__temp_v377)
                (= (sel |var__temp_h'378| res) (+ (sel var__temp_h376 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'378| res) var__temp_v377)
                    (= (sel |var__temp_h'378| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h376 res) 7))
                (=> (= (sel var__temp_h376 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************100
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i370 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i370, res ) ==(v)
 	 , (sel)( , var_h_i370, res ) ==((sel)( , var_h369, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v371:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i370 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i370 --->  Ty_heap  
 var_h369 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h380 --->  Ty_heap  
 var__temp_v381 --->  Ty_int  
 var__temp_h'382 --->  Ty_heap  
 var__temp_v_err383 --->  error  
 var_h369 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h369, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h380, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h380, res ) ==((sel)( , var_h369, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h380, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h380, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'382, res ) ==(var__temp_v381) AND 
 	 Rel (sel)( , var__temp_h'382, res ) ==((sel)( , var__temp_h380, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'382, res ) ==(var__temp_v381) AND 
 	 Rel (sel)( , var__temp_h'382, res ) ==(10)
 
VC_END(declare-const var_h_i370 T1496)
(declare-const var_h369 T1496)
(declare-const v Int)
(declare-const var_h_i226 T1496)
(declare-const var_h225 T1496)
(declare-const v Int)
(declare-const var_h_i67 T1496)
(declare-const var_h66 T1496)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h380 T1496)
(declare-const var__temp_v381 Int)
(declare-const |var__temp_h'382| T1496)
(declare-const var__temp_v_err383 T1497)
(declare-const var_h369 T1496)
(declare-const var_h225 T1496)
(declare-const var_h66 T1496)
(declare-const err T1510)

solver 
 (declare-sort T1496)
(declare-fun sel (T1496 Int) Int)
(declare-fun res () Int)
(declare-fun var_h369 () T1496)
(declare-fun var_h225 () T1496)
(declare-fun |var__temp_h'382| () T1496)
(declare-fun var__temp_v381 () Int)
(declare-fun var__temp_h380 () T1496)
(declare-fun v () Int)
(assert (> (sel var_h369 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h380 res) v)
                (= (sel var__temp_h380 res) (+ (sel var_h369 res) 5))))
      (a!2 (and (= (sel |var__temp_h'382| res) var__temp_v381)
                (= (sel |var__temp_h'382| res) (+ (sel var__temp_h380 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'382| res) var__temp_v381)
                    (= (sel |var__temp_h'382| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h380 res) 7))
                (=> (= (sel var__temp_h380 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************101
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i370 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i370, res ) ==(v)
 	 , (sel)( , var_h_i370, res ) ==((sel)( , var_h369, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v371:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i370 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i370 --->  Ty_heap  
 var_h369 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h384 --->  Ty_heap  
 var__temp_v385 --->  Ty_int  
 var__temp_h'386 --->  Ty_heap  
 var__temp_v_err387 --->  error  
 var_h369 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h369, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h384, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h384, res ) ==((sel)( , var_h369, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h384, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h384, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'386, res ) ==(var__temp_v385) AND 
 	 Rel (sel)( , var__temp_h'386, res ) ==((sel)( , var__temp_h384, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'386, res ) ==(var__temp_v385) AND 
 	 Rel (sel)( , var__temp_h'386, res ) ==(10)
 
VC_END(declare-const var_h_i370 T1513)
(declare-const var_h369 T1513)
(declare-const v Int)
(declare-const var_h_i226 T1513)
(declare-const var_h225 T1513)
(declare-const v Int)
(declare-const var_h_i67 T1513)
(declare-const var_h66 T1513)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h384 T1513)
(declare-const var__temp_v385 Int)
(declare-const |var__temp_h'386| T1513)
(declare-const var__temp_v_err387 T1514)
(declare-const var_h369 T1513)
(declare-const var_h225 T1513)
(declare-const var_h66 T1513)
(declare-const err T1527)

solver 
 (declare-sort T1513)
(declare-fun sel (T1513 Int) Int)
(declare-fun res () Int)
(declare-fun var_h369 () T1513)
(declare-fun var_h225 () T1513)
(declare-fun |var__temp_h'386| () T1513)
(declare-fun var__temp_v385 () Int)
(declare-fun var__temp_h384 () T1513)
(declare-fun v () Int)
(assert (> (sel var_h369 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h384 res) v)
                (= (sel var__temp_h384 res) (+ (sel var_h369 res) 5))))
      (a!2 (and (= (sel |var__temp_h'386| res) var__temp_v385)
                (= (sel |var__temp_h'386| res) (+ (sel var__temp_h384 res) 2)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'386| res) var__temp_v385)
                    (= (sel |var__temp_h'386| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h384 res) 5))
                (=> (= (sel var__temp_h384 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************102
 Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v371:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v371:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2''c2'c2'c3'c3'c1
esynthesizeBind
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i370 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i370, res ) ==(v)
 	 , (sel)( , var_h_i370, res ) ==((sel)( , var_h369, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v388:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c3
c5
c4
c2
 *********************Enumeration Iteration*****************103
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i370 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i370, res ) ==(v)
 	 , (sel)( , var_h_i370, res ) ==((sel)( , var_h369, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v388:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i370 --->  Ty_heap  
 var_h369 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h389 --->  Ty_heap  
 var__temp_v390 --->  Ty_int  
 var__temp_h'391 --->  Ty_heap  
 var__temp_v_err392 --->  error  
 var_h369 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h369, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h389, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h389, res ) ==((sel)( , var_h369, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h389, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h389, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'391, res ) ==(var__temp_v390) AND 
 	 Rel (sel)( , var__temp_h'391, res ) ==((sel)( , var__temp_h389, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i370 T1530)
(declare-const var_h369 T1530)
(declare-const v Int)
(declare-const var_h_i226 T1530)
(declare-const var_h225 T1530)
(declare-const v Int)
(declare-const var_h_i67 T1530)
(declare-const var_h66 T1530)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h389 T1530)
(declare-const var__temp_v390 Int)
(declare-const |var__temp_h'391| T1530)
(declare-const var__temp_v_err392 T1531)
(declare-const var_h369 T1530)
(declare-const var_h225 T1530)
(declare-const var_h66 T1530)
(declare-const err T1544)

solver 
 (declare-sort T1530)
(declare-fun sel (T1530 Int) Int)
(declare-fun res () Int)
(declare-fun var_h369 () T1530)
(declare-fun var_h225 () T1530)
(declare-fun var__temp_h389 () T1530)
(declare-fun |var__temp_h'391| () T1530)
(declare-fun var__temp_v390 () Int)
(declare-fun v () Int)
(assert (> (sel var_h369 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h389 res) v)
                (= (sel var__temp_h389 res) (+ (sel var_h369 res) 5))))
      (a!2 (and (= (sel |var__temp_h'391| res) var__temp_v390)
                (= (sel |var__temp_h'391| res) (+ (sel var__temp_h389 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h389 res) 7))
                (=> (= (sel var__temp_h389 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c3
 *********************Enumeration Iteration*****************104
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i370 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i370, res ) ==(v)
 	 , (sel)( , var_h_i370, res ) ==((sel)( , var_h369, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v388:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i370 --->  Ty_heap  
 var_h369 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h393 --->  Ty_heap  
 var__temp_v394 --->  Ty_int  
 var__temp_h'395 --->  Ty_heap  
 var__temp_v_err396 --->  error  
 var_h369 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h369, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h393, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h393, res ) ==((sel)( , var_h369, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h393, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h393, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'395, res ) ==(var__temp_v394) AND 
 	 Rel (sel)( , var__temp_h'395, res ) ==((sel)( , var__temp_h393, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i370 T1547)
(declare-const var_h369 T1547)
(declare-const v Int)
(declare-const var_h_i226 T1547)
(declare-const var_h225 T1547)
(declare-const v Int)
(declare-const var_h_i67 T1547)
(declare-const var_h66 T1547)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h393 T1547)
(declare-const var__temp_v394 Int)
(declare-const |var__temp_h'395| T1547)
(declare-const var__temp_v_err396 T1548)
(declare-const var_h369 T1547)
(declare-const var_h225 T1547)
(declare-const var_h66 T1547)
(declare-const err T1561)

solver 
 (declare-sort T1547)
(declare-fun sel (T1547 Int) Int)
(declare-fun res () Int)
(declare-fun var_h369 () T1547)
(declare-fun var_h225 () T1547)
(declare-fun var__temp_h393 () T1547)
(declare-fun |var__temp_h'395| () T1547)
(declare-fun var__temp_v394 () Int)
(declare-fun v () Int)
(assert (> (sel var_h369 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h393 res) v)
                (= (sel var__temp_h393 res) (+ (sel var_h369 res) 5))))
      (a!2 (and (= (sel |var__temp_h'395| res) var__temp_v394)
                (= (sel |var__temp_h'395| res) (+ (sel var__temp_h393 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h393 res) 7))
                (=> (= (sel var__temp_h393 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************105
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i370 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i370, res ) ==(v)
 	 , (sel)( , var_h_i370, res ) ==((sel)( , var_h369, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v388:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i370 --->  Ty_heap  
 var_h369 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h397 --->  Ty_heap  
 var__temp_v398 --->  Ty_int  
 var__temp_h'399 --->  Ty_heap  
 var__temp_v_err400 --->  error  
 var_h369 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h369, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h397, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h397, res ) ==((sel)( , var_h369, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h397, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h397, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'399, res ) ==(var__temp_v398) AND 
 	 Rel (sel)( , var__temp_h'399, res ) ==((sel)( , var__temp_h397, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i370 T1564)
(declare-const var_h369 T1564)
(declare-const v Int)
(declare-const var_h_i226 T1564)
(declare-const var_h225 T1564)
(declare-const v Int)
(declare-const var_h_i67 T1564)
(declare-const var_h66 T1564)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h397 T1564)
(declare-const var__temp_v398 Int)
(declare-const |var__temp_h'399| T1564)
(declare-const var__temp_v_err400 T1565)
(declare-const var_h369 T1564)
(declare-const var_h225 T1564)
(declare-const var_h66 T1564)
(declare-const err T1578)

solver 
 (declare-sort T1564)
(declare-fun sel (T1564 Int) Int)
(declare-fun res () Int)
(declare-fun var_h369 () T1564)
(declare-fun var_h225 () T1564)
(declare-fun var__temp_h397 () T1564)
(declare-fun |var__temp_h'399| () T1564)
(declare-fun var__temp_v398 () Int)
(declare-fun v () Int)
(assert (> (sel var_h369 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h397 res) v)
                (= (sel var__temp_h397 res) (+ (sel var_h369 res) 5))))
      (a!2 (and (= (sel |var__temp_h'399| res) var__temp_v398)
                (= (sel |var__temp_h'399| res) (+ (sel var__temp_h397 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h397 res) 7))
                (=> (= (sel var__temp_h397 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************106
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i370 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i370, res ) ==(v)
 	 , (sel)( , var_h_i370, res ) ==((sel)( , var_h369, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v388:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i370 --->  Ty_heap  
 var_h369 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h401 --->  Ty_heap  
 var__temp_v402 --->  Ty_int  
 var__temp_h'403 --->  Ty_heap  
 var__temp_v_err404 --->  error  
 var_h369 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h369, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h401, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h401, res ) ==((sel)( , var_h369, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h401, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h401, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'403, res ) ==(var__temp_v402) AND 
 	 Rel (sel)( , var__temp_h'403, res ) ==((sel)( , var__temp_h401, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i370 T1581)
(declare-const var_h369 T1581)
(declare-const v Int)
(declare-const var_h_i226 T1581)
(declare-const var_h225 T1581)
(declare-const v Int)
(declare-const var_h_i67 T1581)
(declare-const var_h66 T1581)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h401 T1581)
(declare-const var__temp_v402 Int)
(declare-const |var__temp_h'403| T1581)
(declare-const var__temp_v_err404 T1582)
(declare-const var_h369 T1581)
(declare-const var_h225 T1581)
(declare-const var_h66 T1581)
(declare-const err T1595)

solver 
 (declare-sort T1581)
(declare-fun sel (T1581 Int) Int)
(declare-fun res () Int)
(declare-fun var_h369 () T1581)
(declare-fun var_h225 () T1581)
(declare-fun var__temp_h401 () T1581)
(declare-fun |var__temp_h'403| () T1581)
(declare-fun var__temp_v402 () Int)
(declare-fun v () Int)
(assert (> (sel var_h369 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h401 res) v)
                (= (sel var__temp_h401 res) (+ (sel var_h369 res) 5))))
      (a!2 (and (= (sel |var__temp_h'403| res) var__temp_v402)
                (= (sel |var__temp_h'403| res) (+ (sel var__temp_h401 res) 2)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h401 res) 5))
                (=> (= (sel var__temp_h401 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************107
First component finding failed
EXPLORED2 Termsc2''c2'c2'c3'c3'c1
esynthesizeBind
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i370 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i370, res ) ==(v)
 	 , (sel)( , var_h_i370, res ) ==((sel)( , var_h369, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v405:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c3
c5
c4
c2
 *********************Enumeration Iteration*****************108
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i370 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i370, res ) ==(v)
 	 , (sel)( , var_h_i370, res ) ==((sel)( , var_h369, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v405:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i370 --->  Ty_heap  
 var_h369 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h406 --->  Ty_heap  
 var__temp_v407 --->  Ty_int  
 var__temp_h'408 --->  Ty_heap  
 var__temp_v_err409 --->  error  
 var_h369 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h369, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h406, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h406, res ) ==((sel)( , var_h369, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h406, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h406, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'408, res ) ==(var__temp_v407) AND 
 	 Rel (sel)( , var__temp_h'408, res ) ==((sel)( , var__temp_h406, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i370 T1598)
(declare-const var_h369 T1598)
(declare-const v Int)
(declare-const var_h_i226 T1598)
(declare-const var_h225 T1598)
(declare-const v Int)
(declare-const var_h_i67 T1598)
(declare-const var_h66 T1598)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h406 T1598)
(declare-const var__temp_v407 Int)
(declare-const |var__temp_h'408| T1598)
(declare-const var__temp_v_err409 T1599)
(declare-const var_h369 T1598)
(declare-const var_h225 T1598)
(declare-const var_h66 T1598)
(declare-const err T1612)

solver 
 (declare-sort T1598)
(declare-fun sel (T1598 Int) Int)
(declare-fun res () Int)
(declare-fun var_h369 () T1598)
(declare-fun var_h225 () T1598)
(declare-fun var__temp_h406 () T1598)
(declare-fun |var__temp_h'408| () T1598)
(declare-fun var__temp_v407 () Int)
(declare-fun v () Int)
(assert (> (sel var_h369 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h406 res) v)
                (= (sel var__temp_h406 res) (+ (sel var_h369 res) 5))))
      (a!2 (and (= (sel |var__temp_h'408| res) var__temp_v407)
                (= (sel |var__temp_h'408| res) (+ (sel var__temp_h406 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h406 res) 7))
                (=> (= (sel var__temp_h406 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c3
 *********************Enumeration Iteration*****************109
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i370 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i370, res ) ==(v)
 	 , (sel)( , var_h_i370, res ) ==((sel)( , var_h369, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v405:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i370 --->  Ty_heap  
 var_h369 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h410 --->  Ty_heap  
 var__temp_v411 --->  Ty_int  
 var__temp_h'412 --->  Ty_heap  
 var__temp_v_err413 --->  error  
 var_h369 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h369, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h410, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h410, res ) ==((sel)( , var_h369, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h410, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h410, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'412, res ) ==(var__temp_v411) AND 
 	 Rel (sel)( , var__temp_h'412, res ) ==((sel)( , var__temp_h410, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i370 T1615)
(declare-const var_h369 T1615)
(declare-const v Int)
(declare-const var_h_i226 T1615)
(declare-const var_h225 T1615)
(declare-const v Int)
(declare-const var_h_i67 T1615)
(declare-const var_h66 T1615)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h410 T1615)
(declare-const var__temp_v411 Int)
(declare-const |var__temp_h'412| T1615)
(declare-const var__temp_v_err413 T1616)
(declare-const var_h369 T1615)
(declare-const var_h225 T1615)
(declare-const var_h66 T1615)
(declare-const err T1629)

solver 
 (declare-sort T1615)
(declare-fun sel (T1615 Int) Int)
(declare-fun res () Int)
(declare-fun var_h369 () T1615)
(declare-fun var_h225 () T1615)
(declare-fun var__temp_h410 () T1615)
(declare-fun |var__temp_h'412| () T1615)
(declare-fun var__temp_v411 () Int)
(declare-fun v () Int)
(assert (> (sel var_h369 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h410 res) v)
                (= (sel var__temp_h410 res) (+ (sel var_h369 res) 5))))
      (a!2 (and (= (sel |var__temp_h'412| res) var__temp_v411)
                (= (sel |var__temp_h'412| res) (+ (sel var__temp_h410 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h410 res) 7))
                (=> (= (sel var__temp_h410 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************110
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i370 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i370, res ) ==(v)
 	 , (sel)( , var_h_i370, res ) ==((sel)( , var_h369, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v405:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i370 --->  Ty_heap  
 var_h369 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h414 --->  Ty_heap  
 var__temp_v415 --->  Ty_int  
 var__temp_h'416 --->  Ty_heap  
 var__temp_v_err417 --->  error  
 var_h369 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h369, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h414, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h414, res ) ==((sel)( , var_h369, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h414, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h414, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'416, res ) ==(var__temp_v415) AND 
 	 Rel (sel)( , var__temp_h'416, res ) ==((sel)( , var__temp_h414, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i370 T1632)
(declare-const var_h369 T1632)
(declare-const v Int)
(declare-const var_h_i226 T1632)
(declare-const var_h225 T1632)
(declare-const v Int)
(declare-const var_h_i67 T1632)
(declare-const var_h66 T1632)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h414 T1632)
(declare-const var__temp_v415 Int)
(declare-const |var__temp_h'416| T1632)
(declare-const var__temp_v_err417 T1633)
(declare-const var_h369 T1632)
(declare-const var_h225 T1632)
(declare-const var_h66 T1632)
(declare-const err T1646)

solver 
 (declare-sort T1632)
(declare-fun sel (T1632 Int) Int)
(declare-fun res () Int)
(declare-fun var_h369 () T1632)
(declare-fun var_h225 () T1632)
(declare-fun var__temp_h414 () T1632)
(declare-fun |var__temp_h'416| () T1632)
(declare-fun var__temp_v415 () Int)
(declare-fun v () Int)
(assert (> (sel var_h369 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h414 res) v)
                (= (sel var__temp_h414 res) (+ (sel var_h369 res) 5))))
      (a!2 (and (= (sel |var__temp_h'416| res) var__temp_v415)
                (= (sel |var__temp_h'416| res) (+ (sel var__temp_h414 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h414 res) 7))
                (=> (= (sel var__temp_h414 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************111
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i370 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i370, res ) ==(v)
 	 , (sel)( , var_h_i370, res ) ==((sel)( , var_h369, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v405:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i370 --->  Ty_heap  
 var_h369 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h418 --->  Ty_heap  
 var__temp_v419 --->  Ty_int  
 var__temp_h'420 --->  Ty_heap  
 var__temp_v_err421 --->  error  
 var_h369 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h369, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h418, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h418, res ) ==((sel)( , var_h369, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h418, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h418, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'420, res ) ==(var__temp_v419) AND 
 	 Rel (sel)( , var__temp_h'420, res ) ==((sel)( , var__temp_h418, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i370 T1649)
(declare-const var_h369 T1649)
(declare-const v Int)
(declare-const var_h_i226 T1649)
(declare-const var_h225 T1649)
(declare-const v Int)
(declare-const var_h_i67 T1649)
(declare-const var_h66 T1649)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h418 T1649)
(declare-const var__temp_v419 Int)
(declare-const |var__temp_h'420| T1649)
(declare-const var__temp_v_err421 T1650)
(declare-const var_h369 T1649)
(declare-const var_h225 T1649)
(declare-const var_h66 T1649)
(declare-const err T1663)

solver 
 (declare-sort T1649)
(declare-fun sel (T1649 Int) Int)
(declare-fun res () Int)
(declare-fun var_h369 () T1649)
(declare-fun var_h225 () T1649)
(declare-fun var__temp_h418 () T1649)
(declare-fun |var__temp_h'420| () T1649)
(declare-fun var__temp_v419 () Int)
(declare-fun v () Int)
(assert (> (sel var_h369 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h418 res) v)
                (= (sel var__temp_h418 res) (+ (sel var_h369 res) 5))))
      (a!2 (and (= (sel |var__temp_h'420| res) var__temp_v419)
                (= (sel |var__temp_h'420| res) (+ (sel var__temp_h418 res) 2)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h418 res) 5))
                (=> (= (sel var__temp_h418 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************112
First component finding failed
{ 
Eret { 
Evar c2'' 
 } 
 }
@HERE
EXPLORED::BEFORETermsc2''c2'c2'c3'c3'c1
EXPLORED::AFTERTermsc2''c2''c2'c2'c3'c3'c1
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i370 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i370, res ) ==(v)
 	 , (sel)( , var_h_i370, res ) ==((sel)( , var_h369, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v422:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c3
c5
c4
c2
 *********************Enumeration Iteration*****************113
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i370 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i370, res ) ==(v)
 	 , (sel)( , var_h_i370, res ) ==((sel)( , var_h369, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v422:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i370 --->  Ty_heap  
 var_h369 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h423 --->  Ty_heap  
 var__temp_v424 --->  Ty_int  
 var__temp_h'425 --->  Ty_heap  
 var__temp_v_err426 --->  error  
 var_h369 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h369, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h423, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h423, res ) ==((sel)( , var_h369, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h423, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h423, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'425, res ) ==(var__temp_v424) AND 
 	 Rel (sel)( , var__temp_h'425, res ) ==((sel)( , var__temp_h423, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i370 T1666)
(declare-const var_h369 T1666)
(declare-const v Int)
(declare-const var_h_i226 T1666)
(declare-const var_h225 T1666)
(declare-const v Int)
(declare-const var_h_i67 T1666)
(declare-const var_h66 T1666)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h423 T1666)
(declare-const var__temp_v424 Int)
(declare-const |var__temp_h'425| T1666)
(declare-const var__temp_v_err426 T1667)
(declare-const var_h369 T1666)
(declare-const var_h225 T1666)
(declare-const var_h66 T1666)
(declare-const err T1680)

solver 
 (declare-sort T1666)
(declare-fun sel (T1666 Int) Int)
(declare-fun res () Int)
(declare-fun var_h369 () T1666)
(declare-fun var_h225 () T1666)
(declare-fun var__temp_h423 () T1666)
(declare-fun |var__temp_h'425| () T1666)
(declare-fun var__temp_v424 () Int)
(declare-fun v () Int)
(assert (> (sel var_h369 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h423 res) v)
                (= (sel var__temp_h423 res) (+ (sel var_h369 res) 5))))
      (a!2 (and (= (sel |var__temp_h'425| res) var__temp_v424)
                (= (sel |var__temp_h'425| res) (+ (sel var__temp_h423 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h423 res) 7))
                (=> (= (sel var__temp_h423 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c3
 *********************Enumeration Iteration*****************114
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i370 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i370, res ) ==(v)
 	 , (sel)( , var_h_i370, res ) ==((sel)( , var_h369, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v422:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i370 --->  Ty_heap  
 var_h369 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h427 --->  Ty_heap  
 var__temp_v428 --->  Ty_int  
 var__temp_h'429 --->  Ty_heap  
 var__temp_v_err430 --->  error  
 var_h369 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h369, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h427, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h427, res ) ==((sel)( , var_h369, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h427, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h427, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'429, res ) ==(var__temp_v428) AND 
 	 Rel (sel)( , var__temp_h'429, res ) ==((sel)( , var__temp_h427, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i370 T1683)
(declare-const var_h369 T1683)
(declare-const v Int)
(declare-const var_h_i226 T1683)
(declare-const var_h225 T1683)
(declare-const v Int)
(declare-const var_h_i67 T1683)
(declare-const var_h66 T1683)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h427 T1683)
(declare-const var__temp_v428 Int)
(declare-const |var__temp_h'429| T1683)
(declare-const var__temp_v_err430 T1684)
(declare-const var_h369 T1683)
(declare-const var_h225 T1683)
(declare-const var_h66 T1683)
(declare-const err T1697)

solver 
 (declare-sort T1683)
(declare-fun sel (T1683 Int) Int)
(declare-fun res () Int)
(declare-fun var_h369 () T1683)
(declare-fun var_h225 () T1683)
(declare-fun var__temp_h427 () T1683)
(declare-fun |var__temp_h'429| () T1683)
(declare-fun var__temp_v428 () Int)
(declare-fun v () Int)
(assert (> (sel var_h369 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h427 res) v)
                (= (sel var__temp_h427 res) (+ (sel var_h369 res) 5))))
      (a!2 (and (= (sel |var__temp_h'429| res) var__temp_v428)
                (= (sel |var__temp_h'429| res) (+ (sel var__temp_h427 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h427 res) 7))
                (=> (= (sel var__temp_h427 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************115
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i370 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i370, res ) ==(v)
 	 , (sel)( , var_h_i370, res ) ==((sel)( , var_h369, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v422:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i370 --->  Ty_heap  
 var_h369 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h431 --->  Ty_heap  
 var__temp_v432 --->  Ty_int  
 var__temp_h'433 --->  Ty_heap  
 var__temp_v_err434 --->  error  
 var_h369 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h369, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h431, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h431, res ) ==((sel)( , var_h369, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h431, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h431, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'433, res ) ==(var__temp_v432) AND 
 	 Rel (sel)( , var__temp_h'433, res ) ==((sel)( , var__temp_h431, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i370 T1700)
(declare-const var_h369 T1700)
(declare-const v Int)
(declare-const var_h_i226 T1700)
(declare-const var_h225 T1700)
(declare-const v Int)
(declare-const var_h_i67 T1700)
(declare-const var_h66 T1700)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h431 T1700)
(declare-const var__temp_v432 Int)
(declare-const |var__temp_h'433| T1700)
(declare-const var__temp_v_err434 T1701)
(declare-const var_h369 T1700)
(declare-const var_h225 T1700)
(declare-const var_h66 T1700)
(declare-const err T1714)

solver 
 (declare-sort T1700)
(declare-fun sel (T1700 Int) Int)
(declare-fun res () Int)
(declare-fun var_h369 () T1700)
(declare-fun var_h225 () T1700)
(declare-fun var__temp_h431 () T1700)
(declare-fun |var__temp_h'433| () T1700)
(declare-fun var__temp_v432 () Int)
(declare-fun v () Int)
(assert (> (sel var_h369 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h431 res) v)
                (= (sel var__temp_h431 res) (+ (sel var_h369 res) 5))))
      (a!2 (and (= (sel |var__temp_h'433| res) var__temp_v432)
                (= (sel |var__temp_h'433| res) (+ (sel var__temp_h431 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h431 res) 7))
                (=> (= (sel var__temp_h431 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************116
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i370 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i370, res ) ==(v)
 	 , (sel)( , var_h_i370, res ) ==((sel)( , var_h369, res ) + (5)) >c  } 
 } 
 
                                                RET :  Base {var_v422:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i370 --->  Ty_heap  
 var_h369 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i226 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h435 --->  Ty_heap  
 var__temp_v436 --->  Ty_int  
 var__temp_h'437 --->  Ty_heap  
 var__temp_v_err438 --->  error  
 var_h369 --->  Ty_heap  
 var_h225 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h369, res ) > (5) AND 
 	 Rel (sel)( , var_h225, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h435, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h435, res ) ==((sel)( , var_h369, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h435, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h435, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'437, res ) ==(var__temp_v436) AND 
 	 Rel (sel)( , var__temp_h'437, res ) ==((sel)( , var__temp_h435, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i370 T1717)
(declare-const var_h369 T1717)
(declare-const v Int)
(declare-const var_h_i226 T1717)
(declare-const var_h225 T1717)
(declare-const v Int)
(declare-const var_h_i67 T1717)
(declare-const var_h66 T1717)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h435 T1717)
(declare-const var__temp_v436 Int)
(declare-const |var__temp_h'437| T1717)
(declare-const var__temp_v_err438 T1718)
(declare-const var_h369 T1717)
(declare-const var_h225 T1717)
(declare-const var_h66 T1717)
(declare-const err T1731)

solver 
 (declare-sort T1717)
(declare-fun sel (T1717 Int) Int)
(declare-fun res () Int)
(declare-fun var_h369 () T1717)
(declare-fun var_h225 () T1717)
(declare-fun var__temp_h435 () T1717)
(declare-fun |var__temp_h'437| () T1717)
(declare-fun var__temp_v436 () Int)
(declare-fun v () Int)
(assert (> (sel var_h369 res) 5))
(assert (> (sel var_h225 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h435 res) v)
                (= (sel var__temp_h435 res) (+ (sel var_h369 res) 5))))
      (a!2 (and (= (sel |var__temp_h'437| res) var__temp_v436)
                (= (sel |var__temp_h'437| res) (+ (sel var__temp_h435 res) 2)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h435 res) 5))
                (=> (= (sel var__temp_h435 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************117
First component finding failed
{ 
Eret { 
Evar c1 
 } 
 }
@HERE
EXPLORED::BEFORETermsc1
EXPLORED::AFTERTermsc1c1
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i67 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i67, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v439:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c3'
c3
c5
c4
c2''
c2'
c2
 *********************Enumeration Iteration*****************118
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (8) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i67 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i67, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v439:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h440 --->  Ty_heap  
 var__temp_v441 --->  Ty_int  
 var__temp_h'442 --->  Ty_heap  
 var__temp_v_err443 --->  error  
 var_h66 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h440, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h440, res ) > (8) AND 
 	 Rel (sel)( , var__temp_h440, res ) > (8) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'442, res ) ==(var__temp_v441) AND 
 	 Rel (sel)( , var__temp_h'442, res ) ==((sel)( , var__temp_h440, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i67 T1734)
(declare-const var_h66 T1734)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h440 T1734)
(declare-const var__temp_v441 Int)
(declare-const |var__temp_h'442| T1734)
(declare-const var__temp_v_err443 T1735)
(declare-const var_h66 T1734)
(declare-const err T1748)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1734)
(declare-fun |5| () Int)
(declare-fun sel (T1734 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h440 () T1734)
(declare-fun |var__temp_h'442| () T1734)
(declare-fun var__temp_v441 () Int)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h440 res) v) (= v |5|))
               (not (> (sel var__temp_h440 res) 8))))
      (a!2 (and (= (sel |var__temp_h'442| res) var__temp_v441)
                (= (sel |var__temp_h'442| res) (+ (sel var__temp_h440 res) 3)))))
(let ((a!3 (=> (not (> (sel var__temp_h440 res) 8)) (=> a!2 true))))
  (not (and a!1 a!3)))))

***************Selection Successful************c3'
EXPLORED::BEFORETermsc1c1
EXPLORED::AFTERTermsc3'c1c1
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i445 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i445 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i445, res ) ==(v)
 	 , (sel)( , var_h_i445, res ) ==((sel)( , var_h444, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v446:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i445 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
c3
c5
c4
c2''
c2'
c2
 *********************Enumeration Iteration*****************119
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i445 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i445, res ) ==(v)
 	 , (sel)( , var_h_i445, res ) ==((sel)( , var_h444, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v446:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i445 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i445 --->  Ty_heap  
 var_h444 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h447 --->  Ty_heap  
 var__temp_v448 --->  Ty_int  
 var__temp_h'449 --->  Ty_heap  
 var__temp_v_err450 --->  error  
 var_h444 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h444, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h447, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h447, res ) ==((sel)( , var_h444, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h447, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h447, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'449, res ) ==(var__temp_v448) AND 
 	 Rel (sel)( , var__temp_h'449, res ) ==((sel)( , var__temp_h447, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'449, res ) ==(var__temp_v448) AND 
 	 Rel (sel)( , var__temp_h'449, res ) ==(10)
 
VC_END(declare-const var_h_i445 T1751)
(declare-const var_h444 T1751)
(declare-const v Int)
(declare-const var_h_i67 T1751)
(declare-const var_h66 T1751)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h447 T1751)
(declare-const var__temp_v448 Int)
(declare-const |var__temp_h'449| T1751)
(declare-const var__temp_v_err450 T1752)
(declare-const var_h444 T1751)
(declare-const var_h66 T1751)
(declare-const err T1765)

solver 
 (declare-sort T1751)
(declare-fun sel (T1751 Int) Int)
(declare-fun res () Int)
(declare-fun var_h444 () T1751)
(declare-fun |var__temp_h'449| () T1751)
(declare-fun var__temp_v448 () Int)
(declare-fun var__temp_h447 () T1751)
(declare-fun v () Int)
(assert (not (> (sel var_h444 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h447 res) v)
                (= (sel var__temp_h447 res) (+ (sel var_h444 res) 3))))
      (a!2 (and (= (sel |var__temp_h'449| res) var__temp_v448)
                (= (sel |var__temp_h'449| res) (+ (sel var__temp_h447 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'449| res) var__temp_v448)
                    (= (sel |var__temp_h'449| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h447 res) 7))
                (=> (= (sel var__temp_h447 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c3
 *********************Enumeration Iteration*****************120
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i445 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i445, res ) ==(v)
 	 , (sel)( , var_h_i445, res ) ==((sel)( , var_h444, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v446:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i445 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i445 --->  Ty_heap  
 var_h444 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h451 --->  Ty_heap  
 var__temp_v452 --->  Ty_int  
 var__temp_h'453 --->  Ty_heap  
 var__temp_v_err454 --->  error  
 var_h444 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h444, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h451, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h451, res ) ==((sel)( , var_h444, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h451, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h451, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'453, res ) ==(var__temp_v452) AND 
 	 Rel (sel)( , var__temp_h'453, res ) ==((sel)( , var__temp_h451, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'453, res ) ==(var__temp_v452) AND 
 	 Rel (sel)( , var__temp_h'453, res ) ==(10)
 
VC_END(declare-const var_h_i445 T1768)
(declare-const var_h444 T1768)
(declare-const v Int)
(declare-const var_h_i67 T1768)
(declare-const var_h66 T1768)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h451 T1768)
(declare-const var__temp_v452 Int)
(declare-const |var__temp_h'453| T1768)
(declare-const var__temp_v_err454 T1769)
(declare-const var_h444 T1768)
(declare-const var_h66 T1768)
(declare-const err T1782)

solver 
 (declare-sort T1768)
(declare-fun sel (T1768 Int) Int)
(declare-fun res () Int)
(declare-fun var_h444 () T1768)
(declare-fun |var__temp_h'453| () T1768)
(declare-fun var__temp_v452 () Int)
(declare-fun var__temp_h451 () T1768)
(declare-fun v () Int)
(assert (not (> (sel var_h444 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h451 res) v)
                (= (sel var__temp_h451 res) (+ (sel var_h444 res) 3))))
      (a!2 (and (= (sel |var__temp_h'453| res) var__temp_v452)
                (= (sel |var__temp_h'453| res) (+ (sel var__temp_h451 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'453| res) var__temp_v452)
                    (= (sel |var__temp_h'453| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h451 res) 7))
                (=> (= (sel var__temp_h451 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************121
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i445 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i445, res ) ==(v)
 	 , (sel)( , var_h_i445, res ) ==((sel)( , var_h444, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v446:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i445 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i445 --->  Ty_heap  
 var_h444 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h455 --->  Ty_heap  
 var__temp_v456 --->  Ty_int  
 var__temp_h'457 --->  Ty_heap  
 var__temp_v_err458 --->  error  
 var_h444 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h444, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h455, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h455, res ) ==((sel)( , var_h444, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h455, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h455, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'457, res ) ==(var__temp_v456) AND 
 	 Rel (sel)( , var__temp_h'457, res ) ==((sel)( , var__temp_h455, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'457, res ) ==(var__temp_v456) AND 
 	 Rel (sel)( , var__temp_h'457, res ) ==(10)
 
VC_END(declare-const var_h_i445 T1785)
(declare-const var_h444 T1785)
(declare-const v Int)
(declare-const var_h_i67 T1785)
(declare-const var_h66 T1785)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h455 T1785)
(declare-const var__temp_v456 Int)
(declare-const |var__temp_h'457| T1785)
(declare-const var__temp_v_err458 T1786)
(declare-const var_h444 T1785)
(declare-const var_h66 T1785)
(declare-const err T1799)

solver 
 (declare-sort T1785)
(declare-fun sel (T1785 Int) Int)
(declare-fun res () Int)
(declare-fun var_h444 () T1785)
(declare-fun |var__temp_h'457| () T1785)
(declare-fun var__temp_v456 () Int)
(declare-fun var__temp_h455 () T1785)
(declare-fun v () Int)
(assert (not (> (sel var_h444 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h455 res) v)
                (= (sel var__temp_h455 res) (+ (sel var_h444 res) 3))))
      (a!2 (and (= (sel |var__temp_h'457| res) var__temp_v456)
                (= (sel |var__temp_h'457| res) (+ (sel var__temp_h455 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'457| res) var__temp_v456)
                    (= (sel |var__temp_h'457| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h455 res) 7))
                (=> (= (sel var__temp_h455 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************122
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i445 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i445, res ) ==(v)
 	 , (sel)( , var_h_i445, res ) ==((sel)( , var_h444, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v446:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i445 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i445 --->  Ty_heap  
 var_h444 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h459 --->  Ty_heap  
 var__temp_v460 --->  Ty_int  
 var__temp_h'461 --->  Ty_heap  
 var__temp_v_err462 --->  error  
 var_h444 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h444, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h459, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h459, res ) ==((sel)( , var_h444, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h459, res ) > (5) AND 
 	 Rel (sel)( , var__temp_h459, res ) > (5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'461, res ) ==(var__temp_v460) AND 
 	 Rel (sel)( , var__temp_h'461, res ) ==((sel)( , var__temp_h459, res ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'461, res ) ==(var__temp_v460) AND 
 	 Rel (sel)( , var__temp_h'461, res ) ==(10)
 
VC_END(declare-const var_h_i445 T1802)
(declare-const var_h444 T1802)
(declare-const v Int)
(declare-const var_h_i67 T1802)
(declare-const var_h66 T1802)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h459 T1802)
(declare-const var__temp_v460 Int)
(declare-const |var__temp_h'461| T1802)
(declare-const var__temp_v_err462 T1803)
(declare-const var_h444 T1802)
(declare-const var_h66 T1802)
(declare-const err T1816)

solver 
 (declare-sort T1802)
(declare-fun sel (T1802 Int) Int)
(declare-fun res () Int)
(declare-fun var_h444 () T1802)
(declare-fun |var__temp_h'461| () T1802)
(declare-fun var__temp_v460 () Int)
(declare-fun var__temp_h459 () T1802)
(declare-fun v () Int)
(assert (not (> (sel var_h444 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h459 res) v)
                (= (sel var__temp_h459 res) (+ (sel var_h444 res) 3))))
      (a!2 (and (= (sel |var__temp_h'461| res) var__temp_v460)
                (= (sel |var__temp_h'461| res) (+ (sel var__temp_h459 res) 5)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'461| res) var__temp_v460)
                    (= (sel |var__temp_h'461| res) 10)))))
(let ((a!4 (and (=> a!1 (> (sel var__temp_h459 res) 5))
                (=> (> (sel var__temp_h459 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************c2''
 *********************Enumeration Iteration*****************123
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (1)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i445 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i445, res ) ==(v)
 	 , (sel)( , var_h_i445, res ) ==((sel)( , var_h444, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v446:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i445 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (1)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i445 --->  Ty_heap  
 var_h444 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h463 --->  Ty_heap  
 var__temp_v464 --->  Ty_int  
 var__temp_h'465 --->  Ty_heap  
 var__temp_v_err466 --->  error  
 var_h444 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h444, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h463, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h463, res ) ==((sel)( , var_h444, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h463, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h463, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'465, res ) ==(var__temp_v464) AND 
 	 Rel (sel)( , var__temp_h'465, res ) ==((sel)( , var__temp_h463, res ) + (1)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'465, res ) ==(var__temp_v464) AND 
 	 Rel (sel)( , var__temp_h'465, res ) ==(10)
 
VC_END(declare-const var_h_i445 T1819)
(declare-const var_h444 T1819)
(declare-const v Int)
(declare-const var_h_i67 T1819)
(declare-const var_h66 T1819)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h463 T1819)
(declare-const var__temp_v464 Int)
(declare-const |var__temp_h'465| T1819)
(declare-const var__temp_v_err466 T1820)
(declare-const var_h444 T1819)
(declare-const var_h66 T1819)
(declare-const err T1833)

solver 
 (declare-sort T1819)
(declare-fun sel (T1819 Int) Int)
(declare-fun res () Int)
(declare-fun var_h444 () T1819)
(declare-fun |var__temp_h'465| () T1819)
(declare-fun var__temp_v464 () Int)
(declare-fun var__temp_h463 () T1819)
(declare-fun v () Int)
(assert (not (> (sel var_h444 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h463 res) v)
                (= (sel var__temp_h463 res) (+ (sel var_h444 res) 3))))
      (a!2 (and (= (sel |var__temp_h'465| res) var__temp_v464)
                (= (sel |var__temp_h'465| res) (+ (sel var__temp_h463 res) 1)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'465| res) var__temp_v464)
                    (= (sel |var__temp_h'465| res) 10)))))
(let ((a!4 (and (=> a!1 (> (sel var__temp_h463 res) 4))
                (=> (> (sel var__temp_h463 res) 4) a!3))))
  (not a!4)))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************124
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i445 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i445, res ) ==(v)
 	 , (sel)( , var_h_i445, res ) ==((sel)( , var_h444, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v446:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i445 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i445 --->  Ty_heap  
 var_h444 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h467 --->  Ty_heap  
 var__temp_v468 --->  Ty_int  
 var__temp_h'469 --->  Ty_heap  
 var__temp_v_err470 --->  error  
 var_h444 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h444, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h467, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h467, res ) ==((sel)( , var_h444, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h467, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h467, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'469, res ) ==(var__temp_v468) AND 
 	 Rel (sel)( , var__temp_h'469, res ) ==((sel)( , var__temp_h467, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'469, res ) ==(var__temp_v468) AND 
 	 Rel (sel)( , var__temp_h'469, res ) ==(10)
 
VC_END(declare-const var_h_i445 T1836)
(declare-const var_h444 T1836)
(declare-const v Int)
(declare-const var_h_i67 T1836)
(declare-const var_h66 T1836)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h467 T1836)
(declare-const var__temp_v468 Int)
(declare-const |var__temp_h'469| T1836)
(declare-const var__temp_v_err470 T1837)
(declare-const var_h444 T1836)
(declare-const var_h66 T1836)
(declare-const err T1850)

solver 
 (declare-sort T1836)
(declare-fun sel (T1836 Int) Int)
(declare-fun res () Int)
(declare-fun var_h444 () T1836)
(declare-fun |var__temp_h'469| () T1836)
(declare-fun var__temp_v468 () Int)
(declare-fun var__temp_h467 () T1836)
(declare-fun v () Int)
(assert (not (> (sel var_h444 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h467 res) v)
                (= (sel var__temp_h467 res) (+ (sel var_h444 res) 3))))
      (a!2 (and (= (sel |var__temp_h'469| res) var__temp_v468)
                (= (sel |var__temp_h'469| res) (+ (sel var__temp_h467 res) 2)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'469| res) var__temp_v468)
                    (= (sel |var__temp_h'469| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h467 res) 5))
                (=> (= (sel var__temp_h467 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************125
 Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v446:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v446:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc3'c1c1
esynthesizeBind
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i445 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i445, res ) ==(v)
 	 , (sel)( , var_h_i445, res ) ==((sel)( , var_h444, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v471:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c3
c5
c4
c2''
c2'
c2
 *********************Enumeration Iteration*****************126
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i445 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i445, res ) ==(v)
 	 , (sel)( , var_h_i445, res ) ==((sel)( , var_h444, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v471:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i445 --->  Ty_heap  
 var_h444 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h472 --->  Ty_heap  
 var__temp_v473 --->  Ty_int  
 var__temp_h'474 --->  Ty_heap  
 var__temp_v_err475 --->  error  
 var_h444 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h444, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h472, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h472, res ) ==((sel)( , var_h444, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h472, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h472, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'474, res ) ==(var__temp_v473) AND 
 	 Rel (sel)( , var__temp_h'474, res ) ==((sel)( , var__temp_h472, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i445 T1853)
(declare-const var_h444 T1853)
(declare-const v Int)
(declare-const var_h_i67 T1853)
(declare-const var_h66 T1853)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h472 T1853)
(declare-const var__temp_v473 Int)
(declare-const |var__temp_h'474| T1853)
(declare-const var__temp_v_err475 T1854)
(declare-const var_h444 T1853)
(declare-const var_h66 T1853)
(declare-const err T1867)

solver 
 (declare-sort T1853)
(declare-fun sel (T1853 Int) Int)
(declare-fun res () Int)
(declare-fun var_h444 () T1853)
(declare-fun var__temp_h472 () T1853)
(declare-fun |var__temp_h'474| () T1853)
(declare-fun var__temp_v473 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h444 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h472 res) v)
                (= (sel var__temp_h472 res) (+ (sel var_h444 res) 3))))
      (a!2 (and (= (sel |var__temp_h'474| res) var__temp_v473)
                (= (sel |var__temp_h'474| res) (+ (sel var__temp_h472 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h472 res) 7))
                (=> (= (sel var__temp_h472 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c3
 *********************Enumeration Iteration*****************127
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i445 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i445, res ) ==(v)
 	 , (sel)( , var_h_i445, res ) ==((sel)( , var_h444, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v471:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i445 --->  Ty_heap  
 var_h444 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h476 --->  Ty_heap  
 var__temp_v477 --->  Ty_int  
 var__temp_h'478 --->  Ty_heap  
 var__temp_v_err479 --->  error  
 var_h444 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h444, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h476, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h476, res ) ==((sel)( , var_h444, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h476, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h476, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'478, res ) ==(var__temp_v477) AND 
 	 Rel (sel)( , var__temp_h'478, res ) ==((sel)( , var__temp_h476, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i445 T1870)
(declare-const var_h444 T1870)
(declare-const v Int)
(declare-const var_h_i67 T1870)
(declare-const var_h66 T1870)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h476 T1870)
(declare-const var__temp_v477 Int)
(declare-const |var__temp_h'478| T1870)
(declare-const var__temp_v_err479 T1871)
(declare-const var_h444 T1870)
(declare-const var_h66 T1870)
(declare-const err T1884)

solver 
 (declare-sort T1870)
(declare-fun sel (T1870 Int) Int)
(declare-fun res () Int)
(declare-fun var_h444 () T1870)
(declare-fun var__temp_h476 () T1870)
(declare-fun |var__temp_h'478| () T1870)
(declare-fun var__temp_v477 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h444 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h476 res) v)
                (= (sel var__temp_h476 res) (+ (sel var_h444 res) 3))))
      (a!2 (and (= (sel |var__temp_h'478| res) var__temp_v477)
                (= (sel |var__temp_h'478| res) (+ (sel var__temp_h476 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h476 res) 7))
                (=> (= (sel var__temp_h476 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************128
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i445 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i445, res ) ==(v)
 	 , (sel)( , var_h_i445, res ) ==((sel)( , var_h444, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v471:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i445 --->  Ty_heap  
 var_h444 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h480 --->  Ty_heap  
 var__temp_v481 --->  Ty_int  
 var__temp_h'482 --->  Ty_heap  
 var__temp_v_err483 --->  error  
 var_h444 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h444, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h480, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h480, res ) ==((sel)( , var_h444, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h480, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h480, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'482, res ) ==(var__temp_v481) AND 
 	 Rel (sel)( , var__temp_h'482, res ) ==((sel)( , var__temp_h480, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i445 T1887)
(declare-const var_h444 T1887)
(declare-const v Int)
(declare-const var_h_i67 T1887)
(declare-const var_h66 T1887)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h480 T1887)
(declare-const var__temp_v481 Int)
(declare-const |var__temp_h'482| T1887)
(declare-const var__temp_v_err483 T1888)
(declare-const var_h444 T1887)
(declare-const var_h66 T1887)
(declare-const err T1901)

solver 
 (declare-sort T1887)
(declare-fun sel (T1887 Int) Int)
(declare-fun res () Int)
(declare-fun var_h444 () T1887)
(declare-fun var__temp_h480 () T1887)
(declare-fun |var__temp_h'482| () T1887)
(declare-fun var__temp_v481 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h444 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h480 res) v)
                (= (sel var__temp_h480 res) (+ (sel var_h444 res) 3))))
      (a!2 (and (= (sel |var__temp_h'482| res) var__temp_v481)
                (= (sel |var__temp_h'482| res) (+ (sel var__temp_h480 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h480 res) 7))
                (=> (= (sel var__temp_h480 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************129
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i445 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i445, res ) ==(v)
 	 , (sel)( , var_h_i445, res ) ==((sel)( , var_h444, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v471:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i445 --->  Ty_heap  
 var_h444 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h484 --->  Ty_heap  
 var__temp_v485 --->  Ty_int  
 var__temp_h'486 --->  Ty_heap  
 var__temp_v_err487 --->  error  
 var_h444 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h444, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h484, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h484, res ) ==((sel)( , var_h444, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h484, res ) > (5) AND 
 	 Rel (sel)( , var__temp_h484, res ) > (5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'486, res ) ==(var__temp_v485) AND 
 	 Rel (sel)( , var__temp_h'486, res ) ==((sel)( , var__temp_h484, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i445 T1904)
(declare-const var_h444 T1904)
(declare-const v Int)
(declare-const var_h_i67 T1904)
(declare-const var_h66 T1904)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h484 T1904)
(declare-const var__temp_v485 Int)
(declare-const |var__temp_h'486| T1904)
(declare-const var__temp_v_err487 T1905)
(declare-const var_h444 T1904)
(declare-const var_h66 T1904)
(declare-const err T1918)

solver 
 (declare-sort T1904)
(declare-fun sel (T1904 Int) Int)
(declare-fun res () Int)
(declare-fun var_h444 () T1904)
(declare-fun var__temp_h484 () T1904)
(declare-fun |var__temp_h'486| () T1904)
(declare-fun var__temp_v485 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h444 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h484 res) v)
                (= (sel var__temp_h484 res) (+ (sel var_h444 res) 3))))
      (a!2 (and (= (sel |var__temp_h'486| res) var__temp_v485)
                (= (sel |var__temp_h'486| res) (+ (sel var__temp_h484 res) 5)))))
(let ((a!3 (and (=> a!1 (> (sel var__temp_h484 res) 5))
                (=> (> (sel var__temp_h484 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2''
 *********************Enumeration Iteration*****************130
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (1)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i445 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i445, res ) ==(v)
 	 , (sel)( , var_h_i445, res ) ==((sel)( , var_h444, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v471:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (1)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i445 --->  Ty_heap  
 var_h444 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h488 --->  Ty_heap  
 var__temp_v489 --->  Ty_int  
 var__temp_h'490 --->  Ty_heap  
 var__temp_v_err491 --->  error  
 var_h444 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h444, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h488, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h488, res ) ==((sel)( , var_h444, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h488, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h488, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'490, res ) ==(var__temp_v489) AND 
 	 Rel (sel)( , var__temp_h'490, res ) ==((sel)( , var__temp_h488, res ) + (1)) => 
 	 True
 
VC_END(declare-const var_h_i445 T1921)
(declare-const var_h444 T1921)
(declare-const v Int)
(declare-const var_h_i67 T1921)
(declare-const var_h66 T1921)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h488 T1921)
(declare-const var__temp_v489 Int)
(declare-const |var__temp_h'490| T1921)
(declare-const var__temp_v_err491 T1922)
(declare-const var_h444 T1921)
(declare-const var_h66 T1921)
(declare-const err T1935)

solver 
 (declare-sort T1921)
(declare-fun sel (T1921 Int) Int)
(declare-fun res () Int)
(declare-fun var_h444 () T1921)
(declare-fun var__temp_h488 () T1921)
(declare-fun |var__temp_h'490| () T1921)
(declare-fun var__temp_v489 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h444 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h488 res) v)
                (= (sel var__temp_h488 res) (+ (sel var_h444 res) 3))))
      (a!2 (and (= (sel |var__temp_h'490| res) var__temp_v489)
                (= (sel |var__temp_h'490| res) (+ (sel var__temp_h488 res) 1)))))
(let ((a!3 (and (=> a!1 (> (sel var__temp_h488 res) 4))
                (=> (> (sel var__temp_h488 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************131
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i445 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i445, res ) ==(v)
 	 , (sel)( , var_h_i445, res ) ==((sel)( , var_h444, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v471:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i445 --->  Ty_heap  
 var_h444 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h492 --->  Ty_heap  
 var__temp_v493 --->  Ty_int  
 var__temp_h'494 --->  Ty_heap  
 var__temp_v_err495 --->  error  
 var_h444 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h444, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h492, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h492, res ) ==((sel)( , var_h444, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h492, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h492, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'494, res ) ==(var__temp_v493) AND 
 	 Rel (sel)( , var__temp_h'494, res ) ==((sel)( , var__temp_h492, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i445 T1938)
(declare-const var_h444 T1938)
(declare-const v Int)
(declare-const var_h_i67 T1938)
(declare-const var_h66 T1938)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h492 T1938)
(declare-const var__temp_v493 Int)
(declare-const |var__temp_h'494| T1938)
(declare-const var__temp_v_err495 T1939)
(declare-const var_h444 T1938)
(declare-const var_h66 T1938)
(declare-const err T1952)

solver 
 (declare-sort T1938)
(declare-fun sel (T1938 Int) Int)
(declare-fun res () Int)
(declare-fun var_h444 () T1938)
(declare-fun var__temp_h492 () T1938)
(declare-fun |var__temp_h'494| () T1938)
(declare-fun var__temp_v493 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h444 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h492 res) v)
                (= (sel var__temp_h492 res) (+ (sel var_h444 res) 3))))
      (a!2 (and (= (sel |var__temp_h'494| res) var__temp_v493)
                (= (sel |var__temp_h'494| res) (+ (sel var__temp_h492 res) 2)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h492 res) 5))
                (=> (= (sel var__temp_h492 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************132
First component finding failed
EXPLORED2 Termsc3'c1c1
esynthesizeBind
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i445 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i445, res ) ==(v)
 	 , (sel)( , var_h_i445, res ) ==((sel)( , var_h444, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v496:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c3
c5
c4
c2''
c2'
c2
 *********************Enumeration Iteration*****************133
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i445 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i445, res ) ==(v)
 	 , (sel)( , var_h_i445, res ) ==((sel)( , var_h444, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v496:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i445 --->  Ty_heap  
 var_h444 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h497 --->  Ty_heap  
 var__temp_v498 --->  Ty_int  
 var__temp_h'499 --->  Ty_heap  
 var__temp_v_err500 --->  error  
 var_h444 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h444, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h497, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h497, res ) ==((sel)( , var_h444, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h497, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h497, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'499, res ) ==(var__temp_v498) AND 
 	 Rel (sel)( , var__temp_h'499, res ) ==((sel)( , var__temp_h497, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i445 T1955)
(declare-const var_h444 T1955)
(declare-const v Int)
(declare-const var_h_i67 T1955)
(declare-const var_h66 T1955)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h497 T1955)
(declare-const var__temp_v498 Int)
(declare-const |var__temp_h'499| T1955)
(declare-const var__temp_v_err500 T1956)
(declare-const var_h444 T1955)
(declare-const var_h66 T1955)
(declare-const err T1969)

solver 
 (declare-sort T1955)
(declare-fun sel (T1955 Int) Int)
(declare-fun res () Int)
(declare-fun var_h444 () T1955)
(declare-fun var__temp_h497 () T1955)
(declare-fun |var__temp_h'499| () T1955)
(declare-fun var__temp_v498 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h444 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h497 res) v)
                (= (sel var__temp_h497 res) (+ (sel var_h444 res) 3))))
      (a!2 (and (= (sel |var__temp_h'499| res) var__temp_v498)
                (= (sel |var__temp_h'499| res) (+ (sel var__temp_h497 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h497 res) 7))
                (=> (= (sel var__temp_h497 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c3
 *********************Enumeration Iteration*****************134
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i445 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i445, res ) ==(v)
 	 , (sel)( , var_h_i445, res ) ==((sel)( , var_h444, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v496:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i445 --->  Ty_heap  
 var_h444 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h501 --->  Ty_heap  
 var__temp_v502 --->  Ty_int  
 var__temp_h'503 --->  Ty_heap  
 var__temp_v_err504 --->  error  
 var_h444 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h444, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h501, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h501, res ) ==((sel)( , var_h444, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h501, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h501, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'503, res ) ==(var__temp_v502) AND 
 	 Rel (sel)( , var__temp_h'503, res ) ==((sel)( , var__temp_h501, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i445 T1972)
(declare-const var_h444 T1972)
(declare-const v Int)
(declare-const var_h_i67 T1972)
(declare-const var_h66 T1972)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h501 T1972)
(declare-const var__temp_v502 Int)
(declare-const |var__temp_h'503| T1972)
(declare-const var__temp_v_err504 T1973)
(declare-const var_h444 T1972)
(declare-const var_h66 T1972)
(declare-const err T1986)

solver 
 (declare-sort T1972)
(declare-fun sel (T1972 Int) Int)
(declare-fun res () Int)
(declare-fun var_h444 () T1972)
(declare-fun var__temp_h501 () T1972)
(declare-fun |var__temp_h'503| () T1972)
(declare-fun var__temp_v502 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h444 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h501 res) v)
                (= (sel var__temp_h501 res) (+ (sel var_h444 res) 3))))
      (a!2 (and (= (sel |var__temp_h'503| res) var__temp_v502)
                (= (sel |var__temp_h'503| res) (+ (sel var__temp_h501 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h501 res) 7))
                (=> (= (sel var__temp_h501 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************135
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i445 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i445, res ) ==(v)
 	 , (sel)( , var_h_i445, res ) ==((sel)( , var_h444, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v496:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i445 --->  Ty_heap  
 var_h444 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h505 --->  Ty_heap  
 var__temp_v506 --->  Ty_int  
 var__temp_h'507 --->  Ty_heap  
 var__temp_v_err508 --->  error  
 var_h444 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h444, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h505, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h505, res ) ==((sel)( , var_h444, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h505, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h505, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'507, res ) ==(var__temp_v506) AND 
 	 Rel (sel)( , var__temp_h'507, res ) ==((sel)( , var__temp_h505, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i445 T1989)
(declare-const var_h444 T1989)
(declare-const v Int)
(declare-const var_h_i67 T1989)
(declare-const var_h66 T1989)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h505 T1989)
(declare-const var__temp_v506 Int)
(declare-const |var__temp_h'507| T1989)
(declare-const var__temp_v_err508 T1990)
(declare-const var_h444 T1989)
(declare-const var_h66 T1989)
(declare-const err T2003)

solver 
 (declare-sort T1989)
(declare-fun sel (T1989 Int) Int)
(declare-fun res () Int)
(declare-fun var_h444 () T1989)
(declare-fun var__temp_h505 () T1989)
(declare-fun |var__temp_h'507| () T1989)
(declare-fun var__temp_v506 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h444 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h505 res) v)
                (= (sel var__temp_h505 res) (+ (sel var_h444 res) 3))))
      (a!2 (and (= (sel |var__temp_h'507| res) var__temp_v506)
                (= (sel |var__temp_h'507| res) (+ (sel var__temp_h505 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h505 res) 7))
                (=> (= (sel var__temp_h505 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************136
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i445 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i445, res ) ==(v)
 	 , (sel)( , var_h_i445, res ) ==((sel)( , var_h444, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v496:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i445 --->  Ty_heap  
 var_h444 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h509 --->  Ty_heap  
 var__temp_v510 --->  Ty_int  
 var__temp_h'511 --->  Ty_heap  
 var__temp_v_err512 --->  error  
 var_h444 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h444, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h509, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h509, res ) ==((sel)( , var_h444, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h509, res ) > (5) AND 
 	 Rel (sel)( , var__temp_h509, res ) > (5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'511, res ) ==(var__temp_v510) AND 
 	 Rel (sel)( , var__temp_h'511, res ) ==((sel)( , var__temp_h509, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i445 T2006)
(declare-const var_h444 T2006)
(declare-const v Int)
(declare-const var_h_i67 T2006)
(declare-const var_h66 T2006)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h509 T2006)
(declare-const var__temp_v510 Int)
(declare-const |var__temp_h'511| T2006)
(declare-const var__temp_v_err512 T2007)
(declare-const var_h444 T2006)
(declare-const var_h66 T2006)
(declare-const err T2020)

solver 
 (declare-sort T2006)
(declare-fun sel (T2006 Int) Int)
(declare-fun res () Int)
(declare-fun var_h444 () T2006)
(declare-fun var__temp_h509 () T2006)
(declare-fun |var__temp_h'511| () T2006)
(declare-fun var__temp_v510 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h444 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h509 res) v)
                (= (sel var__temp_h509 res) (+ (sel var_h444 res) 3))))
      (a!2 (and (= (sel |var__temp_h'511| res) var__temp_v510)
                (= (sel |var__temp_h'511| res) (+ (sel var__temp_h509 res) 5)))))
(let ((a!3 (and (=> a!1 (> (sel var__temp_h509 res) 5))
                (=> (> (sel var__temp_h509 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2''
 *********************Enumeration Iteration*****************137
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (1)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i445 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i445, res ) ==(v)
 	 , (sel)( , var_h_i445, res ) ==((sel)( , var_h444, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v496:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (1)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i445 --->  Ty_heap  
 var_h444 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h513 --->  Ty_heap  
 var__temp_v514 --->  Ty_int  
 var__temp_h'515 --->  Ty_heap  
 var__temp_v_err516 --->  error  
 var_h444 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h444, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h513, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h513, res ) ==((sel)( , var_h444, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h513, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h513, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'515, res ) ==(var__temp_v514) AND 
 	 Rel (sel)( , var__temp_h'515, res ) ==((sel)( , var__temp_h513, res ) + (1)) => 
 	 True
 
VC_END(declare-const var_h_i445 T2023)
(declare-const var_h444 T2023)
(declare-const v Int)
(declare-const var_h_i67 T2023)
(declare-const var_h66 T2023)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h513 T2023)
(declare-const var__temp_v514 Int)
(declare-const |var__temp_h'515| T2023)
(declare-const var__temp_v_err516 T2024)
(declare-const var_h444 T2023)
(declare-const var_h66 T2023)
(declare-const err T2037)

solver 
 (declare-sort T2023)
(declare-fun sel (T2023 Int) Int)
(declare-fun res () Int)
(declare-fun var_h444 () T2023)
(declare-fun var__temp_h513 () T2023)
(declare-fun |var__temp_h'515| () T2023)
(declare-fun var__temp_v514 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h444 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h513 res) v)
                (= (sel var__temp_h513 res) (+ (sel var_h444 res) 3))))
      (a!2 (and (= (sel |var__temp_h'515| res) var__temp_v514)
                (= (sel |var__temp_h'515| res) (+ (sel var__temp_h513 res) 1)))))
(let ((a!3 (and (=> a!1 (> (sel var__temp_h513 res) 4))
                (=> (> (sel var__temp_h513 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************138
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i445 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i445, res ) ==(v)
 	 , (sel)( , var_h_i445, res ) ==((sel)( , var_h444, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v496:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i445 --->  Ty_heap  
 var_h444 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h517 --->  Ty_heap  
 var__temp_v518 --->  Ty_int  
 var__temp_h'519 --->  Ty_heap  
 var__temp_v_err520 --->  error  
 var_h444 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h444, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h517, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h517, res ) ==((sel)( , var_h444, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h517, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h517, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'519, res ) ==(var__temp_v518) AND 
 	 Rel (sel)( , var__temp_h'519, res ) ==((sel)( , var__temp_h517, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i445 T2040)
(declare-const var_h444 T2040)
(declare-const v Int)
(declare-const var_h_i67 T2040)
(declare-const var_h66 T2040)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h517 T2040)
(declare-const var__temp_v518 Int)
(declare-const |var__temp_h'519| T2040)
(declare-const var__temp_v_err520 T2041)
(declare-const var_h444 T2040)
(declare-const var_h66 T2040)
(declare-const err T2054)

solver 
 (declare-sort T2040)
(declare-fun sel (T2040 Int) Int)
(declare-fun res () Int)
(declare-fun var_h444 () T2040)
(declare-fun var__temp_h517 () T2040)
(declare-fun |var__temp_h'519| () T2040)
(declare-fun var__temp_v518 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h444 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h517 res) v)
                (= (sel var__temp_h517 res) (+ (sel var_h444 res) 3))))
      (a!2 (and (= (sel |var__temp_h'519| res) var__temp_v518)
                (= (sel |var__temp_h'519| res) (+ (sel var__temp_h517 res) 2)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h517 res) 5))
                (=> (= (sel var__temp_h517 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************139
First component finding failed
{ 
Eret { 
Evar c3' 
 } 
 }
@HERE
EXPLORED::BEFORETermsc3'c1c1
EXPLORED::AFTERTermsc3'c3'c1c1
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i445 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i445, res ) ==(v)
 	 , (sel)( , var_h_i445, res ) ==((sel)( , var_h444, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v521:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c3
c5
c4
c2''
c2'
c2
 *********************Enumeration Iteration*****************140
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i445 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i445, res ) ==(v)
 	 , (sel)( , var_h_i445, res ) ==((sel)( , var_h444, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v521:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i445 --->  Ty_heap  
 var_h444 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h522 --->  Ty_heap  
 var__temp_v523 --->  Ty_int  
 var__temp_h'524 --->  Ty_heap  
 var__temp_v_err525 --->  error  
 var_h444 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h444, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h522, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h522, res ) ==((sel)( , var_h444, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h522, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h522, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'524, res ) ==(var__temp_v523) AND 
 	 Rel (sel)( , var__temp_h'524, res ) ==((sel)( , var__temp_h522, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i445 T2057)
(declare-const var_h444 T2057)
(declare-const v Int)
(declare-const var_h_i67 T2057)
(declare-const var_h66 T2057)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h522 T2057)
(declare-const var__temp_v523 Int)
(declare-const |var__temp_h'524| T2057)
(declare-const var__temp_v_err525 T2058)
(declare-const var_h444 T2057)
(declare-const var_h66 T2057)
(declare-const err T2071)

solver 
 (declare-sort T2057)
(declare-fun sel (T2057 Int) Int)
(declare-fun res () Int)
(declare-fun var_h444 () T2057)
(declare-fun var__temp_h522 () T2057)
(declare-fun |var__temp_h'524| () T2057)
(declare-fun var__temp_v523 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h444 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h522 res) v)
                (= (sel var__temp_h522 res) (+ (sel var_h444 res) 3))))
      (a!2 (and (= (sel |var__temp_h'524| res) var__temp_v523)
                (= (sel |var__temp_h'524| res) (+ (sel var__temp_h522 res) 3)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h522 res) 7))
                (=> (= (sel var__temp_h522 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c3
 *********************Enumeration Iteration*****************141
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i445 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i445, res ) ==(v)
 	 , (sel)( , var_h_i445, res ) ==((sel)( , var_h444, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v521:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i445 --->  Ty_heap  
 var_h444 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h526 --->  Ty_heap  
 var__temp_v527 --->  Ty_int  
 var__temp_h'528 --->  Ty_heap  
 var__temp_v_err529 --->  error  
 var_h444 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h444, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h526, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h526, res ) ==((sel)( , var_h444, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h526, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h526, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'528, res ) ==(var__temp_v527) AND 
 	 Rel (sel)( , var__temp_h'528, res ) ==((sel)( , var__temp_h526, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i445 T2074)
(declare-const var_h444 T2074)
(declare-const v Int)
(declare-const var_h_i67 T2074)
(declare-const var_h66 T2074)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h526 T2074)
(declare-const var__temp_v527 Int)
(declare-const |var__temp_h'528| T2074)
(declare-const var__temp_v_err529 T2075)
(declare-const var_h444 T2074)
(declare-const var_h66 T2074)
(declare-const err T2088)

solver 
 (declare-sort T2074)
(declare-fun sel (T2074 Int) Int)
(declare-fun res () Int)
(declare-fun var_h444 () T2074)
(declare-fun var__temp_h526 () T2074)
(declare-fun |var__temp_h'528| () T2074)
(declare-fun var__temp_v527 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h444 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h526 res) v)
                (= (sel var__temp_h526 res) (+ (sel var_h444 res) 3))))
      (a!2 (and (= (sel |var__temp_h'528| res) var__temp_v527)
                (= (sel |var__temp_h'528| res) (+ (sel var__temp_h526 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h526 res) 7))
                (=> (= (sel var__temp_h526 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************142
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i445 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i445, res ) ==(v)
 	 , (sel)( , var_h_i445, res ) ==((sel)( , var_h444, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v521:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i445 --->  Ty_heap  
 var_h444 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h530 --->  Ty_heap  
 var__temp_v531 --->  Ty_int  
 var__temp_h'532 --->  Ty_heap  
 var__temp_v_err533 --->  error  
 var_h444 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h444, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h530, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h530, res ) ==((sel)( , var_h444, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h530, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h530, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'532, res ) ==(var__temp_v531) AND 
 	 Rel (sel)( , var__temp_h'532, res ) ==((sel)( , var__temp_h530, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i445 T2091)
(declare-const var_h444 T2091)
(declare-const v Int)
(declare-const var_h_i67 T2091)
(declare-const var_h66 T2091)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h530 T2091)
(declare-const var__temp_v531 Int)
(declare-const |var__temp_h'532| T2091)
(declare-const var__temp_v_err533 T2092)
(declare-const var_h444 T2091)
(declare-const var_h66 T2091)
(declare-const err T2105)

solver 
 (declare-sort T2091)
(declare-fun sel (T2091 Int) Int)
(declare-fun res () Int)
(declare-fun var_h444 () T2091)
(declare-fun var__temp_h530 () T2091)
(declare-fun |var__temp_h'532| () T2091)
(declare-fun var__temp_v531 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h444 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h530 res) v)
                (= (sel var__temp_h530 res) (+ (sel var_h444 res) 3))))
      (a!2 (and (= (sel |var__temp_h'532| res) var__temp_v531)
                (= (sel |var__temp_h'532| res) (+ (sel var__temp_h530 res) 5)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h530 res) 7))
                (=> (= (sel var__temp_h530 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************143
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i445 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i445, res ) ==(v)
 	 , (sel)( , var_h_i445, res ) ==((sel)( , var_h444, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v521:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i445 --->  Ty_heap  
 var_h444 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h534 --->  Ty_heap  
 var__temp_v535 --->  Ty_int  
 var__temp_h'536 --->  Ty_heap  
 var__temp_v_err537 --->  error  
 var_h444 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h444, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h534, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h534, res ) ==((sel)( , var_h444, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h534, res ) > (5) AND 
 	 Rel (sel)( , var__temp_h534, res ) > (5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'536, res ) ==(var__temp_v535) AND 
 	 Rel (sel)( , var__temp_h'536, res ) ==((sel)( , var__temp_h534, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i445 T2108)
(declare-const var_h444 T2108)
(declare-const v Int)
(declare-const var_h_i67 T2108)
(declare-const var_h66 T2108)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h534 T2108)
(declare-const var__temp_v535 Int)
(declare-const |var__temp_h'536| T2108)
(declare-const var__temp_v_err537 T2109)
(declare-const var_h444 T2108)
(declare-const var_h66 T2108)
(declare-const err T2122)

solver 
 (declare-sort T2108)
(declare-fun sel (T2108 Int) Int)
(declare-fun res () Int)
(declare-fun var_h444 () T2108)
(declare-fun var__temp_h534 () T2108)
(declare-fun |var__temp_h'536| () T2108)
(declare-fun var__temp_v535 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h444 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h534 res) v)
                (= (sel var__temp_h534 res) (+ (sel var_h444 res) 3))))
      (a!2 (and (= (sel |var__temp_h'536| res) var__temp_v535)
                (= (sel |var__temp_h'536| res) (+ (sel var__temp_h534 res) 5)))))
(let ((a!3 (and (=> a!1 (> (sel var__temp_h534 res) 5))
                (=> (> (sel var__temp_h534 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2''
 *********************Enumeration Iteration*****************144
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (1)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i445 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i445, res ) ==(v)
 	 , (sel)( , var_h_i445, res ) ==((sel)( , var_h444, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v521:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (1)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i445 --->  Ty_heap  
 var_h444 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h538 --->  Ty_heap  
 var__temp_v539 --->  Ty_int  
 var__temp_h'540 --->  Ty_heap  
 var__temp_v_err541 --->  error  
 var_h444 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h444, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h538, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h538, res ) ==((sel)( , var_h444, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h538, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h538, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'540, res ) ==(var__temp_v539) AND 
 	 Rel (sel)( , var__temp_h'540, res ) ==((sel)( , var__temp_h538, res ) + (1)) => 
 	 True
 
VC_END(declare-const var_h_i445 T2125)
(declare-const var_h444 T2125)
(declare-const v Int)
(declare-const var_h_i67 T2125)
(declare-const var_h66 T2125)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h538 T2125)
(declare-const var__temp_v539 Int)
(declare-const |var__temp_h'540| T2125)
(declare-const var__temp_v_err541 T2126)
(declare-const var_h444 T2125)
(declare-const var_h66 T2125)
(declare-const err T2139)

solver 
 (declare-sort T2125)
(declare-fun sel (T2125 Int) Int)
(declare-fun res () Int)
(declare-fun var_h444 () T2125)
(declare-fun var__temp_h538 () T2125)
(declare-fun |var__temp_h'540| () T2125)
(declare-fun var__temp_v539 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h444 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h538 res) v)
                (= (sel var__temp_h538 res) (+ (sel var_h444 res) 3))))
      (a!2 (and (= (sel |var__temp_h'540| res) var__temp_v539)
                (= (sel |var__temp_h'540| res) (+ (sel var__temp_h538 res) 1)))))
(let ((a!3 (and (=> a!1 (> (sel var__temp_h538 res) 4))
                (=> (> (sel var__temp_h538 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************145
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i445 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i445, res ) ==(v)
 	 , (sel)( , var_h_i445, res ) ==((sel)( , var_h444, res ) + (3)) >c  } 
 } 
 
                                                RET :  Base {var_v521:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i445 --->  Ty_heap  
 var_h444 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i67 --->  Ty_heap  
 var_h66 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h542 --->  Ty_heap  
 var__temp_v543 --->  Ty_int  
 var__temp_h'544 --->  Ty_heap  
 var__temp_v_err545 --->  error  
 var_h444 --->  Ty_heap  
 var_h66 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h444, res ) > (8) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h542, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h542, res ) ==((sel)( , var_h444, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h542, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h542, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'544, res ) ==(var__temp_v543) AND 
 	 Rel (sel)( , var__temp_h'544, res ) ==((sel)( , var__temp_h542, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i445 T2142)
(declare-const var_h444 T2142)
(declare-const v Int)
(declare-const var_h_i67 T2142)
(declare-const var_h66 T2142)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h542 T2142)
(declare-const var__temp_v543 Int)
(declare-const |var__temp_h'544| T2142)
(declare-const var__temp_v_err545 T2143)
(declare-const var_h444 T2142)
(declare-const var_h66 T2142)
(declare-const err T2156)

solver 
 (declare-sort T2142)
(declare-fun sel (T2142 Int) Int)
(declare-fun res () Int)
(declare-fun var_h444 () T2142)
(declare-fun var__temp_h542 () T2142)
(declare-fun |var__temp_h'544| () T2142)
(declare-fun var__temp_v543 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h444 res) 8)))
(assert (let ((a!1 (and (= (sel var__temp_h542 res) v)
                (= (sel var__temp_h542 res) (+ (sel var_h444 res) 3))))
      (a!2 (and (= (sel |var__temp_h'544| res) var__temp_v543)
                (= (sel |var__temp_h'544| res) (+ (sel var__temp_h542 res) 2)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h542 res) 5))
                (=> (= (sel var__temp_h542 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************146
First component finding failed
EXPLORED2 Termsc3'c3'c1c1
esynthesizeBind
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {var_v546:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c3
c5
c4
c2''
c2'
c2
 *********************Enumeration Iteration*****************147
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {var_v546:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h547 --->  Ty_heap  
 var__temp_v548 --->  Ty_int  
 var__temp_h'549 --->  Ty_heap  
 var__temp_v_err550 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 True => 
 	 Rel (sel)( , var__temp_h547, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h547, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'549, res ) ==(var__temp_v548) AND 
 	 Rel (sel)( , var__temp_h'549, res ) ==((sel)( , var__temp_h547, res ) + (3)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h547 T2159)
(declare-const var__temp_v548 Int)
(declare-const |var__temp_h'549| T2159)
(declare-const var__temp_v_err550 T2160)
(declare-const err T2173)

solver 
 (declare-sort T2159)
(declare-fun sel (T2159 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h547 () T2159)
(declare-fun |var__temp_h'549| () T2159)
(declare-fun var__temp_v548 () Int)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'549| res) var__temp_v548)
                (= (sel |var__temp_h'549| res) (+ (sel var__temp_h547 res) 3)))))
(let ((a!2 (and (=> true (= (sel var__temp_h547 res) 7))
                (=> (= (sel var__temp_h547 res) 7) (=> a!1 true)))))
  (not a!2))))

***************Selection Failed************c3
 *********************Enumeration Iteration*****************148
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {var_v546:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h551 --->  Ty_heap  
 var__temp_v552 --->  Ty_int  
 var__temp_h'553 --->  Ty_heap  
 var__temp_v_err554 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 True => 
 	 Rel (sel)( , var__temp_h551, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h551, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'553, res ) ==(var__temp_v552) AND 
 	 Rel (sel)( , var__temp_h'553, res ) ==((sel)( , var__temp_h551, res ) + (5)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h551 T2176)
(declare-const var__temp_v552 Int)
(declare-const |var__temp_h'553| T2176)
(declare-const var__temp_v_err554 T2177)
(declare-const err T2190)

solver 
 (declare-sort T2176)
(declare-fun sel (T2176 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h551 () T2176)
(declare-fun |var__temp_h'553| () T2176)
(declare-fun var__temp_v552 () Int)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'553| res) var__temp_v552)
                (= (sel |var__temp_h'553| res) (+ (sel var__temp_h551 res) 5)))))
(let ((a!2 (and (=> true (= (sel var__temp_h551 res) 7))
                (=> (= (sel var__temp_h551 res) 7) (=> a!1 true)))))
  (not a!2))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************149
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {var_v546:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h555 --->  Ty_heap  
 var__temp_v556 --->  Ty_int  
 var__temp_h'557 --->  Ty_heap  
 var__temp_v_err558 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 True => 
 	 Rel (sel)( , var__temp_h555, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h555, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'557, res ) ==(var__temp_v556) AND 
 	 Rel (sel)( , var__temp_h'557, res ) ==((sel)( , var__temp_h555, res ) + (5)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h555 T2193)
(declare-const var__temp_v556 Int)
(declare-const |var__temp_h'557| T2193)
(declare-const var__temp_v_err558 T2194)
(declare-const err T2207)

solver 
 (declare-sort T2193)
(declare-fun sel (T2193 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h555 () T2193)
(declare-fun |var__temp_h'557| () T2193)
(declare-fun var__temp_v556 () Int)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'557| res) var__temp_v556)
                (= (sel |var__temp_h'557| res) (+ (sel var__temp_h555 res) 5)))))
(let ((a!2 (and (=> true (= (sel var__temp_h555 res) 7))
                (=> (= (sel var__temp_h555 res) 7) (=> a!1 true)))))
  (not a!2))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************150
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {var_v546:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (5)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h559 --->  Ty_heap  
 var__temp_v560 --->  Ty_int  
 var__temp_h'561 --->  Ty_heap  
 var__temp_v_err562 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 True => 
 	 Rel (sel)( , var__temp_h559, res ) > (5) AND 
 	 Rel (sel)( , var__temp_h559, res ) > (5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'561, res ) ==(var__temp_v560) AND 
 	 Rel (sel)( , var__temp_h'561, res ) ==((sel)( , var__temp_h559, res ) + (5)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h559 T2210)
(declare-const var__temp_v560 Int)
(declare-const |var__temp_h'561| T2210)
(declare-const var__temp_v_err562 T2211)
(declare-const err T2224)

solver 
 (declare-sort T2210)
(declare-fun sel (T2210 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h559 () T2210)
(declare-fun |var__temp_h'561| () T2210)
(declare-fun var__temp_v560 () Int)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'561| res) var__temp_v560)
                (= (sel |var__temp_h'561| res) (+ (sel var__temp_h559 res) 5)))))
(let ((a!2 (and (=> true (> (sel var__temp_h559 res) 5))
                (=> (> (sel var__temp_h559 res) 5) (=> a!1 true)))))
  (not a!2))))

***************Selection Failed************c2''
 *********************Enumeration Iteration*****************151
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (1)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {var_v546:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (1)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h563 --->  Ty_heap  
 var__temp_v564 --->  Ty_int  
 var__temp_h'565 --->  Ty_heap  
 var__temp_v_err566 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 True => 
 	 Rel (sel)( , var__temp_h563, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h563, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'565, res ) ==(var__temp_v564) AND 
 	 Rel (sel)( , var__temp_h'565, res ) ==((sel)( , var__temp_h563, res ) + (1)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h563 T2227)
(declare-const var__temp_v564 Int)
(declare-const |var__temp_h'565| T2227)
(declare-const var__temp_v_err566 T2228)
(declare-const err T2241)

solver 
 (declare-sort T2227)
(declare-fun sel (T2227 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h563 () T2227)
(declare-fun |var__temp_h'565| () T2227)
(declare-fun var__temp_v564 () Int)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'565| res) var__temp_v564)
                (= (sel |var__temp_h'565| res) (+ (sel var__temp_h563 res) 1)))))
(let ((a!2 (and (=> true (> (sel var__temp_h563 res) 4))
                (=> (> (sel var__temp_h563 res) 4) (=> a!1 true)))))
  (not a!2))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************152
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {var_v546:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 c3 --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2'' --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h567 --->  Ty_heap  
 var__temp_v568 --->  Ty_int  
 var__temp_h'569 --->  Ty_heap  
 var__temp_v_err570 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 True => 
 	 Rel (sel)( , var__temp_h567, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h567, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'569, res ) ==(var__temp_v568) AND 
 	 Rel (sel)( , var__temp_h'569, res ) ==((sel)( , var__temp_h567, res ) + (2)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const c3 Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2''| Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h567 T2244)
(declare-const var__temp_v568 Int)
(declare-const |var__temp_h'569| T2244)
(declare-const var__temp_v_err570 T2245)
(declare-const err T2258)

solver 
 (declare-sort T2244)
(declare-fun sel (T2244 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h567 () T2244)
(declare-fun |var__temp_h'569| () T2244)
(declare-fun var__temp_v568 () Int)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'569| res) var__temp_v568)
                (= (sel |var__temp_h'569| res) (+ (sel var__temp_h567 res) 2)))))
(let ((a!2 (and (=> true (= (sel var__temp_h567 res) 5))
                (=> (= (sel var__temp_h567 res) 5) (=> a!1 true)))))
  (not a!2))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************153
First component finding failed
ENUM ::c2::c2'::c2''::c4::c5::c3::c2::c2'::c2''::c4::c5::c3::c2::c2'::c2''::c4::c5::c3::c2::c2'::c2''::c4::c5::c3::c2::c2'::c2''::c4::c5::c3::c3'::c2::c4::c5::c3::c2::c4::c5::c3::c2::c4::c5::c3::c2::c4::c5::c3::c2''::c4::c5::c3::c2::c4::c5::c3::c2::c4::c5::c3::c2::c4::c5::c3::c2::c4::c5::c3::c2::c4::c5::c3::c2''::c4::c5::c3::c2::c2''::c4::c5::c3::c2'::c2''::c4::c5::c3::c2::c2'::c2''::c4::c5::c3::c2::c2'::c2''::c4::c5::c3::c2::c2'::c2''::c4::c5::c3::c2::c2'::c2''::c4::c5::c3::c3'::c2::c2'::c2''::c4::c5::c3::c3'::c1::c2::c2'::c2''::c4::c5::c3::c3'::c1::c2::c2'::c2''::c4::c5::c3::c3'Synthesis returned witout result