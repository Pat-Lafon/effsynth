
 specfile :: synth_tests/eff8.specres : int;
c1 : State  {\(h : heap). true} 
	v : { v : int |  [v=5]} 
	{\(h : heap), (v : int), (h' : heap). sel (h', res) == v /\ [v=5]};




c2 : State  {\(h : heap). sel (h, res) == 5} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == v 
		/\ sel (h', res) == sel (h, res) + 2};

c3 : State  {\(h : heap). sel (h, res) == 7} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == v 
		/\ sel (h', res) == sel (h, res) + 3};




goal : State  {\(h : heap). true} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == v 
		/\ sel (h', res) == 10};


var: res
whitespace colon
whitespace var: int
semicolon
var: c1
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace truercurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace lbrace
var: v
equalopint: 5
rbrace
rcurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace conjwhitespace lbrace
var: v
equalopint: 5
rbrace
rcurly
semicolon
var: c2
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 5
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 2
rcurly
semicolon
var: c3
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 7
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 3
rcurly
semicolon
var: goal
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace truercurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 10
rcurly
semicolon

 List of components availableHERE>>>HERE 2>>>HERE 3 >>>HERE 4>>>RelSpec {  SRs ;  PRs ;  TSs  
 Assume false
 name res : 
 params :
 Type Base {var_v0:Ty_int | true} 
 Assume false
 name c1 : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 ) 
 Assume false
 name c2 : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 ) 
 Assume false
 name c3 : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 ) 
 Assume false
 name goal : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 );  Formulas  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
c3
c2
c1
 *********************Enumeration Iteration*****************0
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3 --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1 --->  Ty_heap  
 var__temp_v2 --->  Ty_int  
 var__temp_h'3 --->  Ty_heap  
 var__temp_v_err4 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 True => 
 	 Rel (sel)( , var__temp_h1, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3, res ) ==(var__temp_v2) AND 
 	 Rel (sel)( , var__temp_h'3, res ) ==((sel)( , var__temp_h1, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3, res ) ==(var__temp_v2) AND 
 	 Rel (sel)( , var__temp_h'3, res ) ==(10)
 
VC_END(declare-const c3 Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h1 T0)
(declare-const var__temp_v2 Int)
(declare-const |var__temp_h'3| T0)
(declare-const var__temp_v_err4 T1)
(declare-const err T14)

solver 
 (declare-sort T0)
(declare-fun sel (T0 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'3| () T0)
(declare-fun var__temp_v2 () Int)
(declare-fun var__temp_h1 () T0)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'3| res) var__temp_v2)
                (= (sel |var__temp_h'3| res) (+ (sel var__temp_h1 res) 3)))))
(let ((a!2 (=> a!1
               (and (= (sel |var__temp_h'3| res) var__temp_v2)
                    (= (sel |var__temp_h'3| res) 10)))))
(let ((a!3 (and (=> true (= (sel var__temp_h1 res) 7))
                (=> (= (sel var__temp_h1 res) 7) a!2))))
  (not a!3)))))

***************Selection Failed************c3
 *********************Enumeration Iteration*****************1
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3 --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h5 --->  Ty_heap  
 var__temp_v6 --->  Ty_int  
 var__temp_h'7 --->  Ty_heap  
 var__temp_v_err8 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 True => 
 	 Rel (sel)( , var__temp_h5, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h5, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'7, res ) ==(var__temp_v6) AND 
 	 Rel (sel)( , var__temp_h'7, res ) ==((sel)( , var__temp_h5, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'7, res ) ==(var__temp_v6) AND 
 	 Rel (sel)( , var__temp_h'7, res ) ==(10)
 
VC_END(declare-const c3 Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h5 T17)
(declare-const var__temp_v6 Int)
(declare-const |var__temp_h'7| T17)
(declare-const var__temp_v_err8 T18)
(declare-const err T31)

solver 
 (declare-sort T17)
(declare-fun sel (T17 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'7| () T17)
(declare-fun var__temp_v6 () Int)
(declare-fun var__temp_h5 () T17)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'7| res) var__temp_v6)
                (= (sel |var__temp_h'7| res) (+ (sel var__temp_h5 res) 2)))))
(let ((a!2 (=> a!1
               (and (= (sel |var__temp_h'7| res) var__temp_v6)
                    (= (sel |var__temp_h'7| res) 10)))))
(let ((a!3 (and (=> true (= (sel var__temp_h5 res) 5))
                (=> (= (sel var__temp_h5 res) 5) a!2))))
  (not a!3)))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************2
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3 --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h9 --->  Ty_heap  
 var__temp_v10 --->  Ty_int  
 var__temp_h'11 --->  Ty_heap  
 var__temp_v_err12 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 True => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'11, res ) ==(var__temp_v10) AND 
 	 Base var__temp_v10 = 5 => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'11, res ) ==(var__temp_v10) AND 
 	 Rel (sel)( , var__temp_h'11, res ) ==(10)
 
VC_END(declare-const c3 Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h9 T34)
(declare-const var__temp_v10 Int)
(declare-const |var__temp_h'11| T34)
(declare-const var__temp_v_err12 T35)
(declare-const err T48)
    (declare-const |5| Int)
  
solver 
 (declare-sort T34)
(declare-fun |5| () Int)
(declare-fun sel (T34 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'11| () T34)
(declare-fun var__temp_v10 () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel |var__temp_h'11| res) var__temp_v10)
                    (= var__temp_v10 |5|))
               (and (= (sel |var__temp_h'11| res) var__temp_v10)
                    (= (sel |var__temp_h'11| res) 10)))))
  (not (and (=> true true) (=> true a!1)))))

***************Selection Failed************c1
 *********************Enumeration Iteration*****************3
 Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {v:Ty_int | true}
isynthesizeConstApp
Spec Base {v:Ty_int | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Terms
esynthesizeBind
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {var_v13:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c3
c2
c1
 *********************Enumeration Iteration*****************4
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {var_v13:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3 --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h14 --->  Ty_heap  
 var__temp_v15 --->  Ty_int  
 var__temp_h'16 --->  Ty_heap  
 var__temp_v_err17 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 True => 
 	 Rel (sel)( , var__temp_h14, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h14, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'16, res ) ==(var__temp_v15) AND 
 	 Rel (sel)( , var__temp_h'16, res ) ==((sel)( , var__temp_h14, res ) + (3)) => 
 	 True
 
VC_END(declare-const c3 Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h14 T51)
(declare-const var__temp_v15 Int)
(declare-const |var__temp_h'16| T51)
(declare-const var__temp_v_err17 T52)
(declare-const err T65)

solver 
 (declare-sort T51)
(declare-fun sel (T51 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h14 () T51)
(declare-fun |var__temp_h'16| () T51)
(declare-fun var__temp_v15 () Int)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'16| res) var__temp_v15)
                (= (sel |var__temp_h'16| res) (+ (sel var__temp_h14 res) 3)))))
(let ((a!2 (and (=> true (= (sel var__temp_h14 res) 7))
                (=> (= (sel var__temp_h14 res) 7) (=> a!1 true)))))
  (not a!2))))

***************Selection Failed************c3
 *********************Enumeration Iteration*****************5
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {var_v13:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3 --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h18 --->  Ty_heap  
 var__temp_v19 --->  Ty_int  
 var__temp_h'20 --->  Ty_heap  
 var__temp_v_err21 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 True => 
 	 Rel (sel)( , var__temp_h18, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h18, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'20, res ) ==(var__temp_v19) AND 
 	 Rel (sel)( , var__temp_h'20, res ) ==((sel)( , var__temp_h18, res ) + (2)) => 
 	 True
 
VC_END(declare-const c3 Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h18 T68)
(declare-const var__temp_v19 Int)
(declare-const |var__temp_h'20| T68)
(declare-const var__temp_v_err21 T69)
(declare-const err T82)

solver 
 (declare-sort T68)
(declare-fun sel (T68 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h18 () T68)
(declare-fun |var__temp_h'20| () T68)
(declare-fun var__temp_v19 () Int)
(assert true)
(assert (let ((a!1 (and (= (sel |var__temp_h'20| res) var__temp_v19)
                (= (sel |var__temp_h'20| res) (+ (sel var__temp_h18 res) 2)))))
(let ((a!2 (and (=> true (= (sel var__temp_h18 res) 5))
                (=> (= (sel var__temp_h18 res) 5) (=> a!1 true)))))
  (not a!2))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************6
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {var_v13:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3 --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h22 --->  Ty_heap  
 var__temp_v23 --->  Ty_int  
 var__temp_h'24 --->  Ty_heap  
 var__temp_v_err25 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 True => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'24, res ) ==(var__temp_v23) AND 
 	 Base var__temp_v23 = 5 => 
 	 True
 
VC_END(declare-const c3 Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h22 T85)
(declare-const var__temp_v23 Int)
(declare-const |var__temp_h'24| T85)
(declare-const var__temp_v_err25 T86)
(declare-const err T99)
    (declare-const |5| Int)
  
solver 
 (declare-sort T85)
(declare-fun |5| () Int)
(declare-fun var__temp_v23 () Int)
(declare-fun sel (T85 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'24| () T85)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel |var__temp_h'24| res) var__temp_v23)
                    (= var__temp_v23 |5|))
               true)))
  (not (and (=> true true) (=> true a!1)))))

***************Selection Successful************c1
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i27 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i27 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i27, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v28:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i27 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
c3
c2
c1
 *********************Enumeration Iteration*****************7
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i27 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i27, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v28:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i27 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i27 --->  Ty_heap  
 var_h26 --->  Ty_heap  
 v --->  Ty_int  
 c3 --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h29 --->  Ty_heap  
 var__temp_v30 --->  Ty_int  
 var__temp_h'31 --->  Ty_heap  
 var__temp_v_err32 --->  error  
 var_h26 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h29, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h29, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h29, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'31, res ) ==(var__temp_v30) AND 
 	 Rel (sel)( , var__temp_h'31, res ) ==((sel)( , var__temp_h29, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'31, res ) ==(var__temp_v30) AND 
 	 Rel (sel)( , var__temp_h'31, res ) ==(10)
 
VC_END(declare-const var_h_i27 T102)
(declare-const var_h26 T102)
(declare-const v Int)
(declare-const c3 Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h29 T102)
(declare-const var__temp_v30 Int)
(declare-const |var__temp_h'31| T102)
(declare-const var__temp_v_err32 T103)
(declare-const var_h26 T102)
(declare-const err T116)
    (declare-const |5| Int)
  
solver 
 (declare-sort T102)
(declare-fun |5| () Int)
(declare-fun sel (T102 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'31| () T102)
(declare-fun var__temp_v30 () Int)
(declare-fun var__temp_h29 () T102)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h29 res) v) (= v |5|))
               (= (sel var__temp_h29 res) 7)))
      (a!2 (and (= (sel |var__temp_h'31| res) var__temp_v30)
                (= (sel |var__temp_h'31| res) (+ (sel var__temp_h29 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'31| res) var__temp_v30)
                    (= (sel |var__temp_h'31| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h29 res) 7) a!3))))
  (not a!4)))))

***************Selection Failed************c3
 *********************Enumeration Iteration*****************8
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i27 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i27, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v28:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i27 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i27 --->  Ty_heap  
 var_h26 --->  Ty_heap  
 v --->  Ty_int  
 c3 --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h33 --->  Ty_heap  
 var__temp_v34 --->  Ty_int  
 var__temp_h'35 --->  Ty_heap  
 var__temp_v_err36 --->  error  
 var_h26 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h33, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h33, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h33, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'35, res ) ==(var__temp_v34) AND 
 	 Rel (sel)( , var__temp_h'35, res ) ==((sel)( , var__temp_h33, res ) + (2)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'35, res ) ==(var__temp_v34) AND 
 	 Rel (sel)( , var__temp_h'35, res ) ==(10)
 
VC_END(declare-const var_h_i27 T119)
(declare-const var_h26 T119)
(declare-const v Int)
(declare-const c3 Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h33 T119)
(declare-const var__temp_v34 Int)
(declare-const |var__temp_h'35| T119)
(declare-const var__temp_v_err36 T120)
(declare-const var_h26 T119)
(declare-const err T133)
    (declare-const |5| Int)
  
solver 
 (declare-sort T119)
(declare-fun |5| () Int)
(declare-fun sel (T119 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'35| () T119)
(declare-fun var__temp_v34 () Int)
(declare-fun var__temp_h33 () T119)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h33 res) v) (= v |5|))
               (= (sel var__temp_h33 res) 5)))
      (a!2 (and (= (sel |var__temp_h'35| res) var__temp_v34)
                (= (sel |var__temp_h'35| res) (+ (sel var__temp_h33 res) 2)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'35| res) var__temp_v34)
                    (= (sel |var__temp_h'35| res) 10)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h33 res) 5) a!3))))
  (not a!4)))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************9
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i27 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i27, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v28:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i27 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i27 --->  Ty_heap  
 var_h26 --->  Ty_heap  
 v --->  Ty_int  
 c3 --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h37 --->  Ty_heap  
 var__temp_v38 --->  Ty_int  
 var__temp_h'39 --->  Ty_heap  
 var__temp_v_err40 --->  error  
 var_h26 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h37, res ) ==(v) AND 
 	 Base v = 5 => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'39, res ) ==(var__temp_v38) AND 
 	 Base var__temp_v38 = 5 => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'39, res ) ==(var__temp_v38) AND 
 	 Rel (sel)( , var__temp_h'39, res ) ==(10)
 
VC_END(declare-const var_h_i27 T136)
(declare-const var_h26 T136)
(declare-const v Int)
(declare-const c3 Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h37 T136)
(declare-const var__temp_v38 Int)
(declare-const |var__temp_h'39| T136)
(declare-const var__temp_v_err40 T137)
(declare-const var_h26 T136)
(declare-const err T150)
    (declare-const |5| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T136)
(declare-fun |5| () Int)
(declare-fun sel (T136 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'39| () T136)
(declare-fun var__temp_v38 () Int)
(declare-fun v () Int)
(declare-fun var__temp_h37 () T136)
(assert true)
(assert (= |5| 5))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h37 res) v) (= v |5|)) true))
      (a!2 (=> (and (= (sel |var__temp_h'39| res) var__temp_v38)
                    (= var__temp_v38 |5|))
               (and (= (sel |var__temp_h'39| res) var__temp_v38)
                    (= (sel |var__temp_h'39| res) 10)))))
  (not (and a!1 (=> true a!2)))))

***************Selection Failed************c1
 *********************Enumeration Iteration*****************10
 Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v28:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v28:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Terms
esynthesizeBind
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i27 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i27, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v41:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c3
c2
c1
 *********************Enumeration Iteration*****************11
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i27 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i27, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v41:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i27 --->  Ty_heap  
 var_h26 --->  Ty_heap  
 v --->  Ty_int  
 c3 --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h42 --->  Ty_heap  
 var__temp_v43 --->  Ty_int  
 var__temp_h'44 --->  Ty_heap  
 var__temp_v_err45 --->  error  
 var_h26 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h42, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h42, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h42, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'44, res ) ==(var__temp_v43) AND 
 	 Rel (sel)( , var__temp_h'44, res ) ==((sel)( , var__temp_h42, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i27 T153)
(declare-const var_h26 T153)
(declare-const v Int)
(declare-const c3 Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h42 T153)
(declare-const var__temp_v43 Int)
(declare-const |var__temp_h'44| T153)
(declare-const var__temp_v_err45 T154)
(declare-const var_h26 T153)
(declare-const err T167)
    (declare-const |5| Int)
  
solver 
 (declare-sort T153)
(declare-fun |5| () Int)
(declare-fun sel (T153 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h42 () T153)
(declare-fun |var__temp_h'44| () T153)
(declare-fun var__temp_v43 () Int)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h42 res) v) (= v |5|))
               (= (sel var__temp_h42 res) 7)))
      (a!2 (and (= (sel |var__temp_h'44| res) var__temp_v43)
                (= (sel |var__temp_h'44| res) (+ (sel var__temp_h42 res) 3)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h42 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c3
 *********************Enumeration Iteration*****************12
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i27 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i27, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v41:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (2)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i27 --->  Ty_heap  
 var_h26 --->  Ty_heap  
 v --->  Ty_int  
 c3 --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h46 --->  Ty_heap  
 var__temp_v47 --->  Ty_int  
 var__temp_h'48 --->  Ty_heap  
 var__temp_v_err49 --->  error  
 var_h26 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h46, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h46, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h46, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'48, res ) ==(var__temp_v47) AND 
 	 Rel (sel)( , var__temp_h'48, res ) ==((sel)( , var__temp_h46, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i27 T170)
(declare-const var_h26 T170)
(declare-const v Int)
(declare-const c3 Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h46 T170)
(declare-const var__temp_v47 Int)
(declare-const |var__temp_h'48| T170)
(declare-const var__temp_v_err49 T171)
(declare-const var_h26 T170)
(declare-const err T184)
    (declare-const |5| Int)
  
solver 
 (declare-sort T170)
(declare-fun |5| () Int)
(declare-fun sel (T170 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h46 () T170)
(declare-fun |var__temp_h'48| () T170)
(declare-fun var__temp_v47 () Int)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h46 res) v) (= v |5|))
               (= (sel var__temp_h46 res) 5)))
      (a!2 (and (= (sel |var__temp_h'48| res) var__temp_v47)
                (= (sel |var__temp_h'48| res) (+ (sel var__temp_h46 res) 2)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h46 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c2
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i51 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i51 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i51, res ) ==(v)
 	 , (sel)( , var_h_i51, res ) ==((sel)( , var_h50, res ) + (2)) >c  } 
 } 
 
                                                RET :  Base {var_v52:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i51 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
FOUND COMPONENTS 
c3
c2
c1
 *********************Enumeration Iteration*****************13
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i51 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i51, res ) ==(v)
 	 , (sel)( , var_h_i51, res ) ==((sel)( , var_h50, res ) + (2)) >c  } 
 } 
 
                                                RET :  Base {var_v52:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i51 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==(10) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , (sel)( , h', res ) ==((sel)( , h, res ) + (3)) >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i51 --->  Ty_heap  
 var_h50 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i27 --->  Ty_heap  
 var_h26 --->  Ty_heap  
 v --->  Ty_int  
 c3 --->  Ty_int  
 c2 --->  Ty_int  
 c1 --->  Ty_int  
 res --->  Ty_int  
 var__temp_h53 --->  Ty_heap  
 var__temp_v54 --->  Ty_int  
 var__temp_h'55 --->  Ty_heap  
 var__temp_v_err56 --->  error  
 var_h50 --->  Ty_heap  
 var_h26 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h50, res ) ==(5) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h53, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h53, res ) ==((sel)( , var_h50, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h53, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h53, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'55, res ) ==(var__temp_v54) AND 
 	 Rel (sel)( , var__temp_h'55, res ) ==((sel)( , var__temp_h53, res ) + (3)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'55, res ) ==(var__temp_v54) AND 
 	 Rel (sel)( , var__temp_h'55, res ) ==(10)
 
VC_END(declare-const var_h_i51 T187)
(declare-const var_h50 T187)
(declare-const v Int)
(declare-const var_h_i27 T187)
(declare-const var_h26 T187)
(declare-const v Int)
(declare-const c3 Int)
(declare-const c2 Int)
(declare-const c1 Int)
(declare-const res Int)
(declare-const var__temp_h53 T187)
(declare-const var__temp_v54 Int)
(declare-const |var__temp_h'55| T187)
(declare-const var__temp_v_err56 T188)
(declare-const var_h50 T187)
(declare-const var_h26 T187)
(declare-const err T201)

solver 
 (declare-sort T187)
(declare-fun sel (T187 Int) Int)
(declare-fun res () Int)
(declare-fun var_h50 () T187)
(declare-fun |var__temp_h'55| () T187)
(declare-fun var__temp_v54 () Int)
(declare-fun var__temp_h53 () T187)
(declare-fun v () Int)
(assert (= (sel var_h50 res) 5))
(assert (let ((a!1 (and (= (sel var__temp_h53 res) v)
                (= (sel var__temp_h53 res) (+ (sel var_h50 res) 2))))
      (a!2 (and (= (sel |var__temp_h'55| res) var__temp_v54)
                (= (sel |var__temp_h'55| res) (+ (sel var__temp_h53 res) 3)))))
(let ((a!3 (=> a!2
               (and (= (sel |var__temp_h'55| res) var__temp_v54)
                    (= (sel |var__temp_h'55| res) 10)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h53 res) 7))
                (=> (= (sel var__temp_h53 res) 7) a!3))))
  (not a!4)))))

***************Selection Successful************c3Component Enumeration Succeeded
Found e2 in (x <- e1 in e2)
{ 
Eret { 
Evar c3 
 } 
 }
Found e2 in (x <- e1 in e2)
{ 
Ebind Evar v <- { 
Eret { 
Evar c2 
 } 
 } in { 
Eret { 
Evar c3 
 } 
 } 
 }
ENUM ::c3::c2::c3::c1::c2::c3::c1::c2::c3::c1::c2::c3Success : { 
Ebind Evar v <- { 
Eret { 
Evar c1 
 } 
 } in { 
Ebind Evar v <- { 
Eret { 
Evar c2 
 } 
 } in { 
Eret { 
Evar c3 
 } 
 } 
 } 
 }