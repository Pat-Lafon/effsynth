
 specfile :: synth_tests/eff14.specres : int;
other : int;

bar : State  {\(h : heap). sel (h, res) == 5} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == v 
		/\ sel (h', res) == sel (h, res) + 2
		/\ sel (h', other) == sel (h, other)};

foo : State  {\(h : heap). true} 
	v : { v : int |  [v=5]} 
	{\(h : heap), (v : int), (h' : heap). sel (h', res) == v /\ [v=5]
	/\ sel (h', other) == sel (h, other)};

foo' : State  {\(h : heap). true} 
	v : { v : int |  [v=5]} 
	{\(h : heap), (v : int), (h' : heap). sel (h', res) == v /\ [v=20]
	/\ sel (h', other) == sel (h, other)};


c2 : State  {\(h : heap). sel (h, res) > 4} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == v 
		/\ sel (h', res) == sel (h, res) + 10
		/\ sel (h', other) == sel (h, other)};


c2' : State  {\(h : heap). not (sel (h, res) > 20)} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == v 
		/\ sel (h, res) == sel (h, res)
		/\ sel (h', other) == sel (h, other)};


c4 : State  {\(h : heap). not (sel (h, res) > 30)} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == v 
		/\ sel (h', res) == sel (h, res) + 5
		/\ sel (h', other) == sel (h, other)};



c5 : State  {\(h : heap). sel (h, res) == 7} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == v 
		/\ sel (h', res) == sel (h, res) + 5
		/\ sel (h', other) == sel (h, other)};


baz : State  {\(h : heap). sel (h, res) == 7} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == v 
		/\ sel (h', res) == sel (h, res) + 3
		/\ sel (h', other) == sel (h, other)};

c3' : State  {\(h : heap). not (sel (h, res) > 8)
		/\ sel (h, other) == 0} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == v 
		/\ sel (h', res) == sel (h, res) + 3 /\
		sel (h', other) == sel (h, other) + 5};



goal : State  {\(h : heap). sel (h, res) == 0 
		/\ sel (h, other) == 0} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		 sel (h', res) == 10 
		/\ not (sel (h', other) > 4)};

var: res
whitespace colon
whitespace var: int
semicolon
var: other
whitespace colon
whitespace var: int
semicolon
var: bar
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 5
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 2
whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: other
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: other
rparen
rcurly
semicolon
var: foo
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace truercurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace lbrace
var: v
equalopint: 5
rbrace
rcurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace conjwhitespace lbrace
var: v
equalopint: 5
rbrace
whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: other
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: other
rparen
rcurly
semicolon
var: foo'
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace truercurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace lbrace
var: v
equalopint: 5
rbrace
rcurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace conjwhitespace lbrace
var: v
equalopint: 20
rbrace
whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: other
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: other
rparen
rcurly
semicolon
var: c2
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace lessthanopwhitespace int: 4
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 10
whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: other
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: other
rparen
rcurly
semicolon
var: c2'
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace notwhitespace lparen
var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace lessthanopwhitespace int: 20
rparen
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace whitespace conjwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: other
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: other
rparen
rcurly
semicolon
var: c4
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace notwhitespace lparen
var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace lessthanopwhitespace int: 30
rparen
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 5
whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: other
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: other
rparen
rcurly
semicolon
var: c5
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 7
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 5
whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: other
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: other
rparen
rcurly
semicolon
var: baz
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 7
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 3
whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: other
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: other
rparen
rcurly
semicolon
var: c3'
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace notwhitespace lparen
var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace lessthanopwhitespace int: 8
rparen
whitespace conjwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: other
rparen
whitespace equalopwhitespace int: 0
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 3
whitespace conjwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: other
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: other
rparen
whitespace pluswhitespace int: 5
rcurly
semicolon
var: goal
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 0
whitespace whitespace conjwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: other
rparen
whitespace equalopwhitespace int: 0
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 10
whitespace whitespace conjwhitespace notwhitespace lparen
var: sel
whitespace lparen
var: h'
comma
whitespace var: other
rparen
whitespace lessthanopwhitespace int: 4
rparen
rcurly
semicolon

 List of components availableHERE>>>HERE 2>>>HERE 3 >>>HERE 4>>>RelSpec {  SRs ;  PRs ;  TSs  
 Assume false
 name res : 
 params :
 Type Base {var_v0:Ty_int | true} 
 Assume false
 name other : 
 params :
 Type Base {var_v1:Ty_int | true} 
 Assume false
 name bar : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 ) 
 Assume false
 name foo : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 ) 
 Assume false
 name foo' : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 ) 
 Assume false
 name c2 : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 ) 
 Assume false
 name c2' : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 ) 
 Assume false
 name c4 : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (30) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 ) 
 Assume false
 name c5 : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 ) 
 Assume false
 name baz : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 ) 
 Assume false
 name c3' : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c Not (sel)( , h, res ) > (8)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==((sel)( , h, other ) + (5)) >c  >c  } 
 } 
 ) 
 Assume false
 name goal : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 );  Formulas  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
c3'
baz
c5
c4
c2'
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************0
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c Not (sel)( , h, res ) > (8)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==((sel)( , h, other ) + (5)) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==((sel)( , h, other ) + (5)) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2 --->  Ty_heap  
 var__temp_v3 --->  Ty_int  
 var__temp_h'4 --->  Ty_heap  
 var__temp_v_err5 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h2, other ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2, res ) > (8) AND 
 	 Rel (sel)( , var__temp_h2, other ) ==(0) AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2, res ) > (8) AND 
 	 Rel (sel)( , var__temp_h2, other ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'4, res ) ==(var__temp_v3) AND 
 	 Rel (sel)( , var__temp_h'4, res ) ==((sel)( , var__temp_h2, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'4, other ) ==((sel)( , var__temp_h2, other ) + (5)) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'4, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'4, other ) > (4)
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2 T0)
(declare-const var__temp_v3 Int)
(declare-const |var__temp_h'4| T0)
(declare-const var__temp_v_err5 T1)
(declare-const err T14)

solver 
 (declare-sort T0)
(declare-fun sel (T0 Int) Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'4| () T0)
(declare-fun res () Int)
(declare-fun var__temp_h2 () T0)
(declare-fun var__temp_v3 () Int)
(assert true)
(assert (let ((a!1 (and (not (> (sel var__temp_h2 res) 8))
                (= (sel var__temp_h2 other) 0)))
      (a!3 (and (= (sel |var__temp_h'4| res) var__temp_v3)
                (= (sel |var__temp_h'4| res) (+ (sel var__temp_h2 res) 3))
                (= (sel |var__temp_h'4| other) (+ (sel var__temp_h2 other) 5))))
      (a!4 (and (= (sel |var__temp_h'4| res) 10)
                (not (> (sel |var__temp_h'4| other) 4)))))
(let ((a!2 (=> (and (= (sel var__temp_h2 res) 0) (= (sel var__temp_h2 other) 0))
               a!1)))
  (not (and a!2 (=> a!1 (=> a!3 a!4)))))))

***************Selection Failed************c3'
 *********************Enumeration Iteration*****************1
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h6 --->  Ty_heap  
 var__temp_v7 --->  Ty_int  
 var__temp_h'8 --->  Ty_heap  
 var__temp_v_err9 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h6, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h6, other ) ==(0) => 
 	 Rel (sel)( , var__temp_h6, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h6, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'8, res ) ==(var__temp_v7) AND 
 	 Rel (sel)( , var__temp_h'8, res ) ==((sel)( , var__temp_h6, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'8, other ) ==(sel)( , var__temp_h6, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'8, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'8, other ) > (4)
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h6 T17)
(declare-const var__temp_v7 Int)
(declare-const |var__temp_h'8| T17)
(declare-const var__temp_v_err9 T18)
(declare-const err T31)

solver 
 (declare-sort T17)
(declare-fun sel (T17 Int) Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'8| () T17)
(declare-fun res () Int)
(declare-fun var__temp_h6 () T17)
(declare-fun var__temp_v7 () Int)
(assert true)
(assert (let ((a!1 (=> (and (= (sel var__temp_h6 res) 0) (= (sel var__temp_h6 other) 0))
               (= (sel var__temp_h6 res) 7)))
      (a!2 (and (= (sel |var__temp_h'8| res) var__temp_v7)
                (= (sel |var__temp_h'8| res) (+ (sel var__temp_h6 res) 3))
                (= (sel |var__temp_h'8| other) (sel var__temp_h6 other))))
      (a!3 (and (= (sel |var__temp_h'8| res) 10)
                (not (> (sel |var__temp_h'8| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h6 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************2
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h10 --->  Ty_heap  
 var__temp_v11 --->  Ty_int  
 var__temp_h'12 --->  Ty_heap  
 var__temp_v_err13 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h10, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h10, other ) ==(0) => 
 	 Rel (sel)( , var__temp_h10, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h10, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'12, res ) ==(var__temp_v11) AND 
 	 Rel (sel)( , var__temp_h'12, res ) ==((sel)( , var__temp_h10, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'12, other ) ==(sel)( , var__temp_h10, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'12, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'12, other ) > (4)
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h10 T34)
(declare-const var__temp_v11 Int)
(declare-const |var__temp_h'12| T34)
(declare-const var__temp_v_err13 T35)
(declare-const err T48)

solver 
 (declare-sort T34)
(declare-fun sel (T34 Int) Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'12| () T34)
(declare-fun res () Int)
(declare-fun var__temp_h10 () T34)
(declare-fun var__temp_v11 () Int)
(assert true)
(assert (let ((a!1 (=> (and (= (sel var__temp_h10 res) 0)
                    (= (sel var__temp_h10 other) 0))
               (= (sel var__temp_h10 res) 7)))
      (a!2 (and (= (sel |var__temp_h'12| res) var__temp_v11)
                (= (sel |var__temp_h'12| res) (+ (sel var__temp_h10 res) 5))
                (= (sel |var__temp_h'12| other) (sel var__temp_h10 other))))
      (a!3 (and (= (sel |var__temp_h'12| res) 10)
                (not (> (sel |var__temp_h'12| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h10 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************3
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (30) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h14 --->  Ty_heap  
 var__temp_v15 --->  Ty_int  
 var__temp_h'16 --->  Ty_heap  
 var__temp_v_err17 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h14, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h14, other ) ==(0) => 
 	 Rel (sel)( , var__temp_h14, res ) > (30) AND 
 	 Rel (sel)( , var__temp_h14, res ) > (30) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'16, res ) ==(var__temp_v15) AND 
 	 Rel (sel)( , var__temp_h'16, res ) ==((sel)( , var__temp_h14, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'16, other ) ==(sel)( , var__temp_h14, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'16, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'16, other ) > (4)
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h14 T51)
(declare-const var__temp_v15 Int)
(declare-const |var__temp_h'16| T51)
(declare-const var__temp_v_err17 T52)
(declare-const err T65)

solver 
 (declare-sort T51)
(declare-fun sel (T51 Int) Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'16| () T51)
(declare-fun res () Int)
(declare-fun var__temp_h14 () T51)
(declare-fun var__temp_v15 () Int)
(assert true)
(assert (let ((a!1 (=> (and (= (sel var__temp_h14 res) 0)
                    (= (sel var__temp_h14 other) 0))
               (not (> (sel var__temp_h14 res) 30))))
      (a!2 (and (= (sel |var__temp_h'16| res) var__temp_v15)
                (= (sel |var__temp_h'16| res) (+ (sel var__temp_h14 res) 5))
                (= (sel |var__temp_h'16| other) (sel var__temp_h14 other))))
      (a!3 (and (= (sel |var__temp_h'16| res) 10)
                (not (> (sel |var__temp_h'16| other) 4)))))
(let ((a!4 (=> (not (> (sel var__temp_h14 res) 30)) (=> a!2 a!3))))
  (not (and a!1 a!4)))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************4
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h18 --->  Ty_heap  
 var__temp_v19 --->  Ty_int  
 var__temp_h'20 --->  Ty_heap  
 var__temp_v_err21 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h18, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h18, other ) ==(0) => 
 	 Rel (sel)( , var__temp_h18, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h18, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'20, res ) ==(var__temp_v19) AND 
 	 Rel (sel)( , var__temp_h18, res ) ==(sel)( , var__temp_h18, res ) AND 
 	 Rel (sel)( , var__temp_h'20, other ) ==(sel)( , var__temp_h18, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'20, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'20, other ) > (4)
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h18 T68)
(declare-const var__temp_v19 Int)
(declare-const |var__temp_h'20| T68)
(declare-const var__temp_v_err21 T69)
(declare-const err T82)

solver 
 (declare-sort T68)
(declare-fun sel (T68 Int) Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'20| () T68)
(declare-fun res () Int)
(declare-fun var__temp_h18 () T68)
(declare-fun var__temp_v19 () Int)
(assert true)
(assert (let ((a!1 (=> (and (= (sel var__temp_h18 res) 0)
                    (= (sel var__temp_h18 other) 0))
               (not (> (sel var__temp_h18 res) 20))))
      (a!2 (and (= (sel |var__temp_h'20| res) 10)
                (not (> (sel |var__temp_h'20| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'20| res) var__temp_v19)
                    (= (sel var__temp_h18 res) (sel var__temp_h18 res))
                    (= (sel |var__temp_h'20| other) (sel var__temp_h18 other)))
               a!2)))
(let ((a!4 (=> (not (> (sel var__temp_h18 res) 20)) a!3)))
  (not (and a!1 a!4))))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************5
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h22 --->  Ty_heap  
 var__temp_v23 --->  Ty_int  
 var__temp_h'24 --->  Ty_heap  
 var__temp_v_err25 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h22, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h22, other ) ==(0) => 
 	 Rel (sel)( , var__temp_h22, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h22, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'24, res ) ==(var__temp_v23) AND 
 	 Rel (sel)( , var__temp_h'24, res ) ==((sel)( , var__temp_h22, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'24, other ) ==(sel)( , var__temp_h22, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'24, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'24, other ) > (4)
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h22 T85)
(declare-const var__temp_v23 Int)
(declare-const |var__temp_h'24| T85)
(declare-const var__temp_v_err25 T86)
(declare-const err T99)

solver 
 (declare-sort T85)
(declare-fun sel (T85 Int) Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'24| () T85)
(declare-fun res () Int)
(declare-fun var__temp_h22 () T85)
(declare-fun var__temp_v23 () Int)
(assert true)
(assert (let ((a!1 (=> (and (= (sel var__temp_h22 res) 0)
                    (= (sel var__temp_h22 other) 0))
               (> (sel var__temp_h22 res) 4)))
      (a!2 (and (= (sel |var__temp_h'24| res) var__temp_v23)
                (= (sel |var__temp_h'24| res) (+ (sel var__temp_h22 res) 10))
                (= (sel |var__temp_h'24| other) (sel var__temp_h22 other))))
      (a!3 (and (= (sel |var__temp_h'24| res) 10)
                (not (> (sel |var__temp_h'24| other) 4)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h22 res) 4) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************6
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h26 --->  Ty_heap  
 var__temp_v27 --->  Ty_int  
 var__temp_h'28 --->  Ty_heap  
 var__temp_v_err29 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h26, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h26, other ) ==(0) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'28, res ) ==(var__temp_v27) AND 
 	 Base var__temp_v27 = 20 AND 
 	 Rel (sel)( , var__temp_h'28, other ) ==(sel)( , var__temp_h26, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'28, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'28, other ) > (4)
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h26 T102)
(declare-const var__temp_v27 Int)
(declare-const |var__temp_h'28| T102)
(declare-const var__temp_v_err29 T103)
(declare-const err T116)
    (declare-const |20| Int)
  
solver 
 (declare-sort T102)
(declare-fun |20| () Int)
(declare-fun sel (T102 Int) Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'28| () T102)
(declare-fun res () Int)
(declare-fun var__temp_h26 () T102)
(declare-fun var__temp_v27 () Int)
(assert true)
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h26 res) 0)
                    (= (sel var__temp_h26 other) 0))
               true))
      (a!2 (and (= (sel |var__temp_h'28| res) 10)
                (not (> (sel |var__temp_h'28| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'28| res) var__temp_v27)
                    (= var__temp_v27 |20|)
                    (= (sel |var__temp_h'28| other) (sel var__temp_h26 other)))
               a!2)))
  (not (and a!1 (=> true a!3))))))

***************Selection Failed************foo'
 *********************Enumeration Iteration*****************7
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h30 --->  Ty_heap  
 var__temp_v31 --->  Ty_int  
 var__temp_h'32 --->  Ty_heap  
 var__temp_v_err33 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h30, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h30, other ) ==(0) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'32, res ) ==(var__temp_v31) AND 
 	 Base var__temp_v31 = 5 AND 
 	 Rel (sel)( , var__temp_h'32, other ) ==(sel)( , var__temp_h30, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'32, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'32, other ) > (4)
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h30 T119)
(declare-const var__temp_v31 Int)
(declare-const |var__temp_h'32| T119)
(declare-const var__temp_v_err33 T120)
(declare-const err T133)
    (declare-const |5| Int)
  
solver 
 (declare-sort T119)
(declare-fun |5| () Int)
(declare-fun sel (T119 Int) Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'32| () T119)
(declare-fun res () Int)
(declare-fun var__temp_h30 () T119)
(declare-fun var__temp_v31 () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h30 res) 0)
                    (= (sel var__temp_h30 other) 0))
               true))
      (a!2 (and (= (sel |var__temp_h'32| res) 10)
                (not (> (sel |var__temp_h'32| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'32| res) var__temp_v31)
                    (= var__temp_v31 |5|)
                    (= (sel |var__temp_h'32| other) (sel var__temp_h30 other)))
               a!2)))
  (not (and a!1 (=> true a!3))))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************8
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h34 --->  Ty_heap  
 var__temp_v35 --->  Ty_int  
 var__temp_h'36 --->  Ty_heap  
 var__temp_v_err37 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h34, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h34, other ) ==(0) => 
 	 Rel (sel)( , var__temp_h34, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h34, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'36, res ) ==(var__temp_v35) AND 
 	 Rel (sel)( , var__temp_h'36, res ) ==((sel)( , var__temp_h34, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'36, other ) ==(sel)( , var__temp_h34, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'36, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'36, other ) > (4)
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h34 T136)
(declare-const var__temp_v35 Int)
(declare-const |var__temp_h'36| T136)
(declare-const var__temp_v_err37 T137)
(declare-const err T150)

solver 
 (declare-sort T136)
(declare-fun sel (T136 Int) Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'36| () T136)
(declare-fun res () Int)
(declare-fun var__temp_h34 () T136)
(declare-fun var__temp_v35 () Int)
(assert true)
(assert (let ((a!1 (=> (and (= (sel var__temp_h34 res) 0)
                    (= (sel var__temp_h34 other) 0))
               (= (sel var__temp_h34 res) 5)))
      (a!2 (and (= (sel |var__temp_h'36| res) var__temp_v35)
                (= (sel |var__temp_h'36| res) (+ (sel var__temp_h34 res) 2))
                (= (sel |var__temp_h'36| other) (sel var__temp_h34 other))))
      (a!3 (and (= (sel |var__temp_h'36| res) 10)
                (not (> (sel |var__temp_h'36| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h34 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************9
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {v:Ty_int | true}
isynthesizeConstApp
Spec Base {v:Ty_int | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Terms
esynthesizeBind
PARTIAL PATH
SUB 
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {var_v38:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c3'
baz
c5
c4
c2'
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************10
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c Not (sel)( , h, res ) > (8)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==((sel)( , h, other ) + (5)) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {var_v38:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==((sel)( , h, other ) + (5)) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h39 --->  Ty_heap  
 var__temp_v40 --->  Ty_int  
 var__temp_h'41 --->  Ty_heap  
 var__temp_v_err42 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h39, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h39, other ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h39, res ) > (8) AND 
 	 Rel (sel)( , var__temp_h39, other ) ==(0) AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h39, res ) > (8) AND 
 	 Rel (sel)( , var__temp_h39, other ) ==(0) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'41, res ) ==(var__temp_v40) AND 
 	 Rel (sel)( , var__temp_h'41, res ) ==((sel)( , var__temp_h39, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'41, other ) ==((sel)( , var__temp_h39, other ) + (5)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h39 T153)
(declare-const var__temp_v40 Int)
(declare-const |var__temp_h'41| T153)
(declare-const var__temp_v_err42 T154)
(declare-const err T167)

solver 
 (declare-sort T153)
(declare-fun sel (T153 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h39 () T153)
(declare-fun |var__temp_h'41| () T153)
(declare-fun res () Int)
(declare-fun var__temp_v40 () Int)
(assert true)
(assert (let ((a!1 (and (not (> (sel var__temp_h39 res) 8))
                (= (sel var__temp_h39 other) 0)))
      (a!3 (and (= (sel |var__temp_h'41| res) var__temp_v40)
                (= (sel |var__temp_h'41| res) (+ (sel var__temp_h39 res) 3))
                (= (sel |var__temp_h'41| other) (+ (sel var__temp_h39 other) 5)))))
(let ((a!2 (=> (and (= (sel var__temp_h39 res) 0)
                    (= (sel var__temp_h39 other) 0))
               a!1)))
  (not (and a!2 (=> a!1 (=> a!3 true)))))))

***************Selection Successful************c3'
PARTIAL PATH NEW
SUB 
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i44 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v45:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i44 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c4
c2'
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************11
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v45:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i44 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h46 --->  Ty_heap  
 var__temp_v47 --->  Ty_int  
 var__temp_h'48 --->  Ty_heap  
 var__temp_v_err49 --->  error  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h46, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h46, res ) ==((sel)( , var_h43, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h46, other ) ==((sel)( , var_h43, other ) + (5)) => 
 	 Rel (sel)( , var__temp_h46, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h46, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'48, res ) ==(var__temp_v47) AND 
 	 Rel (sel)( , var__temp_h'48, res ) ==((sel)( , var__temp_h46, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'48, other ) ==(sel)( , var__temp_h46, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'48, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'48, other ) > (4)
 
VC_END(declare-const var_h_i44 T170)
(declare-const var_h43 T170)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h46 T170)
(declare-const var__temp_v47 Int)
(declare-const |var__temp_h'48| T170)
(declare-const var__temp_v_err49 T171)
(declare-const var_h43 T170)
(declare-const err T184)

solver 
 (declare-sort T170)
(declare-fun sel (T170 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T170)
(declare-fun other () Int)
(declare-fun |var__temp_h'48| () T170)
(declare-fun var__temp_h46 () T170)
(declare-fun var__temp_v47 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h46 res) v)
                (= (sel var__temp_h46 res) (+ (sel var_h43 res) 3))
                (= (sel var__temp_h46 other) (+ (sel var_h43 other) 5))))
      (a!2 (and (= (sel |var__temp_h'48| res) var__temp_v47)
                (= (sel |var__temp_h'48| res) (+ (sel var__temp_h46 res) 3))
                (= (sel |var__temp_h'48| other) (sel var__temp_h46 other))))
      (a!3 (and (= (sel |var__temp_h'48| res) 10)
                (not (> (sel |var__temp_h'48| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h46 res) 7))
                (=> (= (sel var__temp_h46 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************12
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v45:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i44 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h50 --->  Ty_heap  
 var__temp_v51 --->  Ty_int  
 var__temp_h'52 --->  Ty_heap  
 var__temp_v_err53 --->  error  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h50, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h50, res ) ==((sel)( , var_h43, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h50, other ) ==((sel)( , var_h43, other ) + (5)) => 
 	 Rel (sel)( , var__temp_h50, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h50, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'52, res ) ==(var__temp_v51) AND 
 	 Rel (sel)( , var__temp_h'52, res ) ==((sel)( , var__temp_h50, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'52, other ) ==(sel)( , var__temp_h50, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'52, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'52, other ) > (4)
 
VC_END(declare-const var_h_i44 T187)
(declare-const var_h43 T187)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h50 T187)
(declare-const var__temp_v51 Int)
(declare-const |var__temp_h'52| T187)
(declare-const var__temp_v_err53 T188)
(declare-const var_h43 T187)
(declare-const err T201)

solver 
 (declare-sort T187)
(declare-fun sel (T187 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T187)
(declare-fun other () Int)
(declare-fun |var__temp_h'52| () T187)
(declare-fun var__temp_h50 () T187)
(declare-fun var__temp_v51 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h50 res) v)
                (= (sel var__temp_h50 res) (+ (sel var_h43 res) 3))
                (= (sel var__temp_h50 other) (+ (sel var_h43 other) 5))))
      (a!2 (and (= (sel |var__temp_h'52| res) var__temp_v51)
                (= (sel |var__temp_h'52| res) (+ (sel var__temp_h50 res) 5))
                (= (sel |var__temp_h'52| other) (sel var__temp_h50 other))))
      (a!3 (and (= (sel |var__temp_h'52| res) 10)
                (not (> (sel |var__temp_h'52| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h50 res) 7))
                (=> (= (sel var__temp_h50 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************13
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (30) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v45:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i44 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h54 --->  Ty_heap  
 var__temp_v55 --->  Ty_int  
 var__temp_h'56 --->  Ty_heap  
 var__temp_v_err57 --->  error  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h54, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h54, res ) ==((sel)( , var_h43, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h54, other ) ==((sel)( , var_h43, other ) + (5)) => 
 	 Rel (sel)( , var__temp_h54, res ) > (30) AND 
 	 Rel (sel)( , var__temp_h54, res ) > (30) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'56, res ) ==(var__temp_v55) AND 
 	 Rel (sel)( , var__temp_h'56, res ) ==((sel)( , var__temp_h54, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'56, other ) ==(sel)( , var__temp_h54, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'56, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'56, other ) > (4)
 
VC_END(declare-const var_h_i44 T204)
(declare-const var_h43 T204)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h54 T204)
(declare-const var__temp_v55 Int)
(declare-const |var__temp_h'56| T204)
(declare-const var__temp_v_err57 T205)
(declare-const var_h43 T204)
(declare-const err T218)

solver 
 (declare-sort T204)
(declare-fun sel (T204 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T204)
(declare-fun other () Int)
(declare-fun |var__temp_h'56| () T204)
(declare-fun var__temp_h54 () T204)
(declare-fun var__temp_v55 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h54 res) v)
                (= (sel var__temp_h54 res) (+ (sel var_h43 res) 3))
                (= (sel var__temp_h54 other) (+ (sel var_h43 other) 5))))
      (a!3 (and (= (sel |var__temp_h'56| res) var__temp_v55)
                (= (sel |var__temp_h'56| res) (+ (sel var__temp_h54 res) 5))
                (= (sel |var__temp_h'56| other) (sel var__temp_h54 other))))
      (a!4 (and (= (sel |var__temp_h'56| res) 10)
                (not (> (sel |var__temp_h'56| other) 4)))))
(let ((a!2 (=> a!1 (not (> (sel var__temp_h54 res) 30))))
      (a!5 (=> (not (> (sel var__temp_h54 res) 30)) (=> a!3 a!4))))
  (not (and a!2 a!5)))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************14
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v45:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i44 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h58 --->  Ty_heap  
 var__temp_v59 --->  Ty_int  
 var__temp_h'60 --->  Ty_heap  
 var__temp_v_err61 --->  error  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h58, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h58, res ) ==((sel)( , var_h43, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h58, other ) ==((sel)( , var_h43, other ) + (5)) => 
 	 Rel (sel)( , var__temp_h58, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h58, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'60, res ) ==(var__temp_v59) AND 
 	 Rel (sel)( , var__temp_h58, res ) ==(sel)( , var__temp_h58, res ) AND 
 	 Rel (sel)( , var__temp_h'60, other ) ==(sel)( , var__temp_h58, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'60, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'60, other ) > (4)
 
VC_END(declare-const var_h_i44 T221)
(declare-const var_h43 T221)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h58 T221)
(declare-const var__temp_v59 Int)
(declare-const |var__temp_h'60| T221)
(declare-const var__temp_v_err61 T222)
(declare-const var_h43 T221)
(declare-const err T235)

solver 
 (declare-sort T221)
(declare-fun sel (T221 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T221)
(declare-fun other () Int)
(declare-fun |var__temp_h'60| () T221)
(declare-fun var__temp_h58 () T221)
(declare-fun var__temp_v59 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h58 res) v)
                (= (sel var__temp_h58 res) (+ (sel var_h43 res) 3))
                (= (sel var__temp_h58 other) (+ (sel var_h43 other) 5))))
      (a!3 (and (= (sel |var__temp_h'60| res) 10)
                (not (> (sel |var__temp_h'60| other) 4)))))
(let ((a!2 (=> a!1 (not (> (sel var__temp_h58 res) 20))))
      (a!4 (=> (and (= (sel |var__temp_h'60| res) var__temp_v59)
                    (= (sel var__temp_h58 res) (sel var__temp_h58 res))
                    (= (sel |var__temp_h'60| other) (sel var__temp_h58 other)))
               a!3)))
(let ((a!5 (=> (not (> (sel var__temp_h58 res) 20)) a!4)))
  (not (and a!2 a!5))))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************15
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v45:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i44 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h62 --->  Ty_heap  
 var__temp_v63 --->  Ty_int  
 var__temp_h'64 --->  Ty_heap  
 var__temp_v_err65 --->  error  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h62, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h62, res ) ==((sel)( , var_h43, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h62, other ) ==((sel)( , var_h43, other ) + (5)) => 
 	 Rel (sel)( , var__temp_h62, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h62, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'64, res ) ==(var__temp_v63) AND 
 	 Rel (sel)( , var__temp_h'64, res ) ==((sel)( , var__temp_h62, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'64, other ) ==(sel)( , var__temp_h62, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'64, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'64, other ) > (4)
 
VC_END(declare-const var_h_i44 T238)
(declare-const var_h43 T238)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h62 T238)
(declare-const var__temp_v63 Int)
(declare-const |var__temp_h'64| T238)
(declare-const var__temp_v_err65 T239)
(declare-const var_h43 T238)
(declare-const err T252)

solver 
 (declare-sort T238)
(declare-fun sel (T238 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T238)
(declare-fun other () Int)
(declare-fun |var__temp_h'64| () T238)
(declare-fun var__temp_h62 () T238)
(declare-fun var__temp_v63 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h62 res) v)
                (= (sel var__temp_h62 res) (+ (sel var_h43 res) 3))
                (= (sel var__temp_h62 other) (+ (sel var_h43 other) 5))))
      (a!2 (and (= (sel |var__temp_h'64| res) var__temp_v63)
                (= (sel |var__temp_h'64| res) (+ (sel var__temp_h62 res) 10))
                (= (sel |var__temp_h'64| other) (sel var__temp_h62 other))))
      (a!3 (and (= (sel |var__temp_h'64| res) 10)
                (not (> (sel |var__temp_h'64| other) 4)))))
(let ((a!4 (and (=> a!1 (> (sel var__temp_h62 res) 4))
                (=> (> (sel var__temp_h62 res) 4) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************16
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v45:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i44 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h66 --->  Ty_heap  
 var__temp_v67 --->  Ty_int  
 var__temp_h'68 --->  Ty_heap  
 var__temp_v_err69 --->  error  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h66, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h66, res ) ==((sel)( , var_h43, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h66, other ) ==((sel)( , var_h43, other ) + (5)) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'68, res ) ==(var__temp_v67) AND 
 	 Base var__temp_v67 = 20 AND 
 	 Rel (sel)( , var__temp_h'68, other ) ==(sel)( , var__temp_h66, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'68, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'68, other ) > (4)
 
VC_END(declare-const var_h_i44 T255)
(declare-const var_h43 T255)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h66 T255)
(declare-const var__temp_v67 Int)
(declare-const |var__temp_h'68| T255)
(declare-const var__temp_v_err69 T256)
(declare-const var_h43 T255)
(declare-const err T269)
    (declare-const |20| Int)
  
solver 
 (declare-sort T255)
(declare-fun sel (T255 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T255)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'68| () T255)
(declare-fun var__temp_h66 () T255)
(declare-fun var__temp_v67 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (and (= (sel var__temp_h66 res) v)
                (= (sel var__temp_h66 res) (+ (sel var_h43 res) 3))
                (= (sel var__temp_h66 other) (+ (sel var_h43 other) 5))))
      (a!2 (and (= (sel |var__temp_h'68| res) 10)
                (not (> (sel |var__temp_h'68| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'68| res) var__temp_v67)
                    (= var__temp_v67 |20|)
                    (= (sel |var__temp_h'68| other) (sel var__temp_h66 other)))
               a!2)))
  (not (and (=> a!1 true) (=> true a!3))))))

***************Selection Failed************foo'
 *********************Enumeration Iteration*****************17
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v45:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i44 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h70 --->  Ty_heap  
 var__temp_v71 --->  Ty_int  
 var__temp_h'72 --->  Ty_heap  
 var__temp_v_err73 --->  error  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h70, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h70, res ) ==((sel)( , var_h43, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h70, other ) ==((sel)( , var_h43, other ) + (5)) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'72, res ) ==(var__temp_v71) AND 
 	 Base var__temp_v71 = 5 AND 
 	 Rel (sel)( , var__temp_h'72, other ) ==(sel)( , var__temp_h70, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'72, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'72, other ) > (4)
 
VC_END(declare-const var_h_i44 T272)
(declare-const var_h43 T272)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h70 T272)
(declare-const var__temp_v71 Int)
(declare-const |var__temp_h'72| T272)
(declare-const var__temp_v_err73 T273)
(declare-const var_h43 T272)
(declare-const err T286)
    (declare-const |5| Int)
  
solver 
 (declare-sort T272)
(declare-fun sel (T272 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T272)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'72| () T272)
(declare-fun var__temp_h70 () T272)
(declare-fun var__temp_v71 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h70 res) v)
                (= (sel var__temp_h70 res) (+ (sel var_h43 res) 3))
                (= (sel var__temp_h70 other) (+ (sel var_h43 other) 5))))
      (a!2 (and (= (sel |var__temp_h'72| res) 10)
                (not (> (sel |var__temp_h'72| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'72| res) var__temp_v71)
                    (= var__temp_v71 |5|)
                    (= (sel |var__temp_h'72| other) (sel var__temp_h70 other)))
               a!2)))
  (not (and (=> a!1 true) (=> true a!3))))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************18
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v45:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i44 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h74 --->  Ty_heap  
 var__temp_v75 --->  Ty_int  
 var__temp_h'76 --->  Ty_heap  
 var__temp_v_err77 --->  error  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h74, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h74, res ) ==((sel)( , var_h43, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h74, other ) ==((sel)( , var_h43, other ) + (5)) => 
 	 Rel (sel)( , var__temp_h74, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h74, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'76, res ) ==(var__temp_v75) AND 
 	 Rel (sel)( , var__temp_h'76, res ) ==((sel)( , var__temp_h74, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'76, other ) ==(sel)( , var__temp_h74, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'76, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'76, other ) > (4)
 
VC_END(declare-const var_h_i44 T289)
(declare-const var_h43 T289)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h74 T289)
(declare-const var__temp_v75 Int)
(declare-const |var__temp_h'76| T289)
(declare-const var__temp_v_err77 T290)
(declare-const var_h43 T289)
(declare-const err T303)

solver 
 (declare-sort T289)
(declare-fun sel (T289 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T289)
(declare-fun other () Int)
(declare-fun |var__temp_h'76| () T289)
(declare-fun var__temp_h74 () T289)
(declare-fun var__temp_v75 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h74 res) v)
                (= (sel var__temp_h74 res) (+ (sel var_h43 res) 3))
                (= (sel var__temp_h74 other) (+ (sel var_h43 other) 5))))
      (a!2 (and (= (sel |var__temp_h'76| res) var__temp_v75)
                (= (sel |var__temp_h'76| res) (+ (sel var__temp_h74 res) 2))
                (= (sel |var__temp_h'76| other) (sel var__temp_h74 other))))
      (a!3 (and (= (sel |var__temp_h'76| res) 10)
                (not (> (sel |var__temp_h'76| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h74 res) 5))
                (=> (= (sel var__temp_h74 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************19
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v45:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v45:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v78:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c4
c2'
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************20
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v78:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h79 --->  Ty_heap  
 var__temp_v80 --->  Ty_int  
 var__temp_h'81 --->  Ty_heap  
 var__temp_v_err82 --->  error  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h79, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h79, res ) ==((sel)( , var_h43, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h79, other ) ==((sel)( , var_h43, other ) + (5)) => 
 	 Rel (sel)( , var__temp_h79, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h79, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'81, res ) ==(var__temp_v80) AND 
 	 Rel (sel)( , var__temp_h'81, res ) ==((sel)( , var__temp_h79, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'81, other ) ==(sel)( , var__temp_h79, other ) => 
 	 True
 
VC_END(declare-const var_h_i44 T306)
(declare-const var_h43 T306)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h79 T306)
(declare-const var__temp_v80 Int)
(declare-const |var__temp_h'81| T306)
(declare-const var__temp_v_err82 T307)
(declare-const var_h43 T306)
(declare-const err T320)

solver 
 (declare-sort T306)
(declare-fun sel (T306 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T306)
(declare-fun other () Int)
(declare-fun var__temp_h79 () T306)
(declare-fun |var__temp_h'81| () T306)
(declare-fun var__temp_v80 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h79 res) v)
                (= (sel var__temp_h79 res) (+ (sel var_h43 res) 3))
                (= (sel var__temp_h79 other) (+ (sel var_h43 other) 5))))
      (a!2 (and (= (sel |var__temp_h'81| res) var__temp_v80)
                (= (sel |var__temp_h'81| res) (+ (sel var__temp_h79 res) 3))
                (= (sel |var__temp_h'81| other) (sel var__temp_h79 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h79 res) 7))
                (=> (= (sel var__temp_h79 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************21
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v78:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h83 --->  Ty_heap  
 var__temp_v84 --->  Ty_int  
 var__temp_h'85 --->  Ty_heap  
 var__temp_v_err86 --->  error  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h83, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h83, res ) ==((sel)( , var_h43, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h83, other ) ==((sel)( , var_h43, other ) + (5)) => 
 	 Rel (sel)( , var__temp_h83, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h83, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'85, res ) ==(var__temp_v84) AND 
 	 Rel (sel)( , var__temp_h'85, res ) ==((sel)( , var__temp_h83, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'85, other ) ==(sel)( , var__temp_h83, other ) => 
 	 True
 
VC_END(declare-const var_h_i44 T323)
(declare-const var_h43 T323)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h83 T323)
(declare-const var__temp_v84 Int)
(declare-const |var__temp_h'85| T323)
(declare-const var__temp_v_err86 T324)
(declare-const var_h43 T323)
(declare-const err T337)

solver 
 (declare-sort T323)
(declare-fun sel (T323 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T323)
(declare-fun other () Int)
(declare-fun var__temp_h83 () T323)
(declare-fun |var__temp_h'85| () T323)
(declare-fun var__temp_v84 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h83 res) v)
                (= (sel var__temp_h83 res) (+ (sel var_h43 res) 3))
                (= (sel var__temp_h83 other) (+ (sel var_h43 other) 5))))
      (a!2 (and (= (sel |var__temp_h'85| res) var__temp_v84)
                (= (sel |var__temp_h'85| res) (+ (sel var__temp_h83 res) 5))
                (= (sel |var__temp_h'85| other) (sel var__temp_h83 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h83 res) 7))
                (=> (= (sel var__temp_h83 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************22
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (30) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v78:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h87 --->  Ty_heap  
 var__temp_v88 --->  Ty_int  
 var__temp_h'89 --->  Ty_heap  
 var__temp_v_err90 --->  error  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h87, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h87, res ) ==((sel)( , var_h43, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h87, other ) ==((sel)( , var_h43, other ) + (5)) => 
 	 Rel (sel)( , var__temp_h87, res ) > (30) AND 
 	 Rel (sel)( , var__temp_h87, res ) > (30) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'89, res ) ==(var__temp_v88) AND 
 	 Rel (sel)( , var__temp_h'89, res ) ==((sel)( , var__temp_h87, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'89, other ) ==(sel)( , var__temp_h87, other ) => 
 	 True
 
VC_END(declare-const var_h_i44 T340)
(declare-const var_h43 T340)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h87 T340)
(declare-const var__temp_v88 Int)
(declare-const |var__temp_h'89| T340)
(declare-const var__temp_v_err90 T341)
(declare-const var_h43 T340)
(declare-const err T354)

solver 
 (declare-sort T340)
(declare-fun sel (T340 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T340)
(declare-fun other () Int)
(declare-fun var__temp_h87 () T340)
(declare-fun |var__temp_h'89| () T340)
(declare-fun var__temp_v88 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h87 res) v)
                (= (sel var__temp_h87 res) (+ (sel var_h43 res) 3))
                (= (sel var__temp_h87 other) (+ (sel var_h43 other) 5))))
      (a!3 (and (= (sel |var__temp_h'89| res) var__temp_v88)
                (= (sel |var__temp_h'89| res) (+ (sel var__temp_h87 res) 5))
                (= (sel |var__temp_h'89| other) (sel var__temp_h87 other)))))
(let ((a!2 (=> a!1 (not (> (sel var__temp_h87 res) 30))))
      (a!4 (=> (not (> (sel var__temp_h87 res) 30)) (=> a!3 true))))
  (not (and a!2 a!4)))))

***************Selection Successful************c4
PARTIAL PATH NEW
SUB 
 	 --c4
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i92 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i92 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i92, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i92, res ) ==((sel)( , var_h91, res ) + (5))
 	 , (sel)( , var_h_i92, other ) ==(sel)( , var_h91, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v93:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i92 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************23
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i92 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i92, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i92, res ) ==((sel)( , var_h91, res ) + (5))
 	 , (sel)( , var_h_i92, other ) ==(sel)( , var_h91, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v93:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i92 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h94 --->  Ty_heap  
 var__temp_v95 --->  Ty_int  
 var__temp_h'96 --->  Ty_heap  
 var__temp_v_err97 --->  error  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h94, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h94, res ) ==((sel)( , var_h91, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h94, other ) ==(sel)( , var_h91, other ) => 
 	 Rel (sel)( , var__temp_h94, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h94, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'96, res ) ==(var__temp_v95) AND 
 	 Rel (sel)( , var__temp_h'96, res ) ==((sel)( , var__temp_h94, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'96, other ) ==(sel)( , var__temp_h94, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'96, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'96, other ) > (4)
 
VC_END(declare-const var_h_i92 T357)
(declare-const var_h91 T357)
(declare-const v Int)
(declare-const var_h_i44 T357)
(declare-const var_h43 T357)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h94 T357)
(declare-const var__temp_v95 Int)
(declare-const |var__temp_h'96| T357)
(declare-const var__temp_v_err97 T358)
(declare-const var_h91 T357)
(declare-const var_h43 T357)
(declare-const err T371)

solver 
 (declare-sort T357)
(declare-fun sel (T357 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T357)
(declare-fun var_h43 () T357)
(declare-fun other () Int)
(declare-fun |var__temp_h'96| () T357)
(declare-fun var__temp_h94 () T357)
(declare-fun var__temp_v95 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h94 res) v)
                (= (sel var__temp_h94 res) (+ (sel var_h91 res) 5))
                (= (sel var__temp_h94 other) (sel var_h91 other))))
      (a!2 (and (= (sel |var__temp_h'96| res) var__temp_v95)
                (= (sel |var__temp_h'96| res) (+ (sel var__temp_h94 res) 3))
                (= (sel |var__temp_h'96| other) (sel var__temp_h94 other))))
      (a!3 (and (= (sel |var__temp_h'96| res) 10)
                (not (> (sel |var__temp_h'96| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h94 res) 7))
                (=> (= (sel var__temp_h94 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************24
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i92 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i92, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i92, res ) ==((sel)( , var_h91, res ) + (5))
 	 , (sel)( , var_h_i92, other ) ==(sel)( , var_h91, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v93:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i92 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h98 --->  Ty_heap  
 var__temp_v99 --->  Ty_int  
 var__temp_h'100 --->  Ty_heap  
 var__temp_v_err101 --->  error  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h98, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h98, res ) ==((sel)( , var_h91, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h98, other ) ==(sel)( , var_h91, other ) => 
 	 Rel (sel)( , var__temp_h98, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h98, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'100, res ) ==(var__temp_v99) AND 
 	 Rel (sel)( , var__temp_h'100, res ) ==((sel)( , var__temp_h98, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'100, other ) ==(sel)( , var__temp_h98, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'100, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'100, other ) > (4)
 
VC_END(declare-const var_h_i92 T374)
(declare-const var_h91 T374)
(declare-const v Int)
(declare-const var_h_i44 T374)
(declare-const var_h43 T374)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h98 T374)
(declare-const var__temp_v99 Int)
(declare-const |var__temp_h'100| T374)
(declare-const var__temp_v_err101 T375)
(declare-const var_h91 T374)
(declare-const var_h43 T374)
(declare-const err T388)

solver 
 (declare-sort T374)
(declare-fun sel (T374 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T374)
(declare-fun var_h43 () T374)
(declare-fun other () Int)
(declare-fun |var__temp_h'100| () T374)
(declare-fun var__temp_h98 () T374)
(declare-fun var__temp_v99 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h98 res) v)
                (= (sel var__temp_h98 res) (+ (sel var_h91 res) 5))
                (= (sel var__temp_h98 other) (sel var_h91 other))))
      (a!2 (and (= (sel |var__temp_h'100| res) var__temp_v99)
                (= (sel |var__temp_h'100| res) (+ (sel var__temp_h98 res) 5))
                (= (sel |var__temp_h'100| other) (sel var__temp_h98 other))))
      (a!3 (and (= (sel |var__temp_h'100| res) 10)
                (not (> (sel |var__temp_h'100| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h98 res) 7))
                (=> (= (sel var__temp_h98 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************25
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i92 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i92, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i92, res ) ==((sel)( , var_h91, res ) + (5))
 	 , (sel)( , var_h_i92, other ) ==(sel)( , var_h91, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v93:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i92 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h102 --->  Ty_heap  
 var__temp_v103 --->  Ty_int  
 var__temp_h'104 --->  Ty_heap  
 var__temp_v_err105 --->  error  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h102, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h102, res ) ==((sel)( , var_h91, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h102, other ) ==(sel)( , var_h91, other ) => 
 	 Rel (sel)( , var__temp_h102, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h102, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'104, res ) ==(var__temp_v103) AND 
 	 Rel (sel)( , var__temp_h102, res ) ==(sel)( , var__temp_h102, res ) AND 
 	 Rel (sel)( , var__temp_h'104, other ) ==(sel)( , var__temp_h102, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'104, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'104, other ) > (4)
 
VC_END(declare-const var_h_i92 T391)
(declare-const var_h91 T391)
(declare-const v Int)
(declare-const var_h_i44 T391)
(declare-const var_h43 T391)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h102 T391)
(declare-const var__temp_v103 Int)
(declare-const |var__temp_h'104| T391)
(declare-const var__temp_v_err105 T392)
(declare-const var_h91 T391)
(declare-const var_h43 T391)
(declare-const err T405)

solver 
 (declare-sort T391)
(declare-fun sel (T391 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T391)
(declare-fun var_h43 () T391)
(declare-fun other () Int)
(declare-fun |var__temp_h'104| () T391)
(declare-fun var__temp_h102 () T391)
(declare-fun var__temp_v103 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h102 res) v)
                (= (sel var__temp_h102 res) (+ (sel var_h91 res) 5))
                (= (sel var__temp_h102 other) (sel var_h91 other))))
      (a!3 (and (= (sel |var__temp_h'104| res) 10)
                (not (> (sel |var__temp_h'104| other) 4)))))
(let ((a!2 (=> a!1 (not (> (sel var__temp_h102 res) 20))))
      (a!4 (=> (and (= (sel |var__temp_h'104| res) var__temp_v103)
                    (= (sel var__temp_h102 res) (sel var__temp_h102 res))
                    (= (sel |var__temp_h'104| other) (sel var__temp_h102 other)))
               a!3)))
(let ((a!5 (=> (not (> (sel var__temp_h102 res) 20)) a!4)))
  (not (and a!2 a!5))))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************26
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i92 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i92, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i92, res ) ==((sel)( , var_h91, res ) + (5))
 	 , (sel)( , var_h_i92, other ) ==(sel)( , var_h91, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v93:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i92 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h106 --->  Ty_heap  
 var__temp_v107 --->  Ty_int  
 var__temp_h'108 --->  Ty_heap  
 var__temp_v_err109 --->  error  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h106, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h106, res ) ==((sel)( , var_h91, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h106, other ) ==(sel)( , var_h91, other ) => 
 	 Rel (sel)( , var__temp_h106, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h106, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'108, res ) ==(var__temp_v107) AND 
 	 Rel (sel)( , var__temp_h'108, res ) ==((sel)( , var__temp_h106, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'108, other ) ==(sel)( , var__temp_h106, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'108, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'108, other ) > (4)
 
VC_END(declare-const var_h_i92 T408)
(declare-const var_h91 T408)
(declare-const v Int)
(declare-const var_h_i44 T408)
(declare-const var_h43 T408)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h106 T408)
(declare-const var__temp_v107 Int)
(declare-const |var__temp_h'108| T408)
(declare-const var__temp_v_err109 T409)
(declare-const var_h91 T408)
(declare-const var_h43 T408)
(declare-const err T422)

solver 
 (declare-sort T408)
(declare-fun sel (T408 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T408)
(declare-fun var_h43 () T408)
(declare-fun other () Int)
(declare-fun |var__temp_h'108| () T408)
(declare-fun var__temp_h106 () T408)
(declare-fun var__temp_v107 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h106 res) v)
                (= (sel var__temp_h106 res) (+ (sel var_h91 res) 5))
                (= (sel var__temp_h106 other) (sel var_h91 other))))
      (a!2 (and (= (sel |var__temp_h'108| res) var__temp_v107)
                (= (sel |var__temp_h'108| res) (+ (sel var__temp_h106 res) 10))
                (= (sel |var__temp_h'108| other) (sel var__temp_h106 other))))
      (a!3 (and (= (sel |var__temp_h'108| res) 10)
                (not (> (sel |var__temp_h'108| other) 4)))))
(let ((a!4 (and (=> a!1 (> (sel var__temp_h106 res) 4))
                (=> (> (sel var__temp_h106 res) 4) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************27
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i92 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i92, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i92, res ) ==((sel)( , var_h91, res ) + (5))
 	 , (sel)( , var_h_i92, other ) ==(sel)( , var_h91, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v93:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i92 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h110 --->  Ty_heap  
 var__temp_v111 --->  Ty_int  
 var__temp_h'112 --->  Ty_heap  
 var__temp_v_err113 --->  error  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h110, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h110, res ) ==((sel)( , var_h91, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h110, other ) ==(sel)( , var_h91, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'112, res ) ==(var__temp_v111) AND 
 	 Base var__temp_v111 = 20 AND 
 	 Rel (sel)( , var__temp_h'112, other ) ==(sel)( , var__temp_h110, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'112, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'112, other ) > (4)
 
VC_END(declare-const var_h_i92 T425)
(declare-const var_h91 T425)
(declare-const v Int)
(declare-const var_h_i44 T425)
(declare-const var_h43 T425)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h110 T425)
(declare-const var__temp_v111 Int)
(declare-const |var__temp_h'112| T425)
(declare-const var__temp_v_err113 T426)
(declare-const var_h91 T425)
(declare-const var_h43 T425)
(declare-const err T439)
    (declare-const |20| Int)
  
solver 
 (declare-sort T425)
(declare-fun sel (T425 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T425)
(declare-fun var_h43 () T425)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'112| () T425)
(declare-fun var__temp_h110 () T425)
(declare-fun var__temp_v111 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (and (= (sel var__temp_h110 res) v)
                (= (sel var__temp_h110 res) (+ (sel var_h91 res) 5))
                (= (sel var__temp_h110 other) (sel var_h91 other))))
      (a!2 (and (= (sel |var__temp_h'112| res) 10)
                (not (> (sel |var__temp_h'112| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'112| res) var__temp_v111)
                    (= var__temp_v111 |20|)
                    (= (sel |var__temp_h'112| other) (sel var__temp_h110 other)))
               a!2)))
  (not (and (=> a!1 true) (=> true a!3))))))

***************Selection Failed************foo'
 *********************Enumeration Iteration*****************28
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i92 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i92, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i92, res ) ==((sel)( , var_h91, res ) + (5))
 	 , (sel)( , var_h_i92, other ) ==(sel)( , var_h91, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v93:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i92 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h114 --->  Ty_heap  
 var__temp_v115 --->  Ty_int  
 var__temp_h'116 --->  Ty_heap  
 var__temp_v_err117 --->  error  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h114, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h114, res ) ==((sel)( , var_h91, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h114, other ) ==(sel)( , var_h91, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'116, res ) ==(var__temp_v115) AND 
 	 Base var__temp_v115 = 5 AND 
 	 Rel (sel)( , var__temp_h'116, other ) ==(sel)( , var__temp_h114, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'116, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'116, other ) > (4)
 
VC_END(declare-const var_h_i92 T442)
(declare-const var_h91 T442)
(declare-const v Int)
(declare-const var_h_i44 T442)
(declare-const var_h43 T442)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h114 T442)
(declare-const var__temp_v115 Int)
(declare-const |var__temp_h'116| T442)
(declare-const var__temp_v_err117 T443)
(declare-const var_h91 T442)
(declare-const var_h43 T442)
(declare-const err T456)
    (declare-const |5| Int)
  
solver 
 (declare-sort T442)
(declare-fun sel (T442 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T442)
(declare-fun var_h43 () T442)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'116| () T442)
(declare-fun var__temp_h114 () T442)
(declare-fun var__temp_v115 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h114 res) v)
                (= (sel var__temp_h114 res) (+ (sel var_h91 res) 5))
                (= (sel var__temp_h114 other) (sel var_h91 other))))
      (a!2 (and (= (sel |var__temp_h'116| res) 10)
                (not (> (sel |var__temp_h'116| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'116| res) var__temp_v115)
                    (= var__temp_v115 |5|)
                    (= (sel |var__temp_h'116| other) (sel var__temp_h114 other)))
               a!2)))
  (not (and (=> a!1 true) (=> true a!3))))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************29
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i92 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i92, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i92, res ) ==((sel)( , var_h91, res ) + (5))
 	 , (sel)( , var_h_i92, other ) ==(sel)( , var_h91, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v93:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i92 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h118 --->  Ty_heap  
 var__temp_v119 --->  Ty_int  
 var__temp_h'120 --->  Ty_heap  
 var__temp_v_err121 --->  error  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h118, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h118, res ) ==((sel)( , var_h91, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h118, other ) ==(sel)( , var_h91, other ) => 
 	 Rel (sel)( , var__temp_h118, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h118, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'120, res ) ==(var__temp_v119) AND 
 	 Rel (sel)( , var__temp_h'120, res ) ==((sel)( , var__temp_h118, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'120, other ) ==(sel)( , var__temp_h118, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'120, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'120, other ) > (4)
 
VC_END(declare-const var_h_i92 T459)
(declare-const var_h91 T459)
(declare-const v Int)
(declare-const var_h_i44 T459)
(declare-const var_h43 T459)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h118 T459)
(declare-const var__temp_v119 Int)
(declare-const |var__temp_h'120| T459)
(declare-const var__temp_v_err121 T460)
(declare-const var_h91 T459)
(declare-const var_h43 T459)
(declare-const err T473)

solver 
 (declare-sort T459)
(declare-fun sel (T459 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T459)
(declare-fun var_h43 () T459)
(declare-fun other () Int)
(declare-fun |var__temp_h'120| () T459)
(declare-fun var__temp_h118 () T459)
(declare-fun var__temp_v119 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h118 res) v)
                (= (sel var__temp_h118 res) (+ (sel var_h91 res) 5))
                (= (sel var__temp_h118 other) (sel var_h91 other))))
      (a!2 (and (= (sel |var__temp_h'120| res) var__temp_v119)
                (= (sel |var__temp_h'120| res) (+ (sel var__temp_h118 res) 2))
                (= (sel |var__temp_h'120| other) (sel var__temp_h118 other))))
      (a!3 (and (= (sel |var__temp_h'120| res) 10)
                (not (> (sel |var__temp_h'120| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h118 res) 5))
                (=> (= (sel var__temp_h118 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************30
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v93:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v93:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i92 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i92, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i92, res ) ==((sel)( , var_h91, res ) + (5))
 	 , (sel)( , var_h_i92, other ) ==(sel)( , var_h91, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v122:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************31
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i92 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i92, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i92, res ) ==((sel)( , var_h91, res ) + (5))
 	 , (sel)( , var_h_i92, other ) ==(sel)( , var_h91, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v122:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h123 --->  Ty_heap  
 var__temp_v124 --->  Ty_int  
 var__temp_h'125 --->  Ty_heap  
 var__temp_v_err126 --->  error  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h123, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h123, res ) ==((sel)( , var_h91, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h123, other ) ==(sel)( , var_h91, other ) => 
 	 Rel (sel)( , var__temp_h123, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h123, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'125, res ) ==(var__temp_v124) AND 
 	 Rel (sel)( , var__temp_h'125, res ) ==((sel)( , var__temp_h123, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'125, other ) ==(sel)( , var__temp_h123, other ) => 
 	 True
 
VC_END(declare-const var_h_i92 T476)
(declare-const var_h91 T476)
(declare-const v Int)
(declare-const var_h_i44 T476)
(declare-const var_h43 T476)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h123 T476)
(declare-const var__temp_v124 Int)
(declare-const |var__temp_h'125| T476)
(declare-const var__temp_v_err126 T477)
(declare-const var_h91 T476)
(declare-const var_h43 T476)
(declare-const err T490)

solver 
 (declare-sort T476)
(declare-fun sel (T476 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T476)
(declare-fun var_h43 () T476)
(declare-fun other () Int)
(declare-fun var__temp_h123 () T476)
(declare-fun |var__temp_h'125| () T476)
(declare-fun var__temp_v124 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h123 res) v)
                (= (sel var__temp_h123 res) (+ (sel var_h91 res) 5))
                (= (sel var__temp_h123 other) (sel var_h91 other))))
      (a!2 (and (= (sel |var__temp_h'125| res) var__temp_v124)
                (= (sel |var__temp_h'125| res) (+ (sel var__temp_h123 res) 3))
                (= (sel |var__temp_h'125| other) (sel var__temp_h123 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h123 res) 7))
                (=> (= (sel var__temp_h123 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************32
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i92 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i92, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i92, res ) ==((sel)( , var_h91, res ) + (5))
 	 , (sel)( , var_h_i92, other ) ==(sel)( , var_h91, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v122:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h127 --->  Ty_heap  
 var__temp_v128 --->  Ty_int  
 var__temp_h'129 --->  Ty_heap  
 var__temp_v_err130 --->  error  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h127, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h127, res ) ==((sel)( , var_h91, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h127, other ) ==(sel)( , var_h91, other ) => 
 	 Rel (sel)( , var__temp_h127, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h127, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'129, res ) ==(var__temp_v128) AND 
 	 Rel (sel)( , var__temp_h'129, res ) ==((sel)( , var__temp_h127, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'129, other ) ==(sel)( , var__temp_h127, other ) => 
 	 True
 
VC_END(declare-const var_h_i92 T493)
(declare-const var_h91 T493)
(declare-const v Int)
(declare-const var_h_i44 T493)
(declare-const var_h43 T493)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h127 T493)
(declare-const var__temp_v128 Int)
(declare-const |var__temp_h'129| T493)
(declare-const var__temp_v_err130 T494)
(declare-const var_h91 T493)
(declare-const var_h43 T493)
(declare-const err T507)

solver 
 (declare-sort T493)
(declare-fun sel (T493 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T493)
(declare-fun var_h43 () T493)
(declare-fun other () Int)
(declare-fun var__temp_h127 () T493)
(declare-fun |var__temp_h'129| () T493)
(declare-fun var__temp_v128 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h127 res) v)
                (= (sel var__temp_h127 res) (+ (sel var_h91 res) 5))
                (= (sel var__temp_h127 other) (sel var_h91 other))))
      (a!2 (and (= (sel |var__temp_h'129| res) var__temp_v128)
                (= (sel |var__temp_h'129| res) (+ (sel var__temp_h127 res) 5))
                (= (sel |var__temp_h'129| other) (sel var__temp_h127 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h127 res) 7))
                (=> (= (sel var__temp_h127 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************33
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i92 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i92, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i92, res ) ==((sel)( , var_h91, res ) + (5))
 	 , (sel)( , var_h_i92, other ) ==(sel)( , var_h91, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v122:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h131 --->  Ty_heap  
 var__temp_v132 --->  Ty_int  
 var__temp_h'133 --->  Ty_heap  
 var__temp_v_err134 --->  error  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h131, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h131, res ) ==((sel)( , var_h91, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h131, other ) ==(sel)( , var_h91, other ) => 
 	 Rel (sel)( , var__temp_h131, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h131, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'133, res ) ==(var__temp_v132) AND 
 	 Rel (sel)( , var__temp_h131, res ) ==(sel)( , var__temp_h131, res ) AND 
 	 Rel (sel)( , var__temp_h'133, other ) ==(sel)( , var__temp_h131, other ) => 
 	 True
 
VC_END(declare-const var_h_i92 T510)
(declare-const var_h91 T510)
(declare-const v Int)
(declare-const var_h_i44 T510)
(declare-const var_h43 T510)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h131 T510)
(declare-const var__temp_v132 Int)
(declare-const |var__temp_h'133| T510)
(declare-const var__temp_v_err134 T511)
(declare-const var_h91 T510)
(declare-const var_h43 T510)
(declare-const err T524)

solver 
 (declare-sort T510)
(declare-fun sel (T510 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T510)
(declare-fun var_h43 () T510)
(declare-fun other () Int)
(declare-fun var__temp_h131 () T510)
(declare-fun |var__temp_h'133| () T510)
(declare-fun var__temp_v132 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h131 res) v)
                (= (sel var__temp_h131 res) (+ (sel var_h91 res) 5))
                (= (sel var__temp_h131 other) (sel var_h91 other))))
      (a!3 (=> (and (= (sel |var__temp_h'133| res) var__temp_v132)
                    (= (sel var__temp_h131 res) (sel var__temp_h131 res))
                    (= (sel |var__temp_h'133| other) (sel var__temp_h131 other)))
               true)))
(let ((a!2 (=> a!1 (not (> (sel var__temp_h131 res) 20))))
      (a!4 (=> (not (> (sel var__temp_h131 res) 20)) a!3)))
  (not (and a!2 a!4)))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************34
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i92 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i92, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i92, res ) ==((sel)( , var_h91, res ) + (5))
 	 , (sel)( , var_h_i92, other ) ==(sel)( , var_h91, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v122:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h135 --->  Ty_heap  
 var__temp_v136 --->  Ty_int  
 var__temp_h'137 --->  Ty_heap  
 var__temp_v_err138 --->  error  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h135, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h135, res ) ==((sel)( , var_h91, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h135, other ) ==(sel)( , var_h91, other ) => 
 	 Rel (sel)( , var__temp_h135, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h135, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'137, res ) ==(var__temp_v136) AND 
 	 Rel (sel)( , var__temp_h'137, res ) ==((sel)( , var__temp_h135, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'137, other ) ==(sel)( , var__temp_h135, other ) => 
 	 True
 
VC_END(declare-const var_h_i92 T527)
(declare-const var_h91 T527)
(declare-const v Int)
(declare-const var_h_i44 T527)
(declare-const var_h43 T527)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h135 T527)
(declare-const var__temp_v136 Int)
(declare-const |var__temp_h'137| T527)
(declare-const var__temp_v_err138 T528)
(declare-const var_h91 T527)
(declare-const var_h43 T527)
(declare-const err T541)

solver 
 (declare-sort T527)
(declare-fun sel (T527 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T527)
(declare-fun var_h43 () T527)
(declare-fun other () Int)
(declare-fun var__temp_h135 () T527)
(declare-fun |var__temp_h'137| () T527)
(declare-fun var__temp_v136 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h135 res) v)
                (= (sel var__temp_h135 res) (+ (sel var_h91 res) 5))
                (= (sel var__temp_h135 other) (sel var_h91 other))))
      (a!2 (and (= (sel |var__temp_h'137| res) var__temp_v136)
                (= (sel |var__temp_h'137| res) (+ (sel var__temp_h135 res) 10))
                (= (sel |var__temp_h'137| other) (sel var__temp_h135 other)))))
(let ((a!3 (and (=> a!1 (> (sel var__temp_h135 res) 4))
                (=> (> (sel var__temp_h135 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************35
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i92 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i92, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i92, res ) ==((sel)( , var_h91, res ) + (5))
 	 , (sel)( , var_h_i92, other ) ==(sel)( , var_h91, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v122:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h139 --->  Ty_heap  
 var__temp_v140 --->  Ty_int  
 var__temp_h'141 --->  Ty_heap  
 var__temp_v_err142 --->  error  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h139, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h139, res ) ==((sel)( , var_h91, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h139, other ) ==(sel)( , var_h91, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'141, res ) ==(var__temp_v140) AND 
 	 Base var__temp_v140 = 20 AND 
 	 Rel (sel)( , var__temp_h'141, other ) ==(sel)( , var__temp_h139, other ) => 
 	 True
 
VC_END(declare-const var_h_i92 T544)
(declare-const var_h91 T544)
(declare-const v Int)
(declare-const var_h_i44 T544)
(declare-const var_h43 T544)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h139 T544)
(declare-const var__temp_v140 Int)
(declare-const |var__temp_h'141| T544)
(declare-const var__temp_v_err142 T545)
(declare-const var_h91 T544)
(declare-const var_h43 T544)
(declare-const err T558)
    (declare-const |20| Int)
  
solver 
 (declare-sort T544)
(declare-fun sel (T544 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T544)
(declare-fun var_h43 () T544)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h139 () T544)
(declare-fun |var__temp_h'141| () T544)
(declare-fun var__temp_v140 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (and (= (sel var__temp_h139 res) v)
                (= (sel var__temp_h139 res) (+ (sel var_h91 res) 5))
                (= (sel var__temp_h139 other) (sel var_h91 other))))
      (a!2 (=> (and (= (sel |var__temp_h'141| res) var__temp_v140)
                    (= var__temp_v140 |20|)
                    (= (sel |var__temp_h'141| other) (sel var__temp_h139 other)))
               true)))
  (not (and (=> a!1 true) (=> true a!2)))))

***************Selection Successful************foo'
PARTIAL PATH NEW
SUB 
 	 --foo'
 	 --c4
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i144 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i144 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i144, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i144, other ) ==(sel)( , var_h143, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v145:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i144 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
foo
bar
 *********************Enumeration Iteration*****************36
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i144 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i144, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i144, other ) ==(sel)( , var_h143, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v145:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i144 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h146 --->  Ty_heap  
 var__temp_v147 --->  Ty_int  
 var__temp_h'148 --->  Ty_heap  
 var__temp_v_err149 --->  error  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h146, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h146, other ) ==(sel)( , var_h143, other ) => 
 	 Rel (sel)( , var__temp_h146, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h146, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'148, res ) ==(var__temp_v147) AND 
 	 Rel (sel)( , var__temp_h'148, res ) ==((sel)( , var__temp_h146, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'148, other ) ==(sel)( , var__temp_h146, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'148, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'148, other ) > (4)
 
VC_END(declare-const var_h_i144 T561)
(declare-const var_h143 T561)
(declare-const v Int)
(declare-const var_h_i92 T561)
(declare-const var_h91 T561)
(declare-const v Int)
(declare-const var_h_i44 T561)
(declare-const var_h43 T561)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h146 T561)
(declare-const var__temp_v147 Int)
(declare-const |var__temp_h'148| T561)
(declare-const var__temp_v_err149 T562)
(declare-const var_h143 T561)
(declare-const var_h91 T561)
(declare-const var_h43 T561)
(declare-const err T575)
    (declare-const |20| Int)
  
solver 
 (declare-sort T561)
(declare-fun sel (T561 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T561)
(declare-fun var_h43 () T561)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'148| () T561)
(declare-fun var__temp_h146 () T561)
(declare-fun var__temp_v147 () Int)
(declare-fun var_h143 () T561)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h146 res) v)
                    (= v |20|)
                    (= (sel var__temp_h146 other) (sel var_h143 other)))
               (= (sel var__temp_h146 res) 7)))
      (a!2 (and (= (sel |var__temp_h'148| res) var__temp_v147)
                (= (sel |var__temp_h'148| res) (+ (sel var__temp_h146 res) 3))
                (= (sel |var__temp_h'148| other) (sel var__temp_h146 other))))
      (a!3 (and (= (sel |var__temp_h'148| res) 10)
                (not (> (sel |var__temp_h'148| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h146 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************37
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i144 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i144, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i144, other ) ==(sel)( , var_h143, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v145:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i144 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h150 --->  Ty_heap  
 var__temp_v151 --->  Ty_int  
 var__temp_h'152 --->  Ty_heap  
 var__temp_v_err153 --->  error  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h150, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h150, other ) ==(sel)( , var_h143, other ) => 
 	 Rel (sel)( , var__temp_h150, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h150, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'152, res ) ==(var__temp_v151) AND 
 	 Rel (sel)( , var__temp_h'152, res ) ==((sel)( , var__temp_h150, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'152, other ) ==(sel)( , var__temp_h150, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'152, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'152, other ) > (4)
 
VC_END(declare-const var_h_i144 T578)
(declare-const var_h143 T578)
(declare-const v Int)
(declare-const var_h_i92 T578)
(declare-const var_h91 T578)
(declare-const v Int)
(declare-const var_h_i44 T578)
(declare-const var_h43 T578)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h150 T578)
(declare-const var__temp_v151 Int)
(declare-const |var__temp_h'152| T578)
(declare-const var__temp_v_err153 T579)
(declare-const var_h143 T578)
(declare-const var_h91 T578)
(declare-const var_h43 T578)
(declare-const err T592)
    (declare-const |20| Int)
  
solver 
 (declare-sort T578)
(declare-fun sel (T578 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T578)
(declare-fun var_h43 () T578)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'152| () T578)
(declare-fun var__temp_h150 () T578)
(declare-fun var__temp_v151 () Int)
(declare-fun var_h143 () T578)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h150 res) v)
                    (= v |20|)
                    (= (sel var__temp_h150 other) (sel var_h143 other)))
               (= (sel var__temp_h150 res) 7)))
      (a!2 (and (= (sel |var__temp_h'152| res) var__temp_v151)
                (= (sel |var__temp_h'152| res) (+ (sel var__temp_h150 res) 5))
                (= (sel |var__temp_h'152| other) (sel var__temp_h150 other))))
      (a!3 (and (= (sel |var__temp_h'152| res) 10)
                (not (> (sel |var__temp_h'152| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h150 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************38
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i144 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i144, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i144, other ) ==(sel)( , var_h143, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v145:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i144 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h154 --->  Ty_heap  
 var__temp_v155 --->  Ty_int  
 var__temp_h'156 --->  Ty_heap  
 var__temp_v_err157 --->  error  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h154, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h154, other ) ==(sel)( , var_h143, other ) => 
 	 Rel (sel)( , var__temp_h154, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h154, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'156, res ) ==(var__temp_v155) AND 
 	 Rel (sel)( , var__temp_h154, res ) ==(sel)( , var__temp_h154, res ) AND 
 	 Rel (sel)( , var__temp_h'156, other ) ==(sel)( , var__temp_h154, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'156, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'156, other ) > (4)
 
VC_END(declare-const var_h_i144 T595)
(declare-const var_h143 T595)
(declare-const v Int)
(declare-const var_h_i92 T595)
(declare-const var_h91 T595)
(declare-const v Int)
(declare-const var_h_i44 T595)
(declare-const var_h43 T595)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h154 T595)
(declare-const var__temp_v155 Int)
(declare-const |var__temp_h'156| T595)
(declare-const var__temp_v_err157 T596)
(declare-const var_h143 T595)
(declare-const var_h91 T595)
(declare-const var_h43 T595)
(declare-const err T609)
    (declare-const |20| Int)
  
solver 
 (declare-sort T595)
(declare-fun sel (T595 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T595)
(declare-fun var_h43 () T595)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'156| () T595)
(declare-fun var__temp_h154 () T595)
(declare-fun var__temp_v155 () Int)
(declare-fun var_h143 () T595)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h154 res) v)
                    (= v |20|)
                    (= (sel var__temp_h154 other) (sel var_h143 other)))
               (not (> (sel var__temp_h154 res) 20))))
      (a!2 (and (= (sel |var__temp_h'156| res) 10)
                (not (> (sel |var__temp_h'156| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'156| res) var__temp_v155)
                    (= (sel var__temp_h154 res) (sel var__temp_h154 res))
                    (= (sel |var__temp_h'156| other) (sel var__temp_h154 other)))
               a!2)))
(let ((a!4 (=> (not (> (sel var__temp_h154 res) 20)) a!3)))
  (not (and a!1 a!4))))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************39
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i144 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i144, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i144, other ) ==(sel)( , var_h143, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v145:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i144 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h158 --->  Ty_heap  
 var__temp_v159 --->  Ty_int  
 var__temp_h'160 --->  Ty_heap  
 var__temp_v_err161 --->  error  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h158, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h158, other ) ==(sel)( , var_h143, other ) => 
 	 Rel (sel)( , var__temp_h158, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h158, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'160, res ) ==(var__temp_v159) AND 
 	 Rel (sel)( , var__temp_h'160, res ) ==((sel)( , var__temp_h158, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'160, other ) ==(sel)( , var__temp_h158, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'160, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'160, other ) > (4)
 
VC_END(declare-const var_h_i144 T612)
(declare-const var_h143 T612)
(declare-const v Int)
(declare-const var_h_i92 T612)
(declare-const var_h91 T612)
(declare-const v Int)
(declare-const var_h_i44 T612)
(declare-const var_h43 T612)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h158 T612)
(declare-const var__temp_v159 Int)
(declare-const |var__temp_h'160| T612)
(declare-const var__temp_v_err161 T613)
(declare-const var_h143 T612)
(declare-const var_h91 T612)
(declare-const var_h43 T612)
(declare-const err T626)
    (declare-const |20| Int)
  
solver 
 (declare-sort T612)
(declare-fun sel (T612 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T612)
(declare-fun var_h43 () T612)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'160| () T612)
(declare-fun var__temp_h158 () T612)
(declare-fun var__temp_v159 () Int)
(declare-fun var_h143 () T612)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h158 res) v)
                    (= v |20|)
                    (= (sel var__temp_h158 other) (sel var_h143 other)))
               (> (sel var__temp_h158 res) 4)))
      (a!2 (and (= (sel |var__temp_h'160| res) var__temp_v159)
                (= (sel |var__temp_h'160| res) (+ (sel var__temp_h158 res) 10))
                (= (sel |var__temp_h'160| other) (sel var__temp_h158 other))))
      (a!3 (and (= (sel |var__temp_h'160| res) 10)
                (not (> (sel |var__temp_h'160| other) 4)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h158 res) 4) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************40
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i144 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i144, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i144, other ) ==(sel)( , var_h143, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v145:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i144 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h162 --->  Ty_heap  
 var__temp_v163 --->  Ty_int  
 var__temp_h'164 --->  Ty_heap  
 var__temp_v_err165 --->  error  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h162, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h162, other ) ==(sel)( , var_h143, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'164, res ) ==(var__temp_v163) AND 
 	 Base var__temp_v163 = 5 AND 
 	 Rel (sel)( , var__temp_h'164, other ) ==(sel)( , var__temp_h162, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'164, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'164, other ) > (4)
 
VC_END(declare-const var_h_i144 T629)
(declare-const var_h143 T629)
(declare-const v Int)
(declare-const var_h_i92 T629)
(declare-const var_h91 T629)
(declare-const v Int)
(declare-const var_h_i44 T629)
(declare-const var_h43 T629)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h162 T629)
(declare-const var__temp_v163 Int)
(declare-const |var__temp_h'164| T629)
(declare-const var__temp_v_err165 T630)
(declare-const var_h143 T629)
(declare-const var_h91 T629)
(declare-const var_h43 T629)
(declare-const err T643)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T629)
(declare-fun sel (T629 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T629)
(declare-fun var_h43 () T629)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'164| () T629)
(declare-fun var__temp_h162 () T629)
(declare-fun var__temp_v163 () Int)
(declare-fun var_h143 () T629)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h162 res) v)
                    (= v |20|)
                    (= (sel var__temp_h162 other) (sel var_h143 other)))
               true))
      (a!2 (and (= (sel |var__temp_h'164| res) 10)
                (not (> (sel |var__temp_h'164| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'164| res) var__temp_v163)
                    (= var__temp_v163 |5|)
                    (= (sel |var__temp_h'164| other) (sel var__temp_h162 other)))
               a!2)))
  (not (and a!1 (=> true a!3))))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************41
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i144 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i144, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i144, other ) ==(sel)( , var_h143, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v145:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i144 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h166 --->  Ty_heap  
 var__temp_v167 --->  Ty_int  
 var__temp_h'168 --->  Ty_heap  
 var__temp_v_err169 --->  error  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h166, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h166, other ) ==(sel)( , var_h143, other ) => 
 	 Rel (sel)( , var__temp_h166, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h166, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'168, res ) ==(var__temp_v167) AND 
 	 Rel (sel)( , var__temp_h'168, res ) ==((sel)( , var__temp_h166, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'168, other ) ==(sel)( , var__temp_h166, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'168, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'168, other ) > (4)
 
VC_END(declare-const var_h_i144 T646)
(declare-const var_h143 T646)
(declare-const v Int)
(declare-const var_h_i92 T646)
(declare-const var_h91 T646)
(declare-const v Int)
(declare-const var_h_i44 T646)
(declare-const var_h43 T646)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h166 T646)
(declare-const var__temp_v167 Int)
(declare-const |var__temp_h'168| T646)
(declare-const var__temp_v_err169 T647)
(declare-const var_h143 T646)
(declare-const var_h91 T646)
(declare-const var_h43 T646)
(declare-const err T660)
    (declare-const |20| Int)
  
solver 
 (declare-sort T646)
(declare-fun sel (T646 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T646)
(declare-fun var_h43 () T646)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'168| () T646)
(declare-fun var__temp_h166 () T646)
(declare-fun var__temp_v167 () Int)
(declare-fun var_h143 () T646)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h166 res) v)
                    (= v |20|)
                    (= (sel var__temp_h166 other) (sel var_h143 other)))
               (= (sel var__temp_h166 res) 5)))
      (a!2 (and (= (sel |var__temp_h'168| res) var__temp_v167)
                (= (sel |var__temp_h'168| res) (+ (sel var__temp_h166 res) 2))
                (= (sel |var__temp_h'168| other) (sel var__temp_h166 other))))
      (a!3 (and (= (sel |var__temp_h'168| res) 10)
                (not (> (sel |var__temp_h'168| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h166 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************42
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v145:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v145:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfoo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i144 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i144, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i144, other ) ==(sel)( , var_h143, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v170:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
foo
bar
 *********************Enumeration Iteration*****************43
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i144 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i144, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i144, other ) ==(sel)( , var_h143, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v170:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h171 --->  Ty_heap  
 var__temp_v172 --->  Ty_int  
 var__temp_h'173 --->  Ty_heap  
 var__temp_v_err174 --->  error  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h171, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h171, other ) ==(sel)( , var_h143, other ) => 
 	 Rel (sel)( , var__temp_h171, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h171, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'173, res ) ==(var__temp_v172) AND 
 	 Rel (sel)( , var__temp_h'173, res ) ==((sel)( , var__temp_h171, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'173, other ) ==(sel)( , var__temp_h171, other ) => 
 	 True
 
VC_END(declare-const var_h_i144 T663)
(declare-const var_h143 T663)
(declare-const v Int)
(declare-const var_h_i92 T663)
(declare-const var_h91 T663)
(declare-const v Int)
(declare-const var_h_i44 T663)
(declare-const var_h43 T663)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h171 T663)
(declare-const var__temp_v172 Int)
(declare-const |var__temp_h'173| T663)
(declare-const var__temp_v_err174 T664)
(declare-const var_h143 T663)
(declare-const var_h91 T663)
(declare-const var_h43 T663)
(declare-const err T677)
    (declare-const |20| Int)
  
solver 
 (declare-sort T663)
(declare-fun sel (T663 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T663)
(declare-fun var_h43 () T663)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h171 () T663)
(declare-fun |var__temp_h'173| () T663)
(declare-fun var__temp_v172 () Int)
(declare-fun var_h143 () T663)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h171 res) v)
                    (= v |20|)
                    (= (sel var__temp_h171 other) (sel var_h143 other)))
               (= (sel var__temp_h171 res) 7)))
      (a!2 (and (= (sel |var__temp_h'173| res) var__temp_v172)
                (= (sel |var__temp_h'173| res) (+ (sel var__temp_h171 res) 3))
                (= (sel |var__temp_h'173| other) (sel var__temp_h171 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h171 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************44
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i144 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i144, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i144, other ) ==(sel)( , var_h143, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v170:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h175 --->  Ty_heap  
 var__temp_v176 --->  Ty_int  
 var__temp_h'177 --->  Ty_heap  
 var__temp_v_err178 --->  error  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h175, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h175, other ) ==(sel)( , var_h143, other ) => 
 	 Rel (sel)( , var__temp_h175, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h175, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'177, res ) ==(var__temp_v176) AND 
 	 Rel (sel)( , var__temp_h'177, res ) ==((sel)( , var__temp_h175, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'177, other ) ==(sel)( , var__temp_h175, other ) => 
 	 True
 
VC_END(declare-const var_h_i144 T680)
(declare-const var_h143 T680)
(declare-const v Int)
(declare-const var_h_i92 T680)
(declare-const var_h91 T680)
(declare-const v Int)
(declare-const var_h_i44 T680)
(declare-const var_h43 T680)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h175 T680)
(declare-const var__temp_v176 Int)
(declare-const |var__temp_h'177| T680)
(declare-const var__temp_v_err178 T681)
(declare-const var_h143 T680)
(declare-const var_h91 T680)
(declare-const var_h43 T680)
(declare-const err T694)
    (declare-const |20| Int)
  
solver 
 (declare-sort T680)
(declare-fun sel (T680 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T680)
(declare-fun var_h43 () T680)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h175 () T680)
(declare-fun |var__temp_h'177| () T680)
(declare-fun var__temp_v176 () Int)
(declare-fun var_h143 () T680)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h175 res) v)
                    (= v |20|)
                    (= (sel var__temp_h175 other) (sel var_h143 other)))
               (= (sel var__temp_h175 res) 7)))
      (a!2 (and (= (sel |var__temp_h'177| res) var__temp_v176)
                (= (sel |var__temp_h'177| res) (+ (sel var__temp_h175 res) 5))
                (= (sel |var__temp_h'177| other) (sel var__temp_h175 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h175 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************45
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i144 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i144, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i144, other ) ==(sel)( , var_h143, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v170:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h179 --->  Ty_heap  
 var__temp_v180 --->  Ty_int  
 var__temp_h'181 --->  Ty_heap  
 var__temp_v_err182 --->  error  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h179, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h179, other ) ==(sel)( , var_h143, other ) => 
 	 Rel (sel)( , var__temp_h179, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h179, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'181, res ) ==(var__temp_v180) AND 
 	 Rel (sel)( , var__temp_h179, res ) ==(sel)( , var__temp_h179, res ) AND 
 	 Rel (sel)( , var__temp_h'181, other ) ==(sel)( , var__temp_h179, other ) => 
 	 True
 
VC_END(declare-const var_h_i144 T697)
(declare-const var_h143 T697)
(declare-const v Int)
(declare-const var_h_i92 T697)
(declare-const var_h91 T697)
(declare-const v Int)
(declare-const var_h_i44 T697)
(declare-const var_h43 T697)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h179 T697)
(declare-const var__temp_v180 Int)
(declare-const |var__temp_h'181| T697)
(declare-const var__temp_v_err182 T698)
(declare-const var_h143 T697)
(declare-const var_h91 T697)
(declare-const var_h43 T697)
(declare-const err T711)
    (declare-const |20| Int)
  
solver 
 (declare-sort T697)
(declare-fun sel (T697 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T697)
(declare-fun var_h43 () T697)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h179 () T697)
(declare-fun |var__temp_h'181| () T697)
(declare-fun var__temp_v180 () Int)
(declare-fun var_h143 () T697)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h179 res) v)
                    (= v |20|)
                    (= (sel var__temp_h179 other) (sel var_h143 other)))
               (not (> (sel var__temp_h179 res) 20))))
      (a!2 (=> (and (= (sel |var__temp_h'181| res) var__temp_v180)
                    (= (sel var__temp_h179 res) (sel var__temp_h179 res))
                    (= (sel |var__temp_h'181| other) (sel var__temp_h179 other)))
               true)))
(let ((a!3 (=> (not (> (sel var__temp_h179 res) 20)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Successful************c2'
PARTIAL PATH NEW
SUB 
 	 --c2'
 	 --foo'
 	 --c4
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i184 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i184 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i184, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h183, res ) ==(sel)( , var_h183, res )
 	 , (sel)( , var_h_i184, other ) ==(sel)( , var_h183, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v185:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i184 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************46
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i184 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i184, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h183, res ) ==(sel)( , var_h183, res )
 	 , (sel)( , var_h_i184, other ) ==(sel)( , var_h183, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v185:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i184 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h186 --->  Ty_heap  
 var__temp_v187 --->  Ty_int  
 var__temp_h'188 --->  Ty_heap  
 var__temp_v_err189 --->  error  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h186, res ) ==(v) AND 
 	 Rel (sel)( , var_h183, res ) ==(sel)( , var_h183, res ) AND 
 	 Rel (sel)( , var__temp_h186, other ) ==(sel)( , var_h183, other ) => 
 	 Rel (sel)( , var__temp_h186, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h186, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'188, res ) ==(var__temp_v187) AND 
 	 Rel (sel)( , var__temp_h'188, res ) ==((sel)( , var__temp_h186, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'188, other ) ==(sel)( , var__temp_h186, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'188, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'188, other ) > (4)
 
VC_END(declare-const var_h_i184 T714)
(declare-const var_h183 T714)
(declare-const v Int)
(declare-const var_h_i144 T714)
(declare-const var_h143 T714)
(declare-const v Int)
(declare-const var_h_i92 T714)
(declare-const var_h91 T714)
(declare-const v Int)
(declare-const var_h_i44 T714)
(declare-const var_h43 T714)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h186 T714)
(declare-const var__temp_v187 Int)
(declare-const |var__temp_h'188| T714)
(declare-const var__temp_v_err189 T715)
(declare-const var_h183 T714)
(declare-const var_h143 T714)
(declare-const var_h91 T714)
(declare-const var_h43 T714)
(declare-const err T728)

solver 
 (declare-sort T714)
(declare-fun sel (T714 Int) Int)
(declare-fun res () Int)
(declare-fun var_h183 () T714)
(declare-fun var_h91 () T714)
(declare-fun var_h43 () T714)
(declare-fun other () Int)
(declare-fun |var__temp_h'188| () T714)
(declare-fun var__temp_h186 () T714)
(declare-fun var__temp_v187 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h186 res) v)
                    (= (sel var_h183 res) (sel var_h183 res))
                    (= (sel var__temp_h186 other) (sel var_h183 other)))
               (= (sel var__temp_h186 res) 7)))
      (a!2 (and (= (sel |var__temp_h'188| res) var__temp_v187)
                (= (sel |var__temp_h'188| res) (+ (sel var__temp_h186 res) 3))
                (= (sel |var__temp_h'188| other) (sel var__temp_h186 other))))
      (a!3 (and (= (sel |var__temp_h'188| res) 10)
                (not (> (sel |var__temp_h'188| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h186 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************47
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i184 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i184, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h183, res ) ==(sel)( , var_h183, res )
 	 , (sel)( , var_h_i184, other ) ==(sel)( , var_h183, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v185:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i184 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h190 --->  Ty_heap  
 var__temp_v191 --->  Ty_int  
 var__temp_h'192 --->  Ty_heap  
 var__temp_v_err193 --->  error  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h190, res ) ==(v) AND 
 	 Rel (sel)( , var_h183, res ) ==(sel)( , var_h183, res ) AND 
 	 Rel (sel)( , var__temp_h190, other ) ==(sel)( , var_h183, other ) => 
 	 Rel (sel)( , var__temp_h190, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h190, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'192, res ) ==(var__temp_v191) AND 
 	 Rel (sel)( , var__temp_h'192, res ) ==((sel)( , var__temp_h190, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'192, other ) ==(sel)( , var__temp_h190, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'192, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'192, other ) > (4)
 
VC_END(declare-const var_h_i184 T731)
(declare-const var_h183 T731)
(declare-const v Int)
(declare-const var_h_i144 T731)
(declare-const var_h143 T731)
(declare-const v Int)
(declare-const var_h_i92 T731)
(declare-const var_h91 T731)
(declare-const v Int)
(declare-const var_h_i44 T731)
(declare-const var_h43 T731)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h190 T731)
(declare-const var__temp_v191 Int)
(declare-const |var__temp_h'192| T731)
(declare-const var__temp_v_err193 T732)
(declare-const var_h183 T731)
(declare-const var_h143 T731)
(declare-const var_h91 T731)
(declare-const var_h43 T731)
(declare-const err T745)

solver 
 (declare-sort T731)
(declare-fun sel (T731 Int) Int)
(declare-fun res () Int)
(declare-fun var_h183 () T731)
(declare-fun var_h91 () T731)
(declare-fun var_h43 () T731)
(declare-fun other () Int)
(declare-fun |var__temp_h'192| () T731)
(declare-fun var__temp_h190 () T731)
(declare-fun var__temp_v191 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h190 res) v)
                    (= (sel var_h183 res) (sel var_h183 res))
                    (= (sel var__temp_h190 other) (sel var_h183 other)))
               (= (sel var__temp_h190 res) 7)))
      (a!2 (and (= (sel |var__temp_h'192| res) var__temp_v191)
                (= (sel |var__temp_h'192| res) (+ (sel var__temp_h190 res) 5))
                (= (sel |var__temp_h'192| other) (sel var__temp_h190 other))))
      (a!3 (and (= (sel |var__temp_h'192| res) 10)
                (not (> (sel |var__temp_h'192| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h190 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************48
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i184 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i184, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h183, res ) ==(sel)( , var_h183, res )
 	 , (sel)( , var_h_i184, other ) ==(sel)( , var_h183, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v185:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i184 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h194 --->  Ty_heap  
 var__temp_v195 --->  Ty_int  
 var__temp_h'196 --->  Ty_heap  
 var__temp_v_err197 --->  error  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h194, res ) ==(v) AND 
 	 Rel (sel)( , var_h183, res ) ==(sel)( , var_h183, res ) AND 
 	 Rel (sel)( , var__temp_h194, other ) ==(sel)( , var_h183, other ) => 
 	 Rel (sel)( , var__temp_h194, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h194, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'196, res ) ==(var__temp_v195) AND 
 	 Rel (sel)( , var__temp_h'196, res ) ==((sel)( , var__temp_h194, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'196, other ) ==(sel)( , var__temp_h194, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'196, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'196, other ) > (4)
 
VC_END(declare-const var_h_i184 T748)
(declare-const var_h183 T748)
(declare-const v Int)
(declare-const var_h_i144 T748)
(declare-const var_h143 T748)
(declare-const v Int)
(declare-const var_h_i92 T748)
(declare-const var_h91 T748)
(declare-const v Int)
(declare-const var_h_i44 T748)
(declare-const var_h43 T748)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h194 T748)
(declare-const var__temp_v195 Int)
(declare-const |var__temp_h'196| T748)
(declare-const var__temp_v_err197 T749)
(declare-const var_h183 T748)
(declare-const var_h143 T748)
(declare-const var_h91 T748)
(declare-const var_h43 T748)
(declare-const err T762)

solver 
 (declare-sort T748)
(declare-fun sel (T748 Int) Int)
(declare-fun res () Int)
(declare-fun var_h183 () T748)
(declare-fun var_h91 () T748)
(declare-fun var_h43 () T748)
(declare-fun other () Int)
(declare-fun |var__temp_h'196| () T748)
(declare-fun var__temp_h194 () T748)
(declare-fun var__temp_v195 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h194 res) v)
                    (= (sel var_h183 res) (sel var_h183 res))
                    (= (sel var__temp_h194 other) (sel var_h183 other)))
               (> (sel var__temp_h194 res) 4)))
      (a!2 (and (= (sel |var__temp_h'196| res) var__temp_v195)
                (= (sel |var__temp_h'196| res) (+ (sel var__temp_h194 res) 10))
                (= (sel |var__temp_h'196| other) (sel var__temp_h194 other))))
      (a!3 (and (= (sel |var__temp_h'196| res) 10)
                (not (> (sel |var__temp_h'196| other) 4)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h194 res) 4) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************49
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i184 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i184, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h183, res ) ==(sel)( , var_h183, res )
 	 , (sel)( , var_h_i184, other ) ==(sel)( , var_h183, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v185:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i184 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h198 --->  Ty_heap  
 var__temp_v199 --->  Ty_int  
 var__temp_h'200 --->  Ty_heap  
 var__temp_v_err201 --->  error  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h198, res ) ==(v) AND 
 	 Rel (sel)( , var_h183, res ) ==(sel)( , var_h183, res ) AND 
 	 Rel (sel)( , var__temp_h198, other ) ==(sel)( , var_h183, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'200, res ) ==(var__temp_v199) AND 
 	 Base var__temp_v199 = 5 AND 
 	 Rel (sel)( , var__temp_h'200, other ) ==(sel)( , var__temp_h198, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'200, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'200, other ) > (4)
 
VC_END(declare-const var_h_i184 T765)
(declare-const var_h183 T765)
(declare-const v Int)
(declare-const var_h_i144 T765)
(declare-const var_h143 T765)
(declare-const v Int)
(declare-const var_h_i92 T765)
(declare-const var_h91 T765)
(declare-const v Int)
(declare-const var_h_i44 T765)
(declare-const var_h43 T765)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h198 T765)
(declare-const var__temp_v199 Int)
(declare-const |var__temp_h'200| T765)
(declare-const var__temp_v_err201 T766)
(declare-const var_h183 T765)
(declare-const var_h143 T765)
(declare-const var_h91 T765)
(declare-const var_h43 T765)
(declare-const err T779)
    (declare-const |5| Int)
  
solver 
 (declare-sort T765)
(declare-fun sel (T765 Int) Int)
(declare-fun res () Int)
(declare-fun var_h183 () T765)
(declare-fun var_h91 () T765)
(declare-fun var_h43 () T765)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'200| () T765)
(declare-fun var__temp_h198 () T765)
(declare-fun var__temp_v199 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h198 res) v)
                    (= (sel var_h183 res) (sel var_h183 res))
                    (= (sel var__temp_h198 other) (sel var_h183 other)))
               true))
      (a!2 (and (= (sel |var__temp_h'200| res) 10)
                (not (> (sel |var__temp_h'200| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'200| res) var__temp_v199)
                    (= var__temp_v199 |5|)
                    (= (sel |var__temp_h'200| other) (sel var__temp_h198 other)))
               a!2)))
  (not (and a!1 (=> true a!3))))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************50
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i184 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i184, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h183, res ) ==(sel)( , var_h183, res )
 	 , (sel)( , var_h_i184, other ) ==(sel)( , var_h183, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v185:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i184 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h202 --->  Ty_heap  
 var__temp_v203 --->  Ty_int  
 var__temp_h'204 --->  Ty_heap  
 var__temp_v_err205 --->  error  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h202, res ) ==(v) AND 
 	 Rel (sel)( , var_h183, res ) ==(sel)( , var_h183, res ) AND 
 	 Rel (sel)( , var__temp_h202, other ) ==(sel)( , var_h183, other ) => 
 	 Rel (sel)( , var__temp_h202, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h202, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'204, res ) ==(var__temp_v203) AND 
 	 Rel (sel)( , var__temp_h'204, res ) ==((sel)( , var__temp_h202, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'204, other ) ==(sel)( , var__temp_h202, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'204, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'204, other ) > (4)
 
VC_END(declare-const var_h_i184 T782)
(declare-const var_h183 T782)
(declare-const v Int)
(declare-const var_h_i144 T782)
(declare-const var_h143 T782)
(declare-const v Int)
(declare-const var_h_i92 T782)
(declare-const var_h91 T782)
(declare-const v Int)
(declare-const var_h_i44 T782)
(declare-const var_h43 T782)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h202 T782)
(declare-const var__temp_v203 Int)
(declare-const |var__temp_h'204| T782)
(declare-const var__temp_v_err205 T783)
(declare-const var_h183 T782)
(declare-const var_h143 T782)
(declare-const var_h91 T782)
(declare-const var_h43 T782)
(declare-const err T796)

solver 
 (declare-sort T782)
(declare-fun sel (T782 Int) Int)
(declare-fun res () Int)
(declare-fun var_h183 () T782)
(declare-fun var_h91 () T782)
(declare-fun var_h43 () T782)
(declare-fun other () Int)
(declare-fun |var__temp_h'204| () T782)
(declare-fun var__temp_h202 () T782)
(declare-fun var__temp_v203 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h202 res) v)
                    (= (sel var_h183 res) (sel var_h183 res))
                    (= (sel var__temp_h202 other) (sel var_h183 other)))
               (= (sel var__temp_h202 res) 5)))
      (a!2 (and (= (sel |var__temp_h'204| res) var__temp_v203)
                (= (sel |var__temp_h'204| res) (+ (sel var__temp_h202 res) 2))
                (= (sel |var__temp_h'204| other) (sel var__temp_h202 other))))
      (a!3 (and (= (sel |var__temp_h'204| res) 10)
                (not (> (sel |var__temp_h'204| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h202 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************51
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v185:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v185:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c2'
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i184 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i184, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h183, res ) ==(sel)( , var_h183, res )
 	 , (sel)( , var_h_i184, other ) ==(sel)( , var_h183, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v206:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************52
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i184 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i184, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h183, res ) ==(sel)( , var_h183, res )
 	 , (sel)( , var_h_i184, other ) ==(sel)( , var_h183, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v206:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h207 --->  Ty_heap  
 var__temp_v208 --->  Ty_int  
 var__temp_h'209 --->  Ty_heap  
 var__temp_v_err210 --->  error  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h207, res ) ==(v) AND 
 	 Rel (sel)( , var_h183, res ) ==(sel)( , var_h183, res ) AND 
 	 Rel (sel)( , var__temp_h207, other ) ==(sel)( , var_h183, other ) => 
 	 Rel (sel)( , var__temp_h207, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h207, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'209, res ) ==(var__temp_v208) AND 
 	 Rel (sel)( , var__temp_h'209, res ) ==((sel)( , var__temp_h207, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'209, other ) ==(sel)( , var__temp_h207, other ) => 
 	 True
 
VC_END(declare-const var_h_i184 T799)
(declare-const var_h183 T799)
(declare-const v Int)
(declare-const var_h_i144 T799)
(declare-const var_h143 T799)
(declare-const v Int)
(declare-const var_h_i92 T799)
(declare-const var_h91 T799)
(declare-const v Int)
(declare-const var_h_i44 T799)
(declare-const var_h43 T799)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h207 T799)
(declare-const var__temp_v208 Int)
(declare-const |var__temp_h'209| T799)
(declare-const var__temp_v_err210 T800)
(declare-const var_h183 T799)
(declare-const var_h143 T799)
(declare-const var_h91 T799)
(declare-const var_h43 T799)
(declare-const err T813)

solver 
 (declare-sort T799)
(declare-fun sel (T799 Int) Int)
(declare-fun res () Int)
(declare-fun var_h183 () T799)
(declare-fun var_h91 () T799)
(declare-fun var_h43 () T799)
(declare-fun other () Int)
(declare-fun var__temp_h207 () T799)
(declare-fun |var__temp_h'209| () T799)
(declare-fun var__temp_v208 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h207 res) v)
                    (= (sel var_h183 res) (sel var_h183 res))
                    (= (sel var__temp_h207 other) (sel var_h183 other)))
               (= (sel var__temp_h207 res) 7)))
      (a!2 (and (= (sel |var__temp_h'209| res) var__temp_v208)
                (= (sel |var__temp_h'209| res) (+ (sel var__temp_h207 res) 3))
                (= (sel |var__temp_h'209| other) (sel var__temp_h207 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h207 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************53
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i184 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i184, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h183, res ) ==(sel)( , var_h183, res )
 	 , (sel)( , var_h_i184, other ) ==(sel)( , var_h183, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v206:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h211 --->  Ty_heap  
 var__temp_v212 --->  Ty_int  
 var__temp_h'213 --->  Ty_heap  
 var__temp_v_err214 --->  error  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h211, res ) ==(v) AND 
 	 Rel (sel)( , var_h183, res ) ==(sel)( , var_h183, res ) AND 
 	 Rel (sel)( , var__temp_h211, other ) ==(sel)( , var_h183, other ) => 
 	 Rel (sel)( , var__temp_h211, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h211, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'213, res ) ==(var__temp_v212) AND 
 	 Rel (sel)( , var__temp_h'213, res ) ==((sel)( , var__temp_h211, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'213, other ) ==(sel)( , var__temp_h211, other ) => 
 	 True
 
VC_END(declare-const var_h_i184 T816)
(declare-const var_h183 T816)
(declare-const v Int)
(declare-const var_h_i144 T816)
(declare-const var_h143 T816)
(declare-const v Int)
(declare-const var_h_i92 T816)
(declare-const var_h91 T816)
(declare-const v Int)
(declare-const var_h_i44 T816)
(declare-const var_h43 T816)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h211 T816)
(declare-const var__temp_v212 Int)
(declare-const |var__temp_h'213| T816)
(declare-const var__temp_v_err214 T817)
(declare-const var_h183 T816)
(declare-const var_h143 T816)
(declare-const var_h91 T816)
(declare-const var_h43 T816)
(declare-const err T830)

solver 
 (declare-sort T816)
(declare-fun sel (T816 Int) Int)
(declare-fun res () Int)
(declare-fun var_h183 () T816)
(declare-fun var_h91 () T816)
(declare-fun var_h43 () T816)
(declare-fun other () Int)
(declare-fun var__temp_h211 () T816)
(declare-fun |var__temp_h'213| () T816)
(declare-fun var__temp_v212 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h211 res) v)
                    (= (sel var_h183 res) (sel var_h183 res))
                    (= (sel var__temp_h211 other) (sel var_h183 other)))
               (= (sel var__temp_h211 res) 7)))
      (a!2 (and (= (sel |var__temp_h'213| res) var__temp_v212)
                (= (sel |var__temp_h'213| res) (+ (sel var__temp_h211 res) 5))
                (= (sel |var__temp_h'213| other) (sel var__temp_h211 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h211 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************54
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i184 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i184, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h183, res ) ==(sel)( , var_h183, res )
 	 , (sel)( , var_h_i184, other ) ==(sel)( , var_h183, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v206:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h215 --->  Ty_heap  
 var__temp_v216 --->  Ty_int  
 var__temp_h'217 --->  Ty_heap  
 var__temp_v_err218 --->  error  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h215, res ) ==(v) AND 
 	 Rel (sel)( , var_h183, res ) ==(sel)( , var_h183, res ) AND 
 	 Rel (sel)( , var__temp_h215, other ) ==(sel)( , var_h183, other ) => 
 	 Rel (sel)( , var__temp_h215, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h215, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'217, res ) ==(var__temp_v216) AND 
 	 Rel (sel)( , var__temp_h'217, res ) ==((sel)( , var__temp_h215, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'217, other ) ==(sel)( , var__temp_h215, other ) => 
 	 True
 
VC_END(declare-const var_h_i184 T833)
(declare-const var_h183 T833)
(declare-const v Int)
(declare-const var_h_i144 T833)
(declare-const var_h143 T833)
(declare-const v Int)
(declare-const var_h_i92 T833)
(declare-const var_h91 T833)
(declare-const v Int)
(declare-const var_h_i44 T833)
(declare-const var_h43 T833)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h215 T833)
(declare-const var__temp_v216 Int)
(declare-const |var__temp_h'217| T833)
(declare-const var__temp_v_err218 T834)
(declare-const var_h183 T833)
(declare-const var_h143 T833)
(declare-const var_h91 T833)
(declare-const var_h43 T833)
(declare-const err T847)

solver 
 (declare-sort T833)
(declare-fun sel (T833 Int) Int)
(declare-fun res () Int)
(declare-fun var_h183 () T833)
(declare-fun var_h91 () T833)
(declare-fun var_h43 () T833)
(declare-fun other () Int)
(declare-fun var__temp_h215 () T833)
(declare-fun |var__temp_h'217| () T833)
(declare-fun var__temp_v216 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h215 res) v)
                    (= (sel var_h183 res) (sel var_h183 res))
                    (= (sel var__temp_h215 other) (sel var_h183 other)))
               (> (sel var__temp_h215 res) 4)))
      (a!2 (and (= (sel |var__temp_h'217| res) var__temp_v216)
                (= (sel |var__temp_h'217| res) (+ (sel var__temp_h215 res) 10))
                (= (sel |var__temp_h'217| other) (sel var__temp_h215 other)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h215 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************55
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i184 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i184, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h183, res ) ==(sel)( , var_h183, res )
 	 , (sel)( , var_h_i184, other ) ==(sel)( , var_h183, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v206:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h219 --->  Ty_heap  
 var__temp_v220 --->  Ty_int  
 var__temp_h'221 --->  Ty_heap  
 var__temp_v_err222 --->  error  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h219, res ) ==(v) AND 
 	 Rel (sel)( , var_h183, res ) ==(sel)( , var_h183, res ) AND 
 	 Rel (sel)( , var__temp_h219, other ) ==(sel)( , var_h183, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'221, res ) ==(var__temp_v220) AND 
 	 Base var__temp_v220 = 5 AND 
 	 Rel (sel)( , var__temp_h'221, other ) ==(sel)( , var__temp_h219, other ) => 
 	 True
 
VC_END(declare-const var_h_i184 T850)
(declare-const var_h183 T850)
(declare-const v Int)
(declare-const var_h_i144 T850)
(declare-const var_h143 T850)
(declare-const v Int)
(declare-const var_h_i92 T850)
(declare-const var_h91 T850)
(declare-const v Int)
(declare-const var_h_i44 T850)
(declare-const var_h43 T850)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h219 T850)
(declare-const var__temp_v220 Int)
(declare-const |var__temp_h'221| T850)
(declare-const var__temp_v_err222 T851)
(declare-const var_h183 T850)
(declare-const var_h143 T850)
(declare-const var_h91 T850)
(declare-const var_h43 T850)
(declare-const err T864)
    (declare-const |5| Int)
  
solver 
 (declare-sort T850)
(declare-fun sel (T850 Int) Int)
(declare-fun res () Int)
(declare-fun var_h183 () T850)
(declare-fun var_h91 () T850)
(declare-fun var_h43 () T850)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h219 () T850)
(declare-fun |var__temp_h'221| () T850)
(declare-fun var__temp_v220 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h219 res) v)
                    (= (sel var_h183 res) (sel var_h183 res))
                    (= (sel var__temp_h219 other) (sel var_h183 other)))
               true))
      (a!2 (=> (and (= (sel |var__temp_h'221| res) var__temp_v220)
                    (= var__temp_v220 |5|)
                    (= (sel |var__temp_h'221| other) (sel var__temp_h219 other)))
               true)))
  (not (and a!1 (=> true a!2)))))

***************Selection Successful************foo
PARTIAL PATH NEW
SUB 
 	 --foo
 	 --c2'
 	 --foo'
 	 --c4
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i224 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i224 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i224, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i224, other ) ==(sel)( , var_h223, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v225:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i224 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
bar
 *********************Enumeration Iteration*****************56
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i224 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i224, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i224, other ) ==(sel)( , var_h223, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v225:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i224 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i224 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h226 --->  Ty_heap  
 var__temp_v227 --->  Ty_int  
 var__temp_h'228 --->  Ty_heap  
 var__temp_v_err229 --->  error  
 var_h223 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h226, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h226, other ) ==(sel)( , var_h223, other ) => 
 	 Rel (sel)( , var__temp_h226, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h226, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'228, res ) ==(var__temp_v227) AND 
 	 Rel (sel)( , var__temp_h'228, res ) ==((sel)( , var__temp_h226, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'228, other ) ==(sel)( , var__temp_h226, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'228, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'228, other ) > (4)
 
VC_END(declare-const var_h_i224 T867)
(declare-const var_h223 T867)
(declare-const v Int)
(declare-const var_h_i184 T867)
(declare-const var_h183 T867)
(declare-const v Int)
(declare-const var_h_i144 T867)
(declare-const var_h143 T867)
(declare-const v Int)
(declare-const var_h_i92 T867)
(declare-const var_h91 T867)
(declare-const v Int)
(declare-const var_h_i44 T867)
(declare-const var_h43 T867)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h226 T867)
(declare-const var__temp_v227 Int)
(declare-const |var__temp_h'228| T867)
(declare-const var__temp_v_err229 T868)
(declare-const var_h223 T867)
(declare-const var_h183 T867)
(declare-const var_h143 T867)
(declare-const var_h91 T867)
(declare-const var_h43 T867)
(declare-const err T881)
    (declare-const |5| Int)
  
solver 
 (declare-sort T867)
(declare-fun sel (T867 Int) Int)
(declare-fun res () Int)
(declare-fun var_h183 () T867)
(declare-fun var_h91 () T867)
(declare-fun var_h43 () T867)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'228| () T867)
(declare-fun var__temp_h226 () T867)
(declare-fun var__temp_v227 () Int)
(declare-fun var_h223 () T867)
(declare-fun v () Int)
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h226 res) v)
                    (= v |5|)
                    (= (sel var__temp_h226 other) (sel var_h223 other)))
               (= (sel var__temp_h226 res) 7)))
      (a!2 (and (= (sel |var__temp_h'228| res) var__temp_v227)
                (= (sel |var__temp_h'228| res) (+ (sel var__temp_h226 res) 3))
                (= (sel |var__temp_h'228| other) (sel var__temp_h226 other))))
      (a!3 (and (= (sel |var__temp_h'228| res) 10)
                (not (> (sel |var__temp_h'228| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h226 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************57
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i224 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i224, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i224, other ) ==(sel)( , var_h223, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v225:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i224 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i224 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h230 --->  Ty_heap  
 var__temp_v231 --->  Ty_int  
 var__temp_h'232 --->  Ty_heap  
 var__temp_v_err233 --->  error  
 var_h223 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h230, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h230, other ) ==(sel)( , var_h223, other ) => 
 	 Rel (sel)( , var__temp_h230, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h230, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'232, res ) ==(var__temp_v231) AND 
 	 Rel (sel)( , var__temp_h'232, res ) ==((sel)( , var__temp_h230, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'232, other ) ==(sel)( , var__temp_h230, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'232, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'232, other ) > (4)
 
VC_END(declare-const var_h_i224 T884)
(declare-const var_h223 T884)
(declare-const v Int)
(declare-const var_h_i184 T884)
(declare-const var_h183 T884)
(declare-const v Int)
(declare-const var_h_i144 T884)
(declare-const var_h143 T884)
(declare-const v Int)
(declare-const var_h_i92 T884)
(declare-const var_h91 T884)
(declare-const v Int)
(declare-const var_h_i44 T884)
(declare-const var_h43 T884)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h230 T884)
(declare-const var__temp_v231 Int)
(declare-const |var__temp_h'232| T884)
(declare-const var__temp_v_err233 T885)
(declare-const var_h223 T884)
(declare-const var_h183 T884)
(declare-const var_h143 T884)
(declare-const var_h91 T884)
(declare-const var_h43 T884)
(declare-const err T898)
    (declare-const |5| Int)
  
solver 
 (declare-sort T884)
(declare-fun sel (T884 Int) Int)
(declare-fun res () Int)
(declare-fun var_h183 () T884)
(declare-fun var_h91 () T884)
(declare-fun var_h43 () T884)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'232| () T884)
(declare-fun var__temp_h230 () T884)
(declare-fun var__temp_v231 () Int)
(declare-fun var_h223 () T884)
(declare-fun v () Int)
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h230 res) v)
                    (= v |5|)
                    (= (sel var__temp_h230 other) (sel var_h223 other)))
               (= (sel var__temp_h230 res) 7)))
      (a!2 (and (= (sel |var__temp_h'232| res) var__temp_v231)
                (= (sel |var__temp_h'232| res) (+ (sel var__temp_h230 res) 5))
                (= (sel |var__temp_h'232| other) (sel var__temp_h230 other))))
      (a!3 (and (= (sel |var__temp_h'232| res) 10)
                (not (> (sel |var__temp_h'232| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h230 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************58
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i224 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i224, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i224, other ) ==(sel)( , var_h223, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v225:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i224 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i224 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h234 --->  Ty_heap  
 var__temp_v235 --->  Ty_int  
 var__temp_h'236 --->  Ty_heap  
 var__temp_v_err237 --->  error  
 var_h223 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h234, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h234, other ) ==(sel)( , var_h223, other ) => 
 	 Rel (sel)( , var__temp_h234, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h234, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'236, res ) ==(var__temp_v235) AND 
 	 Rel (sel)( , var__temp_h'236, res ) ==((sel)( , var__temp_h234, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'236, other ) ==(sel)( , var__temp_h234, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'236, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'236, other ) > (4)
 
VC_END(declare-const var_h_i224 T901)
(declare-const var_h223 T901)
(declare-const v Int)
(declare-const var_h_i184 T901)
(declare-const var_h183 T901)
(declare-const v Int)
(declare-const var_h_i144 T901)
(declare-const var_h143 T901)
(declare-const v Int)
(declare-const var_h_i92 T901)
(declare-const var_h91 T901)
(declare-const v Int)
(declare-const var_h_i44 T901)
(declare-const var_h43 T901)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h234 T901)
(declare-const var__temp_v235 Int)
(declare-const |var__temp_h'236| T901)
(declare-const var__temp_v_err237 T902)
(declare-const var_h223 T901)
(declare-const var_h183 T901)
(declare-const var_h143 T901)
(declare-const var_h91 T901)
(declare-const var_h43 T901)
(declare-const err T915)
    (declare-const |5| Int)
  
solver 
 (declare-sort T901)
(declare-fun sel (T901 Int) Int)
(declare-fun res () Int)
(declare-fun var_h183 () T901)
(declare-fun var_h91 () T901)
(declare-fun var_h43 () T901)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'236| () T901)
(declare-fun var__temp_h234 () T901)
(declare-fun var__temp_v235 () Int)
(declare-fun var_h223 () T901)
(declare-fun v () Int)
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h234 res) v)
                    (= v |5|)
                    (= (sel var__temp_h234 other) (sel var_h223 other)))
               (> (sel var__temp_h234 res) 4)))
      (a!2 (and (= (sel |var__temp_h'236| res) var__temp_v235)
                (= (sel |var__temp_h'236| res) (+ (sel var__temp_h234 res) 10))
                (= (sel |var__temp_h'236| other) (sel var__temp_h234 other))))
      (a!3 (and (= (sel |var__temp_h'236| res) 10)
                (not (> (sel |var__temp_h'236| other) 4)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h234 res) 4) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************59
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i224 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i224, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i224, other ) ==(sel)( , var_h223, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v225:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i224 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i224 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h238 --->  Ty_heap  
 var__temp_v239 --->  Ty_int  
 var__temp_h'240 --->  Ty_heap  
 var__temp_v_err241 --->  error  
 var_h223 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h238, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h238, other ) ==(sel)( , var_h223, other ) => 
 	 Rel (sel)( , var__temp_h238, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h238, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'240, res ) ==(var__temp_v239) AND 
 	 Rel (sel)( , var__temp_h'240, res ) ==((sel)( , var__temp_h238, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'240, other ) ==(sel)( , var__temp_h238, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'240, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'240, other ) > (4)
 
VC_END(declare-const var_h_i224 T918)
(declare-const var_h223 T918)
(declare-const v Int)
(declare-const var_h_i184 T918)
(declare-const var_h183 T918)
(declare-const v Int)
(declare-const var_h_i144 T918)
(declare-const var_h143 T918)
(declare-const v Int)
(declare-const var_h_i92 T918)
(declare-const var_h91 T918)
(declare-const v Int)
(declare-const var_h_i44 T918)
(declare-const var_h43 T918)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h238 T918)
(declare-const var__temp_v239 Int)
(declare-const |var__temp_h'240| T918)
(declare-const var__temp_v_err241 T919)
(declare-const var_h223 T918)
(declare-const var_h183 T918)
(declare-const var_h143 T918)
(declare-const var_h91 T918)
(declare-const var_h43 T918)
(declare-const err T932)
    (declare-const |5| Int)
  
solver 
 (declare-sort T918)
(declare-fun sel (T918 Int) Int)
(declare-fun res () Int)
(declare-fun var_h183 () T918)
(declare-fun var_h91 () T918)
(declare-fun var_h43 () T918)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'240| () T918)
(declare-fun var__temp_h238 () T918)
(declare-fun var__temp_v239 () Int)
(declare-fun var_h223 () T918)
(declare-fun v () Int)
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h238 res) v)
                    (= v |5|)
                    (= (sel var__temp_h238 other) (sel var_h223 other)))
               (= (sel var__temp_h238 res) 5)))
      (a!2 (and (= (sel |var__temp_h'240| res) var__temp_v239)
                (= (sel |var__temp_h'240| res) (+ (sel var__temp_h238 res) 2))
                (= (sel |var__temp_h'240| other) (sel var__temp_h238 other))))
      (a!3 (and (= (sel |var__temp_h'240| res) 10)
                (not (> (sel |var__temp_h'240| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h238 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************60
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v225:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v225:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfooc2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --foo
 	 --c2'
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i224 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i224, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i224, other ) ==(sel)( , var_h223, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v242:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
bar
 *********************Enumeration Iteration*****************61
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i224 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i224, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i224, other ) ==(sel)( , var_h223, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v242:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i224 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h243 --->  Ty_heap  
 var__temp_v244 --->  Ty_int  
 var__temp_h'245 --->  Ty_heap  
 var__temp_v_err246 --->  error  
 var_h223 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h243, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h243, other ) ==(sel)( , var_h223, other ) => 
 	 Rel (sel)( , var__temp_h243, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h243, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'245, res ) ==(var__temp_v244) AND 
 	 Rel (sel)( , var__temp_h'245, res ) ==((sel)( , var__temp_h243, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'245, other ) ==(sel)( , var__temp_h243, other ) => 
 	 True
 
VC_END(declare-const var_h_i224 T935)
(declare-const var_h223 T935)
(declare-const v Int)
(declare-const var_h_i184 T935)
(declare-const var_h183 T935)
(declare-const v Int)
(declare-const var_h_i144 T935)
(declare-const var_h143 T935)
(declare-const v Int)
(declare-const var_h_i92 T935)
(declare-const var_h91 T935)
(declare-const v Int)
(declare-const var_h_i44 T935)
(declare-const var_h43 T935)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h243 T935)
(declare-const var__temp_v244 Int)
(declare-const |var__temp_h'245| T935)
(declare-const var__temp_v_err246 T936)
(declare-const var_h223 T935)
(declare-const var_h183 T935)
(declare-const var_h143 T935)
(declare-const var_h91 T935)
(declare-const var_h43 T935)
(declare-const err T949)
    (declare-const |5| Int)
  
solver 
 (declare-sort T935)
(declare-fun sel (T935 Int) Int)
(declare-fun res () Int)
(declare-fun var_h183 () T935)
(declare-fun var_h91 () T935)
(declare-fun var_h43 () T935)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h243 () T935)
(declare-fun |var__temp_h'245| () T935)
(declare-fun var__temp_v244 () Int)
(declare-fun var_h223 () T935)
(declare-fun v () Int)
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h243 res) v)
                    (= v |5|)
                    (= (sel var__temp_h243 other) (sel var_h223 other)))
               (= (sel var__temp_h243 res) 7)))
      (a!2 (and (= (sel |var__temp_h'245| res) var__temp_v244)
                (= (sel |var__temp_h'245| res) (+ (sel var__temp_h243 res) 3))
                (= (sel |var__temp_h'245| other) (sel var__temp_h243 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h243 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************62
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i224 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i224, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i224, other ) ==(sel)( , var_h223, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v242:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i224 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h247 --->  Ty_heap  
 var__temp_v248 --->  Ty_int  
 var__temp_h'249 --->  Ty_heap  
 var__temp_v_err250 --->  error  
 var_h223 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h247, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h247, other ) ==(sel)( , var_h223, other ) => 
 	 Rel (sel)( , var__temp_h247, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h247, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'249, res ) ==(var__temp_v248) AND 
 	 Rel (sel)( , var__temp_h'249, res ) ==((sel)( , var__temp_h247, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'249, other ) ==(sel)( , var__temp_h247, other ) => 
 	 True
 
VC_END(declare-const var_h_i224 T952)
(declare-const var_h223 T952)
(declare-const v Int)
(declare-const var_h_i184 T952)
(declare-const var_h183 T952)
(declare-const v Int)
(declare-const var_h_i144 T952)
(declare-const var_h143 T952)
(declare-const v Int)
(declare-const var_h_i92 T952)
(declare-const var_h91 T952)
(declare-const v Int)
(declare-const var_h_i44 T952)
(declare-const var_h43 T952)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h247 T952)
(declare-const var__temp_v248 Int)
(declare-const |var__temp_h'249| T952)
(declare-const var__temp_v_err250 T953)
(declare-const var_h223 T952)
(declare-const var_h183 T952)
(declare-const var_h143 T952)
(declare-const var_h91 T952)
(declare-const var_h43 T952)
(declare-const err T966)
    (declare-const |5| Int)
  
solver 
 (declare-sort T952)
(declare-fun sel (T952 Int) Int)
(declare-fun res () Int)
(declare-fun var_h183 () T952)
(declare-fun var_h91 () T952)
(declare-fun var_h43 () T952)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h247 () T952)
(declare-fun |var__temp_h'249| () T952)
(declare-fun var__temp_v248 () Int)
(declare-fun var_h223 () T952)
(declare-fun v () Int)
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h247 res) v)
                    (= v |5|)
                    (= (sel var__temp_h247 other) (sel var_h223 other)))
               (= (sel var__temp_h247 res) 7)))
      (a!2 (and (= (sel |var__temp_h'249| res) var__temp_v248)
                (= (sel |var__temp_h'249| res) (+ (sel var__temp_h247 res) 5))
                (= (sel |var__temp_h'249| other) (sel var__temp_h247 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h247 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************63
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i224 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i224, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i224, other ) ==(sel)( , var_h223, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v242:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i224 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h251 --->  Ty_heap  
 var__temp_v252 --->  Ty_int  
 var__temp_h'253 --->  Ty_heap  
 var__temp_v_err254 --->  error  
 var_h223 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h251, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h251, other ) ==(sel)( , var_h223, other ) => 
 	 Rel (sel)( , var__temp_h251, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h251, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'253, res ) ==(var__temp_v252) AND 
 	 Rel (sel)( , var__temp_h'253, res ) ==((sel)( , var__temp_h251, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'253, other ) ==(sel)( , var__temp_h251, other ) => 
 	 True
 
VC_END(declare-const var_h_i224 T969)
(declare-const var_h223 T969)
(declare-const v Int)
(declare-const var_h_i184 T969)
(declare-const var_h183 T969)
(declare-const v Int)
(declare-const var_h_i144 T969)
(declare-const var_h143 T969)
(declare-const v Int)
(declare-const var_h_i92 T969)
(declare-const var_h91 T969)
(declare-const v Int)
(declare-const var_h_i44 T969)
(declare-const var_h43 T969)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h251 T969)
(declare-const var__temp_v252 Int)
(declare-const |var__temp_h'253| T969)
(declare-const var__temp_v_err254 T970)
(declare-const var_h223 T969)
(declare-const var_h183 T969)
(declare-const var_h143 T969)
(declare-const var_h91 T969)
(declare-const var_h43 T969)
(declare-const err T983)
    (declare-const |5| Int)
  
solver 
 (declare-sort T969)
(declare-fun sel (T969 Int) Int)
(declare-fun res () Int)
(declare-fun var_h183 () T969)
(declare-fun var_h91 () T969)
(declare-fun var_h43 () T969)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h251 () T969)
(declare-fun |var__temp_h'253| () T969)
(declare-fun var__temp_v252 () Int)
(declare-fun var_h223 () T969)
(declare-fun v () Int)
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h251 res) v)
                    (= v |5|)
                    (= (sel var__temp_h251 other) (sel var_h223 other)))
               (> (sel var__temp_h251 res) 4)))
      (a!2 (and (= (sel |var__temp_h'253| res) var__temp_v252)
                (= (sel |var__temp_h'253| res) (+ (sel var__temp_h251 res) 10))
                (= (sel |var__temp_h'253| other) (sel var__temp_h251 other)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h251 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c2
PARTIAL PATH NEW
SUB 
 	 --c2
 	 --foo
 	 --c2'
 	 --foo'
 	 --c4
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i256 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i256 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i256, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i256, res ) ==((sel)( , var_h255, res ) + (10))
 	 , (sel)( , var_h_i256, other ) ==(sel)( , var_h255, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v257:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i256 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************64
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i256 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i256, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i256, res ) ==((sel)( , var_h255, res ) + (10))
 	 , (sel)( , var_h_i256, other ) ==(sel)( , var_h255, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v257:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i256 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i256 --->  Ty_heap  
 var_h255 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i224 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h258 --->  Ty_heap  
 var__temp_v259 --->  Ty_int  
 var__temp_h'260 --->  Ty_heap  
 var__temp_v_err261 --->  error  
 var_h255 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h255, res ) > (4) AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h258, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h258, res ) ==((sel)( , var_h255, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h258, other ) ==(sel)( , var_h255, other ) => 
 	 Rel (sel)( , var__temp_h258, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h258, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'260, res ) ==(var__temp_v259) AND 
 	 Rel (sel)( , var__temp_h'260, res ) ==((sel)( , var__temp_h258, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'260, other ) ==(sel)( , var__temp_h258, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'260, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'260, other ) > (4)
 
VC_END(declare-const var_h_i256 T986)
(declare-const var_h255 T986)
(declare-const v Int)
(declare-const var_h_i224 T986)
(declare-const var_h223 T986)
(declare-const v Int)
(declare-const var_h_i184 T986)
(declare-const var_h183 T986)
(declare-const v Int)
(declare-const var_h_i144 T986)
(declare-const var_h143 T986)
(declare-const v Int)
(declare-const var_h_i92 T986)
(declare-const var_h91 T986)
(declare-const v Int)
(declare-const var_h_i44 T986)
(declare-const var_h43 T986)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h258 T986)
(declare-const var__temp_v259 Int)
(declare-const |var__temp_h'260| T986)
(declare-const var__temp_v_err261 T987)
(declare-const var_h255 T986)
(declare-const var_h223 T986)
(declare-const var_h183 T986)
(declare-const var_h143 T986)
(declare-const var_h91 T986)
(declare-const var_h43 T986)
(declare-const err T1000)

solver 
 (declare-sort T986)
(declare-fun sel (T986 Int) Int)
(declare-fun res () Int)
(declare-fun var_h255 () T986)
(declare-fun var_h183 () T986)
(declare-fun var_h91 () T986)
(declare-fun var_h43 () T986)
(declare-fun other () Int)
(declare-fun |var__temp_h'260| () T986)
(declare-fun var__temp_h258 () T986)
(declare-fun var__temp_v259 () Int)
(declare-fun v () Int)
(assert (> (sel var_h255 res) 4))
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h258 res) v)
                (= (sel var__temp_h258 res) (+ (sel var_h255 res) 10))
                (= (sel var__temp_h258 other) (sel var_h255 other))))
      (a!2 (and (= (sel |var__temp_h'260| res) var__temp_v259)
                (= (sel |var__temp_h'260| res) (+ (sel var__temp_h258 res) 3))
                (= (sel |var__temp_h'260| other) (sel var__temp_h258 other))))
      (a!3 (and (= (sel |var__temp_h'260| res) 10)
                (not (> (sel |var__temp_h'260| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h258 res) 7))
                (=> (= (sel var__temp_h258 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************65
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i256 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i256, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i256, res ) ==((sel)( , var_h255, res ) + (10))
 	 , (sel)( , var_h_i256, other ) ==(sel)( , var_h255, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v257:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i256 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i256 --->  Ty_heap  
 var_h255 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i224 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h262 --->  Ty_heap  
 var__temp_v263 --->  Ty_int  
 var__temp_h'264 --->  Ty_heap  
 var__temp_v_err265 --->  error  
 var_h255 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h255, res ) > (4) AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h262, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h262, res ) ==((sel)( , var_h255, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h262, other ) ==(sel)( , var_h255, other ) => 
 	 Rel (sel)( , var__temp_h262, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h262, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'264, res ) ==(var__temp_v263) AND 
 	 Rel (sel)( , var__temp_h'264, res ) ==((sel)( , var__temp_h262, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'264, other ) ==(sel)( , var__temp_h262, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'264, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'264, other ) > (4)
 
VC_END(declare-const var_h_i256 T1003)
(declare-const var_h255 T1003)
(declare-const v Int)
(declare-const var_h_i224 T1003)
(declare-const var_h223 T1003)
(declare-const v Int)
(declare-const var_h_i184 T1003)
(declare-const var_h183 T1003)
(declare-const v Int)
(declare-const var_h_i144 T1003)
(declare-const var_h143 T1003)
(declare-const v Int)
(declare-const var_h_i92 T1003)
(declare-const var_h91 T1003)
(declare-const v Int)
(declare-const var_h_i44 T1003)
(declare-const var_h43 T1003)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h262 T1003)
(declare-const var__temp_v263 Int)
(declare-const |var__temp_h'264| T1003)
(declare-const var__temp_v_err265 T1004)
(declare-const var_h255 T1003)
(declare-const var_h223 T1003)
(declare-const var_h183 T1003)
(declare-const var_h143 T1003)
(declare-const var_h91 T1003)
(declare-const var_h43 T1003)
(declare-const err T1017)

solver 
 (declare-sort T1003)
(declare-fun sel (T1003 Int) Int)
(declare-fun res () Int)
(declare-fun var_h255 () T1003)
(declare-fun var_h183 () T1003)
(declare-fun var_h91 () T1003)
(declare-fun var_h43 () T1003)
(declare-fun other () Int)
(declare-fun |var__temp_h'264| () T1003)
(declare-fun var__temp_h262 () T1003)
(declare-fun var__temp_v263 () Int)
(declare-fun v () Int)
(assert (> (sel var_h255 res) 4))
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h262 res) v)
                (= (sel var__temp_h262 res) (+ (sel var_h255 res) 10))
                (= (sel var__temp_h262 other) (sel var_h255 other))))
      (a!2 (and (= (sel |var__temp_h'264| res) var__temp_v263)
                (= (sel |var__temp_h'264| res) (+ (sel var__temp_h262 res) 5))
                (= (sel |var__temp_h'264| other) (sel var__temp_h262 other))))
      (a!3 (and (= (sel |var__temp_h'264| res) 10)
                (not (> (sel |var__temp_h'264| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h262 res) 7))
                (=> (= (sel var__temp_h262 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************66
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i256 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i256, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i256, res ) ==((sel)( , var_h255, res ) + (10))
 	 , (sel)( , var_h_i256, other ) ==(sel)( , var_h255, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v257:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i256 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i256 --->  Ty_heap  
 var_h255 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i224 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h266 --->  Ty_heap  
 var__temp_v267 --->  Ty_int  
 var__temp_h'268 --->  Ty_heap  
 var__temp_v_err269 --->  error  
 var_h255 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h255, res ) > (4) AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h266, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h266, res ) ==((sel)( , var_h255, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h266, other ) ==(sel)( , var_h255, other ) => 
 	 Rel (sel)( , var__temp_h266, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h266, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'268, res ) ==(var__temp_v267) AND 
 	 Rel (sel)( , var__temp_h'268, res ) ==((sel)( , var__temp_h266, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'268, other ) ==(sel)( , var__temp_h266, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'268, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'268, other ) > (4)
 
VC_END(declare-const var_h_i256 T1020)
(declare-const var_h255 T1020)
(declare-const v Int)
(declare-const var_h_i224 T1020)
(declare-const var_h223 T1020)
(declare-const v Int)
(declare-const var_h_i184 T1020)
(declare-const var_h183 T1020)
(declare-const v Int)
(declare-const var_h_i144 T1020)
(declare-const var_h143 T1020)
(declare-const v Int)
(declare-const var_h_i92 T1020)
(declare-const var_h91 T1020)
(declare-const v Int)
(declare-const var_h_i44 T1020)
(declare-const var_h43 T1020)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h266 T1020)
(declare-const var__temp_v267 Int)
(declare-const |var__temp_h'268| T1020)
(declare-const var__temp_v_err269 T1021)
(declare-const var_h255 T1020)
(declare-const var_h223 T1020)
(declare-const var_h183 T1020)
(declare-const var_h143 T1020)
(declare-const var_h91 T1020)
(declare-const var_h43 T1020)
(declare-const err T1034)

solver 
 (declare-sort T1020)
(declare-fun sel (T1020 Int) Int)
(declare-fun res () Int)
(declare-fun var_h255 () T1020)
(declare-fun var_h183 () T1020)
(declare-fun var_h91 () T1020)
(declare-fun var_h43 () T1020)
(declare-fun other () Int)
(declare-fun |var__temp_h'268| () T1020)
(declare-fun var__temp_h266 () T1020)
(declare-fun var__temp_v267 () Int)
(declare-fun v () Int)
(assert (> (sel var_h255 res) 4))
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h266 res) v)
                (= (sel var__temp_h266 res) (+ (sel var_h255 res) 10))
                (= (sel var__temp_h266 other) (sel var_h255 other))))
      (a!2 (and (= (sel |var__temp_h'268| res) var__temp_v267)
                (= (sel |var__temp_h'268| res) (+ (sel var__temp_h266 res) 2))
                (= (sel |var__temp_h'268| other) (sel var__temp_h266 other))))
      (a!3 (and (= (sel |var__temp_h'268| res) 10)
                (not (> (sel |var__temp_h'268| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h266 res) 5))
                (=> (= (sel var__temp_h266 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************67
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v257:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v257:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2fooc2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c2
 	 --foo
 	 --c2'
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i256 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i256, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i256, res ) ==((sel)( , var_h255, res ) + (10))
 	 , (sel)( , var_h_i256, other ) ==(sel)( , var_h255, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v270:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************68
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i256 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i256, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i256, res ) ==((sel)( , var_h255, res ) + (10))
 	 , (sel)( , var_h_i256, other ) ==(sel)( , var_h255, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v270:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i256 --->  Ty_heap  
 var_h255 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i224 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h271 --->  Ty_heap  
 var__temp_v272 --->  Ty_int  
 var__temp_h'273 --->  Ty_heap  
 var__temp_v_err274 --->  error  
 var_h255 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h255, res ) > (4) AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h271, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h271, res ) ==((sel)( , var_h255, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h271, other ) ==(sel)( , var_h255, other ) => 
 	 Rel (sel)( , var__temp_h271, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h271, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'273, res ) ==(var__temp_v272) AND 
 	 Rel (sel)( , var__temp_h'273, res ) ==((sel)( , var__temp_h271, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'273, other ) ==(sel)( , var__temp_h271, other ) => 
 	 True
 
VC_END(declare-const var_h_i256 T1037)
(declare-const var_h255 T1037)
(declare-const v Int)
(declare-const var_h_i224 T1037)
(declare-const var_h223 T1037)
(declare-const v Int)
(declare-const var_h_i184 T1037)
(declare-const var_h183 T1037)
(declare-const v Int)
(declare-const var_h_i144 T1037)
(declare-const var_h143 T1037)
(declare-const v Int)
(declare-const var_h_i92 T1037)
(declare-const var_h91 T1037)
(declare-const v Int)
(declare-const var_h_i44 T1037)
(declare-const var_h43 T1037)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h271 T1037)
(declare-const var__temp_v272 Int)
(declare-const |var__temp_h'273| T1037)
(declare-const var__temp_v_err274 T1038)
(declare-const var_h255 T1037)
(declare-const var_h223 T1037)
(declare-const var_h183 T1037)
(declare-const var_h143 T1037)
(declare-const var_h91 T1037)
(declare-const var_h43 T1037)
(declare-const err T1051)

solver 
 (declare-sort T1037)
(declare-fun sel (T1037 Int) Int)
(declare-fun res () Int)
(declare-fun var_h255 () T1037)
(declare-fun var_h183 () T1037)
(declare-fun var_h91 () T1037)
(declare-fun var_h43 () T1037)
(declare-fun other () Int)
(declare-fun var__temp_h271 () T1037)
(declare-fun |var__temp_h'273| () T1037)
(declare-fun var__temp_v272 () Int)
(declare-fun v () Int)
(assert (> (sel var_h255 res) 4))
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h271 res) v)
                (= (sel var__temp_h271 res) (+ (sel var_h255 res) 10))
                (= (sel var__temp_h271 other) (sel var_h255 other))))
      (a!2 (and (= (sel |var__temp_h'273| res) var__temp_v272)
                (= (sel |var__temp_h'273| res) (+ (sel var__temp_h271 res) 3))
                (= (sel |var__temp_h'273| other) (sel var__temp_h271 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h271 res) 7))
                (=> (= (sel var__temp_h271 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************69
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i256 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i256, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i256, res ) ==((sel)( , var_h255, res ) + (10))
 	 , (sel)( , var_h_i256, other ) ==(sel)( , var_h255, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v270:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i256 --->  Ty_heap  
 var_h255 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i224 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h275 --->  Ty_heap  
 var__temp_v276 --->  Ty_int  
 var__temp_h'277 --->  Ty_heap  
 var__temp_v_err278 --->  error  
 var_h255 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h255, res ) > (4) AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h275, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h275, res ) ==((sel)( , var_h255, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h275, other ) ==(sel)( , var_h255, other ) => 
 	 Rel (sel)( , var__temp_h275, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h275, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'277, res ) ==(var__temp_v276) AND 
 	 Rel (sel)( , var__temp_h'277, res ) ==((sel)( , var__temp_h275, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'277, other ) ==(sel)( , var__temp_h275, other ) => 
 	 True
 
VC_END(declare-const var_h_i256 T1054)
(declare-const var_h255 T1054)
(declare-const v Int)
(declare-const var_h_i224 T1054)
(declare-const var_h223 T1054)
(declare-const v Int)
(declare-const var_h_i184 T1054)
(declare-const var_h183 T1054)
(declare-const v Int)
(declare-const var_h_i144 T1054)
(declare-const var_h143 T1054)
(declare-const v Int)
(declare-const var_h_i92 T1054)
(declare-const var_h91 T1054)
(declare-const v Int)
(declare-const var_h_i44 T1054)
(declare-const var_h43 T1054)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h275 T1054)
(declare-const var__temp_v276 Int)
(declare-const |var__temp_h'277| T1054)
(declare-const var__temp_v_err278 T1055)
(declare-const var_h255 T1054)
(declare-const var_h223 T1054)
(declare-const var_h183 T1054)
(declare-const var_h143 T1054)
(declare-const var_h91 T1054)
(declare-const var_h43 T1054)
(declare-const err T1068)

solver 
 (declare-sort T1054)
(declare-fun sel (T1054 Int) Int)
(declare-fun res () Int)
(declare-fun var_h255 () T1054)
(declare-fun var_h183 () T1054)
(declare-fun var_h91 () T1054)
(declare-fun var_h43 () T1054)
(declare-fun other () Int)
(declare-fun var__temp_h275 () T1054)
(declare-fun |var__temp_h'277| () T1054)
(declare-fun var__temp_v276 () Int)
(declare-fun v () Int)
(assert (> (sel var_h255 res) 4))
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h275 res) v)
                (= (sel var__temp_h275 res) (+ (sel var_h255 res) 10))
                (= (sel var__temp_h275 other) (sel var_h255 other))))
      (a!2 (and (= (sel |var__temp_h'277| res) var__temp_v276)
                (= (sel |var__temp_h'277| res) (+ (sel var__temp_h275 res) 5))
                (= (sel |var__temp_h'277| other) (sel var__temp_h275 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h275 res) 7))
                (=> (= (sel var__temp_h275 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************70
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i256 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i256, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i256, res ) ==((sel)( , var_h255, res ) + (10))
 	 , (sel)( , var_h_i256, other ) ==(sel)( , var_h255, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v270:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i256 --->  Ty_heap  
 var_h255 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i224 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h279 --->  Ty_heap  
 var__temp_v280 --->  Ty_int  
 var__temp_h'281 --->  Ty_heap  
 var__temp_v_err282 --->  error  
 var_h255 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h255, res ) > (4) AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h279, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h279, res ) ==((sel)( , var_h255, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h279, other ) ==(sel)( , var_h255, other ) => 
 	 Rel (sel)( , var__temp_h279, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h279, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'281, res ) ==(var__temp_v280) AND 
 	 Rel (sel)( , var__temp_h'281, res ) ==((sel)( , var__temp_h279, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'281, other ) ==(sel)( , var__temp_h279, other ) => 
 	 True
 
VC_END(declare-const var_h_i256 T1071)
(declare-const var_h255 T1071)
(declare-const v Int)
(declare-const var_h_i224 T1071)
(declare-const var_h223 T1071)
(declare-const v Int)
(declare-const var_h_i184 T1071)
(declare-const var_h183 T1071)
(declare-const v Int)
(declare-const var_h_i144 T1071)
(declare-const var_h143 T1071)
(declare-const v Int)
(declare-const var_h_i92 T1071)
(declare-const var_h91 T1071)
(declare-const v Int)
(declare-const var_h_i44 T1071)
(declare-const var_h43 T1071)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h279 T1071)
(declare-const var__temp_v280 Int)
(declare-const |var__temp_h'281| T1071)
(declare-const var__temp_v_err282 T1072)
(declare-const var_h255 T1071)
(declare-const var_h223 T1071)
(declare-const var_h183 T1071)
(declare-const var_h143 T1071)
(declare-const var_h91 T1071)
(declare-const var_h43 T1071)
(declare-const err T1085)

solver 
 (declare-sort T1071)
(declare-fun sel (T1071 Int) Int)
(declare-fun res () Int)
(declare-fun var_h255 () T1071)
(declare-fun var_h183 () T1071)
(declare-fun var_h91 () T1071)
(declare-fun var_h43 () T1071)
(declare-fun other () Int)
(declare-fun var__temp_h279 () T1071)
(declare-fun |var__temp_h'281| () T1071)
(declare-fun var__temp_v280 () Int)
(declare-fun v () Int)
(assert (> (sel var_h255 res) 4))
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h279 res) v)
                (= (sel var__temp_h279 res) (+ (sel var_h255 res) 10))
                (= (sel var__temp_h279 other) (sel var_h255 other))))
      (a!2 (and (= (sel |var__temp_h'281| res) var__temp_v280)
                (= (sel |var__temp_h'281| res) (+ (sel var__temp_h279 res) 2))
                (= (sel |var__temp_h'281| other) (sel var__temp_h279 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h279 res) 5))
                (=> (= (sel var__temp_h279 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************71
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 
 	 --foo
 	 --c2'
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i224 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i224, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i224, other ) ==(sel)( , var_h223, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v283:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************72
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i224 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i224, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i224, other ) ==(sel)( , var_h223, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v283:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i224 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h284 --->  Ty_heap  
 var__temp_v285 --->  Ty_int  
 var__temp_h'286 --->  Ty_heap  
 var__temp_v_err287 --->  error  
 var_h223 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h284, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h284, other ) ==(sel)( , var_h223, other ) => 
 	 Rel (sel)( , var__temp_h284, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h284, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'286, res ) ==(var__temp_v285) AND 
 	 Rel (sel)( , var__temp_h'286, res ) ==((sel)( , var__temp_h284, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'286, other ) ==(sel)( , var__temp_h284, other ) => 
 	 True
 
VC_END(declare-const var_h_i224 T1088)
(declare-const var_h223 T1088)
(declare-const v Int)
(declare-const var_h_i184 T1088)
(declare-const var_h183 T1088)
(declare-const v Int)
(declare-const var_h_i144 T1088)
(declare-const var_h143 T1088)
(declare-const v Int)
(declare-const var_h_i92 T1088)
(declare-const var_h91 T1088)
(declare-const v Int)
(declare-const var_h_i44 T1088)
(declare-const var_h43 T1088)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h284 T1088)
(declare-const var__temp_v285 Int)
(declare-const |var__temp_h'286| T1088)
(declare-const var__temp_v_err287 T1089)
(declare-const var_h223 T1088)
(declare-const var_h183 T1088)
(declare-const var_h143 T1088)
(declare-const var_h91 T1088)
(declare-const var_h43 T1088)
(declare-const err T1102)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1088)
(declare-fun sel (T1088 Int) Int)
(declare-fun res () Int)
(declare-fun var_h183 () T1088)
(declare-fun var_h91 () T1088)
(declare-fun var_h43 () T1088)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h284 () T1088)
(declare-fun |var__temp_h'286| () T1088)
(declare-fun var__temp_v285 () Int)
(declare-fun var_h223 () T1088)
(declare-fun v () Int)
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h284 res) v)
                    (= v |5|)
                    (= (sel var__temp_h284 other) (sel var_h223 other)))
               (= (sel var__temp_h284 res) 7)))
      (a!2 (and (= (sel |var__temp_h'286| res) var__temp_v285)
                (= (sel |var__temp_h'286| res) (+ (sel var__temp_h284 res) 3))
                (= (sel |var__temp_h'286| other) (sel var__temp_h284 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h284 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************73
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i224 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i224, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i224, other ) ==(sel)( , var_h223, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v283:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i224 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h288 --->  Ty_heap  
 var__temp_v289 --->  Ty_int  
 var__temp_h'290 --->  Ty_heap  
 var__temp_v_err291 --->  error  
 var_h223 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h288, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h288, other ) ==(sel)( , var_h223, other ) => 
 	 Rel (sel)( , var__temp_h288, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h288, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'290, res ) ==(var__temp_v289) AND 
 	 Rel (sel)( , var__temp_h'290, res ) ==((sel)( , var__temp_h288, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'290, other ) ==(sel)( , var__temp_h288, other ) => 
 	 True
 
VC_END(declare-const var_h_i224 T1105)
(declare-const var_h223 T1105)
(declare-const v Int)
(declare-const var_h_i184 T1105)
(declare-const var_h183 T1105)
(declare-const v Int)
(declare-const var_h_i144 T1105)
(declare-const var_h143 T1105)
(declare-const v Int)
(declare-const var_h_i92 T1105)
(declare-const var_h91 T1105)
(declare-const v Int)
(declare-const var_h_i44 T1105)
(declare-const var_h43 T1105)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h288 T1105)
(declare-const var__temp_v289 Int)
(declare-const |var__temp_h'290| T1105)
(declare-const var__temp_v_err291 T1106)
(declare-const var_h223 T1105)
(declare-const var_h183 T1105)
(declare-const var_h143 T1105)
(declare-const var_h91 T1105)
(declare-const var_h43 T1105)
(declare-const err T1119)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1105)
(declare-fun sel (T1105 Int) Int)
(declare-fun res () Int)
(declare-fun var_h183 () T1105)
(declare-fun var_h91 () T1105)
(declare-fun var_h43 () T1105)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h288 () T1105)
(declare-fun |var__temp_h'290| () T1105)
(declare-fun var__temp_v289 () Int)
(declare-fun var_h223 () T1105)
(declare-fun v () Int)
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h288 res) v)
                    (= v |5|)
                    (= (sel var__temp_h288 other) (sel var_h223 other)))
               (= (sel var__temp_h288 res) 7)))
      (a!2 (and (= (sel |var__temp_h'290| res) var__temp_v289)
                (= (sel |var__temp_h'290| res) (+ (sel var__temp_h288 res) 5))
                (= (sel |var__temp_h'290| other) (sel var__temp_h288 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h288 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************74
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i224 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i224, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i224, other ) ==(sel)( , var_h223, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v283:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i224 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h292 --->  Ty_heap  
 var__temp_v293 --->  Ty_int  
 var__temp_h'294 --->  Ty_heap  
 var__temp_v_err295 --->  error  
 var_h223 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h292, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h292, other ) ==(sel)( , var_h223, other ) => 
 	 Rel (sel)( , var__temp_h292, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h292, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'294, res ) ==(var__temp_v293) AND 
 	 Rel (sel)( , var__temp_h'294, res ) ==((sel)( , var__temp_h292, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'294, other ) ==(sel)( , var__temp_h292, other ) => 
 	 True
 
VC_END(declare-const var_h_i224 T1122)
(declare-const var_h223 T1122)
(declare-const v Int)
(declare-const var_h_i184 T1122)
(declare-const var_h183 T1122)
(declare-const v Int)
(declare-const var_h_i144 T1122)
(declare-const var_h143 T1122)
(declare-const v Int)
(declare-const var_h_i92 T1122)
(declare-const var_h91 T1122)
(declare-const v Int)
(declare-const var_h_i44 T1122)
(declare-const var_h43 T1122)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h292 T1122)
(declare-const var__temp_v293 Int)
(declare-const |var__temp_h'294| T1122)
(declare-const var__temp_v_err295 T1123)
(declare-const var_h223 T1122)
(declare-const var_h183 T1122)
(declare-const var_h143 T1122)
(declare-const var_h91 T1122)
(declare-const var_h43 T1122)
(declare-const err T1136)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1122)
(declare-fun sel (T1122 Int) Int)
(declare-fun res () Int)
(declare-fun var_h183 () T1122)
(declare-fun var_h91 () T1122)
(declare-fun var_h43 () T1122)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h292 () T1122)
(declare-fun |var__temp_h'294| () T1122)
(declare-fun var__temp_v293 () Int)
(declare-fun var_h223 () T1122)
(declare-fun v () Int)
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h292 res) v)
                    (= v |5|)
                    (= (sel var__temp_h292 other) (sel var_h223 other)))
               (= (sel var__temp_h292 res) 5)))
      (a!2 (and (= (sel |var__temp_h'294| res) var__temp_v293)
                (= (sel |var__temp_h'294| res) (+ (sel var__temp_h292 res) 2))
                (= (sel |var__temp_h'294| other) (sel var__temp_h292 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h292 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************bar
PARTIAL PATH NEW
SUB 
 	 --bar
 	 --foo
 	 --c2'
 	 --foo'
 	 --c4
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i297 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i297 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i297, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i297, res ) ==((sel)( , var_h296, res ) + (2))
 	 , (sel)( , var_h_i297, other ) ==(sel)( , var_h296, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v298:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i297 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************75
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i297 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i297, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i297, res ) ==((sel)( , var_h296, res ) + (2))
 	 , (sel)( , var_h_i297, other ) ==(sel)( , var_h296, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v298:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i297 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i297 --->  Ty_heap  
 var_h296 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i224 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h299 --->  Ty_heap  
 var__temp_v300 --->  Ty_int  
 var__temp_h'301 --->  Ty_heap  
 var__temp_v_err302 --->  error  
 var_h296 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h296, res ) ==(5) AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h299, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h299, res ) ==((sel)( , var_h296, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h299, other ) ==(sel)( , var_h296, other ) => 
 	 Rel (sel)( , var__temp_h299, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h299, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'301, res ) ==(var__temp_v300) AND 
 	 Rel (sel)( , var__temp_h'301, res ) ==((sel)( , var__temp_h299, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'301, other ) ==(sel)( , var__temp_h299, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'301, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'301, other ) > (4)
 
VC_END(declare-const var_h_i297 T1139)
(declare-const var_h296 T1139)
(declare-const v Int)
(declare-const var_h_i224 T1139)
(declare-const var_h223 T1139)
(declare-const v Int)
(declare-const var_h_i184 T1139)
(declare-const var_h183 T1139)
(declare-const v Int)
(declare-const var_h_i144 T1139)
(declare-const var_h143 T1139)
(declare-const v Int)
(declare-const var_h_i92 T1139)
(declare-const var_h91 T1139)
(declare-const v Int)
(declare-const var_h_i44 T1139)
(declare-const var_h43 T1139)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h299 T1139)
(declare-const var__temp_v300 Int)
(declare-const |var__temp_h'301| T1139)
(declare-const var__temp_v_err302 T1140)
(declare-const var_h296 T1139)
(declare-const var_h223 T1139)
(declare-const var_h183 T1139)
(declare-const var_h143 T1139)
(declare-const var_h91 T1139)
(declare-const var_h43 T1139)
(declare-const err T1153)

solver 
 (declare-sort T1139)
(declare-fun sel (T1139 Int) Int)
(declare-fun res () Int)
(declare-fun var_h296 () T1139)
(declare-fun var_h183 () T1139)
(declare-fun var_h91 () T1139)
(declare-fun var_h43 () T1139)
(declare-fun other () Int)
(declare-fun |var__temp_h'301| () T1139)
(declare-fun var__temp_h299 () T1139)
(declare-fun var__temp_v300 () Int)
(declare-fun v () Int)
(assert (= (sel var_h296 res) 5))
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h299 res) v)
                (= (sel var__temp_h299 res) (+ (sel var_h296 res) 2))
                (= (sel var__temp_h299 other) (sel var_h296 other))))
      (a!2 (and (= (sel |var__temp_h'301| res) var__temp_v300)
                (= (sel |var__temp_h'301| res) (+ (sel var__temp_h299 res) 3))
                (= (sel |var__temp_h'301| other) (sel var__temp_h299 other))))
      (a!3 (and (= (sel |var__temp_h'301| res) 10)
                (not (> (sel |var__temp_h'301| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h299 res) 7))
                (=> (= (sel var__temp_h299 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************76
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i297 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i297, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i297, res ) ==((sel)( , var_h296, res ) + (2))
 	 , (sel)( , var_h_i297, other ) ==(sel)( , var_h296, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v298:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i297 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i297 --->  Ty_heap  
 var_h296 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i224 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h303 --->  Ty_heap  
 var__temp_v304 --->  Ty_int  
 var__temp_h'305 --->  Ty_heap  
 var__temp_v_err306 --->  error  
 var_h296 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h296, res ) ==(5) AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h303, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h303, res ) ==((sel)( , var_h296, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h303, other ) ==(sel)( , var_h296, other ) => 
 	 Rel (sel)( , var__temp_h303, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h303, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'305, res ) ==(var__temp_v304) AND 
 	 Rel (sel)( , var__temp_h'305, res ) ==((sel)( , var__temp_h303, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'305, other ) ==(sel)( , var__temp_h303, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'305, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'305, other ) > (4)
 
VC_END(declare-const var_h_i297 T1156)
(declare-const var_h296 T1156)
(declare-const v Int)
(declare-const var_h_i224 T1156)
(declare-const var_h223 T1156)
(declare-const v Int)
(declare-const var_h_i184 T1156)
(declare-const var_h183 T1156)
(declare-const v Int)
(declare-const var_h_i144 T1156)
(declare-const var_h143 T1156)
(declare-const v Int)
(declare-const var_h_i92 T1156)
(declare-const var_h91 T1156)
(declare-const v Int)
(declare-const var_h_i44 T1156)
(declare-const var_h43 T1156)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h303 T1156)
(declare-const var__temp_v304 Int)
(declare-const |var__temp_h'305| T1156)
(declare-const var__temp_v_err306 T1157)
(declare-const var_h296 T1156)
(declare-const var_h223 T1156)
(declare-const var_h183 T1156)
(declare-const var_h143 T1156)
(declare-const var_h91 T1156)
(declare-const var_h43 T1156)
(declare-const err T1170)

solver 
 (declare-sort T1156)
(declare-fun sel (T1156 Int) Int)
(declare-fun res () Int)
(declare-fun var_h296 () T1156)
(declare-fun var_h183 () T1156)
(declare-fun var_h91 () T1156)
(declare-fun var_h43 () T1156)
(declare-fun other () Int)
(declare-fun |var__temp_h'305| () T1156)
(declare-fun var__temp_h303 () T1156)
(declare-fun var__temp_v304 () Int)
(declare-fun v () Int)
(assert (= (sel var_h296 res) 5))
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h303 res) v)
                (= (sel var__temp_h303 res) (+ (sel var_h296 res) 2))
                (= (sel var__temp_h303 other) (sel var_h296 other))))
      (a!2 (and (= (sel |var__temp_h'305| res) var__temp_v304)
                (= (sel |var__temp_h'305| res) (+ (sel var__temp_h303 res) 5))
                (= (sel |var__temp_h'305| other) (sel var__temp_h303 other))))
      (a!3 (and (= (sel |var__temp_h'305| res) 10)
                (not (> (sel |var__temp_h'305| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h303 res) 7))
                (=> (= (sel var__temp_h303 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************77
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v298:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v298:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbarc2fooc2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2'
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i297 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i297, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i297, res ) ==((sel)( , var_h296, res ) + (2))
 	 , (sel)( , var_h_i297, other ) ==(sel)( , var_h296, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v307:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************78
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i297 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i297, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i297, res ) ==((sel)( , var_h296, res ) + (2))
 	 , (sel)( , var_h_i297, other ) ==(sel)( , var_h296, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v307:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i297 --->  Ty_heap  
 var_h296 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i224 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h308 --->  Ty_heap  
 var__temp_v309 --->  Ty_int  
 var__temp_h'310 --->  Ty_heap  
 var__temp_v_err311 --->  error  
 var_h296 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h296, res ) ==(5) AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h308, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h308, res ) ==((sel)( , var_h296, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h308, other ) ==(sel)( , var_h296, other ) => 
 	 Rel (sel)( , var__temp_h308, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h308, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'310, res ) ==(var__temp_v309) AND 
 	 Rel (sel)( , var__temp_h'310, res ) ==((sel)( , var__temp_h308, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'310, other ) ==(sel)( , var__temp_h308, other ) => 
 	 True
 
VC_END(declare-const var_h_i297 T1173)
(declare-const var_h296 T1173)
(declare-const v Int)
(declare-const var_h_i224 T1173)
(declare-const var_h223 T1173)
(declare-const v Int)
(declare-const var_h_i184 T1173)
(declare-const var_h183 T1173)
(declare-const v Int)
(declare-const var_h_i144 T1173)
(declare-const var_h143 T1173)
(declare-const v Int)
(declare-const var_h_i92 T1173)
(declare-const var_h91 T1173)
(declare-const v Int)
(declare-const var_h_i44 T1173)
(declare-const var_h43 T1173)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h308 T1173)
(declare-const var__temp_v309 Int)
(declare-const |var__temp_h'310| T1173)
(declare-const var__temp_v_err311 T1174)
(declare-const var_h296 T1173)
(declare-const var_h223 T1173)
(declare-const var_h183 T1173)
(declare-const var_h143 T1173)
(declare-const var_h91 T1173)
(declare-const var_h43 T1173)
(declare-const err T1187)

solver 
 (declare-sort T1173)
(declare-fun sel (T1173 Int) Int)
(declare-fun res () Int)
(declare-fun var_h296 () T1173)
(declare-fun var_h183 () T1173)
(declare-fun var_h91 () T1173)
(declare-fun var_h43 () T1173)
(declare-fun other () Int)
(declare-fun var__temp_h308 () T1173)
(declare-fun |var__temp_h'310| () T1173)
(declare-fun var__temp_v309 () Int)
(declare-fun v () Int)
(assert (= (sel var_h296 res) 5))
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h308 res) v)
                (= (sel var__temp_h308 res) (+ (sel var_h296 res) 2))
                (= (sel var__temp_h308 other) (sel var_h296 other))))
      (a!2 (and (= (sel |var__temp_h'310| res) var__temp_v309)
                (= (sel |var__temp_h'310| res) (+ (sel var__temp_h308 res) 3))
                (= (sel |var__temp_h'310| other) (sel var__temp_h308 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h308 res) 7))
                (=> (= (sel var__temp_h308 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************baz
PARTIAL PATH NEW
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --c2'
 	 --foo'
 	 --c4
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i313 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i313 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i313, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i313, res ) ==((sel)( , var_h312, res ) + (3))
 	 , (sel)( , var_h_i313, other ) ==(sel)( , var_h312, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v314:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i313 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************79
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i313 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i313, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i313, res ) ==((sel)( , var_h312, res ) + (3))
 	 , (sel)( , var_h_i313, other ) ==(sel)( , var_h312, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v314:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i313 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i313 --->  Ty_heap  
 var_h312 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i297 --->  Ty_heap  
 var_h296 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i224 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h315 --->  Ty_heap  
 var__temp_v316 --->  Ty_int  
 var__temp_h'317 --->  Ty_heap  
 var__temp_v_err318 --->  error  
 var_h312 --->  Ty_heap  
 var_h296 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h312, res ) ==(7) AND 
 	 Rel (sel)( , var_h296, res ) ==(5) AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h315, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h315, res ) ==((sel)( , var_h312, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h315, other ) ==(sel)( , var_h312, other ) => 
 	 Rel (sel)( , var__temp_h315, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h315, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'317, res ) ==(var__temp_v316) AND 
 	 Rel (sel)( , var__temp_h'317, res ) ==((sel)( , var__temp_h315, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'317, other ) ==(sel)( , var__temp_h315, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'317, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'317, other ) > (4)
 
VC_END(declare-const var_h_i313 T1190)
(declare-const var_h312 T1190)
(declare-const v Int)
(declare-const var_h_i297 T1190)
(declare-const var_h296 T1190)
(declare-const v Int)
(declare-const var_h_i224 T1190)
(declare-const var_h223 T1190)
(declare-const v Int)
(declare-const var_h_i184 T1190)
(declare-const var_h183 T1190)
(declare-const v Int)
(declare-const var_h_i144 T1190)
(declare-const var_h143 T1190)
(declare-const v Int)
(declare-const var_h_i92 T1190)
(declare-const var_h91 T1190)
(declare-const v Int)
(declare-const var_h_i44 T1190)
(declare-const var_h43 T1190)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h315 T1190)
(declare-const var__temp_v316 Int)
(declare-const |var__temp_h'317| T1190)
(declare-const var__temp_v_err318 T1191)
(declare-const var_h312 T1190)
(declare-const var_h296 T1190)
(declare-const var_h223 T1190)
(declare-const var_h183 T1190)
(declare-const var_h143 T1190)
(declare-const var_h91 T1190)
(declare-const var_h43 T1190)
(declare-const err T1204)

solver 
 (declare-sort T1190)
(declare-fun sel (T1190 Int) Int)
(declare-fun res () Int)
(declare-fun var_h312 () T1190)
(declare-fun var_h296 () T1190)
(declare-fun var_h183 () T1190)
(declare-fun var_h91 () T1190)
(declare-fun var_h43 () T1190)
(declare-fun other () Int)
(declare-fun |var__temp_h'317| () T1190)
(declare-fun var__temp_h315 () T1190)
(declare-fun var__temp_v316 () Int)
(declare-fun v () Int)
(assert (= (sel var_h312 res) 7))
(assert (= (sel var_h296 res) 5))
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h315 res) v)
                (= (sel var__temp_h315 res) (+ (sel var_h312 res) 3))
                (= (sel var__temp_h315 other) (sel var_h312 other))))
      (a!2 (and (= (sel |var__temp_h'317| res) var__temp_v316)
                (= (sel |var__temp_h'317| res) (+ (sel var__temp_h315 res) 5))
                (= (sel |var__temp_h'317| other) (sel var__temp_h315 other))))
      (a!3 (and (= (sel |var__temp_h'317| res) 10)
                (not (> (sel |var__temp_h'317| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h315 res) 7))
                (=> (= (sel var__temp_h315 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************80
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v314:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v314:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbazbarc2fooc2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --c2'
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i313 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i313, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i313, res ) ==((sel)( , var_h312, res ) + (3))
 	 , (sel)( , var_h_i313, other ) ==(sel)( , var_h312, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v319:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************81
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i313 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i313, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i313, res ) ==((sel)( , var_h312, res ) + (3))
 	 , (sel)( , var_h_i313, other ) ==(sel)( , var_h312, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v319:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i313 --->  Ty_heap  
 var_h312 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i297 --->  Ty_heap  
 var_h296 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i224 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h320 --->  Ty_heap  
 var__temp_v321 --->  Ty_int  
 var__temp_h'322 --->  Ty_heap  
 var__temp_v_err323 --->  error  
 var_h312 --->  Ty_heap  
 var_h296 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h312, res ) ==(7) AND 
 	 Rel (sel)( , var_h296, res ) ==(5) AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h320, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h320, res ) ==((sel)( , var_h312, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h320, other ) ==(sel)( , var_h312, other ) => 
 	 Rel (sel)( , var__temp_h320, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h320, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'322, res ) ==(var__temp_v321) AND 
 	 Rel (sel)( , var__temp_h'322, res ) ==((sel)( , var__temp_h320, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'322, other ) ==(sel)( , var__temp_h320, other ) => 
 	 True
 
VC_END(declare-const var_h_i313 T1207)
(declare-const var_h312 T1207)
(declare-const v Int)
(declare-const var_h_i297 T1207)
(declare-const var_h296 T1207)
(declare-const v Int)
(declare-const var_h_i224 T1207)
(declare-const var_h223 T1207)
(declare-const v Int)
(declare-const var_h_i184 T1207)
(declare-const var_h183 T1207)
(declare-const v Int)
(declare-const var_h_i144 T1207)
(declare-const var_h143 T1207)
(declare-const v Int)
(declare-const var_h_i92 T1207)
(declare-const var_h91 T1207)
(declare-const v Int)
(declare-const var_h_i44 T1207)
(declare-const var_h43 T1207)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h320 T1207)
(declare-const var__temp_v321 Int)
(declare-const |var__temp_h'322| T1207)
(declare-const var__temp_v_err323 T1208)
(declare-const var_h312 T1207)
(declare-const var_h296 T1207)
(declare-const var_h223 T1207)
(declare-const var_h183 T1207)
(declare-const var_h143 T1207)
(declare-const var_h91 T1207)
(declare-const var_h43 T1207)
(declare-const err T1221)

solver 
 (declare-sort T1207)
(declare-fun sel (T1207 Int) Int)
(declare-fun res () Int)
(declare-fun var_h312 () T1207)
(declare-fun var_h296 () T1207)
(declare-fun var_h183 () T1207)
(declare-fun var_h91 () T1207)
(declare-fun var_h43 () T1207)
(declare-fun other () Int)
(declare-fun var__temp_h320 () T1207)
(declare-fun |var__temp_h'322| () T1207)
(declare-fun var__temp_v321 () Int)
(declare-fun v () Int)
(assert (= (sel var_h312 res) 7))
(assert (= (sel var_h296 res) 5))
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h320 res) v)
                (= (sel var__temp_h320 res) (+ (sel var_h312 res) 3))
                (= (sel var__temp_h320 other) (sel var_h312 other))))
      (a!2 (and (= (sel |var__temp_h'322| res) var__temp_v321)
                (= (sel |var__temp_h'322| res) (+ (sel var__temp_h320 res) 5))
                (= (sel |var__temp_h'322| other) (sel var__temp_h320 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h320 res) 7))
                (=> (= (sel var__temp_h320 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************82
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT baz
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2'
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i297 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i297, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i297, res ) ==((sel)( , var_h296, res ) + (2))
 	 , (sel)( , var_h_i297, other ) ==(sel)( , var_h296, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v324:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************83
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i297 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i297, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i297, res ) ==((sel)( , var_h296, res ) + (2))
 	 , (sel)( , var_h_i297, other ) ==(sel)( , var_h296, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v324:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i297 --->  Ty_heap  
 var_h296 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i224 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h325 --->  Ty_heap  
 var__temp_v326 --->  Ty_int  
 var__temp_h'327 --->  Ty_heap  
 var__temp_v_err328 --->  error  
 var_h296 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h296, res ) ==(5) AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h325, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h325, res ) ==((sel)( , var_h296, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h325, other ) ==(sel)( , var_h296, other ) => 
 	 Rel (sel)( , var__temp_h325, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h325, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'327, res ) ==(var__temp_v326) AND 
 	 Rel (sel)( , var__temp_h'327, res ) ==((sel)( , var__temp_h325, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'327, other ) ==(sel)( , var__temp_h325, other ) => 
 	 True
 
VC_END(declare-const var_h_i297 T1224)
(declare-const var_h296 T1224)
(declare-const v Int)
(declare-const var_h_i224 T1224)
(declare-const var_h223 T1224)
(declare-const v Int)
(declare-const var_h_i184 T1224)
(declare-const var_h183 T1224)
(declare-const v Int)
(declare-const var_h_i144 T1224)
(declare-const var_h143 T1224)
(declare-const v Int)
(declare-const var_h_i92 T1224)
(declare-const var_h91 T1224)
(declare-const v Int)
(declare-const var_h_i44 T1224)
(declare-const var_h43 T1224)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h325 T1224)
(declare-const var__temp_v326 Int)
(declare-const |var__temp_h'327| T1224)
(declare-const var__temp_v_err328 T1225)
(declare-const var_h296 T1224)
(declare-const var_h223 T1224)
(declare-const var_h183 T1224)
(declare-const var_h143 T1224)
(declare-const var_h91 T1224)
(declare-const var_h43 T1224)
(declare-const err T1238)

solver 
 (declare-sort T1224)
(declare-fun sel (T1224 Int) Int)
(declare-fun res () Int)
(declare-fun var_h296 () T1224)
(declare-fun var_h183 () T1224)
(declare-fun var_h91 () T1224)
(declare-fun var_h43 () T1224)
(declare-fun other () Int)
(declare-fun var__temp_h325 () T1224)
(declare-fun |var__temp_h'327| () T1224)
(declare-fun var__temp_v326 () Int)
(declare-fun v () Int)
(assert (= (sel var_h296 res) 5))
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h325 res) v)
                (= (sel var__temp_h325 res) (+ (sel var_h296 res) 2))
                (= (sel var__temp_h325 other) (sel var_h296 other))))
      (a!2 (and (= (sel |var__temp_h'327| res) var__temp_v326)
                (= (sel |var__temp_h'327| res) (+ (sel var__temp_h325 res) 5))
                (= (sel |var__temp_h'327| other) (sel var__temp_h325 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h325 res) 7))
                (=> (= (sel var__temp_h325 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c5
PARTIAL PATH NEW
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --c2'
 	 --foo'
 	 --c4
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i330 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i330 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i330, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i330, res ) ==((sel)( , var_h329, res ) + (5))
 	 , (sel)( , var_h_i330, other ) ==(sel)( , var_h329, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v331:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i330 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************84
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v331:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v331:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc5bazbarc2fooc2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --c2'
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i330 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i330, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i330, res ) ==((sel)( , var_h329, res ) + (5))
 	 , (sel)( , var_h_i330, other ) ==(sel)( , var_h329, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v332:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************85
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2'
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i297 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i297, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i297, res ) ==((sel)( , var_h296, res ) + (2))
 	 , (sel)( , var_h_i297, other ) ==(sel)( , var_h296, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v333:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************86
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --foo
 	 --c2'
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i224 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i224, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i224, other ) ==(sel)( , var_h223, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v334:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************87
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i224 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i224, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i224, other ) ==(sel)( , var_h223, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v334:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i224 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h335 --->  Ty_heap  
 var__temp_v336 --->  Ty_int  
 var__temp_h'337 --->  Ty_heap  
 var__temp_v_err338 --->  error  
 var_h223 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h335, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h335, other ) ==(sel)( , var_h223, other ) => 
 	 Rel (sel)( , var__temp_h335, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h335, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'337, res ) ==(var__temp_v336) AND 
 	 Rel (sel)( , var__temp_h'337, res ) ==((sel)( , var__temp_h335, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'337, other ) ==(sel)( , var__temp_h335, other ) => 
 	 True
 
VC_END(declare-const var_h_i224 T1241)
(declare-const var_h223 T1241)
(declare-const v Int)
(declare-const var_h_i184 T1241)
(declare-const var_h183 T1241)
(declare-const v Int)
(declare-const var_h_i144 T1241)
(declare-const var_h143 T1241)
(declare-const v Int)
(declare-const var_h_i92 T1241)
(declare-const var_h91 T1241)
(declare-const v Int)
(declare-const var_h_i44 T1241)
(declare-const var_h43 T1241)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h335 T1241)
(declare-const var__temp_v336 Int)
(declare-const |var__temp_h'337| T1241)
(declare-const var__temp_v_err338 T1242)
(declare-const var_h223 T1241)
(declare-const var_h183 T1241)
(declare-const var_h143 T1241)
(declare-const var_h91 T1241)
(declare-const var_h43 T1241)
(declare-const err T1255)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1241)
(declare-fun sel (T1241 Int) Int)
(declare-fun res () Int)
(declare-fun var_h183 () T1241)
(declare-fun var_h91 () T1241)
(declare-fun var_h43 () T1241)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h335 () T1241)
(declare-fun |var__temp_h'337| () T1241)
(declare-fun var__temp_v336 () Int)
(declare-fun var_h223 () T1241)
(declare-fun v () Int)
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h335 res) v)
                    (= v |5|)
                    (= (sel var__temp_h335 other) (sel var_h223 other)))
               (= (sel var__temp_h335 res) 7)))
      (a!2 (and (= (sel |var__temp_h'337| res) var__temp_v336)
                (= (sel |var__temp_h'337| res) (+ (sel var__temp_h335 res) 3))
                (= (sel |var__temp_h'337| other) (sel var__temp_h335 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h335 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************88
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i224 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i224, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i224, other ) ==(sel)( , var_h223, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v334:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i224 --->  Ty_heap  
 var_h223 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h339 --->  Ty_heap  
 var__temp_v340 --->  Ty_int  
 var__temp_h'341 --->  Ty_heap  
 var__temp_v_err342 --->  error  
 var_h223 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h339, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h339, other ) ==(sel)( , var_h223, other ) => 
 	 Rel (sel)( , var__temp_h339, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h339, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'341, res ) ==(var__temp_v340) AND 
 	 Rel (sel)( , var__temp_h'341, res ) ==((sel)( , var__temp_h339, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'341, other ) ==(sel)( , var__temp_h339, other ) => 
 	 True
 
VC_END(declare-const var_h_i224 T1258)
(declare-const var_h223 T1258)
(declare-const v Int)
(declare-const var_h_i184 T1258)
(declare-const var_h183 T1258)
(declare-const v Int)
(declare-const var_h_i144 T1258)
(declare-const var_h143 T1258)
(declare-const v Int)
(declare-const var_h_i92 T1258)
(declare-const var_h91 T1258)
(declare-const v Int)
(declare-const var_h_i44 T1258)
(declare-const var_h43 T1258)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h339 T1258)
(declare-const var__temp_v340 Int)
(declare-const |var__temp_h'341| T1258)
(declare-const var__temp_v_err342 T1259)
(declare-const var_h223 T1258)
(declare-const var_h183 T1258)
(declare-const var_h143 T1258)
(declare-const var_h91 T1258)
(declare-const var_h43 T1258)
(declare-const err T1272)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1258)
(declare-fun sel (T1258 Int) Int)
(declare-fun res () Int)
(declare-fun var_h183 () T1258)
(declare-fun var_h91 () T1258)
(declare-fun var_h43 () T1258)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h339 () T1258)
(declare-fun |var__temp_h'341| () T1258)
(declare-fun var__temp_v340 () Int)
(declare-fun var_h223 () T1258)
(declare-fun v () Int)
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h339 res) v)
                    (= v |5|)
                    (= (sel var__temp_h339 other) (sel var_h223 other)))
               (= (sel var__temp_h339 res) 7)))
      (a!2 (and (= (sel |var__temp_h'341| res) var__temp_v340)
                (= (sel |var__temp_h'341| res) (+ (sel var__temp_h339 res) 5))
                (= (sel |var__temp_h'341| other) (sel var__temp_h339 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h339 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************89
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT bar
PARTIAL PATH
SUB 
 	 --c2'
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i184 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i184, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h183, res ) ==(sel)( , var_h183, res )
 	 , (sel)( , var_h_i184, other ) ==(sel)( , var_h183, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v343:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
bar
 *********************Enumeration Iteration*****************90
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i184 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i184, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h183, res ) ==(sel)( , var_h183, res )
 	 , (sel)( , var_h_i184, other ) ==(sel)( , var_h183, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v343:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h344 --->  Ty_heap  
 var__temp_v345 --->  Ty_int  
 var__temp_h'346 --->  Ty_heap  
 var__temp_v_err347 --->  error  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h344, res ) ==(v) AND 
 	 Rel (sel)( , var_h183, res ) ==(sel)( , var_h183, res ) AND 
 	 Rel (sel)( , var__temp_h344, other ) ==(sel)( , var_h183, other ) => 
 	 Rel (sel)( , var__temp_h344, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h344, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'346, res ) ==(var__temp_v345) AND 
 	 Rel (sel)( , var__temp_h'346, res ) ==((sel)( , var__temp_h344, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'346, other ) ==(sel)( , var__temp_h344, other ) => 
 	 True
 
VC_END(declare-const var_h_i184 T1275)
(declare-const var_h183 T1275)
(declare-const v Int)
(declare-const var_h_i144 T1275)
(declare-const var_h143 T1275)
(declare-const v Int)
(declare-const var_h_i92 T1275)
(declare-const var_h91 T1275)
(declare-const v Int)
(declare-const var_h_i44 T1275)
(declare-const var_h43 T1275)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h344 T1275)
(declare-const var__temp_v345 Int)
(declare-const |var__temp_h'346| T1275)
(declare-const var__temp_v_err347 T1276)
(declare-const var_h183 T1275)
(declare-const var_h143 T1275)
(declare-const var_h91 T1275)
(declare-const var_h43 T1275)
(declare-const err T1289)

solver 
 (declare-sort T1275)
(declare-fun sel (T1275 Int) Int)
(declare-fun res () Int)
(declare-fun var_h183 () T1275)
(declare-fun var_h91 () T1275)
(declare-fun var_h43 () T1275)
(declare-fun other () Int)
(declare-fun var__temp_h344 () T1275)
(declare-fun |var__temp_h'346| () T1275)
(declare-fun var__temp_v345 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h344 res) v)
                    (= (sel var_h183 res) (sel var_h183 res))
                    (= (sel var__temp_h344 other) (sel var_h183 other)))
               (= (sel var__temp_h344 res) 7)))
      (a!2 (and (= (sel |var__temp_h'346| res) var__temp_v345)
                (= (sel |var__temp_h'346| res) (+ (sel var__temp_h344 res) 3))
                (= (sel |var__temp_h'346| other) (sel var__temp_h344 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h344 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************91
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i184 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i184, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h183, res ) ==(sel)( , var_h183, res )
 	 , (sel)( , var_h_i184, other ) ==(sel)( , var_h183, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v343:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h348 --->  Ty_heap  
 var__temp_v349 --->  Ty_int  
 var__temp_h'350 --->  Ty_heap  
 var__temp_v_err351 --->  error  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h348, res ) ==(v) AND 
 	 Rel (sel)( , var_h183, res ) ==(sel)( , var_h183, res ) AND 
 	 Rel (sel)( , var__temp_h348, other ) ==(sel)( , var_h183, other ) => 
 	 Rel (sel)( , var__temp_h348, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h348, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'350, res ) ==(var__temp_v349) AND 
 	 Rel (sel)( , var__temp_h'350, res ) ==((sel)( , var__temp_h348, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'350, other ) ==(sel)( , var__temp_h348, other ) => 
 	 True
 
VC_END(declare-const var_h_i184 T1292)
(declare-const var_h183 T1292)
(declare-const v Int)
(declare-const var_h_i144 T1292)
(declare-const var_h143 T1292)
(declare-const v Int)
(declare-const var_h_i92 T1292)
(declare-const var_h91 T1292)
(declare-const v Int)
(declare-const var_h_i44 T1292)
(declare-const var_h43 T1292)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h348 T1292)
(declare-const var__temp_v349 Int)
(declare-const |var__temp_h'350| T1292)
(declare-const var__temp_v_err351 T1293)
(declare-const var_h183 T1292)
(declare-const var_h143 T1292)
(declare-const var_h91 T1292)
(declare-const var_h43 T1292)
(declare-const err T1306)

solver 
 (declare-sort T1292)
(declare-fun sel (T1292 Int) Int)
(declare-fun res () Int)
(declare-fun var_h183 () T1292)
(declare-fun var_h91 () T1292)
(declare-fun var_h43 () T1292)
(declare-fun other () Int)
(declare-fun var__temp_h348 () T1292)
(declare-fun |var__temp_h'350| () T1292)
(declare-fun var__temp_v349 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h348 res) v)
                    (= (sel var_h183 res) (sel var_h183 res))
                    (= (sel var__temp_h348 other) (sel var_h183 other)))
               (= (sel var__temp_h348 res) 7)))
      (a!2 (and (= (sel |var__temp_h'350| res) var__temp_v349)
                (= (sel |var__temp_h'350| res) (+ (sel var__temp_h348 res) 5))
                (= (sel |var__temp_h'350| other) (sel var__temp_h348 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h348 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************92
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i184 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i184, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h183, res ) ==(sel)( , var_h183, res )
 	 , (sel)( , var_h_i184, other ) ==(sel)( , var_h183, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v343:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h352 --->  Ty_heap  
 var__temp_v353 --->  Ty_int  
 var__temp_h'354 --->  Ty_heap  
 var__temp_v_err355 --->  error  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h352, res ) ==(v) AND 
 	 Rel (sel)( , var_h183, res ) ==(sel)( , var_h183, res ) AND 
 	 Rel (sel)( , var__temp_h352, other ) ==(sel)( , var_h183, other ) => 
 	 Rel (sel)( , var__temp_h352, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h352, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'354, res ) ==(var__temp_v353) AND 
 	 Rel (sel)( , var__temp_h'354, res ) ==((sel)( , var__temp_h352, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'354, other ) ==(sel)( , var__temp_h352, other ) => 
 	 True
 
VC_END(declare-const var_h_i184 T1309)
(declare-const var_h183 T1309)
(declare-const v Int)
(declare-const var_h_i144 T1309)
(declare-const var_h143 T1309)
(declare-const v Int)
(declare-const var_h_i92 T1309)
(declare-const var_h91 T1309)
(declare-const v Int)
(declare-const var_h_i44 T1309)
(declare-const var_h43 T1309)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h352 T1309)
(declare-const var__temp_v353 Int)
(declare-const |var__temp_h'354| T1309)
(declare-const var__temp_v_err355 T1310)
(declare-const var_h183 T1309)
(declare-const var_h143 T1309)
(declare-const var_h91 T1309)
(declare-const var_h43 T1309)
(declare-const err T1323)

solver 
 (declare-sort T1309)
(declare-fun sel (T1309 Int) Int)
(declare-fun res () Int)
(declare-fun var_h183 () T1309)
(declare-fun var_h91 () T1309)
(declare-fun var_h43 () T1309)
(declare-fun other () Int)
(declare-fun var__temp_h352 () T1309)
(declare-fun |var__temp_h'354| () T1309)
(declare-fun var__temp_v353 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h352 res) v)
                    (= (sel var_h183 res) (sel var_h183 res))
                    (= (sel var__temp_h352 other) (sel var_h183 other)))
               (> (sel var__temp_h352 res) 4)))
      (a!2 (and (= (sel |var__temp_h'354| res) var__temp_v353)
                (= (sel |var__temp_h'354| res) (+ (sel var__temp_h352 res) 10))
                (= (sel |var__temp_h'354| other) (sel var__temp_h352 other)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h352 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************93
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i184 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i184, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h183, res ) ==(sel)( , var_h183, res )
 	 , (sel)( , var_h_i184, other ) ==(sel)( , var_h183, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v343:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i184 --->  Ty_heap  
 var_h183 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h356 --->  Ty_heap  
 var__temp_v357 --->  Ty_int  
 var__temp_h'358 --->  Ty_heap  
 var__temp_v_err359 --->  error  
 var_h183 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h183, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h356, res ) ==(v) AND 
 	 Rel (sel)( , var_h183, res ) ==(sel)( , var_h183, res ) AND 
 	 Rel (sel)( , var__temp_h356, other ) ==(sel)( , var_h183, other ) => 
 	 Rel (sel)( , var__temp_h356, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h356, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'358, res ) ==(var__temp_v357) AND 
 	 Rel (sel)( , var__temp_h'358, res ) ==((sel)( , var__temp_h356, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'358, other ) ==(sel)( , var__temp_h356, other ) => 
 	 True
 
VC_END(declare-const var_h_i184 T1326)
(declare-const var_h183 T1326)
(declare-const v Int)
(declare-const var_h_i144 T1326)
(declare-const var_h143 T1326)
(declare-const v Int)
(declare-const var_h_i92 T1326)
(declare-const var_h91 T1326)
(declare-const v Int)
(declare-const var_h_i44 T1326)
(declare-const var_h43 T1326)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h356 T1326)
(declare-const var__temp_v357 Int)
(declare-const |var__temp_h'358| T1326)
(declare-const var__temp_v_err359 T1327)
(declare-const var_h183 T1326)
(declare-const var_h143 T1326)
(declare-const var_h91 T1326)
(declare-const var_h43 T1326)
(declare-const err T1340)

solver 
 (declare-sort T1326)
(declare-fun sel (T1326 Int) Int)
(declare-fun res () Int)
(declare-fun var_h183 () T1326)
(declare-fun var_h91 () T1326)
(declare-fun var_h43 () T1326)
(declare-fun other () Int)
(declare-fun var__temp_h356 () T1326)
(declare-fun |var__temp_h'358| () T1326)
(declare-fun var__temp_v357 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h183 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h356 res) v)
                    (= (sel var_h183 res) (sel var_h183 res))
                    (= (sel var__temp_h356 other) (sel var_h183 other)))
               (= (sel var__temp_h356 res) 5)))
      (a!2 (and (= (sel |var__temp_h'358| res) var__temp_v357)
                (= (sel |var__temp_h'358| res) (+ (sel var__temp_h356 res) 2))
                (= (sel |var__temp_h'358| other) (sel var__temp_h356 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h356 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************94
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo
PARTIAL PATH
SUB 
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i144 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i144, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i144, other ) ==(sel)( , var_h143, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v360:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************95
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i144 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i144, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i144, other ) ==(sel)( , var_h143, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v360:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h361 --->  Ty_heap  
 var__temp_v362 --->  Ty_int  
 var__temp_h'363 --->  Ty_heap  
 var__temp_v_err364 --->  error  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h361, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h361, other ) ==(sel)( , var_h143, other ) => 
 	 Rel (sel)( , var__temp_h361, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h361, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'363, res ) ==(var__temp_v362) AND 
 	 Rel (sel)( , var__temp_h'363, res ) ==((sel)( , var__temp_h361, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'363, other ) ==(sel)( , var__temp_h361, other ) => 
 	 True
 
VC_END(declare-const var_h_i144 T1343)
(declare-const var_h143 T1343)
(declare-const v Int)
(declare-const var_h_i92 T1343)
(declare-const var_h91 T1343)
(declare-const v Int)
(declare-const var_h_i44 T1343)
(declare-const var_h43 T1343)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h361 T1343)
(declare-const var__temp_v362 Int)
(declare-const |var__temp_h'363| T1343)
(declare-const var__temp_v_err364 T1344)
(declare-const var_h143 T1343)
(declare-const var_h91 T1343)
(declare-const var_h43 T1343)
(declare-const err T1357)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1343)
(declare-fun sel (T1343 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T1343)
(declare-fun var_h43 () T1343)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h361 () T1343)
(declare-fun |var__temp_h'363| () T1343)
(declare-fun var__temp_v362 () Int)
(declare-fun var_h143 () T1343)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h361 res) v)
                    (= v |20|)
                    (= (sel var__temp_h361 other) (sel var_h143 other)))
               (= (sel var__temp_h361 res) 7)))
      (a!2 (and (= (sel |var__temp_h'363| res) var__temp_v362)
                (= (sel |var__temp_h'363| res) (+ (sel var__temp_h361 res) 3))
                (= (sel |var__temp_h'363| other) (sel var__temp_h361 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h361 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************96
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i144 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i144, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i144, other ) ==(sel)( , var_h143, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v360:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h365 --->  Ty_heap  
 var__temp_v366 --->  Ty_int  
 var__temp_h'367 --->  Ty_heap  
 var__temp_v_err368 --->  error  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h365, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h365, other ) ==(sel)( , var_h143, other ) => 
 	 Rel (sel)( , var__temp_h365, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h365, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'367, res ) ==(var__temp_v366) AND 
 	 Rel (sel)( , var__temp_h'367, res ) ==((sel)( , var__temp_h365, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'367, other ) ==(sel)( , var__temp_h365, other ) => 
 	 True
 
VC_END(declare-const var_h_i144 T1360)
(declare-const var_h143 T1360)
(declare-const v Int)
(declare-const var_h_i92 T1360)
(declare-const var_h91 T1360)
(declare-const v Int)
(declare-const var_h_i44 T1360)
(declare-const var_h43 T1360)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h365 T1360)
(declare-const var__temp_v366 Int)
(declare-const |var__temp_h'367| T1360)
(declare-const var__temp_v_err368 T1361)
(declare-const var_h143 T1360)
(declare-const var_h91 T1360)
(declare-const var_h43 T1360)
(declare-const err T1374)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1360)
(declare-fun sel (T1360 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T1360)
(declare-fun var_h43 () T1360)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h365 () T1360)
(declare-fun |var__temp_h'367| () T1360)
(declare-fun var__temp_v366 () Int)
(declare-fun var_h143 () T1360)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h365 res) v)
                    (= v |20|)
                    (= (sel var__temp_h365 other) (sel var_h143 other)))
               (= (sel var__temp_h365 res) 7)))
      (a!2 (and (= (sel |var__temp_h'367| res) var__temp_v366)
                (= (sel |var__temp_h'367| res) (+ (sel var__temp_h365 res) 5))
                (= (sel |var__temp_h'367| other) (sel var__temp_h365 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h365 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************97
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i144 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i144, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i144, other ) ==(sel)( , var_h143, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v360:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h369 --->  Ty_heap  
 var__temp_v370 --->  Ty_int  
 var__temp_h'371 --->  Ty_heap  
 var__temp_v_err372 --->  error  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h369, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h369, other ) ==(sel)( , var_h143, other ) => 
 	 Rel (sel)( , var__temp_h369, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h369, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'371, res ) ==(var__temp_v370) AND 
 	 Rel (sel)( , var__temp_h'371, res ) ==((sel)( , var__temp_h369, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'371, other ) ==(sel)( , var__temp_h369, other ) => 
 	 True
 
VC_END(declare-const var_h_i144 T1377)
(declare-const var_h143 T1377)
(declare-const v Int)
(declare-const var_h_i92 T1377)
(declare-const var_h91 T1377)
(declare-const v Int)
(declare-const var_h_i44 T1377)
(declare-const var_h43 T1377)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h369 T1377)
(declare-const var__temp_v370 Int)
(declare-const |var__temp_h'371| T1377)
(declare-const var__temp_v_err372 T1378)
(declare-const var_h143 T1377)
(declare-const var_h91 T1377)
(declare-const var_h43 T1377)
(declare-const err T1391)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1377)
(declare-fun sel (T1377 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T1377)
(declare-fun var_h43 () T1377)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h369 () T1377)
(declare-fun |var__temp_h'371| () T1377)
(declare-fun var__temp_v370 () Int)
(declare-fun var_h143 () T1377)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h369 res) v)
                    (= v |20|)
                    (= (sel var__temp_h369 other) (sel var_h143 other)))
               (> (sel var__temp_h369 res) 4)))
      (a!2 (and (= (sel |var__temp_h'371| res) var__temp_v370)
                (= (sel |var__temp_h'371| res) (+ (sel var__temp_h369 res) 10))
                (= (sel |var__temp_h'371| other) (sel var__temp_h369 other)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h369 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c2
PARTIAL PATH NEW
SUB 
 	 --c2
 	 --foo'
 	 --c4
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i374 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i374 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i374, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i374, res ) ==((sel)( , var_h373, res ) + (10))
 	 , (sel)( , var_h_i374, other ) ==(sel)( , var_h373, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v375:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i374 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************98
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i374 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i374, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i374, res ) ==((sel)( , var_h373, res ) + (10))
 	 , (sel)( , var_h_i374, other ) ==(sel)( , var_h373, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v375:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i374 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i374 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h376 --->  Ty_heap  
 var__temp_v377 --->  Ty_int  
 var__temp_h'378 --->  Ty_heap  
 var__temp_v_err379 --->  error  
 var_h373 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h373, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h376, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h376, res ) ==((sel)( , var_h373, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h376, other ) ==(sel)( , var_h373, other ) => 
 	 Rel (sel)( , var__temp_h376, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h376, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'378, res ) ==(var__temp_v377) AND 
 	 Rel (sel)( , var__temp_h'378, res ) ==((sel)( , var__temp_h376, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'378, other ) ==(sel)( , var__temp_h376, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'378, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'378, other ) > (4)
 
VC_END(declare-const var_h_i374 T1394)
(declare-const var_h373 T1394)
(declare-const v Int)
(declare-const var_h_i144 T1394)
(declare-const var_h143 T1394)
(declare-const v Int)
(declare-const var_h_i92 T1394)
(declare-const var_h91 T1394)
(declare-const v Int)
(declare-const var_h_i44 T1394)
(declare-const var_h43 T1394)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h376 T1394)
(declare-const var__temp_v377 Int)
(declare-const |var__temp_h'378| T1394)
(declare-const var__temp_v_err379 T1395)
(declare-const var_h373 T1394)
(declare-const var_h143 T1394)
(declare-const var_h91 T1394)
(declare-const var_h43 T1394)
(declare-const err T1408)

solver 
 (declare-sort T1394)
(declare-fun sel (T1394 Int) Int)
(declare-fun res () Int)
(declare-fun var_h373 () T1394)
(declare-fun var_h91 () T1394)
(declare-fun var_h43 () T1394)
(declare-fun other () Int)
(declare-fun |var__temp_h'378| () T1394)
(declare-fun var__temp_h376 () T1394)
(declare-fun var__temp_v377 () Int)
(declare-fun v () Int)
(assert (> (sel var_h373 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h376 res) v)
                (= (sel var__temp_h376 res) (+ (sel var_h373 res) 10))
                (= (sel var__temp_h376 other) (sel var_h373 other))))
      (a!2 (and (= (sel |var__temp_h'378| res) var__temp_v377)
                (= (sel |var__temp_h'378| res) (+ (sel var__temp_h376 res) 3))
                (= (sel |var__temp_h'378| other) (sel var__temp_h376 other))))
      (a!3 (and (= (sel |var__temp_h'378| res) 10)
                (not (> (sel |var__temp_h'378| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h376 res) 7))
                (=> (= (sel var__temp_h376 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************99
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i374 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i374, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i374, res ) ==((sel)( , var_h373, res ) + (10))
 	 , (sel)( , var_h_i374, other ) ==(sel)( , var_h373, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v375:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i374 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i374 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h380 --->  Ty_heap  
 var__temp_v381 --->  Ty_int  
 var__temp_h'382 --->  Ty_heap  
 var__temp_v_err383 --->  error  
 var_h373 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h373, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h380, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h380, res ) ==((sel)( , var_h373, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h380, other ) ==(sel)( , var_h373, other ) => 
 	 Rel (sel)( , var__temp_h380, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h380, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'382, res ) ==(var__temp_v381) AND 
 	 Rel (sel)( , var__temp_h'382, res ) ==((sel)( , var__temp_h380, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'382, other ) ==(sel)( , var__temp_h380, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'382, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'382, other ) > (4)
 
VC_END(declare-const var_h_i374 T1411)
(declare-const var_h373 T1411)
(declare-const v Int)
(declare-const var_h_i144 T1411)
(declare-const var_h143 T1411)
(declare-const v Int)
(declare-const var_h_i92 T1411)
(declare-const var_h91 T1411)
(declare-const v Int)
(declare-const var_h_i44 T1411)
(declare-const var_h43 T1411)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h380 T1411)
(declare-const var__temp_v381 Int)
(declare-const |var__temp_h'382| T1411)
(declare-const var__temp_v_err383 T1412)
(declare-const var_h373 T1411)
(declare-const var_h143 T1411)
(declare-const var_h91 T1411)
(declare-const var_h43 T1411)
(declare-const err T1425)

solver 
 (declare-sort T1411)
(declare-fun sel (T1411 Int) Int)
(declare-fun res () Int)
(declare-fun var_h373 () T1411)
(declare-fun var_h91 () T1411)
(declare-fun var_h43 () T1411)
(declare-fun other () Int)
(declare-fun |var__temp_h'382| () T1411)
(declare-fun var__temp_h380 () T1411)
(declare-fun var__temp_v381 () Int)
(declare-fun v () Int)
(assert (> (sel var_h373 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h380 res) v)
                (= (sel var__temp_h380 res) (+ (sel var_h373 res) 10))
                (= (sel var__temp_h380 other) (sel var_h373 other))))
      (a!2 (and (= (sel |var__temp_h'382| res) var__temp_v381)
                (= (sel |var__temp_h'382| res) (+ (sel var__temp_h380 res) 5))
                (= (sel |var__temp_h'382| other) (sel var__temp_h380 other))))
      (a!3 (and (= (sel |var__temp_h'382| res) 10)
                (not (> (sel |var__temp_h'382| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h380 res) 7))
                (=> (= (sel var__temp_h380 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************100
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i374 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i374, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i374, res ) ==((sel)( , var_h373, res ) + (10))
 	 , (sel)( , var_h_i374, other ) ==(sel)( , var_h373, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v375:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i374 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i374 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h384 --->  Ty_heap  
 var__temp_v385 --->  Ty_int  
 var__temp_h'386 --->  Ty_heap  
 var__temp_v_err387 --->  error  
 var_h373 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h373, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h384, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h384, res ) ==((sel)( , var_h373, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h384, other ) ==(sel)( , var_h373, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'386, res ) ==(var__temp_v385) AND 
 	 Base var__temp_v385 = 5 AND 
 	 Rel (sel)( , var__temp_h'386, other ) ==(sel)( , var__temp_h384, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'386, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'386, other ) > (4)
 
VC_END(declare-const var_h_i374 T1428)
(declare-const var_h373 T1428)
(declare-const v Int)
(declare-const var_h_i144 T1428)
(declare-const var_h143 T1428)
(declare-const v Int)
(declare-const var_h_i92 T1428)
(declare-const var_h91 T1428)
(declare-const v Int)
(declare-const var_h_i44 T1428)
(declare-const var_h43 T1428)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h384 T1428)
(declare-const var__temp_v385 Int)
(declare-const |var__temp_h'386| T1428)
(declare-const var__temp_v_err387 T1429)
(declare-const var_h373 T1428)
(declare-const var_h143 T1428)
(declare-const var_h91 T1428)
(declare-const var_h43 T1428)
(declare-const err T1442)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1428)
(declare-fun sel (T1428 Int) Int)
(declare-fun res () Int)
(declare-fun var_h373 () T1428)
(declare-fun var_h91 () T1428)
(declare-fun var_h43 () T1428)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'386| () T1428)
(declare-fun var__temp_h384 () T1428)
(declare-fun var__temp_v385 () Int)
(declare-fun v () Int)
(assert (> (sel var_h373 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h384 res) v)
                (= (sel var__temp_h384 res) (+ (sel var_h373 res) 10))
                (= (sel var__temp_h384 other) (sel var_h373 other))))
      (a!2 (and (= (sel |var__temp_h'386| res) 10)
                (not (> (sel |var__temp_h'386| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'386| res) var__temp_v385)
                    (= var__temp_v385 |5|)
                    (= (sel |var__temp_h'386| other) (sel var__temp_h384 other)))
               a!2)))
  (not (and (=> a!1 true) (=> true a!3))))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************101
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i374 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i374, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i374, res ) ==((sel)( , var_h373, res ) + (10))
 	 , (sel)( , var_h_i374, other ) ==(sel)( , var_h373, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v375:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i374 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i374 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h388 --->  Ty_heap  
 var__temp_v389 --->  Ty_int  
 var__temp_h'390 --->  Ty_heap  
 var__temp_v_err391 --->  error  
 var_h373 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h373, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h388, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h388, res ) ==((sel)( , var_h373, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h388, other ) ==(sel)( , var_h373, other ) => 
 	 Rel (sel)( , var__temp_h388, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h388, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'390, res ) ==(var__temp_v389) AND 
 	 Rel (sel)( , var__temp_h'390, res ) ==((sel)( , var__temp_h388, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'390, other ) ==(sel)( , var__temp_h388, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'390, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'390, other ) > (4)
 
VC_END(declare-const var_h_i374 T1445)
(declare-const var_h373 T1445)
(declare-const v Int)
(declare-const var_h_i144 T1445)
(declare-const var_h143 T1445)
(declare-const v Int)
(declare-const var_h_i92 T1445)
(declare-const var_h91 T1445)
(declare-const v Int)
(declare-const var_h_i44 T1445)
(declare-const var_h43 T1445)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h388 T1445)
(declare-const var__temp_v389 Int)
(declare-const |var__temp_h'390| T1445)
(declare-const var__temp_v_err391 T1446)
(declare-const var_h373 T1445)
(declare-const var_h143 T1445)
(declare-const var_h91 T1445)
(declare-const var_h43 T1445)
(declare-const err T1459)

solver 
 (declare-sort T1445)
(declare-fun sel (T1445 Int) Int)
(declare-fun res () Int)
(declare-fun var_h373 () T1445)
(declare-fun var_h91 () T1445)
(declare-fun var_h43 () T1445)
(declare-fun other () Int)
(declare-fun |var__temp_h'390| () T1445)
(declare-fun var__temp_h388 () T1445)
(declare-fun var__temp_v389 () Int)
(declare-fun v () Int)
(assert (> (sel var_h373 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h388 res) v)
                (= (sel var__temp_h388 res) (+ (sel var_h373 res) 10))
                (= (sel var__temp_h388 other) (sel var_h373 other))))
      (a!2 (and (= (sel |var__temp_h'390| res) var__temp_v389)
                (= (sel |var__temp_h'390| res) (+ (sel var__temp_h388 res) 2))
                (= (sel |var__temp_h'390| other) (sel var__temp_h388 other))))
      (a!3 (and (= (sel |var__temp_h'390| res) 10)
                (not (> (sel |var__temp_h'390| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h388 res) 5))
                (=> (= (sel var__temp_h388 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************102
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v375:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v375:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2c2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c2
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i374 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i374, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i374, res ) ==((sel)( , var_h373, res ) + (10))
 	 , (sel)( , var_h_i374, other ) ==(sel)( , var_h373, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v392:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************103
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i374 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i374, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i374, res ) ==((sel)( , var_h373, res ) + (10))
 	 , (sel)( , var_h_i374, other ) ==(sel)( , var_h373, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v392:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i374 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h393 --->  Ty_heap  
 var__temp_v394 --->  Ty_int  
 var__temp_h'395 --->  Ty_heap  
 var__temp_v_err396 --->  error  
 var_h373 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h373, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h393, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h393, res ) ==((sel)( , var_h373, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h393, other ) ==(sel)( , var_h373, other ) => 
 	 Rel (sel)( , var__temp_h393, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h393, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'395, res ) ==(var__temp_v394) AND 
 	 Rel (sel)( , var__temp_h'395, res ) ==((sel)( , var__temp_h393, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'395, other ) ==(sel)( , var__temp_h393, other ) => 
 	 True
 
VC_END(declare-const var_h_i374 T1462)
(declare-const var_h373 T1462)
(declare-const v Int)
(declare-const var_h_i144 T1462)
(declare-const var_h143 T1462)
(declare-const v Int)
(declare-const var_h_i92 T1462)
(declare-const var_h91 T1462)
(declare-const v Int)
(declare-const var_h_i44 T1462)
(declare-const var_h43 T1462)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h393 T1462)
(declare-const var__temp_v394 Int)
(declare-const |var__temp_h'395| T1462)
(declare-const var__temp_v_err396 T1463)
(declare-const var_h373 T1462)
(declare-const var_h143 T1462)
(declare-const var_h91 T1462)
(declare-const var_h43 T1462)
(declare-const err T1476)

solver 
 (declare-sort T1462)
(declare-fun sel (T1462 Int) Int)
(declare-fun res () Int)
(declare-fun var_h373 () T1462)
(declare-fun var_h91 () T1462)
(declare-fun var_h43 () T1462)
(declare-fun other () Int)
(declare-fun var__temp_h393 () T1462)
(declare-fun |var__temp_h'395| () T1462)
(declare-fun var__temp_v394 () Int)
(declare-fun v () Int)
(assert (> (sel var_h373 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h393 res) v)
                (= (sel var__temp_h393 res) (+ (sel var_h373 res) 10))
                (= (sel var__temp_h393 other) (sel var_h373 other))))
      (a!2 (and (= (sel |var__temp_h'395| res) var__temp_v394)
                (= (sel |var__temp_h'395| res) (+ (sel var__temp_h393 res) 3))
                (= (sel |var__temp_h'395| other) (sel var__temp_h393 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h393 res) 7))
                (=> (= (sel var__temp_h393 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************104
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i374 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i374, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i374, res ) ==((sel)( , var_h373, res ) + (10))
 	 , (sel)( , var_h_i374, other ) ==(sel)( , var_h373, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v392:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i374 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h397 --->  Ty_heap  
 var__temp_v398 --->  Ty_int  
 var__temp_h'399 --->  Ty_heap  
 var__temp_v_err400 --->  error  
 var_h373 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h373, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h397, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h397, res ) ==((sel)( , var_h373, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h397, other ) ==(sel)( , var_h373, other ) => 
 	 Rel (sel)( , var__temp_h397, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h397, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'399, res ) ==(var__temp_v398) AND 
 	 Rel (sel)( , var__temp_h'399, res ) ==((sel)( , var__temp_h397, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'399, other ) ==(sel)( , var__temp_h397, other ) => 
 	 True
 
VC_END(declare-const var_h_i374 T1479)
(declare-const var_h373 T1479)
(declare-const v Int)
(declare-const var_h_i144 T1479)
(declare-const var_h143 T1479)
(declare-const v Int)
(declare-const var_h_i92 T1479)
(declare-const var_h91 T1479)
(declare-const v Int)
(declare-const var_h_i44 T1479)
(declare-const var_h43 T1479)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h397 T1479)
(declare-const var__temp_v398 Int)
(declare-const |var__temp_h'399| T1479)
(declare-const var__temp_v_err400 T1480)
(declare-const var_h373 T1479)
(declare-const var_h143 T1479)
(declare-const var_h91 T1479)
(declare-const var_h43 T1479)
(declare-const err T1493)

solver 
 (declare-sort T1479)
(declare-fun sel (T1479 Int) Int)
(declare-fun res () Int)
(declare-fun var_h373 () T1479)
(declare-fun var_h91 () T1479)
(declare-fun var_h43 () T1479)
(declare-fun other () Int)
(declare-fun var__temp_h397 () T1479)
(declare-fun |var__temp_h'399| () T1479)
(declare-fun var__temp_v398 () Int)
(declare-fun v () Int)
(assert (> (sel var_h373 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h397 res) v)
                (= (sel var__temp_h397 res) (+ (sel var_h373 res) 10))
                (= (sel var__temp_h397 other) (sel var_h373 other))))
      (a!2 (and (= (sel |var__temp_h'399| res) var__temp_v398)
                (= (sel |var__temp_h'399| res) (+ (sel var__temp_h397 res) 5))
                (= (sel |var__temp_h'399| other) (sel var__temp_h397 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h397 res) 7))
                (=> (= (sel var__temp_h397 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************105
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i374 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i374, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i374, res ) ==((sel)( , var_h373, res ) + (10))
 	 , (sel)( , var_h_i374, other ) ==(sel)( , var_h373, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v392:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i374 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h401 --->  Ty_heap  
 var__temp_v402 --->  Ty_int  
 var__temp_h'403 --->  Ty_heap  
 var__temp_v_err404 --->  error  
 var_h373 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h373, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h401, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h401, res ) ==((sel)( , var_h373, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h401, other ) ==(sel)( , var_h373, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'403, res ) ==(var__temp_v402) AND 
 	 Base var__temp_v402 = 5 AND 
 	 Rel (sel)( , var__temp_h'403, other ) ==(sel)( , var__temp_h401, other ) => 
 	 True
 
VC_END(declare-const var_h_i374 T1496)
(declare-const var_h373 T1496)
(declare-const v Int)
(declare-const var_h_i144 T1496)
(declare-const var_h143 T1496)
(declare-const v Int)
(declare-const var_h_i92 T1496)
(declare-const var_h91 T1496)
(declare-const v Int)
(declare-const var_h_i44 T1496)
(declare-const var_h43 T1496)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h401 T1496)
(declare-const var__temp_v402 Int)
(declare-const |var__temp_h'403| T1496)
(declare-const var__temp_v_err404 T1497)
(declare-const var_h373 T1496)
(declare-const var_h143 T1496)
(declare-const var_h91 T1496)
(declare-const var_h43 T1496)
(declare-const err T1510)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1496)
(declare-fun sel (T1496 Int) Int)
(declare-fun res () Int)
(declare-fun var_h373 () T1496)
(declare-fun var_h91 () T1496)
(declare-fun var_h43 () T1496)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h401 () T1496)
(declare-fun |var__temp_h'403| () T1496)
(declare-fun var__temp_v402 () Int)
(declare-fun v () Int)
(assert (> (sel var_h373 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h401 res) v)
                (= (sel var__temp_h401 res) (+ (sel var_h373 res) 10))
                (= (sel var__temp_h401 other) (sel var_h373 other))))
      (a!2 (=> (and (= (sel |var__temp_h'403| res) var__temp_v402)
                    (= var__temp_v402 |5|)
                    (= (sel |var__temp_h'403| other) (sel var__temp_h401 other)))
               true)))
  (not (and (=> a!1 true) (=> true a!2)))))

***************Selection Successful************foo
PARTIAL PATH NEW
SUB 
 	 --foo
 	 --c2
 	 --foo'
 	 --c4
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i406 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i406 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i406, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i406, other ) ==(sel)( , var_h405, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v407:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i406 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************106
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i406 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i406, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i406, other ) ==(sel)( , var_h405, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v407:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i406 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i406 --->  Ty_heap  
 var_h405 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i374 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h408 --->  Ty_heap  
 var__temp_v409 --->  Ty_int  
 var__temp_h'410 --->  Ty_heap  
 var__temp_v_err411 --->  error  
 var_h405 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h373, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h408, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h408, other ) ==(sel)( , var_h405, other ) => 
 	 Rel (sel)( , var__temp_h408, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h408, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'410, res ) ==(var__temp_v409) AND 
 	 Rel (sel)( , var__temp_h'410, res ) ==((sel)( , var__temp_h408, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'410, other ) ==(sel)( , var__temp_h408, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'410, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'410, other ) > (4)
 
VC_END(declare-const var_h_i406 T1513)
(declare-const var_h405 T1513)
(declare-const v Int)
(declare-const var_h_i374 T1513)
(declare-const var_h373 T1513)
(declare-const v Int)
(declare-const var_h_i144 T1513)
(declare-const var_h143 T1513)
(declare-const v Int)
(declare-const var_h_i92 T1513)
(declare-const var_h91 T1513)
(declare-const v Int)
(declare-const var_h_i44 T1513)
(declare-const var_h43 T1513)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h408 T1513)
(declare-const var__temp_v409 Int)
(declare-const |var__temp_h'410| T1513)
(declare-const var__temp_v_err411 T1514)
(declare-const var_h405 T1513)
(declare-const var_h373 T1513)
(declare-const var_h143 T1513)
(declare-const var_h91 T1513)
(declare-const var_h43 T1513)
(declare-const err T1527)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1513)
(declare-fun sel (T1513 Int) Int)
(declare-fun res () Int)
(declare-fun var_h373 () T1513)
(declare-fun var_h91 () T1513)
(declare-fun var_h43 () T1513)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'410| () T1513)
(declare-fun var__temp_h408 () T1513)
(declare-fun var__temp_v409 () Int)
(declare-fun var_h405 () T1513)
(declare-fun v () Int)
(assert (> (sel var_h373 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h408 res) v)
                    (= v |5|)
                    (= (sel var__temp_h408 other) (sel var_h405 other)))
               (= (sel var__temp_h408 res) 7)))
      (a!2 (and (= (sel |var__temp_h'410| res) var__temp_v409)
                (= (sel |var__temp_h'410| res) (+ (sel var__temp_h408 res) 3))
                (= (sel |var__temp_h'410| other) (sel var__temp_h408 other))))
      (a!3 (and (= (sel |var__temp_h'410| res) 10)
                (not (> (sel |var__temp_h'410| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h408 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************107
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i406 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i406, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i406, other ) ==(sel)( , var_h405, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v407:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i406 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i406 --->  Ty_heap  
 var_h405 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i374 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h412 --->  Ty_heap  
 var__temp_v413 --->  Ty_int  
 var__temp_h'414 --->  Ty_heap  
 var__temp_v_err415 --->  error  
 var_h405 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h373, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h412, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h412, other ) ==(sel)( , var_h405, other ) => 
 	 Rel (sel)( , var__temp_h412, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h412, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'414, res ) ==(var__temp_v413) AND 
 	 Rel (sel)( , var__temp_h'414, res ) ==((sel)( , var__temp_h412, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'414, other ) ==(sel)( , var__temp_h412, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'414, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'414, other ) > (4)
 
VC_END(declare-const var_h_i406 T1530)
(declare-const var_h405 T1530)
(declare-const v Int)
(declare-const var_h_i374 T1530)
(declare-const var_h373 T1530)
(declare-const v Int)
(declare-const var_h_i144 T1530)
(declare-const var_h143 T1530)
(declare-const v Int)
(declare-const var_h_i92 T1530)
(declare-const var_h91 T1530)
(declare-const v Int)
(declare-const var_h_i44 T1530)
(declare-const var_h43 T1530)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h412 T1530)
(declare-const var__temp_v413 Int)
(declare-const |var__temp_h'414| T1530)
(declare-const var__temp_v_err415 T1531)
(declare-const var_h405 T1530)
(declare-const var_h373 T1530)
(declare-const var_h143 T1530)
(declare-const var_h91 T1530)
(declare-const var_h43 T1530)
(declare-const err T1544)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1530)
(declare-fun sel (T1530 Int) Int)
(declare-fun res () Int)
(declare-fun var_h373 () T1530)
(declare-fun var_h91 () T1530)
(declare-fun var_h43 () T1530)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'414| () T1530)
(declare-fun var__temp_h412 () T1530)
(declare-fun var__temp_v413 () Int)
(declare-fun var_h405 () T1530)
(declare-fun v () Int)
(assert (> (sel var_h373 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h412 res) v)
                    (= v |5|)
                    (= (sel var__temp_h412 other) (sel var_h405 other)))
               (= (sel var__temp_h412 res) 7)))
      (a!2 (and (= (sel |var__temp_h'414| res) var__temp_v413)
                (= (sel |var__temp_h'414| res) (+ (sel var__temp_h412 res) 5))
                (= (sel |var__temp_h'414| other) (sel var__temp_h412 other))))
      (a!3 (and (= (sel |var__temp_h'414| res) 10)
                (not (> (sel |var__temp_h'414| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h412 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************108
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i406 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i406, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i406, other ) ==(sel)( , var_h405, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v407:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i406 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i406 --->  Ty_heap  
 var_h405 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i374 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h416 --->  Ty_heap  
 var__temp_v417 --->  Ty_int  
 var__temp_h'418 --->  Ty_heap  
 var__temp_v_err419 --->  error  
 var_h405 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h373, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h416, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h416, other ) ==(sel)( , var_h405, other ) => 
 	 Rel (sel)( , var__temp_h416, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h416, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'418, res ) ==(var__temp_v417) AND 
 	 Rel (sel)( , var__temp_h'418, res ) ==((sel)( , var__temp_h416, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'418, other ) ==(sel)( , var__temp_h416, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'418, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'418, other ) > (4)
 
VC_END(declare-const var_h_i406 T1547)
(declare-const var_h405 T1547)
(declare-const v Int)
(declare-const var_h_i374 T1547)
(declare-const var_h373 T1547)
(declare-const v Int)
(declare-const var_h_i144 T1547)
(declare-const var_h143 T1547)
(declare-const v Int)
(declare-const var_h_i92 T1547)
(declare-const var_h91 T1547)
(declare-const v Int)
(declare-const var_h_i44 T1547)
(declare-const var_h43 T1547)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h416 T1547)
(declare-const var__temp_v417 Int)
(declare-const |var__temp_h'418| T1547)
(declare-const var__temp_v_err419 T1548)
(declare-const var_h405 T1547)
(declare-const var_h373 T1547)
(declare-const var_h143 T1547)
(declare-const var_h91 T1547)
(declare-const var_h43 T1547)
(declare-const err T1561)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1547)
(declare-fun sel (T1547 Int) Int)
(declare-fun res () Int)
(declare-fun var_h373 () T1547)
(declare-fun var_h91 () T1547)
(declare-fun var_h43 () T1547)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'418| () T1547)
(declare-fun var__temp_h416 () T1547)
(declare-fun var__temp_v417 () Int)
(declare-fun var_h405 () T1547)
(declare-fun v () Int)
(assert (> (sel var_h373 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h416 res) v)
                    (= v |5|)
                    (= (sel var__temp_h416 other) (sel var_h405 other)))
               (= (sel var__temp_h416 res) 5)))
      (a!2 (and (= (sel |var__temp_h'418| res) var__temp_v417)
                (= (sel |var__temp_h'418| res) (+ (sel var__temp_h416 res) 2))
                (= (sel |var__temp_h'418| other) (sel var__temp_h416 other))))
      (a!3 (and (= (sel |var__temp_h'418| res) 10)
                (not (> (sel |var__temp_h'418| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h416 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************109
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v407:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v407:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfooc2c2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --foo
 	 --c2
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i406 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i406, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i406, other ) ==(sel)( , var_h405, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v420:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************110
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i406 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i406, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i406, other ) ==(sel)( , var_h405, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v420:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i406 --->  Ty_heap  
 var_h405 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i374 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h421 --->  Ty_heap  
 var__temp_v422 --->  Ty_int  
 var__temp_h'423 --->  Ty_heap  
 var__temp_v_err424 --->  error  
 var_h405 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h373, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h421, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h421, other ) ==(sel)( , var_h405, other ) => 
 	 Rel (sel)( , var__temp_h421, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h421, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'423, res ) ==(var__temp_v422) AND 
 	 Rel (sel)( , var__temp_h'423, res ) ==((sel)( , var__temp_h421, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'423, other ) ==(sel)( , var__temp_h421, other ) => 
 	 True
 
VC_END(declare-const var_h_i406 T1564)
(declare-const var_h405 T1564)
(declare-const v Int)
(declare-const var_h_i374 T1564)
(declare-const var_h373 T1564)
(declare-const v Int)
(declare-const var_h_i144 T1564)
(declare-const var_h143 T1564)
(declare-const v Int)
(declare-const var_h_i92 T1564)
(declare-const var_h91 T1564)
(declare-const v Int)
(declare-const var_h_i44 T1564)
(declare-const var_h43 T1564)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h421 T1564)
(declare-const var__temp_v422 Int)
(declare-const |var__temp_h'423| T1564)
(declare-const var__temp_v_err424 T1565)
(declare-const var_h405 T1564)
(declare-const var_h373 T1564)
(declare-const var_h143 T1564)
(declare-const var_h91 T1564)
(declare-const var_h43 T1564)
(declare-const err T1578)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1564)
(declare-fun sel (T1564 Int) Int)
(declare-fun res () Int)
(declare-fun var_h373 () T1564)
(declare-fun var_h91 () T1564)
(declare-fun var_h43 () T1564)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h421 () T1564)
(declare-fun |var__temp_h'423| () T1564)
(declare-fun var__temp_v422 () Int)
(declare-fun var_h405 () T1564)
(declare-fun v () Int)
(assert (> (sel var_h373 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h421 res) v)
                    (= v |5|)
                    (= (sel var__temp_h421 other) (sel var_h405 other)))
               (= (sel var__temp_h421 res) 7)))
      (a!2 (and (= (sel |var__temp_h'423| res) var__temp_v422)
                (= (sel |var__temp_h'423| res) (+ (sel var__temp_h421 res) 3))
                (= (sel |var__temp_h'423| other) (sel var__temp_h421 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h421 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************111
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i406 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i406, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i406, other ) ==(sel)( , var_h405, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v420:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i406 --->  Ty_heap  
 var_h405 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i374 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h425 --->  Ty_heap  
 var__temp_v426 --->  Ty_int  
 var__temp_h'427 --->  Ty_heap  
 var__temp_v_err428 --->  error  
 var_h405 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h373, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h425, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h425, other ) ==(sel)( , var_h405, other ) => 
 	 Rel (sel)( , var__temp_h425, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h425, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'427, res ) ==(var__temp_v426) AND 
 	 Rel (sel)( , var__temp_h'427, res ) ==((sel)( , var__temp_h425, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'427, other ) ==(sel)( , var__temp_h425, other ) => 
 	 True
 
VC_END(declare-const var_h_i406 T1581)
(declare-const var_h405 T1581)
(declare-const v Int)
(declare-const var_h_i374 T1581)
(declare-const var_h373 T1581)
(declare-const v Int)
(declare-const var_h_i144 T1581)
(declare-const var_h143 T1581)
(declare-const v Int)
(declare-const var_h_i92 T1581)
(declare-const var_h91 T1581)
(declare-const v Int)
(declare-const var_h_i44 T1581)
(declare-const var_h43 T1581)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h425 T1581)
(declare-const var__temp_v426 Int)
(declare-const |var__temp_h'427| T1581)
(declare-const var__temp_v_err428 T1582)
(declare-const var_h405 T1581)
(declare-const var_h373 T1581)
(declare-const var_h143 T1581)
(declare-const var_h91 T1581)
(declare-const var_h43 T1581)
(declare-const err T1595)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1581)
(declare-fun sel (T1581 Int) Int)
(declare-fun res () Int)
(declare-fun var_h373 () T1581)
(declare-fun var_h91 () T1581)
(declare-fun var_h43 () T1581)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h425 () T1581)
(declare-fun |var__temp_h'427| () T1581)
(declare-fun var__temp_v426 () Int)
(declare-fun var_h405 () T1581)
(declare-fun v () Int)
(assert (> (sel var_h373 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h425 res) v)
                    (= v |5|)
                    (= (sel var__temp_h425 other) (sel var_h405 other)))
               (= (sel var__temp_h425 res) 7)))
      (a!2 (and (= (sel |var__temp_h'427| res) var__temp_v426)
                (= (sel |var__temp_h'427| res) (+ (sel var__temp_h425 res) 5))
                (= (sel |var__temp_h'427| other) (sel var__temp_h425 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h425 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************112
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i406 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i406, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i406, other ) ==(sel)( , var_h405, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v420:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i406 --->  Ty_heap  
 var_h405 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i374 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h429 --->  Ty_heap  
 var__temp_v430 --->  Ty_int  
 var__temp_h'431 --->  Ty_heap  
 var__temp_v_err432 --->  error  
 var_h405 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h373, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h429, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h429, other ) ==(sel)( , var_h405, other ) => 
 	 Rel (sel)( , var__temp_h429, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h429, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'431, res ) ==(var__temp_v430) AND 
 	 Rel (sel)( , var__temp_h'431, res ) ==((sel)( , var__temp_h429, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'431, other ) ==(sel)( , var__temp_h429, other ) => 
 	 True
 
VC_END(declare-const var_h_i406 T1598)
(declare-const var_h405 T1598)
(declare-const v Int)
(declare-const var_h_i374 T1598)
(declare-const var_h373 T1598)
(declare-const v Int)
(declare-const var_h_i144 T1598)
(declare-const var_h143 T1598)
(declare-const v Int)
(declare-const var_h_i92 T1598)
(declare-const var_h91 T1598)
(declare-const v Int)
(declare-const var_h_i44 T1598)
(declare-const var_h43 T1598)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h429 T1598)
(declare-const var__temp_v430 Int)
(declare-const |var__temp_h'431| T1598)
(declare-const var__temp_v_err432 T1599)
(declare-const var_h405 T1598)
(declare-const var_h373 T1598)
(declare-const var_h143 T1598)
(declare-const var_h91 T1598)
(declare-const var_h43 T1598)
(declare-const err T1612)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1598)
(declare-fun sel (T1598 Int) Int)
(declare-fun res () Int)
(declare-fun var_h373 () T1598)
(declare-fun var_h91 () T1598)
(declare-fun var_h43 () T1598)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h429 () T1598)
(declare-fun |var__temp_h'431| () T1598)
(declare-fun var__temp_v430 () Int)
(declare-fun var_h405 () T1598)
(declare-fun v () Int)
(assert (> (sel var_h373 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h429 res) v)
                    (= v |5|)
                    (= (sel var__temp_h429 other) (sel var_h405 other)))
               (= (sel var__temp_h429 res) 5)))
      (a!2 (and (= (sel |var__temp_h'431| res) var__temp_v430)
                (= (sel |var__temp_h'431| res) (+ (sel var__temp_h429 res) 2))
                (= (sel |var__temp_h'431| other) (sel var__temp_h429 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h429 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************bar
PARTIAL PATH NEW
SUB 
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c4
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i434 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i434 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i434, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i434, res ) ==((sel)( , var_h433, res ) + (2))
 	 , (sel)( , var_h_i434, other ) ==(sel)( , var_h433, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v435:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i434 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************113
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i434 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i434, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i434, res ) ==((sel)( , var_h433, res ) + (2))
 	 , (sel)( , var_h_i434, other ) ==(sel)( , var_h433, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v435:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i434 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i434 --->  Ty_heap  
 var_h433 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i406 --->  Ty_heap  
 var_h405 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i374 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h436 --->  Ty_heap  
 var__temp_v437 --->  Ty_int  
 var__temp_h'438 --->  Ty_heap  
 var__temp_v_err439 --->  error  
 var_h433 --->  Ty_heap  
 var_h405 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h433, res ) ==(5) AND 
 	 Rel (sel)( , var_h373, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h436, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h436, res ) ==((sel)( , var_h433, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h436, other ) ==(sel)( , var_h433, other ) => 
 	 Rel (sel)( , var__temp_h436, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h436, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'438, res ) ==(var__temp_v437) AND 
 	 Rel (sel)( , var__temp_h'438, res ) ==((sel)( , var__temp_h436, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'438, other ) ==(sel)( , var__temp_h436, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'438, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'438, other ) > (4)
 
VC_END(declare-const var_h_i434 T1615)
(declare-const var_h433 T1615)
(declare-const v Int)
(declare-const var_h_i406 T1615)
(declare-const var_h405 T1615)
(declare-const v Int)
(declare-const var_h_i374 T1615)
(declare-const var_h373 T1615)
(declare-const v Int)
(declare-const var_h_i144 T1615)
(declare-const var_h143 T1615)
(declare-const v Int)
(declare-const var_h_i92 T1615)
(declare-const var_h91 T1615)
(declare-const v Int)
(declare-const var_h_i44 T1615)
(declare-const var_h43 T1615)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h436 T1615)
(declare-const var__temp_v437 Int)
(declare-const |var__temp_h'438| T1615)
(declare-const var__temp_v_err439 T1616)
(declare-const var_h433 T1615)
(declare-const var_h405 T1615)
(declare-const var_h373 T1615)
(declare-const var_h143 T1615)
(declare-const var_h91 T1615)
(declare-const var_h43 T1615)
(declare-const err T1629)

solver 
 (declare-sort T1615)
(declare-fun sel (T1615 Int) Int)
(declare-fun res () Int)
(declare-fun var_h433 () T1615)
(declare-fun var_h373 () T1615)
(declare-fun var_h91 () T1615)
(declare-fun var_h43 () T1615)
(declare-fun other () Int)
(declare-fun |var__temp_h'438| () T1615)
(declare-fun var__temp_h436 () T1615)
(declare-fun var__temp_v437 () Int)
(declare-fun v () Int)
(assert (= (sel var_h433 res) 5))
(assert (> (sel var_h373 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h436 res) v)
                (= (sel var__temp_h436 res) (+ (sel var_h433 res) 2))
                (= (sel var__temp_h436 other) (sel var_h433 other))))
      (a!2 (and (= (sel |var__temp_h'438| res) var__temp_v437)
                (= (sel |var__temp_h'438| res) (+ (sel var__temp_h436 res) 3))
                (= (sel |var__temp_h'438| other) (sel var__temp_h436 other))))
      (a!3 (and (= (sel |var__temp_h'438| res) 10)
                (not (> (sel |var__temp_h'438| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h436 res) 7))
                (=> (= (sel var__temp_h436 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************114
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i434 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i434, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i434, res ) ==((sel)( , var_h433, res ) + (2))
 	 , (sel)( , var_h_i434, other ) ==(sel)( , var_h433, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v435:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i434 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i434 --->  Ty_heap  
 var_h433 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i406 --->  Ty_heap  
 var_h405 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i374 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h440 --->  Ty_heap  
 var__temp_v441 --->  Ty_int  
 var__temp_h'442 --->  Ty_heap  
 var__temp_v_err443 --->  error  
 var_h433 --->  Ty_heap  
 var_h405 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h433, res ) ==(5) AND 
 	 Rel (sel)( , var_h373, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h440, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h440, res ) ==((sel)( , var_h433, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h440, other ) ==(sel)( , var_h433, other ) => 
 	 Rel (sel)( , var__temp_h440, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h440, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'442, res ) ==(var__temp_v441) AND 
 	 Rel (sel)( , var__temp_h'442, res ) ==((sel)( , var__temp_h440, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'442, other ) ==(sel)( , var__temp_h440, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'442, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'442, other ) > (4)
 
VC_END(declare-const var_h_i434 T1632)
(declare-const var_h433 T1632)
(declare-const v Int)
(declare-const var_h_i406 T1632)
(declare-const var_h405 T1632)
(declare-const v Int)
(declare-const var_h_i374 T1632)
(declare-const var_h373 T1632)
(declare-const v Int)
(declare-const var_h_i144 T1632)
(declare-const var_h143 T1632)
(declare-const v Int)
(declare-const var_h_i92 T1632)
(declare-const var_h91 T1632)
(declare-const v Int)
(declare-const var_h_i44 T1632)
(declare-const var_h43 T1632)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h440 T1632)
(declare-const var__temp_v441 Int)
(declare-const |var__temp_h'442| T1632)
(declare-const var__temp_v_err443 T1633)
(declare-const var_h433 T1632)
(declare-const var_h405 T1632)
(declare-const var_h373 T1632)
(declare-const var_h143 T1632)
(declare-const var_h91 T1632)
(declare-const var_h43 T1632)
(declare-const err T1646)

solver 
 (declare-sort T1632)
(declare-fun sel (T1632 Int) Int)
(declare-fun res () Int)
(declare-fun var_h433 () T1632)
(declare-fun var_h373 () T1632)
(declare-fun var_h91 () T1632)
(declare-fun var_h43 () T1632)
(declare-fun other () Int)
(declare-fun |var__temp_h'442| () T1632)
(declare-fun var__temp_h440 () T1632)
(declare-fun var__temp_v441 () Int)
(declare-fun v () Int)
(assert (= (sel var_h433 res) 5))
(assert (> (sel var_h373 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h440 res) v)
                (= (sel var__temp_h440 res) (+ (sel var_h433 res) 2))
                (= (sel var__temp_h440 other) (sel var_h433 other))))
      (a!2 (and (= (sel |var__temp_h'442| res) var__temp_v441)
                (= (sel |var__temp_h'442| res) (+ (sel var__temp_h440 res) 5))
                (= (sel |var__temp_h'442| other) (sel var__temp_h440 other))))
      (a!3 (and (= (sel |var__temp_h'442| res) 10)
                (not (> (sel |var__temp_h'442| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h440 res) 7))
                (=> (= (sel var__temp_h440 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************115
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v435:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v435:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbarfooc2c2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i434 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i434, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i434, res ) ==((sel)( , var_h433, res ) + (2))
 	 , (sel)( , var_h_i434, other ) ==(sel)( , var_h433, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v444:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************116
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i434 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i434, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i434, res ) ==((sel)( , var_h433, res ) + (2))
 	 , (sel)( , var_h_i434, other ) ==(sel)( , var_h433, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v444:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i434 --->  Ty_heap  
 var_h433 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i406 --->  Ty_heap  
 var_h405 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i374 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h445 --->  Ty_heap  
 var__temp_v446 --->  Ty_int  
 var__temp_h'447 --->  Ty_heap  
 var__temp_v_err448 --->  error  
 var_h433 --->  Ty_heap  
 var_h405 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h433, res ) ==(5) AND 
 	 Rel (sel)( , var_h373, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h445, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h445, res ) ==((sel)( , var_h433, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h445, other ) ==(sel)( , var_h433, other ) => 
 	 Rel (sel)( , var__temp_h445, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h445, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'447, res ) ==(var__temp_v446) AND 
 	 Rel (sel)( , var__temp_h'447, res ) ==((sel)( , var__temp_h445, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'447, other ) ==(sel)( , var__temp_h445, other ) => 
 	 True
 
VC_END(declare-const var_h_i434 T1649)
(declare-const var_h433 T1649)
(declare-const v Int)
(declare-const var_h_i406 T1649)
(declare-const var_h405 T1649)
(declare-const v Int)
(declare-const var_h_i374 T1649)
(declare-const var_h373 T1649)
(declare-const v Int)
(declare-const var_h_i144 T1649)
(declare-const var_h143 T1649)
(declare-const v Int)
(declare-const var_h_i92 T1649)
(declare-const var_h91 T1649)
(declare-const v Int)
(declare-const var_h_i44 T1649)
(declare-const var_h43 T1649)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h445 T1649)
(declare-const var__temp_v446 Int)
(declare-const |var__temp_h'447| T1649)
(declare-const var__temp_v_err448 T1650)
(declare-const var_h433 T1649)
(declare-const var_h405 T1649)
(declare-const var_h373 T1649)
(declare-const var_h143 T1649)
(declare-const var_h91 T1649)
(declare-const var_h43 T1649)
(declare-const err T1663)

solver 
 (declare-sort T1649)
(declare-fun sel (T1649 Int) Int)
(declare-fun res () Int)
(declare-fun var_h433 () T1649)
(declare-fun var_h373 () T1649)
(declare-fun var_h91 () T1649)
(declare-fun var_h43 () T1649)
(declare-fun other () Int)
(declare-fun var__temp_h445 () T1649)
(declare-fun |var__temp_h'447| () T1649)
(declare-fun var__temp_v446 () Int)
(declare-fun v () Int)
(assert (= (sel var_h433 res) 5))
(assert (> (sel var_h373 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h445 res) v)
                (= (sel var__temp_h445 res) (+ (sel var_h433 res) 2))
                (= (sel var__temp_h445 other) (sel var_h433 other))))
      (a!2 (and (= (sel |var__temp_h'447| res) var__temp_v446)
                (= (sel |var__temp_h'447| res) (+ (sel var__temp_h445 res) 3))
                (= (sel |var__temp_h'447| other) (sel var__temp_h445 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h445 res) 7))
                (=> (= (sel var__temp_h445 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************baz
PARTIAL PATH NEW
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c4
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i450 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i450 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i450, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i450, res ) ==((sel)( , var_h449, res ) + (3))
 	 , (sel)( , var_h_i450, other ) ==(sel)( , var_h449, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v451:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i450 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************117
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i450 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i450, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i450, res ) ==((sel)( , var_h449, res ) + (3))
 	 , (sel)( , var_h_i450, other ) ==(sel)( , var_h449, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v451:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i450 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i450 --->  Ty_heap  
 var_h449 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i434 --->  Ty_heap  
 var_h433 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i406 --->  Ty_heap  
 var_h405 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i374 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h452 --->  Ty_heap  
 var__temp_v453 --->  Ty_int  
 var__temp_h'454 --->  Ty_heap  
 var__temp_v_err455 --->  error  
 var_h449 --->  Ty_heap  
 var_h433 --->  Ty_heap  
 var_h405 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h449, res ) ==(7) AND 
 	 Rel (sel)( , var_h433, res ) ==(5) AND 
 	 Rel (sel)( , var_h373, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h452, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h452, res ) ==((sel)( , var_h449, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h452, other ) ==(sel)( , var_h449, other ) => 
 	 Rel (sel)( , var__temp_h452, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h452, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'454, res ) ==(var__temp_v453) AND 
 	 Rel (sel)( , var__temp_h'454, res ) ==((sel)( , var__temp_h452, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'454, other ) ==(sel)( , var__temp_h452, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'454, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'454, other ) > (4)
 
VC_END(declare-const var_h_i450 T1666)
(declare-const var_h449 T1666)
(declare-const v Int)
(declare-const var_h_i434 T1666)
(declare-const var_h433 T1666)
(declare-const v Int)
(declare-const var_h_i406 T1666)
(declare-const var_h405 T1666)
(declare-const v Int)
(declare-const var_h_i374 T1666)
(declare-const var_h373 T1666)
(declare-const v Int)
(declare-const var_h_i144 T1666)
(declare-const var_h143 T1666)
(declare-const v Int)
(declare-const var_h_i92 T1666)
(declare-const var_h91 T1666)
(declare-const v Int)
(declare-const var_h_i44 T1666)
(declare-const var_h43 T1666)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h452 T1666)
(declare-const var__temp_v453 Int)
(declare-const |var__temp_h'454| T1666)
(declare-const var__temp_v_err455 T1667)
(declare-const var_h449 T1666)
(declare-const var_h433 T1666)
(declare-const var_h405 T1666)
(declare-const var_h373 T1666)
(declare-const var_h143 T1666)
(declare-const var_h91 T1666)
(declare-const var_h43 T1666)
(declare-const err T1680)

solver 
 (declare-sort T1666)
(declare-fun sel (T1666 Int) Int)
(declare-fun res () Int)
(declare-fun var_h449 () T1666)
(declare-fun var_h433 () T1666)
(declare-fun var_h373 () T1666)
(declare-fun var_h91 () T1666)
(declare-fun var_h43 () T1666)
(declare-fun other () Int)
(declare-fun |var__temp_h'454| () T1666)
(declare-fun var__temp_h452 () T1666)
(declare-fun var__temp_v453 () Int)
(declare-fun v () Int)
(assert (= (sel var_h449 res) 7))
(assert (= (sel var_h433 res) 5))
(assert (> (sel var_h373 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h452 res) v)
                (= (sel var__temp_h452 res) (+ (sel var_h449 res) 3))
                (= (sel var__temp_h452 other) (sel var_h449 other))))
      (a!2 (and (= (sel |var__temp_h'454| res) var__temp_v453)
                (= (sel |var__temp_h'454| res) (+ (sel var__temp_h452 res) 5))
                (= (sel |var__temp_h'454| other) (sel var__temp_h452 other))))
      (a!3 (and (= (sel |var__temp_h'454| res) 10)
                (not (> (sel |var__temp_h'454| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h452 res) 7))
                (=> (= (sel var__temp_h452 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************118
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v451:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v451:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbazbarfooc2c2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i450 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i450, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i450, res ) ==((sel)( , var_h449, res ) + (3))
 	 , (sel)( , var_h_i450, other ) ==(sel)( , var_h449, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v456:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************119
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i450 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i450, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i450, res ) ==((sel)( , var_h449, res ) + (3))
 	 , (sel)( , var_h_i450, other ) ==(sel)( , var_h449, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v456:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i450 --->  Ty_heap  
 var_h449 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i434 --->  Ty_heap  
 var_h433 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i406 --->  Ty_heap  
 var_h405 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i374 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h457 --->  Ty_heap  
 var__temp_v458 --->  Ty_int  
 var__temp_h'459 --->  Ty_heap  
 var__temp_v_err460 --->  error  
 var_h449 --->  Ty_heap  
 var_h433 --->  Ty_heap  
 var_h405 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h449, res ) ==(7) AND 
 	 Rel (sel)( , var_h433, res ) ==(5) AND 
 	 Rel (sel)( , var_h373, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h457, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h457, res ) ==((sel)( , var_h449, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h457, other ) ==(sel)( , var_h449, other ) => 
 	 Rel (sel)( , var__temp_h457, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h457, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'459, res ) ==(var__temp_v458) AND 
 	 Rel (sel)( , var__temp_h'459, res ) ==((sel)( , var__temp_h457, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'459, other ) ==(sel)( , var__temp_h457, other ) => 
 	 True
 
VC_END(declare-const var_h_i450 T1683)
(declare-const var_h449 T1683)
(declare-const v Int)
(declare-const var_h_i434 T1683)
(declare-const var_h433 T1683)
(declare-const v Int)
(declare-const var_h_i406 T1683)
(declare-const var_h405 T1683)
(declare-const v Int)
(declare-const var_h_i374 T1683)
(declare-const var_h373 T1683)
(declare-const v Int)
(declare-const var_h_i144 T1683)
(declare-const var_h143 T1683)
(declare-const v Int)
(declare-const var_h_i92 T1683)
(declare-const var_h91 T1683)
(declare-const v Int)
(declare-const var_h_i44 T1683)
(declare-const var_h43 T1683)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h457 T1683)
(declare-const var__temp_v458 Int)
(declare-const |var__temp_h'459| T1683)
(declare-const var__temp_v_err460 T1684)
(declare-const var_h449 T1683)
(declare-const var_h433 T1683)
(declare-const var_h405 T1683)
(declare-const var_h373 T1683)
(declare-const var_h143 T1683)
(declare-const var_h91 T1683)
(declare-const var_h43 T1683)
(declare-const err T1697)

solver 
 (declare-sort T1683)
(declare-fun sel (T1683 Int) Int)
(declare-fun res () Int)
(declare-fun var_h449 () T1683)
(declare-fun var_h433 () T1683)
(declare-fun var_h373 () T1683)
(declare-fun var_h91 () T1683)
(declare-fun var_h43 () T1683)
(declare-fun other () Int)
(declare-fun var__temp_h457 () T1683)
(declare-fun |var__temp_h'459| () T1683)
(declare-fun var__temp_v458 () Int)
(declare-fun v () Int)
(assert (= (sel var_h449 res) 7))
(assert (= (sel var_h433 res) 5))
(assert (> (sel var_h373 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h457 res) v)
                (= (sel var__temp_h457 res) (+ (sel var_h449 res) 3))
                (= (sel var__temp_h457 other) (sel var_h449 other))))
      (a!2 (and (= (sel |var__temp_h'459| res) var__temp_v458)
                (= (sel |var__temp_h'459| res) (+ (sel var__temp_h457 res) 5))
                (= (sel |var__temp_h'459| other) (sel var__temp_h457 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h457 res) 7))
                (=> (= (sel var__temp_h457 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************120
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT baz
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i434 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i434, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i434, res ) ==((sel)( , var_h433, res ) + (2))
 	 , (sel)( , var_h_i434, other ) ==(sel)( , var_h433, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v461:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************121
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i434 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i434, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i434, res ) ==((sel)( , var_h433, res ) + (2))
 	 , (sel)( , var_h_i434, other ) ==(sel)( , var_h433, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v461:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i434 --->  Ty_heap  
 var_h433 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i406 --->  Ty_heap  
 var_h405 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i374 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h462 --->  Ty_heap  
 var__temp_v463 --->  Ty_int  
 var__temp_h'464 --->  Ty_heap  
 var__temp_v_err465 --->  error  
 var_h433 --->  Ty_heap  
 var_h405 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h433, res ) ==(5) AND 
 	 Rel (sel)( , var_h373, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h462, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h462, res ) ==((sel)( , var_h433, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h462, other ) ==(sel)( , var_h433, other ) => 
 	 Rel (sel)( , var__temp_h462, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h462, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'464, res ) ==(var__temp_v463) AND 
 	 Rel (sel)( , var__temp_h'464, res ) ==((sel)( , var__temp_h462, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'464, other ) ==(sel)( , var__temp_h462, other ) => 
 	 True
 
VC_END(declare-const var_h_i434 T1700)
(declare-const var_h433 T1700)
(declare-const v Int)
(declare-const var_h_i406 T1700)
(declare-const var_h405 T1700)
(declare-const v Int)
(declare-const var_h_i374 T1700)
(declare-const var_h373 T1700)
(declare-const v Int)
(declare-const var_h_i144 T1700)
(declare-const var_h143 T1700)
(declare-const v Int)
(declare-const var_h_i92 T1700)
(declare-const var_h91 T1700)
(declare-const v Int)
(declare-const var_h_i44 T1700)
(declare-const var_h43 T1700)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h462 T1700)
(declare-const var__temp_v463 Int)
(declare-const |var__temp_h'464| T1700)
(declare-const var__temp_v_err465 T1701)
(declare-const var_h433 T1700)
(declare-const var_h405 T1700)
(declare-const var_h373 T1700)
(declare-const var_h143 T1700)
(declare-const var_h91 T1700)
(declare-const var_h43 T1700)
(declare-const err T1714)

solver 
 (declare-sort T1700)
(declare-fun sel (T1700 Int) Int)
(declare-fun res () Int)
(declare-fun var_h433 () T1700)
(declare-fun var_h373 () T1700)
(declare-fun var_h91 () T1700)
(declare-fun var_h43 () T1700)
(declare-fun other () Int)
(declare-fun var__temp_h462 () T1700)
(declare-fun |var__temp_h'464| () T1700)
(declare-fun var__temp_v463 () Int)
(declare-fun v () Int)
(assert (= (sel var_h433 res) 5))
(assert (> (sel var_h373 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h462 res) v)
                (= (sel var__temp_h462 res) (+ (sel var_h433 res) 2))
                (= (sel var__temp_h462 other) (sel var_h433 other))))
      (a!2 (and (= (sel |var__temp_h'464| res) var__temp_v463)
                (= (sel |var__temp_h'464| res) (+ (sel var__temp_h462 res) 5))
                (= (sel |var__temp_h'464| other) (sel var__temp_h462 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h462 res) 7))
                (=> (= (sel var__temp_h462 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c5
PARTIAL PATH NEW
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c4
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i467 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i467 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i467, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i467, res ) ==((sel)( , var_h466, res ) + (5))
 	 , (sel)( , var_h_i467, other ) ==(sel)( , var_h466, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v468:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i467 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************122
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v468:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v468:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc5bazbarfooc2c2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i467 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i467, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i467, res ) ==((sel)( , var_h466, res ) + (5))
 	 , (sel)( , var_h_i467, other ) ==(sel)( , var_h466, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v469:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************123
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i434 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i434, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i434, res ) ==((sel)( , var_h433, res ) + (2))
 	 , (sel)( , var_h_i434, other ) ==(sel)( , var_h433, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v470:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************124
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --foo
 	 --c2
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i406 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i406, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i406, other ) ==(sel)( , var_h405, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v471:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************125
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i406 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i406, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i406, other ) ==(sel)( , var_h405, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v471:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i406 --->  Ty_heap  
 var_h405 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i374 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h472 --->  Ty_heap  
 var__temp_v473 --->  Ty_int  
 var__temp_h'474 --->  Ty_heap  
 var__temp_v_err475 --->  error  
 var_h405 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h373, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h472, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h472, other ) ==(sel)( , var_h405, other ) => 
 	 Rel (sel)( , var__temp_h472, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h472, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'474, res ) ==(var__temp_v473) AND 
 	 Rel (sel)( , var__temp_h'474, res ) ==((sel)( , var__temp_h472, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'474, other ) ==(sel)( , var__temp_h472, other ) => 
 	 True
 
VC_END(declare-const var_h_i406 T1717)
(declare-const var_h405 T1717)
(declare-const v Int)
(declare-const var_h_i374 T1717)
(declare-const var_h373 T1717)
(declare-const v Int)
(declare-const var_h_i144 T1717)
(declare-const var_h143 T1717)
(declare-const v Int)
(declare-const var_h_i92 T1717)
(declare-const var_h91 T1717)
(declare-const v Int)
(declare-const var_h_i44 T1717)
(declare-const var_h43 T1717)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h472 T1717)
(declare-const var__temp_v473 Int)
(declare-const |var__temp_h'474| T1717)
(declare-const var__temp_v_err475 T1718)
(declare-const var_h405 T1717)
(declare-const var_h373 T1717)
(declare-const var_h143 T1717)
(declare-const var_h91 T1717)
(declare-const var_h43 T1717)
(declare-const err T1731)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1717)
(declare-fun sel (T1717 Int) Int)
(declare-fun res () Int)
(declare-fun var_h373 () T1717)
(declare-fun var_h91 () T1717)
(declare-fun var_h43 () T1717)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h472 () T1717)
(declare-fun |var__temp_h'474| () T1717)
(declare-fun var__temp_v473 () Int)
(declare-fun var_h405 () T1717)
(declare-fun v () Int)
(assert (> (sel var_h373 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h472 res) v)
                    (= v |5|)
                    (= (sel var__temp_h472 other) (sel var_h405 other)))
               (= (sel var__temp_h472 res) 7)))
      (a!2 (and (= (sel |var__temp_h'474| res) var__temp_v473)
                (= (sel |var__temp_h'474| res) (+ (sel var__temp_h472 res) 3))
                (= (sel |var__temp_h'474| other) (sel var__temp_h472 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h472 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************126
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i406 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i406, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i406, other ) ==(sel)( , var_h405, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v471:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i406 --->  Ty_heap  
 var_h405 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i374 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h476 --->  Ty_heap  
 var__temp_v477 --->  Ty_int  
 var__temp_h'478 --->  Ty_heap  
 var__temp_v_err479 --->  error  
 var_h405 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h373, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h476, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h476, other ) ==(sel)( , var_h405, other ) => 
 	 Rel (sel)( , var__temp_h476, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h476, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'478, res ) ==(var__temp_v477) AND 
 	 Rel (sel)( , var__temp_h'478, res ) ==((sel)( , var__temp_h476, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'478, other ) ==(sel)( , var__temp_h476, other ) => 
 	 True
 
VC_END(declare-const var_h_i406 T1734)
(declare-const var_h405 T1734)
(declare-const v Int)
(declare-const var_h_i374 T1734)
(declare-const var_h373 T1734)
(declare-const v Int)
(declare-const var_h_i144 T1734)
(declare-const var_h143 T1734)
(declare-const v Int)
(declare-const var_h_i92 T1734)
(declare-const var_h91 T1734)
(declare-const v Int)
(declare-const var_h_i44 T1734)
(declare-const var_h43 T1734)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h476 T1734)
(declare-const var__temp_v477 Int)
(declare-const |var__temp_h'478| T1734)
(declare-const var__temp_v_err479 T1735)
(declare-const var_h405 T1734)
(declare-const var_h373 T1734)
(declare-const var_h143 T1734)
(declare-const var_h91 T1734)
(declare-const var_h43 T1734)
(declare-const err T1748)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1734)
(declare-fun sel (T1734 Int) Int)
(declare-fun res () Int)
(declare-fun var_h373 () T1734)
(declare-fun var_h91 () T1734)
(declare-fun var_h43 () T1734)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h476 () T1734)
(declare-fun |var__temp_h'478| () T1734)
(declare-fun var__temp_v477 () Int)
(declare-fun var_h405 () T1734)
(declare-fun v () Int)
(assert (> (sel var_h373 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h476 res) v)
                    (= v |5|)
                    (= (sel var__temp_h476 other) (sel var_h405 other)))
               (= (sel var__temp_h476 res) 7)))
      (a!2 (and (= (sel |var__temp_h'478| res) var__temp_v477)
                (= (sel |var__temp_h'478| res) (+ (sel var__temp_h476 res) 5))
                (= (sel |var__temp_h'478| other) (sel var__temp_h476 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h476 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************127
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT bar
PARTIAL PATH
SUB 
 	 --c2
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i374 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i374, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i374, res ) ==((sel)( , var_h373, res ) + (10))
 	 , (sel)( , var_h_i374, other ) ==(sel)( , var_h373, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v480:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************128
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i374 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i374, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i374, res ) ==((sel)( , var_h373, res ) + (10))
 	 , (sel)( , var_h_i374, other ) ==(sel)( , var_h373, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v480:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i374 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h481 --->  Ty_heap  
 var__temp_v482 --->  Ty_int  
 var__temp_h'483 --->  Ty_heap  
 var__temp_v_err484 --->  error  
 var_h373 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h373, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h481, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h481, res ) ==((sel)( , var_h373, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h481, other ) ==(sel)( , var_h373, other ) => 
 	 Rel (sel)( , var__temp_h481, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h481, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'483, res ) ==(var__temp_v482) AND 
 	 Rel (sel)( , var__temp_h'483, res ) ==((sel)( , var__temp_h481, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'483, other ) ==(sel)( , var__temp_h481, other ) => 
 	 True
 
VC_END(declare-const var_h_i374 T1751)
(declare-const var_h373 T1751)
(declare-const v Int)
(declare-const var_h_i144 T1751)
(declare-const var_h143 T1751)
(declare-const v Int)
(declare-const var_h_i92 T1751)
(declare-const var_h91 T1751)
(declare-const v Int)
(declare-const var_h_i44 T1751)
(declare-const var_h43 T1751)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h481 T1751)
(declare-const var__temp_v482 Int)
(declare-const |var__temp_h'483| T1751)
(declare-const var__temp_v_err484 T1752)
(declare-const var_h373 T1751)
(declare-const var_h143 T1751)
(declare-const var_h91 T1751)
(declare-const var_h43 T1751)
(declare-const err T1765)

solver 
 (declare-sort T1751)
(declare-fun sel (T1751 Int) Int)
(declare-fun res () Int)
(declare-fun var_h373 () T1751)
(declare-fun var_h91 () T1751)
(declare-fun var_h43 () T1751)
(declare-fun other () Int)
(declare-fun var__temp_h481 () T1751)
(declare-fun |var__temp_h'483| () T1751)
(declare-fun var__temp_v482 () Int)
(declare-fun v () Int)
(assert (> (sel var_h373 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h481 res) v)
                (= (sel var__temp_h481 res) (+ (sel var_h373 res) 10))
                (= (sel var__temp_h481 other) (sel var_h373 other))))
      (a!2 (and (= (sel |var__temp_h'483| res) var__temp_v482)
                (= (sel |var__temp_h'483| res) (+ (sel var__temp_h481 res) 3))
                (= (sel |var__temp_h'483| other) (sel var__temp_h481 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h481 res) 7))
                (=> (= (sel var__temp_h481 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************129
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i374 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i374, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i374, res ) ==((sel)( , var_h373, res ) + (10))
 	 , (sel)( , var_h_i374, other ) ==(sel)( , var_h373, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v480:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i374 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h485 --->  Ty_heap  
 var__temp_v486 --->  Ty_int  
 var__temp_h'487 --->  Ty_heap  
 var__temp_v_err488 --->  error  
 var_h373 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h373, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h485, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h485, res ) ==((sel)( , var_h373, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h485, other ) ==(sel)( , var_h373, other ) => 
 	 Rel (sel)( , var__temp_h485, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h485, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'487, res ) ==(var__temp_v486) AND 
 	 Rel (sel)( , var__temp_h'487, res ) ==((sel)( , var__temp_h485, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'487, other ) ==(sel)( , var__temp_h485, other ) => 
 	 True
 
VC_END(declare-const var_h_i374 T1768)
(declare-const var_h373 T1768)
(declare-const v Int)
(declare-const var_h_i144 T1768)
(declare-const var_h143 T1768)
(declare-const v Int)
(declare-const var_h_i92 T1768)
(declare-const var_h91 T1768)
(declare-const v Int)
(declare-const var_h_i44 T1768)
(declare-const var_h43 T1768)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h485 T1768)
(declare-const var__temp_v486 Int)
(declare-const |var__temp_h'487| T1768)
(declare-const var__temp_v_err488 T1769)
(declare-const var_h373 T1768)
(declare-const var_h143 T1768)
(declare-const var_h91 T1768)
(declare-const var_h43 T1768)
(declare-const err T1782)

solver 
 (declare-sort T1768)
(declare-fun sel (T1768 Int) Int)
(declare-fun res () Int)
(declare-fun var_h373 () T1768)
(declare-fun var_h91 () T1768)
(declare-fun var_h43 () T1768)
(declare-fun other () Int)
(declare-fun var__temp_h485 () T1768)
(declare-fun |var__temp_h'487| () T1768)
(declare-fun var__temp_v486 () Int)
(declare-fun v () Int)
(assert (> (sel var_h373 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h485 res) v)
                (= (sel var__temp_h485 res) (+ (sel var_h373 res) 10))
                (= (sel var__temp_h485 other) (sel var_h373 other))))
      (a!2 (and (= (sel |var__temp_h'487| res) var__temp_v486)
                (= (sel |var__temp_h'487| res) (+ (sel var__temp_h485 res) 5))
                (= (sel |var__temp_h'487| other) (sel var__temp_h485 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h485 res) 7))
                (=> (= (sel var__temp_h485 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************130
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i374 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i374, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i374, res ) ==((sel)( , var_h373, res ) + (10))
 	 , (sel)( , var_h_i374, other ) ==(sel)( , var_h373, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v480:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i374 --->  Ty_heap  
 var_h373 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h489 --->  Ty_heap  
 var__temp_v490 --->  Ty_int  
 var__temp_h'491 --->  Ty_heap  
 var__temp_v_err492 --->  error  
 var_h373 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h373, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h489, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h489, res ) ==((sel)( , var_h373, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h489, other ) ==(sel)( , var_h373, other ) => 
 	 Rel (sel)( , var__temp_h489, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h489, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'491, res ) ==(var__temp_v490) AND 
 	 Rel (sel)( , var__temp_h'491, res ) ==((sel)( , var__temp_h489, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'491, other ) ==(sel)( , var__temp_h489, other ) => 
 	 True
 
VC_END(declare-const var_h_i374 T1785)
(declare-const var_h373 T1785)
(declare-const v Int)
(declare-const var_h_i144 T1785)
(declare-const var_h143 T1785)
(declare-const v Int)
(declare-const var_h_i92 T1785)
(declare-const var_h91 T1785)
(declare-const v Int)
(declare-const var_h_i44 T1785)
(declare-const var_h43 T1785)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h489 T1785)
(declare-const var__temp_v490 Int)
(declare-const |var__temp_h'491| T1785)
(declare-const var__temp_v_err492 T1786)
(declare-const var_h373 T1785)
(declare-const var_h143 T1785)
(declare-const var_h91 T1785)
(declare-const var_h43 T1785)
(declare-const err T1799)

solver 
 (declare-sort T1785)
(declare-fun sel (T1785 Int) Int)
(declare-fun res () Int)
(declare-fun var_h373 () T1785)
(declare-fun var_h91 () T1785)
(declare-fun var_h43 () T1785)
(declare-fun other () Int)
(declare-fun var__temp_h489 () T1785)
(declare-fun |var__temp_h'491| () T1785)
(declare-fun var__temp_v490 () Int)
(declare-fun v () Int)
(assert (> (sel var_h373 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h489 res) v)
                (= (sel var__temp_h489 res) (+ (sel var_h373 res) 10))
                (= (sel var__temp_h489 other) (sel var_h373 other))))
      (a!2 (and (= (sel |var__temp_h'491| res) var__temp_v490)
                (= (sel |var__temp_h'491| res) (+ (sel var__temp_h489 res) 2))
                (= (sel |var__temp_h'491| other) (sel var__temp_h489 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h489 res) 5))
                (=> (= (sel var__temp_h489 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************131
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo
PARTIAL PATH
SUB 
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i144 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i144, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i144, other ) ==(sel)( , var_h143, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v493:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************132
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i144 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i144, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i144, other ) ==(sel)( , var_h143, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v493:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h494 --->  Ty_heap  
 var__temp_v495 --->  Ty_int  
 var__temp_h'496 --->  Ty_heap  
 var__temp_v_err497 --->  error  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h494, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h494, other ) ==(sel)( , var_h143, other ) => 
 	 Rel (sel)( , var__temp_h494, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h494, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'496, res ) ==(var__temp_v495) AND 
 	 Rel (sel)( , var__temp_h'496, res ) ==((sel)( , var__temp_h494, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'496, other ) ==(sel)( , var__temp_h494, other ) => 
 	 True
 
VC_END(declare-const var_h_i144 T1802)
(declare-const var_h143 T1802)
(declare-const v Int)
(declare-const var_h_i92 T1802)
(declare-const var_h91 T1802)
(declare-const v Int)
(declare-const var_h_i44 T1802)
(declare-const var_h43 T1802)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h494 T1802)
(declare-const var__temp_v495 Int)
(declare-const |var__temp_h'496| T1802)
(declare-const var__temp_v_err497 T1803)
(declare-const var_h143 T1802)
(declare-const var_h91 T1802)
(declare-const var_h43 T1802)
(declare-const err T1816)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1802)
(declare-fun sel (T1802 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T1802)
(declare-fun var_h43 () T1802)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h494 () T1802)
(declare-fun |var__temp_h'496| () T1802)
(declare-fun var__temp_v495 () Int)
(declare-fun var_h143 () T1802)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h494 res) v)
                    (= v |20|)
                    (= (sel var__temp_h494 other) (sel var_h143 other)))
               (= (sel var__temp_h494 res) 7)))
      (a!2 (and (= (sel |var__temp_h'496| res) var__temp_v495)
                (= (sel |var__temp_h'496| res) (+ (sel var__temp_h494 res) 3))
                (= (sel |var__temp_h'496| other) (sel var__temp_h494 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h494 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************133
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i144 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i144, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i144, other ) ==(sel)( , var_h143, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v493:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h498 --->  Ty_heap  
 var__temp_v499 --->  Ty_int  
 var__temp_h'500 --->  Ty_heap  
 var__temp_v_err501 --->  error  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h498, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h498, other ) ==(sel)( , var_h143, other ) => 
 	 Rel (sel)( , var__temp_h498, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h498, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'500, res ) ==(var__temp_v499) AND 
 	 Rel (sel)( , var__temp_h'500, res ) ==((sel)( , var__temp_h498, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'500, other ) ==(sel)( , var__temp_h498, other ) => 
 	 True
 
VC_END(declare-const var_h_i144 T1819)
(declare-const var_h143 T1819)
(declare-const v Int)
(declare-const var_h_i92 T1819)
(declare-const var_h91 T1819)
(declare-const v Int)
(declare-const var_h_i44 T1819)
(declare-const var_h43 T1819)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h498 T1819)
(declare-const var__temp_v499 Int)
(declare-const |var__temp_h'500| T1819)
(declare-const var__temp_v_err501 T1820)
(declare-const var_h143 T1819)
(declare-const var_h91 T1819)
(declare-const var_h43 T1819)
(declare-const err T1833)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1819)
(declare-fun sel (T1819 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T1819)
(declare-fun var_h43 () T1819)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h498 () T1819)
(declare-fun |var__temp_h'500| () T1819)
(declare-fun var__temp_v499 () Int)
(declare-fun var_h143 () T1819)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h498 res) v)
                    (= v |20|)
                    (= (sel var__temp_h498 other) (sel var_h143 other)))
               (= (sel var__temp_h498 res) 7)))
      (a!2 (and (= (sel |var__temp_h'500| res) var__temp_v499)
                (= (sel |var__temp_h'500| res) (+ (sel var__temp_h498 res) 5))
                (= (sel |var__temp_h'500| other) (sel var__temp_h498 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h498 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************134
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i144 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i144, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i144, other ) ==(sel)( , var_h143, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v493:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h502 --->  Ty_heap  
 var__temp_v503 --->  Ty_int  
 var__temp_h'504 --->  Ty_heap  
 var__temp_v_err505 --->  error  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h502, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h502, other ) ==(sel)( , var_h143, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'504, res ) ==(var__temp_v503) AND 
 	 Base var__temp_v503 = 5 AND 
 	 Rel (sel)( , var__temp_h'504, other ) ==(sel)( , var__temp_h502, other ) => 
 	 True
 
VC_END(declare-const var_h_i144 T1836)
(declare-const var_h143 T1836)
(declare-const v Int)
(declare-const var_h_i92 T1836)
(declare-const var_h91 T1836)
(declare-const v Int)
(declare-const var_h_i44 T1836)
(declare-const var_h43 T1836)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h502 T1836)
(declare-const var__temp_v503 Int)
(declare-const |var__temp_h'504| T1836)
(declare-const var__temp_v_err505 T1837)
(declare-const var_h143 T1836)
(declare-const var_h91 T1836)
(declare-const var_h43 T1836)
(declare-const err T1850)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T1836)
(declare-fun sel (T1836 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T1836)
(declare-fun var_h43 () T1836)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h502 () T1836)
(declare-fun |var__temp_h'504| () T1836)
(declare-fun var__temp_v503 () Int)
(declare-fun var_h143 () T1836)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h502 res) v)
                    (= v |20|)
                    (= (sel var__temp_h502 other) (sel var_h143 other)))
               true))
      (a!2 (=> (and (= (sel |var__temp_h'504| res) var__temp_v503)
                    (= var__temp_v503 |5|)
                    (= (sel |var__temp_h'504| other) (sel var__temp_h502 other)))
               true)))
  (not (and a!1 (=> true a!2)))))

***************Selection Successful************foo
PARTIAL PATH NEW
SUB 
 	 --foo
 	 --foo'
 	 --c4
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i507 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i507 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i507, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i507, other ) ==(sel)( , var_h506, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v508:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i507 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************135
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i507 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i507, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i507, other ) ==(sel)( , var_h506, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v508:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i507 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i507 --->  Ty_heap  
 var_h506 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h509 --->  Ty_heap  
 var__temp_v510 --->  Ty_int  
 var__temp_h'511 --->  Ty_heap  
 var__temp_v_err512 --->  error  
 var_h506 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h509, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h509, other ) ==(sel)( , var_h506, other ) => 
 	 Rel (sel)( , var__temp_h509, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h509, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'511, res ) ==(var__temp_v510) AND 
 	 Rel (sel)( , var__temp_h'511, res ) ==((sel)( , var__temp_h509, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'511, other ) ==(sel)( , var__temp_h509, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'511, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'511, other ) > (4)
 
VC_END(declare-const var_h_i507 T1853)
(declare-const var_h506 T1853)
(declare-const v Int)
(declare-const var_h_i144 T1853)
(declare-const var_h143 T1853)
(declare-const v Int)
(declare-const var_h_i92 T1853)
(declare-const var_h91 T1853)
(declare-const v Int)
(declare-const var_h_i44 T1853)
(declare-const var_h43 T1853)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h509 T1853)
(declare-const var__temp_v510 Int)
(declare-const |var__temp_h'511| T1853)
(declare-const var__temp_v_err512 T1854)
(declare-const var_h506 T1853)
(declare-const var_h143 T1853)
(declare-const var_h91 T1853)
(declare-const var_h43 T1853)
(declare-const err T1867)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1853)
(declare-fun sel (T1853 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T1853)
(declare-fun var_h43 () T1853)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'511| () T1853)
(declare-fun var__temp_h509 () T1853)
(declare-fun var__temp_v510 () Int)
(declare-fun var_h506 () T1853)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h509 res) v)
                    (= v |5|)
                    (= (sel var__temp_h509 other) (sel var_h506 other)))
               (= (sel var__temp_h509 res) 7)))
      (a!2 (and (= (sel |var__temp_h'511| res) var__temp_v510)
                (= (sel |var__temp_h'511| res) (+ (sel var__temp_h509 res) 3))
                (= (sel |var__temp_h'511| other) (sel var__temp_h509 other))))
      (a!3 (and (= (sel |var__temp_h'511| res) 10)
                (not (> (sel |var__temp_h'511| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h509 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************136
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i507 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i507, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i507, other ) ==(sel)( , var_h506, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v508:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i507 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i507 --->  Ty_heap  
 var_h506 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h513 --->  Ty_heap  
 var__temp_v514 --->  Ty_int  
 var__temp_h'515 --->  Ty_heap  
 var__temp_v_err516 --->  error  
 var_h506 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h513, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h513, other ) ==(sel)( , var_h506, other ) => 
 	 Rel (sel)( , var__temp_h513, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h513, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'515, res ) ==(var__temp_v514) AND 
 	 Rel (sel)( , var__temp_h'515, res ) ==((sel)( , var__temp_h513, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'515, other ) ==(sel)( , var__temp_h513, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'515, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'515, other ) > (4)
 
VC_END(declare-const var_h_i507 T1870)
(declare-const var_h506 T1870)
(declare-const v Int)
(declare-const var_h_i144 T1870)
(declare-const var_h143 T1870)
(declare-const v Int)
(declare-const var_h_i92 T1870)
(declare-const var_h91 T1870)
(declare-const v Int)
(declare-const var_h_i44 T1870)
(declare-const var_h43 T1870)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h513 T1870)
(declare-const var__temp_v514 Int)
(declare-const |var__temp_h'515| T1870)
(declare-const var__temp_v_err516 T1871)
(declare-const var_h506 T1870)
(declare-const var_h143 T1870)
(declare-const var_h91 T1870)
(declare-const var_h43 T1870)
(declare-const err T1884)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1870)
(declare-fun sel (T1870 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T1870)
(declare-fun var_h43 () T1870)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'515| () T1870)
(declare-fun var__temp_h513 () T1870)
(declare-fun var__temp_v514 () Int)
(declare-fun var_h506 () T1870)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h513 res) v)
                    (= v |5|)
                    (= (sel var__temp_h513 other) (sel var_h506 other)))
               (= (sel var__temp_h513 res) 7)))
      (a!2 (and (= (sel |var__temp_h'515| res) var__temp_v514)
                (= (sel |var__temp_h'515| res) (+ (sel var__temp_h513 res) 5))
                (= (sel |var__temp_h'515| other) (sel var__temp_h513 other))))
      (a!3 (and (= (sel |var__temp_h'515| res) 10)
                (not (> (sel |var__temp_h'515| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h513 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************137
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i507 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i507, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i507, other ) ==(sel)( , var_h506, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v508:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i507 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i507 --->  Ty_heap  
 var_h506 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h517 --->  Ty_heap  
 var__temp_v518 --->  Ty_int  
 var__temp_h'519 --->  Ty_heap  
 var__temp_v_err520 --->  error  
 var_h506 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h517, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h517, other ) ==(sel)( , var_h506, other ) => 
 	 Rel (sel)( , var__temp_h517, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h517, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'519, res ) ==(var__temp_v518) AND 
 	 Rel (sel)( , var__temp_h'519, res ) ==((sel)( , var__temp_h517, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'519, other ) ==(sel)( , var__temp_h517, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'519, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'519, other ) > (4)
 
VC_END(declare-const var_h_i507 T1887)
(declare-const var_h506 T1887)
(declare-const v Int)
(declare-const var_h_i144 T1887)
(declare-const var_h143 T1887)
(declare-const v Int)
(declare-const var_h_i92 T1887)
(declare-const var_h91 T1887)
(declare-const v Int)
(declare-const var_h_i44 T1887)
(declare-const var_h43 T1887)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h517 T1887)
(declare-const var__temp_v518 Int)
(declare-const |var__temp_h'519| T1887)
(declare-const var__temp_v_err520 T1888)
(declare-const var_h506 T1887)
(declare-const var_h143 T1887)
(declare-const var_h91 T1887)
(declare-const var_h43 T1887)
(declare-const err T1901)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1887)
(declare-fun sel (T1887 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T1887)
(declare-fun var_h43 () T1887)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'519| () T1887)
(declare-fun var__temp_h517 () T1887)
(declare-fun var__temp_v518 () Int)
(declare-fun var_h506 () T1887)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h517 res) v)
                    (= v |5|)
                    (= (sel var__temp_h517 other) (sel var_h506 other)))
               (= (sel var__temp_h517 res) 5)))
      (a!2 (and (= (sel |var__temp_h'519| res) var__temp_v518)
                (= (sel |var__temp_h'519| res) (+ (sel var__temp_h517 res) 2))
                (= (sel |var__temp_h'519| other) (sel var__temp_h517 other))))
      (a!3 (and (= (sel |var__temp_h'519| res) 10)
                (not (> (sel |var__temp_h'519| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h517 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************138
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v508:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v508:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfooc2c2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --foo
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i507 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i507, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i507, other ) ==(sel)( , var_h506, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v521:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************139
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i507 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i507, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i507, other ) ==(sel)( , var_h506, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v521:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i507 --->  Ty_heap  
 var_h506 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h522 --->  Ty_heap  
 var__temp_v523 --->  Ty_int  
 var__temp_h'524 --->  Ty_heap  
 var__temp_v_err525 --->  error  
 var_h506 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h522, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h522, other ) ==(sel)( , var_h506, other ) => 
 	 Rel (sel)( , var__temp_h522, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h522, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'524, res ) ==(var__temp_v523) AND 
 	 Rel (sel)( , var__temp_h'524, res ) ==((sel)( , var__temp_h522, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'524, other ) ==(sel)( , var__temp_h522, other ) => 
 	 True
 
VC_END(declare-const var_h_i507 T1904)
(declare-const var_h506 T1904)
(declare-const v Int)
(declare-const var_h_i144 T1904)
(declare-const var_h143 T1904)
(declare-const v Int)
(declare-const var_h_i92 T1904)
(declare-const var_h91 T1904)
(declare-const v Int)
(declare-const var_h_i44 T1904)
(declare-const var_h43 T1904)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h522 T1904)
(declare-const var__temp_v523 Int)
(declare-const |var__temp_h'524| T1904)
(declare-const var__temp_v_err525 T1905)
(declare-const var_h506 T1904)
(declare-const var_h143 T1904)
(declare-const var_h91 T1904)
(declare-const var_h43 T1904)
(declare-const err T1918)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1904)
(declare-fun sel (T1904 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T1904)
(declare-fun var_h43 () T1904)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h522 () T1904)
(declare-fun |var__temp_h'524| () T1904)
(declare-fun var__temp_v523 () Int)
(declare-fun var_h506 () T1904)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h522 res) v)
                    (= v |5|)
                    (= (sel var__temp_h522 other) (sel var_h506 other)))
               (= (sel var__temp_h522 res) 7)))
      (a!2 (and (= (sel |var__temp_h'524| res) var__temp_v523)
                (= (sel |var__temp_h'524| res) (+ (sel var__temp_h522 res) 3))
                (= (sel |var__temp_h'524| other) (sel var__temp_h522 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h522 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************140
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i507 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i507, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i507, other ) ==(sel)( , var_h506, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v521:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i507 --->  Ty_heap  
 var_h506 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h526 --->  Ty_heap  
 var__temp_v527 --->  Ty_int  
 var__temp_h'528 --->  Ty_heap  
 var__temp_v_err529 --->  error  
 var_h506 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h526, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h526, other ) ==(sel)( , var_h506, other ) => 
 	 Rel (sel)( , var__temp_h526, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h526, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'528, res ) ==(var__temp_v527) AND 
 	 Rel (sel)( , var__temp_h'528, res ) ==((sel)( , var__temp_h526, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'528, other ) ==(sel)( , var__temp_h526, other ) => 
 	 True
 
VC_END(declare-const var_h_i507 T1921)
(declare-const var_h506 T1921)
(declare-const v Int)
(declare-const var_h_i144 T1921)
(declare-const var_h143 T1921)
(declare-const v Int)
(declare-const var_h_i92 T1921)
(declare-const var_h91 T1921)
(declare-const v Int)
(declare-const var_h_i44 T1921)
(declare-const var_h43 T1921)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h526 T1921)
(declare-const var__temp_v527 Int)
(declare-const |var__temp_h'528| T1921)
(declare-const var__temp_v_err529 T1922)
(declare-const var_h506 T1921)
(declare-const var_h143 T1921)
(declare-const var_h91 T1921)
(declare-const var_h43 T1921)
(declare-const err T1935)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1921)
(declare-fun sel (T1921 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T1921)
(declare-fun var_h43 () T1921)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h526 () T1921)
(declare-fun |var__temp_h'528| () T1921)
(declare-fun var__temp_v527 () Int)
(declare-fun var_h506 () T1921)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h526 res) v)
                    (= v |5|)
                    (= (sel var__temp_h526 other) (sel var_h506 other)))
               (= (sel var__temp_h526 res) 7)))
      (a!2 (and (= (sel |var__temp_h'528| res) var__temp_v527)
                (= (sel |var__temp_h'528| res) (+ (sel var__temp_h526 res) 5))
                (= (sel |var__temp_h'528| other) (sel var__temp_h526 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h526 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************141
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i507 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i507, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i507, other ) ==(sel)( , var_h506, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v521:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i507 --->  Ty_heap  
 var_h506 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h530 --->  Ty_heap  
 var__temp_v531 --->  Ty_int  
 var__temp_h'532 --->  Ty_heap  
 var__temp_v_err533 --->  error  
 var_h506 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h530, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h530, other ) ==(sel)( , var_h506, other ) => 
 	 Rel (sel)( , var__temp_h530, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h530, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'532, res ) ==(var__temp_v531) AND 
 	 Rel (sel)( , var__temp_h'532, res ) ==((sel)( , var__temp_h530, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'532, other ) ==(sel)( , var__temp_h530, other ) => 
 	 True
 
VC_END(declare-const var_h_i507 T1938)
(declare-const var_h506 T1938)
(declare-const v Int)
(declare-const var_h_i144 T1938)
(declare-const var_h143 T1938)
(declare-const v Int)
(declare-const var_h_i92 T1938)
(declare-const var_h91 T1938)
(declare-const v Int)
(declare-const var_h_i44 T1938)
(declare-const var_h43 T1938)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h530 T1938)
(declare-const var__temp_v531 Int)
(declare-const |var__temp_h'532| T1938)
(declare-const var__temp_v_err533 T1939)
(declare-const var_h506 T1938)
(declare-const var_h143 T1938)
(declare-const var_h91 T1938)
(declare-const var_h43 T1938)
(declare-const err T1952)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1938)
(declare-fun sel (T1938 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T1938)
(declare-fun var_h43 () T1938)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h530 () T1938)
(declare-fun |var__temp_h'532| () T1938)
(declare-fun var__temp_v531 () Int)
(declare-fun var_h506 () T1938)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h530 res) v)
                    (= v |5|)
                    (= (sel var__temp_h530 other) (sel var_h506 other)))
               (= (sel var__temp_h530 res) 5)))
      (a!2 (and (= (sel |var__temp_h'532| res) var__temp_v531)
                (= (sel |var__temp_h'532| res) (+ (sel var__temp_h530 res) 2))
                (= (sel |var__temp_h'532| other) (sel var__temp_h530 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h530 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************bar
PARTIAL PATH NEW
SUB 
 	 --bar
 	 --foo
 	 --foo'
 	 --c4
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i535 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i535 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i535, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i535, res ) ==((sel)( , var_h534, res ) + (2))
 	 , (sel)( , var_h_i535, other ) ==(sel)( , var_h534, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v536:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i535 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************142
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i535 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i535, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i535, res ) ==((sel)( , var_h534, res ) + (2))
 	 , (sel)( , var_h_i535, other ) ==(sel)( , var_h534, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v536:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i535 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i535 --->  Ty_heap  
 var_h534 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i507 --->  Ty_heap  
 var_h506 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h537 --->  Ty_heap  
 var__temp_v538 --->  Ty_int  
 var__temp_h'539 --->  Ty_heap  
 var__temp_v_err540 --->  error  
 var_h534 --->  Ty_heap  
 var_h506 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h534, res ) ==(5) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h537, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h537, res ) ==((sel)( , var_h534, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h537, other ) ==(sel)( , var_h534, other ) => 
 	 Rel (sel)( , var__temp_h537, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h537, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'539, res ) ==(var__temp_v538) AND 
 	 Rel (sel)( , var__temp_h'539, res ) ==((sel)( , var__temp_h537, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'539, other ) ==(sel)( , var__temp_h537, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'539, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'539, other ) > (4)
 
VC_END(declare-const var_h_i535 T1955)
(declare-const var_h534 T1955)
(declare-const v Int)
(declare-const var_h_i507 T1955)
(declare-const var_h506 T1955)
(declare-const v Int)
(declare-const var_h_i144 T1955)
(declare-const var_h143 T1955)
(declare-const v Int)
(declare-const var_h_i92 T1955)
(declare-const var_h91 T1955)
(declare-const v Int)
(declare-const var_h_i44 T1955)
(declare-const var_h43 T1955)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h537 T1955)
(declare-const var__temp_v538 Int)
(declare-const |var__temp_h'539| T1955)
(declare-const var__temp_v_err540 T1956)
(declare-const var_h534 T1955)
(declare-const var_h506 T1955)
(declare-const var_h143 T1955)
(declare-const var_h91 T1955)
(declare-const var_h43 T1955)
(declare-const err T1969)

solver 
 (declare-sort T1955)
(declare-fun sel (T1955 Int) Int)
(declare-fun res () Int)
(declare-fun var_h534 () T1955)
(declare-fun var_h91 () T1955)
(declare-fun var_h43 () T1955)
(declare-fun other () Int)
(declare-fun |var__temp_h'539| () T1955)
(declare-fun var__temp_h537 () T1955)
(declare-fun var__temp_v538 () Int)
(declare-fun v () Int)
(assert (= (sel var_h534 res) 5))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h537 res) v)
                (= (sel var__temp_h537 res) (+ (sel var_h534 res) 2))
                (= (sel var__temp_h537 other) (sel var_h534 other))))
      (a!2 (and (= (sel |var__temp_h'539| res) var__temp_v538)
                (= (sel |var__temp_h'539| res) (+ (sel var__temp_h537 res) 3))
                (= (sel |var__temp_h'539| other) (sel var__temp_h537 other))))
      (a!3 (and (= (sel |var__temp_h'539| res) 10)
                (not (> (sel |var__temp_h'539| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h537 res) 7))
                (=> (= (sel var__temp_h537 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************143
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i535 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i535, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i535, res ) ==((sel)( , var_h534, res ) + (2))
 	 , (sel)( , var_h_i535, other ) ==(sel)( , var_h534, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v536:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i535 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i535 --->  Ty_heap  
 var_h534 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i507 --->  Ty_heap  
 var_h506 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h541 --->  Ty_heap  
 var__temp_v542 --->  Ty_int  
 var__temp_h'543 --->  Ty_heap  
 var__temp_v_err544 --->  error  
 var_h534 --->  Ty_heap  
 var_h506 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h534, res ) ==(5) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h541, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h541, res ) ==((sel)( , var_h534, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h541, other ) ==(sel)( , var_h534, other ) => 
 	 Rel (sel)( , var__temp_h541, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h541, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'543, res ) ==(var__temp_v542) AND 
 	 Rel (sel)( , var__temp_h'543, res ) ==((sel)( , var__temp_h541, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'543, other ) ==(sel)( , var__temp_h541, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'543, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'543, other ) > (4)
 
VC_END(declare-const var_h_i535 T1972)
(declare-const var_h534 T1972)
(declare-const v Int)
(declare-const var_h_i507 T1972)
(declare-const var_h506 T1972)
(declare-const v Int)
(declare-const var_h_i144 T1972)
(declare-const var_h143 T1972)
(declare-const v Int)
(declare-const var_h_i92 T1972)
(declare-const var_h91 T1972)
(declare-const v Int)
(declare-const var_h_i44 T1972)
(declare-const var_h43 T1972)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h541 T1972)
(declare-const var__temp_v542 Int)
(declare-const |var__temp_h'543| T1972)
(declare-const var__temp_v_err544 T1973)
(declare-const var_h534 T1972)
(declare-const var_h506 T1972)
(declare-const var_h143 T1972)
(declare-const var_h91 T1972)
(declare-const var_h43 T1972)
(declare-const err T1986)

solver 
 (declare-sort T1972)
(declare-fun sel (T1972 Int) Int)
(declare-fun res () Int)
(declare-fun var_h534 () T1972)
(declare-fun var_h91 () T1972)
(declare-fun var_h43 () T1972)
(declare-fun other () Int)
(declare-fun |var__temp_h'543| () T1972)
(declare-fun var__temp_h541 () T1972)
(declare-fun var__temp_v542 () Int)
(declare-fun v () Int)
(assert (= (sel var_h534 res) 5))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h541 res) v)
                (= (sel var__temp_h541 res) (+ (sel var_h534 res) 2))
                (= (sel var__temp_h541 other) (sel var_h534 other))))
      (a!2 (and (= (sel |var__temp_h'543| res) var__temp_v542)
                (= (sel |var__temp_h'543| res) (+ (sel var__temp_h541 res) 5))
                (= (sel |var__temp_h'543| other) (sel var__temp_h541 other))))
      (a!3 (and (= (sel |var__temp_h'543| res) 10)
                (not (> (sel |var__temp_h'543| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h541 res) 7))
                (=> (= (sel var__temp_h541 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************144
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v536:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v536:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbarfooc2c2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i535 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i535, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i535, res ) ==((sel)( , var_h534, res ) + (2))
 	 , (sel)( , var_h_i535, other ) ==(sel)( , var_h534, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v545:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************145
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i535 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i535, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i535, res ) ==((sel)( , var_h534, res ) + (2))
 	 , (sel)( , var_h_i535, other ) ==(sel)( , var_h534, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v545:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i535 --->  Ty_heap  
 var_h534 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i507 --->  Ty_heap  
 var_h506 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h546 --->  Ty_heap  
 var__temp_v547 --->  Ty_int  
 var__temp_h'548 --->  Ty_heap  
 var__temp_v_err549 --->  error  
 var_h534 --->  Ty_heap  
 var_h506 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h534, res ) ==(5) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h546, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h546, res ) ==((sel)( , var_h534, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h546, other ) ==(sel)( , var_h534, other ) => 
 	 Rel (sel)( , var__temp_h546, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h546, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'548, res ) ==(var__temp_v547) AND 
 	 Rel (sel)( , var__temp_h'548, res ) ==((sel)( , var__temp_h546, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'548, other ) ==(sel)( , var__temp_h546, other ) => 
 	 True
 
VC_END(declare-const var_h_i535 T1989)
(declare-const var_h534 T1989)
(declare-const v Int)
(declare-const var_h_i507 T1989)
(declare-const var_h506 T1989)
(declare-const v Int)
(declare-const var_h_i144 T1989)
(declare-const var_h143 T1989)
(declare-const v Int)
(declare-const var_h_i92 T1989)
(declare-const var_h91 T1989)
(declare-const v Int)
(declare-const var_h_i44 T1989)
(declare-const var_h43 T1989)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h546 T1989)
(declare-const var__temp_v547 Int)
(declare-const |var__temp_h'548| T1989)
(declare-const var__temp_v_err549 T1990)
(declare-const var_h534 T1989)
(declare-const var_h506 T1989)
(declare-const var_h143 T1989)
(declare-const var_h91 T1989)
(declare-const var_h43 T1989)
(declare-const err T2003)

solver 
 (declare-sort T1989)
(declare-fun sel (T1989 Int) Int)
(declare-fun res () Int)
(declare-fun var_h534 () T1989)
(declare-fun var_h91 () T1989)
(declare-fun var_h43 () T1989)
(declare-fun other () Int)
(declare-fun var__temp_h546 () T1989)
(declare-fun |var__temp_h'548| () T1989)
(declare-fun var__temp_v547 () Int)
(declare-fun v () Int)
(assert (= (sel var_h534 res) 5))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h546 res) v)
                (= (sel var__temp_h546 res) (+ (sel var_h534 res) 2))
                (= (sel var__temp_h546 other) (sel var_h534 other))))
      (a!2 (and (= (sel |var__temp_h'548| res) var__temp_v547)
                (= (sel |var__temp_h'548| res) (+ (sel var__temp_h546 res) 3))
                (= (sel |var__temp_h'548| other) (sel var__temp_h546 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h546 res) 7))
                (=> (= (sel var__temp_h546 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************baz
PARTIAL PATH NEW
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --foo'
 	 --c4
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i551 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i551 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i551, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i551, res ) ==((sel)( , var_h550, res ) + (3))
 	 , (sel)( , var_h_i551, other ) ==(sel)( , var_h550, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v552:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i551 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************146
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i551 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i551, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i551, res ) ==((sel)( , var_h550, res ) + (3))
 	 , (sel)( , var_h_i551, other ) ==(sel)( , var_h550, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v552:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i551 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i551 --->  Ty_heap  
 var_h550 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i535 --->  Ty_heap  
 var_h534 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i507 --->  Ty_heap  
 var_h506 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h553 --->  Ty_heap  
 var__temp_v554 --->  Ty_int  
 var__temp_h'555 --->  Ty_heap  
 var__temp_v_err556 --->  error  
 var_h550 --->  Ty_heap  
 var_h534 --->  Ty_heap  
 var_h506 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h550, res ) ==(7) AND 
 	 Rel (sel)( , var_h534, res ) ==(5) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h553, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h553, res ) ==((sel)( , var_h550, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h553, other ) ==(sel)( , var_h550, other ) => 
 	 Rel (sel)( , var__temp_h553, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h553, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'555, res ) ==(var__temp_v554) AND 
 	 Rel (sel)( , var__temp_h'555, res ) ==((sel)( , var__temp_h553, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'555, other ) ==(sel)( , var__temp_h553, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'555, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'555, other ) > (4)
 
VC_END(declare-const var_h_i551 T2006)
(declare-const var_h550 T2006)
(declare-const v Int)
(declare-const var_h_i535 T2006)
(declare-const var_h534 T2006)
(declare-const v Int)
(declare-const var_h_i507 T2006)
(declare-const var_h506 T2006)
(declare-const v Int)
(declare-const var_h_i144 T2006)
(declare-const var_h143 T2006)
(declare-const v Int)
(declare-const var_h_i92 T2006)
(declare-const var_h91 T2006)
(declare-const v Int)
(declare-const var_h_i44 T2006)
(declare-const var_h43 T2006)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h553 T2006)
(declare-const var__temp_v554 Int)
(declare-const |var__temp_h'555| T2006)
(declare-const var__temp_v_err556 T2007)
(declare-const var_h550 T2006)
(declare-const var_h534 T2006)
(declare-const var_h506 T2006)
(declare-const var_h143 T2006)
(declare-const var_h91 T2006)
(declare-const var_h43 T2006)
(declare-const err T2020)

solver 
 (declare-sort T2006)
(declare-fun sel (T2006 Int) Int)
(declare-fun res () Int)
(declare-fun var_h550 () T2006)
(declare-fun var_h534 () T2006)
(declare-fun var_h91 () T2006)
(declare-fun var_h43 () T2006)
(declare-fun other () Int)
(declare-fun |var__temp_h'555| () T2006)
(declare-fun var__temp_h553 () T2006)
(declare-fun var__temp_v554 () Int)
(declare-fun v () Int)
(assert (= (sel var_h550 res) 7))
(assert (= (sel var_h534 res) 5))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h553 res) v)
                (= (sel var__temp_h553 res) (+ (sel var_h550 res) 3))
                (= (sel var__temp_h553 other) (sel var_h550 other))))
      (a!2 (and (= (sel |var__temp_h'555| res) var__temp_v554)
                (= (sel |var__temp_h'555| res) (+ (sel var__temp_h553 res) 5))
                (= (sel |var__temp_h'555| other) (sel var__temp_h553 other))))
      (a!3 (and (= (sel |var__temp_h'555| res) 10)
                (not (> (sel |var__temp_h'555| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h553 res) 7))
                (=> (= (sel var__temp_h553 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************147
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v552:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v552:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbazbarfooc2c2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i551 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i551, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i551, res ) ==((sel)( , var_h550, res ) + (3))
 	 , (sel)( , var_h_i551, other ) ==(sel)( , var_h550, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v557:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************148
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i551 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i551, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i551, res ) ==((sel)( , var_h550, res ) + (3))
 	 , (sel)( , var_h_i551, other ) ==(sel)( , var_h550, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v557:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i551 --->  Ty_heap  
 var_h550 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i535 --->  Ty_heap  
 var_h534 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i507 --->  Ty_heap  
 var_h506 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h558 --->  Ty_heap  
 var__temp_v559 --->  Ty_int  
 var__temp_h'560 --->  Ty_heap  
 var__temp_v_err561 --->  error  
 var_h550 --->  Ty_heap  
 var_h534 --->  Ty_heap  
 var_h506 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h550, res ) ==(7) AND 
 	 Rel (sel)( , var_h534, res ) ==(5) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h558, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h558, res ) ==((sel)( , var_h550, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h558, other ) ==(sel)( , var_h550, other ) => 
 	 Rel (sel)( , var__temp_h558, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h558, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'560, res ) ==(var__temp_v559) AND 
 	 Rel (sel)( , var__temp_h'560, res ) ==((sel)( , var__temp_h558, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'560, other ) ==(sel)( , var__temp_h558, other ) => 
 	 True
 
VC_END(declare-const var_h_i551 T2023)
(declare-const var_h550 T2023)
(declare-const v Int)
(declare-const var_h_i535 T2023)
(declare-const var_h534 T2023)
(declare-const v Int)
(declare-const var_h_i507 T2023)
(declare-const var_h506 T2023)
(declare-const v Int)
(declare-const var_h_i144 T2023)
(declare-const var_h143 T2023)
(declare-const v Int)
(declare-const var_h_i92 T2023)
(declare-const var_h91 T2023)
(declare-const v Int)
(declare-const var_h_i44 T2023)
(declare-const var_h43 T2023)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h558 T2023)
(declare-const var__temp_v559 Int)
(declare-const |var__temp_h'560| T2023)
(declare-const var__temp_v_err561 T2024)
(declare-const var_h550 T2023)
(declare-const var_h534 T2023)
(declare-const var_h506 T2023)
(declare-const var_h143 T2023)
(declare-const var_h91 T2023)
(declare-const var_h43 T2023)
(declare-const err T2037)

solver 
 (declare-sort T2023)
(declare-fun sel (T2023 Int) Int)
(declare-fun res () Int)
(declare-fun var_h550 () T2023)
(declare-fun var_h534 () T2023)
(declare-fun var_h91 () T2023)
(declare-fun var_h43 () T2023)
(declare-fun other () Int)
(declare-fun var__temp_h558 () T2023)
(declare-fun |var__temp_h'560| () T2023)
(declare-fun var__temp_v559 () Int)
(declare-fun v () Int)
(assert (= (sel var_h550 res) 7))
(assert (= (sel var_h534 res) 5))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h558 res) v)
                (= (sel var__temp_h558 res) (+ (sel var_h550 res) 3))
                (= (sel var__temp_h558 other) (sel var_h550 other))))
      (a!2 (and (= (sel |var__temp_h'560| res) var__temp_v559)
                (= (sel |var__temp_h'560| res) (+ (sel var__temp_h558 res) 5))
                (= (sel |var__temp_h'560| other) (sel var__temp_h558 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h558 res) 7))
                (=> (= (sel var__temp_h558 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************149
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT baz
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i535 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i535, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i535, res ) ==((sel)( , var_h534, res ) + (2))
 	 , (sel)( , var_h_i535, other ) ==(sel)( , var_h534, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v562:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************150
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i535 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i535, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i535, res ) ==((sel)( , var_h534, res ) + (2))
 	 , (sel)( , var_h_i535, other ) ==(sel)( , var_h534, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v562:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i535 --->  Ty_heap  
 var_h534 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i507 --->  Ty_heap  
 var_h506 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h563 --->  Ty_heap  
 var__temp_v564 --->  Ty_int  
 var__temp_h'565 --->  Ty_heap  
 var__temp_v_err566 --->  error  
 var_h534 --->  Ty_heap  
 var_h506 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h534, res ) ==(5) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h563, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h563, res ) ==((sel)( , var_h534, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h563, other ) ==(sel)( , var_h534, other ) => 
 	 Rel (sel)( , var__temp_h563, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h563, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'565, res ) ==(var__temp_v564) AND 
 	 Rel (sel)( , var__temp_h'565, res ) ==((sel)( , var__temp_h563, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'565, other ) ==(sel)( , var__temp_h563, other ) => 
 	 True
 
VC_END(declare-const var_h_i535 T2040)
(declare-const var_h534 T2040)
(declare-const v Int)
(declare-const var_h_i507 T2040)
(declare-const var_h506 T2040)
(declare-const v Int)
(declare-const var_h_i144 T2040)
(declare-const var_h143 T2040)
(declare-const v Int)
(declare-const var_h_i92 T2040)
(declare-const var_h91 T2040)
(declare-const v Int)
(declare-const var_h_i44 T2040)
(declare-const var_h43 T2040)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h563 T2040)
(declare-const var__temp_v564 Int)
(declare-const |var__temp_h'565| T2040)
(declare-const var__temp_v_err566 T2041)
(declare-const var_h534 T2040)
(declare-const var_h506 T2040)
(declare-const var_h143 T2040)
(declare-const var_h91 T2040)
(declare-const var_h43 T2040)
(declare-const err T2054)

solver 
 (declare-sort T2040)
(declare-fun sel (T2040 Int) Int)
(declare-fun res () Int)
(declare-fun var_h534 () T2040)
(declare-fun var_h91 () T2040)
(declare-fun var_h43 () T2040)
(declare-fun other () Int)
(declare-fun var__temp_h563 () T2040)
(declare-fun |var__temp_h'565| () T2040)
(declare-fun var__temp_v564 () Int)
(declare-fun v () Int)
(assert (= (sel var_h534 res) 5))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h563 res) v)
                (= (sel var__temp_h563 res) (+ (sel var_h534 res) 2))
                (= (sel var__temp_h563 other) (sel var_h534 other))))
      (a!2 (and (= (sel |var__temp_h'565| res) var__temp_v564)
                (= (sel |var__temp_h'565| res) (+ (sel var__temp_h563 res) 5))
                (= (sel |var__temp_h'565| other) (sel var__temp_h563 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h563 res) 7))
                (=> (= (sel var__temp_h563 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c5
PARTIAL PATH NEW
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --foo'
 	 --c4
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i568 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i568 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i568, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i568, res ) ==((sel)( , var_h567, res ) + (5))
 	 , (sel)( , var_h_i568, other ) ==(sel)( , var_h567, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v569:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i568 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************151
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v569:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v569:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc5bazbarfooc2c2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i568 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i568, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i568, res ) ==((sel)( , var_h567, res ) + (5))
 	 , (sel)( , var_h_i568, other ) ==(sel)( , var_h567, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v570:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************152
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i535 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i535, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i535, res ) ==((sel)( , var_h534, res ) + (2))
 	 , (sel)( , var_h_i535, other ) ==(sel)( , var_h534, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v571:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************153
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --foo
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i507 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i507, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i507, other ) ==(sel)( , var_h506, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v572:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************154
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i507 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i507, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i507, other ) ==(sel)( , var_h506, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v572:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i507 --->  Ty_heap  
 var_h506 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h573 --->  Ty_heap  
 var__temp_v574 --->  Ty_int  
 var__temp_h'575 --->  Ty_heap  
 var__temp_v_err576 --->  error  
 var_h506 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h573, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h573, other ) ==(sel)( , var_h506, other ) => 
 	 Rel (sel)( , var__temp_h573, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h573, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'575, res ) ==(var__temp_v574) AND 
 	 Rel (sel)( , var__temp_h'575, res ) ==((sel)( , var__temp_h573, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'575, other ) ==(sel)( , var__temp_h573, other ) => 
 	 True
 
VC_END(declare-const var_h_i507 T2057)
(declare-const var_h506 T2057)
(declare-const v Int)
(declare-const var_h_i144 T2057)
(declare-const var_h143 T2057)
(declare-const v Int)
(declare-const var_h_i92 T2057)
(declare-const var_h91 T2057)
(declare-const v Int)
(declare-const var_h_i44 T2057)
(declare-const var_h43 T2057)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h573 T2057)
(declare-const var__temp_v574 Int)
(declare-const |var__temp_h'575| T2057)
(declare-const var__temp_v_err576 T2058)
(declare-const var_h506 T2057)
(declare-const var_h143 T2057)
(declare-const var_h91 T2057)
(declare-const var_h43 T2057)
(declare-const err T2071)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2057)
(declare-fun sel (T2057 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2057)
(declare-fun var_h43 () T2057)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h573 () T2057)
(declare-fun |var__temp_h'575| () T2057)
(declare-fun var__temp_v574 () Int)
(declare-fun var_h506 () T2057)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h573 res) v)
                    (= v |5|)
                    (= (sel var__temp_h573 other) (sel var_h506 other)))
               (= (sel var__temp_h573 res) 7)))
      (a!2 (and (= (sel |var__temp_h'575| res) var__temp_v574)
                (= (sel |var__temp_h'575| res) (+ (sel var__temp_h573 res) 3))
                (= (sel |var__temp_h'575| other) (sel var__temp_h573 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h573 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************155
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i507 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i507, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i507, other ) ==(sel)( , var_h506, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v572:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i507 --->  Ty_heap  
 var_h506 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h577 --->  Ty_heap  
 var__temp_v578 --->  Ty_int  
 var__temp_h'579 --->  Ty_heap  
 var__temp_v_err580 --->  error  
 var_h506 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h577, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h577, other ) ==(sel)( , var_h506, other ) => 
 	 Rel (sel)( , var__temp_h577, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h577, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'579, res ) ==(var__temp_v578) AND 
 	 Rel (sel)( , var__temp_h'579, res ) ==((sel)( , var__temp_h577, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'579, other ) ==(sel)( , var__temp_h577, other ) => 
 	 True
 
VC_END(declare-const var_h_i507 T2074)
(declare-const var_h506 T2074)
(declare-const v Int)
(declare-const var_h_i144 T2074)
(declare-const var_h143 T2074)
(declare-const v Int)
(declare-const var_h_i92 T2074)
(declare-const var_h91 T2074)
(declare-const v Int)
(declare-const var_h_i44 T2074)
(declare-const var_h43 T2074)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h577 T2074)
(declare-const var__temp_v578 Int)
(declare-const |var__temp_h'579| T2074)
(declare-const var__temp_v_err580 T2075)
(declare-const var_h506 T2074)
(declare-const var_h143 T2074)
(declare-const var_h91 T2074)
(declare-const var_h43 T2074)
(declare-const err T2088)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2074)
(declare-fun sel (T2074 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2074)
(declare-fun var_h43 () T2074)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h577 () T2074)
(declare-fun |var__temp_h'579| () T2074)
(declare-fun var__temp_v578 () Int)
(declare-fun var_h506 () T2074)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h577 res) v)
                    (= v |5|)
                    (= (sel var__temp_h577 other) (sel var_h506 other)))
               (= (sel var__temp_h577 res) 7)))
      (a!2 (and (= (sel |var__temp_h'579| res) var__temp_v578)
                (= (sel |var__temp_h'579| res) (+ (sel var__temp_h577 res) 5))
                (= (sel |var__temp_h'579| other) (sel var__temp_h577 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h577 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************156
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT bar
PARTIAL PATH
SUB 
 	 --foo'
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i144 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i144, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i144, other ) ==(sel)( , var_h143, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v581:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************157
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i144 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i144, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i144, other ) ==(sel)( , var_h143, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v581:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h582 --->  Ty_heap  
 var__temp_v583 --->  Ty_int  
 var__temp_h'584 --->  Ty_heap  
 var__temp_v_err585 --->  error  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h582, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h582, other ) ==(sel)( , var_h143, other ) => 
 	 Rel (sel)( , var__temp_h582, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h582, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'584, res ) ==(var__temp_v583) AND 
 	 Rel (sel)( , var__temp_h'584, res ) ==((sel)( , var__temp_h582, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'584, other ) ==(sel)( , var__temp_h582, other ) => 
 	 True
 
VC_END(declare-const var_h_i144 T2091)
(declare-const var_h143 T2091)
(declare-const v Int)
(declare-const var_h_i92 T2091)
(declare-const var_h91 T2091)
(declare-const v Int)
(declare-const var_h_i44 T2091)
(declare-const var_h43 T2091)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h582 T2091)
(declare-const var__temp_v583 Int)
(declare-const |var__temp_h'584| T2091)
(declare-const var__temp_v_err585 T2092)
(declare-const var_h143 T2091)
(declare-const var_h91 T2091)
(declare-const var_h43 T2091)
(declare-const err T2105)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2091)
(declare-fun sel (T2091 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2091)
(declare-fun var_h43 () T2091)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h582 () T2091)
(declare-fun |var__temp_h'584| () T2091)
(declare-fun var__temp_v583 () Int)
(declare-fun var_h143 () T2091)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h582 res) v)
                    (= v |20|)
                    (= (sel var__temp_h582 other) (sel var_h143 other)))
               (= (sel var__temp_h582 res) 7)))
      (a!2 (and (= (sel |var__temp_h'584| res) var__temp_v583)
                (= (sel |var__temp_h'584| res) (+ (sel var__temp_h582 res) 3))
                (= (sel |var__temp_h'584| other) (sel var__temp_h582 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h582 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************158
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i144 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i144, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i144, other ) ==(sel)( , var_h143, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v581:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h586 --->  Ty_heap  
 var__temp_v587 --->  Ty_int  
 var__temp_h'588 --->  Ty_heap  
 var__temp_v_err589 --->  error  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h586, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h586, other ) ==(sel)( , var_h143, other ) => 
 	 Rel (sel)( , var__temp_h586, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h586, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'588, res ) ==(var__temp_v587) AND 
 	 Rel (sel)( , var__temp_h'588, res ) ==((sel)( , var__temp_h586, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'588, other ) ==(sel)( , var__temp_h586, other ) => 
 	 True
 
VC_END(declare-const var_h_i144 T2108)
(declare-const var_h143 T2108)
(declare-const v Int)
(declare-const var_h_i92 T2108)
(declare-const var_h91 T2108)
(declare-const v Int)
(declare-const var_h_i44 T2108)
(declare-const var_h43 T2108)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h586 T2108)
(declare-const var__temp_v587 Int)
(declare-const |var__temp_h'588| T2108)
(declare-const var__temp_v_err589 T2109)
(declare-const var_h143 T2108)
(declare-const var_h91 T2108)
(declare-const var_h43 T2108)
(declare-const err T2122)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2108)
(declare-fun sel (T2108 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2108)
(declare-fun var_h43 () T2108)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h586 () T2108)
(declare-fun |var__temp_h'588| () T2108)
(declare-fun var__temp_v587 () Int)
(declare-fun var_h143 () T2108)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h586 res) v)
                    (= v |20|)
                    (= (sel var__temp_h586 other) (sel var_h143 other)))
               (= (sel var__temp_h586 res) 7)))
      (a!2 (and (= (sel |var__temp_h'588| res) var__temp_v587)
                (= (sel |var__temp_h'588| res) (+ (sel var__temp_h586 res) 5))
                (= (sel |var__temp_h'588| other) (sel var__temp_h586 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h586 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************159
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i144 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i144, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i144, other ) ==(sel)( , var_h143, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v581:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i144 --->  Ty_heap  
 var_h143 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h590 --->  Ty_heap  
 var__temp_v591 --->  Ty_int  
 var__temp_h'592 --->  Ty_heap  
 var__temp_v_err593 --->  error  
 var_h143 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h590, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h590, other ) ==(sel)( , var_h143, other ) => 
 	 Rel (sel)( , var__temp_h590, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h590, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'592, res ) ==(var__temp_v591) AND 
 	 Rel (sel)( , var__temp_h'592, res ) ==((sel)( , var__temp_h590, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'592, other ) ==(sel)( , var__temp_h590, other ) => 
 	 True
 
VC_END(declare-const var_h_i144 T2125)
(declare-const var_h143 T2125)
(declare-const v Int)
(declare-const var_h_i92 T2125)
(declare-const var_h91 T2125)
(declare-const v Int)
(declare-const var_h_i44 T2125)
(declare-const var_h43 T2125)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h590 T2125)
(declare-const var__temp_v591 Int)
(declare-const |var__temp_h'592| T2125)
(declare-const var__temp_v_err593 T2126)
(declare-const var_h143 T2125)
(declare-const var_h91 T2125)
(declare-const var_h43 T2125)
(declare-const err T2139)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2125)
(declare-fun sel (T2125 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2125)
(declare-fun var_h43 () T2125)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h590 () T2125)
(declare-fun |var__temp_h'592| () T2125)
(declare-fun var__temp_v591 () Int)
(declare-fun var_h143 () T2125)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h590 res) v)
                    (= v |20|)
                    (= (sel var__temp_h590 other) (sel var_h143 other)))
               (= (sel var__temp_h590 res) 5)))
      (a!2 (and (= (sel |var__temp_h'592| res) var__temp_v591)
                (= (sel |var__temp_h'592| res) (+ (sel var__temp_h590 res) 2))
                (= (sel |var__temp_h'592| other) (sel var__temp_h590 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h590 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************160
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo
PARTIAL PATH
SUB 
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i92 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i92, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i92, res ) ==((sel)( , var_h91, res ) + (5))
 	 , (sel)( , var_h_i92, other ) ==(sel)( , var_h91, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v594:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
foo
bar
 *********************Enumeration Iteration*****************161
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i92 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i92, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i92, res ) ==((sel)( , var_h91, res ) + (5))
 	 , (sel)( , var_h_i92, other ) ==(sel)( , var_h91, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v594:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h595 --->  Ty_heap  
 var__temp_v596 --->  Ty_int  
 var__temp_h'597 --->  Ty_heap  
 var__temp_v_err598 --->  error  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h595, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h595, res ) ==((sel)( , var_h91, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h595, other ) ==(sel)( , var_h91, other ) => 
 	 Rel (sel)( , var__temp_h595, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h595, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'597, res ) ==(var__temp_v596) AND 
 	 Rel (sel)( , var__temp_h'597, res ) ==((sel)( , var__temp_h595, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'597, other ) ==(sel)( , var__temp_h595, other ) => 
 	 True
 
VC_END(declare-const var_h_i92 T2142)
(declare-const var_h91 T2142)
(declare-const v Int)
(declare-const var_h_i44 T2142)
(declare-const var_h43 T2142)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h595 T2142)
(declare-const var__temp_v596 Int)
(declare-const |var__temp_h'597| T2142)
(declare-const var__temp_v_err598 T2143)
(declare-const var_h91 T2142)
(declare-const var_h43 T2142)
(declare-const err T2156)

solver 
 (declare-sort T2142)
(declare-fun sel (T2142 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2142)
(declare-fun var_h43 () T2142)
(declare-fun other () Int)
(declare-fun var__temp_h595 () T2142)
(declare-fun |var__temp_h'597| () T2142)
(declare-fun var__temp_v596 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h595 res) v)
                (= (sel var__temp_h595 res) (+ (sel var_h91 res) 5))
                (= (sel var__temp_h595 other) (sel var_h91 other))))
      (a!2 (and (= (sel |var__temp_h'597| res) var__temp_v596)
                (= (sel |var__temp_h'597| res) (+ (sel var__temp_h595 res) 3))
                (= (sel |var__temp_h'597| other) (sel var__temp_h595 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h595 res) 7))
                (=> (= (sel var__temp_h595 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************162
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i92 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i92, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i92, res ) ==((sel)( , var_h91, res ) + (5))
 	 , (sel)( , var_h_i92, other ) ==(sel)( , var_h91, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v594:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h599 --->  Ty_heap  
 var__temp_v600 --->  Ty_int  
 var__temp_h'601 --->  Ty_heap  
 var__temp_v_err602 --->  error  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h599, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h599, res ) ==((sel)( , var_h91, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h599, other ) ==(sel)( , var_h91, other ) => 
 	 Rel (sel)( , var__temp_h599, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h599, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'601, res ) ==(var__temp_v600) AND 
 	 Rel (sel)( , var__temp_h'601, res ) ==((sel)( , var__temp_h599, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'601, other ) ==(sel)( , var__temp_h599, other ) => 
 	 True
 
VC_END(declare-const var_h_i92 T2159)
(declare-const var_h91 T2159)
(declare-const v Int)
(declare-const var_h_i44 T2159)
(declare-const var_h43 T2159)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h599 T2159)
(declare-const var__temp_v600 Int)
(declare-const |var__temp_h'601| T2159)
(declare-const var__temp_v_err602 T2160)
(declare-const var_h91 T2159)
(declare-const var_h43 T2159)
(declare-const err T2173)

solver 
 (declare-sort T2159)
(declare-fun sel (T2159 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2159)
(declare-fun var_h43 () T2159)
(declare-fun other () Int)
(declare-fun var__temp_h599 () T2159)
(declare-fun |var__temp_h'601| () T2159)
(declare-fun var__temp_v600 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h599 res) v)
                (= (sel var__temp_h599 res) (+ (sel var_h91 res) 5))
                (= (sel var__temp_h599 other) (sel var_h91 other))))
      (a!2 (and (= (sel |var__temp_h'601| res) var__temp_v600)
                (= (sel |var__temp_h'601| res) (+ (sel var__temp_h599 res) 5))
                (= (sel |var__temp_h'601| other) (sel var__temp_h599 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h599 res) 7))
                (=> (= (sel var__temp_h599 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************163
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i92 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i92, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i92, res ) ==((sel)( , var_h91, res ) + (5))
 	 , (sel)( , var_h_i92, other ) ==(sel)( , var_h91, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v594:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h603 --->  Ty_heap  
 var__temp_v604 --->  Ty_int  
 var__temp_h'605 --->  Ty_heap  
 var__temp_v_err606 --->  error  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h603, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h603, res ) ==((sel)( , var_h91, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h603, other ) ==(sel)( , var_h91, other ) => 
 	 Rel (sel)( , var__temp_h603, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h603, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'605, res ) ==(var__temp_v604) AND 
 	 Rel (sel)( , var__temp_h603, res ) ==(sel)( , var__temp_h603, res ) AND 
 	 Rel (sel)( , var__temp_h'605, other ) ==(sel)( , var__temp_h603, other ) => 
 	 True
 
VC_END(declare-const var_h_i92 T2176)
(declare-const var_h91 T2176)
(declare-const v Int)
(declare-const var_h_i44 T2176)
(declare-const var_h43 T2176)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h603 T2176)
(declare-const var__temp_v604 Int)
(declare-const |var__temp_h'605| T2176)
(declare-const var__temp_v_err606 T2177)
(declare-const var_h91 T2176)
(declare-const var_h43 T2176)
(declare-const err T2190)

solver 
 (declare-sort T2176)
(declare-fun sel (T2176 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2176)
(declare-fun var_h43 () T2176)
(declare-fun other () Int)
(declare-fun var__temp_h603 () T2176)
(declare-fun |var__temp_h'605| () T2176)
(declare-fun var__temp_v604 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h603 res) v)
                (= (sel var__temp_h603 res) (+ (sel var_h91 res) 5))
                (= (sel var__temp_h603 other) (sel var_h91 other))))
      (a!3 (=> (and (= (sel |var__temp_h'605| res) var__temp_v604)
                    (= (sel var__temp_h603 res) (sel var__temp_h603 res))
                    (= (sel |var__temp_h'605| other) (sel var__temp_h603 other)))
               true)))
(let ((a!2 (=> a!1 (not (> (sel var__temp_h603 res) 20))))
      (a!4 (=> (not (> (sel var__temp_h603 res) 20)) a!3)))
  (not (and a!2 a!4)))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************164
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i92 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i92, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i92, res ) ==((sel)( , var_h91, res ) + (5))
 	 , (sel)( , var_h_i92, other ) ==(sel)( , var_h91, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v594:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h607 --->  Ty_heap  
 var__temp_v608 --->  Ty_int  
 var__temp_h'609 --->  Ty_heap  
 var__temp_v_err610 --->  error  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h607, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h607, res ) ==((sel)( , var_h91, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h607, other ) ==(sel)( , var_h91, other ) => 
 	 Rel (sel)( , var__temp_h607, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h607, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'609, res ) ==(var__temp_v608) AND 
 	 Rel (sel)( , var__temp_h'609, res ) ==((sel)( , var__temp_h607, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'609, other ) ==(sel)( , var__temp_h607, other ) => 
 	 True
 
VC_END(declare-const var_h_i92 T2193)
(declare-const var_h91 T2193)
(declare-const v Int)
(declare-const var_h_i44 T2193)
(declare-const var_h43 T2193)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h607 T2193)
(declare-const var__temp_v608 Int)
(declare-const |var__temp_h'609| T2193)
(declare-const var__temp_v_err610 T2194)
(declare-const var_h91 T2193)
(declare-const var_h43 T2193)
(declare-const err T2207)

solver 
 (declare-sort T2193)
(declare-fun sel (T2193 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2193)
(declare-fun var_h43 () T2193)
(declare-fun other () Int)
(declare-fun var__temp_h607 () T2193)
(declare-fun |var__temp_h'609| () T2193)
(declare-fun var__temp_v608 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h607 res) v)
                (= (sel var__temp_h607 res) (+ (sel var_h91 res) 5))
                (= (sel var__temp_h607 other) (sel var_h91 other))))
      (a!2 (and (= (sel |var__temp_h'609| res) var__temp_v608)
                (= (sel |var__temp_h'609| res) (+ (sel var__temp_h607 res) 10))
                (= (sel |var__temp_h'609| other) (sel var__temp_h607 other)))))
(let ((a!3 (and (=> a!1 (> (sel var__temp_h607 res) 4))
                (=> (> (sel var__temp_h607 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************165
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i92 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i92, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i92, res ) ==((sel)( , var_h91, res ) + (5))
 	 , (sel)( , var_h_i92, other ) ==(sel)( , var_h91, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v594:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h611 --->  Ty_heap  
 var__temp_v612 --->  Ty_int  
 var__temp_h'613 --->  Ty_heap  
 var__temp_v_err614 --->  error  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h611, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h611, res ) ==((sel)( , var_h91, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h611, other ) ==(sel)( , var_h91, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'613, res ) ==(var__temp_v612) AND 
 	 Base var__temp_v612 = 5 AND 
 	 Rel (sel)( , var__temp_h'613, other ) ==(sel)( , var__temp_h611, other ) => 
 	 True
 
VC_END(declare-const var_h_i92 T2210)
(declare-const var_h91 T2210)
(declare-const v Int)
(declare-const var_h_i44 T2210)
(declare-const var_h43 T2210)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h611 T2210)
(declare-const var__temp_v612 Int)
(declare-const |var__temp_h'613| T2210)
(declare-const var__temp_v_err614 T2211)
(declare-const var_h91 T2210)
(declare-const var_h43 T2210)
(declare-const err T2224)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2210)
(declare-fun sel (T2210 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2210)
(declare-fun var_h43 () T2210)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h611 () T2210)
(declare-fun |var__temp_h'613| () T2210)
(declare-fun var__temp_v612 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h611 res) v)
                (= (sel var__temp_h611 res) (+ (sel var_h91 res) 5))
                (= (sel var__temp_h611 other) (sel var_h91 other))))
      (a!2 (=> (and (= (sel |var__temp_h'613| res) var__temp_v612)
                    (= var__temp_v612 |5|)
                    (= (sel |var__temp_h'613| other) (sel var__temp_h611 other)))
               true)))
  (not (and (=> a!1 true) (=> true a!2)))))

***************Selection Successful************foo
PARTIAL PATH NEW
SUB 
 	 --foo
 	 --c4
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i616 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i616 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i616, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i616, other ) ==(sel)( , var_h615, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v617:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i616 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
bar
 *********************Enumeration Iteration*****************166
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i616 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i616, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i616, other ) ==(sel)( , var_h615, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v617:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i616 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h618 --->  Ty_heap  
 var__temp_v619 --->  Ty_int  
 var__temp_h'620 --->  Ty_heap  
 var__temp_v_err621 --->  error  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h618, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h618, other ) ==(sel)( , var_h615, other ) => 
 	 Rel (sel)( , var__temp_h618, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h618, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'620, res ) ==(var__temp_v619) AND 
 	 Rel (sel)( , var__temp_h'620, res ) ==((sel)( , var__temp_h618, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'620, other ) ==(sel)( , var__temp_h618, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'620, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'620, other ) > (4)
 
VC_END(declare-const var_h_i616 T2227)
(declare-const var_h615 T2227)
(declare-const v Int)
(declare-const var_h_i92 T2227)
(declare-const var_h91 T2227)
(declare-const v Int)
(declare-const var_h_i44 T2227)
(declare-const var_h43 T2227)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h618 T2227)
(declare-const var__temp_v619 Int)
(declare-const |var__temp_h'620| T2227)
(declare-const var__temp_v_err621 T2228)
(declare-const var_h615 T2227)
(declare-const var_h91 T2227)
(declare-const var_h43 T2227)
(declare-const err T2241)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2227)
(declare-fun sel (T2227 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2227)
(declare-fun var_h43 () T2227)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'620| () T2227)
(declare-fun var__temp_h618 () T2227)
(declare-fun var__temp_v619 () Int)
(declare-fun var_h615 () T2227)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h618 res) v)
                    (= v |5|)
                    (= (sel var__temp_h618 other) (sel var_h615 other)))
               (= (sel var__temp_h618 res) 7)))
      (a!2 (and (= (sel |var__temp_h'620| res) var__temp_v619)
                (= (sel |var__temp_h'620| res) (+ (sel var__temp_h618 res) 3))
                (= (sel |var__temp_h'620| other) (sel var__temp_h618 other))))
      (a!3 (and (= (sel |var__temp_h'620| res) 10)
                (not (> (sel |var__temp_h'620| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h618 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************167
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i616 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i616, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i616, other ) ==(sel)( , var_h615, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v617:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i616 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h622 --->  Ty_heap  
 var__temp_v623 --->  Ty_int  
 var__temp_h'624 --->  Ty_heap  
 var__temp_v_err625 --->  error  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h622, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h622, other ) ==(sel)( , var_h615, other ) => 
 	 Rel (sel)( , var__temp_h622, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h622, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'624, res ) ==(var__temp_v623) AND 
 	 Rel (sel)( , var__temp_h'624, res ) ==((sel)( , var__temp_h622, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'624, other ) ==(sel)( , var__temp_h622, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'624, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'624, other ) > (4)
 
VC_END(declare-const var_h_i616 T2244)
(declare-const var_h615 T2244)
(declare-const v Int)
(declare-const var_h_i92 T2244)
(declare-const var_h91 T2244)
(declare-const v Int)
(declare-const var_h_i44 T2244)
(declare-const var_h43 T2244)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h622 T2244)
(declare-const var__temp_v623 Int)
(declare-const |var__temp_h'624| T2244)
(declare-const var__temp_v_err625 T2245)
(declare-const var_h615 T2244)
(declare-const var_h91 T2244)
(declare-const var_h43 T2244)
(declare-const err T2258)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2244)
(declare-fun sel (T2244 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2244)
(declare-fun var_h43 () T2244)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'624| () T2244)
(declare-fun var__temp_h622 () T2244)
(declare-fun var__temp_v623 () Int)
(declare-fun var_h615 () T2244)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h622 res) v)
                    (= v |5|)
                    (= (sel var__temp_h622 other) (sel var_h615 other)))
               (= (sel var__temp_h622 res) 7)))
      (a!2 (and (= (sel |var__temp_h'624| res) var__temp_v623)
                (= (sel |var__temp_h'624| res) (+ (sel var__temp_h622 res) 5))
                (= (sel |var__temp_h'624| other) (sel var__temp_h622 other))))
      (a!3 (and (= (sel |var__temp_h'624| res) 10)
                (not (> (sel |var__temp_h'624| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h622 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************168
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i616 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i616, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i616, other ) ==(sel)( , var_h615, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v617:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i616 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h626 --->  Ty_heap  
 var__temp_v627 --->  Ty_int  
 var__temp_h'628 --->  Ty_heap  
 var__temp_v_err629 --->  error  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h626, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h626, other ) ==(sel)( , var_h615, other ) => 
 	 Rel (sel)( , var__temp_h626, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h626, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'628, res ) ==(var__temp_v627) AND 
 	 Rel (sel)( , var__temp_h626, res ) ==(sel)( , var__temp_h626, res ) AND 
 	 Rel (sel)( , var__temp_h'628, other ) ==(sel)( , var__temp_h626, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'628, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'628, other ) > (4)
 
VC_END(declare-const var_h_i616 T2261)
(declare-const var_h615 T2261)
(declare-const v Int)
(declare-const var_h_i92 T2261)
(declare-const var_h91 T2261)
(declare-const v Int)
(declare-const var_h_i44 T2261)
(declare-const var_h43 T2261)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h626 T2261)
(declare-const var__temp_v627 Int)
(declare-const |var__temp_h'628| T2261)
(declare-const var__temp_v_err629 T2262)
(declare-const var_h615 T2261)
(declare-const var_h91 T2261)
(declare-const var_h43 T2261)
(declare-const err T2275)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2261)
(declare-fun sel (T2261 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2261)
(declare-fun var_h43 () T2261)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'628| () T2261)
(declare-fun var__temp_h626 () T2261)
(declare-fun var__temp_v627 () Int)
(declare-fun var_h615 () T2261)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h626 res) v)
                    (= v |5|)
                    (= (sel var__temp_h626 other) (sel var_h615 other)))
               (not (> (sel var__temp_h626 res) 20))))
      (a!2 (and (= (sel |var__temp_h'628| res) 10)
                (not (> (sel |var__temp_h'628| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'628| res) var__temp_v627)
                    (= (sel var__temp_h626 res) (sel var__temp_h626 res))
                    (= (sel |var__temp_h'628| other) (sel var__temp_h626 other)))
               a!2)))
(let ((a!4 (=> (not (> (sel var__temp_h626 res) 20)) a!3)))
  (not (and a!1 a!4))))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************169
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i616 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i616, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i616, other ) ==(sel)( , var_h615, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v617:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i616 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h630 --->  Ty_heap  
 var__temp_v631 --->  Ty_int  
 var__temp_h'632 --->  Ty_heap  
 var__temp_v_err633 --->  error  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h630, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h630, other ) ==(sel)( , var_h615, other ) => 
 	 Rel (sel)( , var__temp_h630, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h630, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'632, res ) ==(var__temp_v631) AND 
 	 Rel (sel)( , var__temp_h'632, res ) ==((sel)( , var__temp_h630, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'632, other ) ==(sel)( , var__temp_h630, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'632, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'632, other ) > (4)
 
VC_END(declare-const var_h_i616 T2278)
(declare-const var_h615 T2278)
(declare-const v Int)
(declare-const var_h_i92 T2278)
(declare-const var_h91 T2278)
(declare-const v Int)
(declare-const var_h_i44 T2278)
(declare-const var_h43 T2278)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h630 T2278)
(declare-const var__temp_v631 Int)
(declare-const |var__temp_h'632| T2278)
(declare-const var__temp_v_err633 T2279)
(declare-const var_h615 T2278)
(declare-const var_h91 T2278)
(declare-const var_h43 T2278)
(declare-const err T2292)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2278)
(declare-fun sel (T2278 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2278)
(declare-fun var_h43 () T2278)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'632| () T2278)
(declare-fun var__temp_h630 () T2278)
(declare-fun var__temp_v631 () Int)
(declare-fun var_h615 () T2278)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h630 res) v)
                    (= v |5|)
                    (= (sel var__temp_h630 other) (sel var_h615 other)))
               (> (sel var__temp_h630 res) 4)))
      (a!2 (and (= (sel |var__temp_h'632| res) var__temp_v631)
                (= (sel |var__temp_h'632| res) (+ (sel var__temp_h630 res) 10))
                (= (sel |var__temp_h'632| other) (sel var__temp_h630 other))))
      (a!3 (and (= (sel |var__temp_h'632| res) 10)
                (not (> (sel |var__temp_h'632| other) 4)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h630 res) 4) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************170
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i616 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i616, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i616, other ) ==(sel)( , var_h615, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v617:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i616 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h634 --->  Ty_heap  
 var__temp_v635 --->  Ty_int  
 var__temp_h'636 --->  Ty_heap  
 var__temp_v_err637 --->  error  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h634, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h634, other ) ==(sel)( , var_h615, other ) => 
 	 Rel (sel)( , var__temp_h634, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h634, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'636, res ) ==(var__temp_v635) AND 
 	 Rel (sel)( , var__temp_h'636, res ) ==((sel)( , var__temp_h634, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'636, other ) ==(sel)( , var__temp_h634, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'636, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'636, other ) > (4)
 
VC_END(declare-const var_h_i616 T2295)
(declare-const var_h615 T2295)
(declare-const v Int)
(declare-const var_h_i92 T2295)
(declare-const var_h91 T2295)
(declare-const v Int)
(declare-const var_h_i44 T2295)
(declare-const var_h43 T2295)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h634 T2295)
(declare-const var__temp_v635 Int)
(declare-const |var__temp_h'636| T2295)
(declare-const var__temp_v_err637 T2296)
(declare-const var_h615 T2295)
(declare-const var_h91 T2295)
(declare-const var_h43 T2295)
(declare-const err T2309)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2295)
(declare-fun sel (T2295 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2295)
(declare-fun var_h43 () T2295)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'636| () T2295)
(declare-fun var__temp_h634 () T2295)
(declare-fun var__temp_v635 () Int)
(declare-fun var_h615 () T2295)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h634 res) v)
                    (= v |5|)
                    (= (sel var__temp_h634 other) (sel var_h615 other)))
               (= (sel var__temp_h634 res) 5)))
      (a!2 (and (= (sel |var__temp_h'636| res) var__temp_v635)
                (= (sel |var__temp_h'636| res) (+ (sel var__temp_h634 res) 2))
                (= (sel |var__temp_h'636| other) (sel var__temp_h634 other))))
      (a!3 (and (= (sel |var__temp_h'636| res) 10)
                (not (> (sel |var__temp_h'636| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h634 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************171
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v617:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v617:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfoofoo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --foo
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i616 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i616, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i616, other ) ==(sel)( , var_h615, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v638:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
bar
 *********************Enumeration Iteration*****************172
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i616 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i616, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i616, other ) ==(sel)( , var_h615, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v638:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h639 --->  Ty_heap  
 var__temp_v640 --->  Ty_int  
 var__temp_h'641 --->  Ty_heap  
 var__temp_v_err642 --->  error  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h639, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h639, other ) ==(sel)( , var_h615, other ) => 
 	 Rel (sel)( , var__temp_h639, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h639, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'641, res ) ==(var__temp_v640) AND 
 	 Rel (sel)( , var__temp_h'641, res ) ==((sel)( , var__temp_h639, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'641, other ) ==(sel)( , var__temp_h639, other ) => 
 	 True
 
VC_END(declare-const var_h_i616 T2312)
(declare-const var_h615 T2312)
(declare-const v Int)
(declare-const var_h_i92 T2312)
(declare-const var_h91 T2312)
(declare-const v Int)
(declare-const var_h_i44 T2312)
(declare-const var_h43 T2312)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h639 T2312)
(declare-const var__temp_v640 Int)
(declare-const |var__temp_h'641| T2312)
(declare-const var__temp_v_err642 T2313)
(declare-const var_h615 T2312)
(declare-const var_h91 T2312)
(declare-const var_h43 T2312)
(declare-const err T2326)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2312)
(declare-fun sel (T2312 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2312)
(declare-fun var_h43 () T2312)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h639 () T2312)
(declare-fun |var__temp_h'641| () T2312)
(declare-fun var__temp_v640 () Int)
(declare-fun var_h615 () T2312)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h639 res) v)
                    (= v |5|)
                    (= (sel var__temp_h639 other) (sel var_h615 other)))
               (= (sel var__temp_h639 res) 7)))
      (a!2 (and (= (sel |var__temp_h'641| res) var__temp_v640)
                (= (sel |var__temp_h'641| res) (+ (sel var__temp_h639 res) 3))
                (= (sel |var__temp_h'641| other) (sel var__temp_h639 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h639 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************173
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i616 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i616, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i616, other ) ==(sel)( , var_h615, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v638:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h643 --->  Ty_heap  
 var__temp_v644 --->  Ty_int  
 var__temp_h'645 --->  Ty_heap  
 var__temp_v_err646 --->  error  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h643, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h643, other ) ==(sel)( , var_h615, other ) => 
 	 Rel (sel)( , var__temp_h643, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h643, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'645, res ) ==(var__temp_v644) AND 
 	 Rel (sel)( , var__temp_h'645, res ) ==((sel)( , var__temp_h643, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'645, other ) ==(sel)( , var__temp_h643, other ) => 
 	 True
 
VC_END(declare-const var_h_i616 T2329)
(declare-const var_h615 T2329)
(declare-const v Int)
(declare-const var_h_i92 T2329)
(declare-const var_h91 T2329)
(declare-const v Int)
(declare-const var_h_i44 T2329)
(declare-const var_h43 T2329)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h643 T2329)
(declare-const var__temp_v644 Int)
(declare-const |var__temp_h'645| T2329)
(declare-const var__temp_v_err646 T2330)
(declare-const var_h615 T2329)
(declare-const var_h91 T2329)
(declare-const var_h43 T2329)
(declare-const err T2343)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2329)
(declare-fun sel (T2329 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2329)
(declare-fun var_h43 () T2329)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h643 () T2329)
(declare-fun |var__temp_h'645| () T2329)
(declare-fun var__temp_v644 () Int)
(declare-fun var_h615 () T2329)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h643 res) v)
                    (= v |5|)
                    (= (sel var__temp_h643 other) (sel var_h615 other)))
               (= (sel var__temp_h643 res) 7)))
      (a!2 (and (= (sel |var__temp_h'645| res) var__temp_v644)
                (= (sel |var__temp_h'645| res) (+ (sel var__temp_h643 res) 5))
                (= (sel |var__temp_h'645| other) (sel var__temp_h643 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h643 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************174
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i616 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i616, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i616, other ) ==(sel)( , var_h615, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v638:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h647 --->  Ty_heap  
 var__temp_v648 --->  Ty_int  
 var__temp_h'649 --->  Ty_heap  
 var__temp_v_err650 --->  error  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h647, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h647, other ) ==(sel)( , var_h615, other ) => 
 	 Rel (sel)( , var__temp_h647, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h647, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'649, res ) ==(var__temp_v648) AND 
 	 Rel (sel)( , var__temp_h647, res ) ==(sel)( , var__temp_h647, res ) AND 
 	 Rel (sel)( , var__temp_h'649, other ) ==(sel)( , var__temp_h647, other ) => 
 	 True
 
VC_END(declare-const var_h_i616 T2346)
(declare-const var_h615 T2346)
(declare-const v Int)
(declare-const var_h_i92 T2346)
(declare-const var_h91 T2346)
(declare-const v Int)
(declare-const var_h_i44 T2346)
(declare-const var_h43 T2346)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h647 T2346)
(declare-const var__temp_v648 Int)
(declare-const |var__temp_h'649| T2346)
(declare-const var__temp_v_err650 T2347)
(declare-const var_h615 T2346)
(declare-const var_h91 T2346)
(declare-const var_h43 T2346)
(declare-const err T2360)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2346)
(declare-fun sel (T2346 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2346)
(declare-fun var_h43 () T2346)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h647 () T2346)
(declare-fun |var__temp_h'649| () T2346)
(declare-fun var__temp_v648 () Int)
(declare-fun var_h615 () T2346)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h647 res) v)
                    (= v |5|)
                    (= (sel var__temp_h647 other) (sel var_h615 other)))
               (not (> (sel var__temp_h647 res) 20))))
      (a!2 (=> (and (= (sel |var__temp_h'649| res) var__temp_v648)
                    (= (sel var__temp_h647 res) (sel var__temp_h647 res))
                    (= (sel |var__temp_h'649| other) (sel var__temp_h647 other)))
               true)))
(let ((a!3 (=> (not (> (sel var__temp_h647 res) 20)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Successful************c2'
PARTIAL PATH NEW
SUB 
 	 --c2'
 	 --foo
 	 --c4
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i652 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i652 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i652, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h651, res ) ==(sel)( , var_h651, res )
 	 , (sel)( , var_h_i652, other ) ==(sel)( , var_h651, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v653:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i652 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
bar
 *********************Enumeration Iteration*****************175
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i652 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i652, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h651, res ) ==(sel)( , var_h651, res )
 	 , (sel)( , var_h_i652, other ) ==(sel)( , var_h651, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v653:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i652 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i652 --->  Ty_heap  
 var_h651 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h654 --->  Ty_heap  
 var__temp_v655 --->  Ty_int  
 var__temp_h'656 --->  Ty_heap  
 var__temp_v_err657 --->  error  
 var_h651 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h651, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h654, res ) ==(v) AND 
 	 Rel (sel)( , var_h651, res ) ==(sel)( , var_h651, res ) AND 
 	 Rel (sel)( , var__temp_h654, other ) ==(sel)( , var_h651, other ) => 
 	 Rel (sel)( , var__temp_h654, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h654, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'656, res ) ==(var__temp_v655) AND 
 	 Rel (sel)( , var__temp_h'656, res ) ==((sel)( , var__temp_h654, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'656, other ) ==(sel)( , var__temp_h654, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'656, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'656, other ) > (4)
 
VC_END(declare-const var_h_i652 T2363)
(declare-const var_h651 T2363)
(declare-const v Int)
(declare-const var_h_i616 T2363)
(declare-const var_h615 T2363)
(declare-const v Int)
(declare-const var_h_i92 T2363)
(declare-const var_h91 T2363)
(declare-const v Int)
(declare-const var_h_i44 T2363)
(declare-const var_h43 T2363)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h654 T2363)
(declare-const var__temp_v655 Int)
(declare-const |var__temp_h'656| T2363)
(declare-const var__temp_v_err657 T2364)
(declare-const var_h651 T2363)
(declare-const var_h615 T2363)
(declare-const var_h91 T2363)
(declare-const var_h43 T2363)
(declare-const err T2377)

solver 
 (declare-sort T2363)
(declare-fun sel (T2363 Int) Int)
(declare-fun res () Int)
(declare-fun var_h651 () T2363)
(declare-fun var_h91 () T2363)
(declare-fun var_h43 () T2363)
(declare-fun other () Int)
(declare-fun |var__temp_h'656| () T2363)
(declare-fun var__temp_h654 () T2363)
(declare-fun var__temp_v655 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h651 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h654 res) v)
                    (= (sel var_h651 res) (sel var_h651 res))
                    (= (sel var__temp_h654 other) (sel var_h651 other)))
               (= (sel var__temp_h654 res) 7)))
      (a!2 (and (= (sel |var__temp_h'656| res) var__temp_v655)
                (= (sel |var__temp_h'656| res) (+ (sel var__temp_h654 res) 3))
                (= (sel |var__temp_h'656| other) (sel var__temp_h654 other))))
      (a!3 (and (= (sel |var__temp_h'656| res) 10)
                (not (> (sel |var__temp_h'656| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h654 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************176
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i652 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i652, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h651, res ) ==(sel)( , var_h651, res )
 	 , (sel)( , var_h_i652, other ) ==(sel)( , var_h651, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v653:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i652 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i652 --->  Ty_heap  
 var_h651 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h658 --->  Ty_heap  
 var__temp_v659 --->  Ty_int  
 var__temp_h'660 --->  Ty_heap  
 var__temp_v_err661 --->  error  
 var_h651 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h651, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h658, res ) ==(v) AND 
 	 Rel (sel)( , var_h651, res ) ==(sel)( , var_h651, res ) AND 
 	 Rel (sel)( , var__temp_h658, other ) ==(sel)( , var_h651, other ) => 
 	 Rel (sel)( , var__temp_h658, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h658, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'660, res ) ==(var__temp_v659) AND 
 	 Rel (sel)( , var__temp_h'660, res ) ==((sel)( , var__temp_h658, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'660, other ) ==(sel)( , var__temp_h658, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'660, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'660, other ) > (4)
 
VC_END(declare-const var_h_i652 T2380)
(declare-const var_h651 T2380)
(declare-const v Int)
(declare-const var_h_i616 T2380)
(declare-const var_h615 T2380)
(declare-const v Int)
(declare-const var_h_i92 T2380)
(declare-const var_h91 T2380)
(declare-const v Int)
(declare-const var_h_i44 T2380)
(declare-const var_h43 T2380)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h658 T2380)
(declare-const var__temp_v659 Int)
(declare-const |var__temp_h'660| T2380)
(declare-const var__temp_v_err661 T2381)
(declare-const var_h651 T2380)
(declare-const var_h615 T2380)
(declare-const var_h91 T2380)
(declare-const var_h43 T2380)
(declare-const err T2394)

solver 
 (declare-sort T2380)
(declare-fun sel (T2380 Int) Int)
(declare-fun res () Int)
(declare-fun var_h651 () T2380)
(declare-fun var_h91 () T2380)
(declare-fun var_h43 () T2380)
(declare-fun other () Int)
(declare-fun |var__temp_h'660| () T2380)
(declare-fun var__temp_h658 () T2380)
(declare-fun var__temp_v659 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h651 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h658 res) v)
                    (= (sel var_h651 res) (sel var_h651 res))
                    (= (sel var__temp_h658 other) (sel var_h651 other)))
               (= (sel var__temp_h658 res) 7)))
      (a!2 (and (= (sel |var__temp_h'660| res) var__temp_v659)
                (= (sel |var__temp_h'660| res) (+ (sel var__temp_h658 res) 5))
                (= (sel |var__temp_h'660| other) (sel var__temp_h658 other))))
      (a!3 (and (= (sel |var__temp_h'660| res) 10)
                (not (> (sel |var__temp_h'660| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h658 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************177
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i652 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i652, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h651, res ) ==(sel)( , var_h651, res )
 	 , (sel)( , var_h_i652, other ) ==(sel)( , var_h651, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v653:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i652 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i652 --->  Ty_heap  
 var_h651 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h662 --->  Ty_heap  
 var__temp_v663 --->  Ty_int  
 var__temp_h'664 --->  Ty_heap  
 var__temp_v_err665 --->  error  
 var_h651 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h651, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h662, res ) ==(v) AND 
 	 Rel (sel)( , var_h651, res ) ==(sel)( , var_h651, res ) AND 
 	 Rel (sel)( , var__temp_h662, other ) ==(sel)( , var_h651, other ) => 
 	 Rel (sel)( , var__temp_h662, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h662, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'664, res ) ==(var__temp_v663) AND 
 	 Rel (sel)( , var__temp_h'664, res ) ==((sel)( , var__temp_h662, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'664, other ) ==(sel)( , var__temp_h662, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'664, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'664, other ) > (4)
 
VC_END(declare-const var_h_i652 T2397)
(declare-const var_h651 T2397)
(declare-const v Int)
(declare-const var_h_i616 T2397)
(declare-const var_h615 T2397)
(declare-const v Int)
(declare-const var_h_i92 T2397)
(declare-const var_h91 T2397)
(declare-const v Int)
(declare-const var_h_i44 T2397)
(declare-const var_h43 T2397)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h662 T2397)
(declare-const var__temp_v663 Int)
(declare-const |var__temp_h'664| T2397)
(declare-const var__temp_v_err665 T2398)
(declare-const var_h651 T2397)
(declare-const var_h615 T2397)
(declare-const var_h91 T2397)
(declare-const var_h43 T2397)
(declare-const err T2411)

solver 
 (declare-sort T2397)
(declare-fun sel (T2397 Int) Int)
(declare-fun res () Int)
(declare-fun var_h651 () T2397)
(declare-fun var_h91 () T2397)
(declare-fun var_h43 () T2397)
(declare-fun other () Int)
(declare-fun |var__temp_h'664| () T2397)
(declare-fun var__temp_h662 () T2397)
(declare-fun var__temp_v663 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h651 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h662 res) v)
                    (= (sel var_h651 res) (sel var_h651 res))
                    (= (sel var__temp_h662 other) (sel var_h651 other)))
               (> (sel var__temp_h662 res) 4)))
      (a!2 (and (= (sel |var__temp_h'664| res) var__temp_v663)
                (= (sel |var__temp_h'664| res) (+ (sel var__temp_h662 res) 10))
                (= (sel |var__temp_h'664| other) (sel var__temp_h662 other))))
      (a!3 (and (= (sel |var__temp_h'664| res) 10)
                (not (> (sel |var__temp_h'664| other) 4)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h662 res) 4) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************178
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i652 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i652, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h651, res ) ==(sel)( , var_h651, res )
 	 , (sel)( , var_h_i652, other ) ==(sel)( , var_h651, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v653:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i652 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i652 --->  Ty_heap  
 var_h651 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h666 --->  Ty_heap  
 var__temp_v667 --->  Ty_int  
 var__temp_h'668 --->  Ty_heap  
 var__temp_v_err669 --->  error  
 var_h651 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h651, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h666, res ) ==(v) AND 
 	 Rel (sel)( , var_h651, res ) ==(sel)( , var_h651, res ) AND 
 	 Rel (sel)( , var__temp_h666, other ) ==(sel)( , var_h651, other ) => 
 	 Rel (sel)( , var__temp_h666, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h666, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'668, res ) ==(var__temp_v667) AND 
 	 Rel (sel)( , var__temp_h'668, res ) ==((sel)( , var__temp_h666, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'668, other ) ==(sel)( , var__temp_h666, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'668, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'668, other ) > (4)
 
VC_END(declare-const var_h_i652 T2414)
(declare-const var_h651 T2414)
(declare-const v Int)
(declare-const var_h_i616 T2414)
(declare-const var_h615 T2414)
(declare-const v Int)
(declare-const var_h_i92 T2414)
(declare-const var_h91 T2414)
(declare-const v Int)
(declare-const var_h_i44 T2414)
(declare-const var_h43 T2414)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h666 T2414)
(declare-const var__temp_v667 Int)
(declare-const |var__temp_h'668| T2414)
(declare-const var__temp_v_err669 T2415)
(declare-const var_h651 T2414)
(declare-const var_h615 T2414)
(declare-const var_h91 T2414)
(declare-const var_h43 T2414)
(declare-const err T2428)

solver 
 (declare-sort T2414)
(declare-fun sel (T2414 Int) Int)
(declare-fun res () Int)
(declare-fun var_h651 () T2414)
(declare-fun var_h91 () T2414)
(declare-fun var_h43 () T2414)
(declare-fun other () Int)
(declare-fun |var__temp_h'668| () T2414)
(declare-fun var__temp_h666 () T2414)
(declare-fun var__temp_v667 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h651 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h666 res) v)
                    (= (sel var_h651 res) (sel var_h651 res))
                    (= (sel var__temp_h666 other) (sel var_h651 other)))
               (= (sel var__temp_h666 res) 5)))
      (a!2 (and (= (sel |var__temp_h'668| res) var__temp_v667)
                (= (sel |var__temp_h'668| res) (+ (sel var__temp_h666 res) 2))
                (= (sel |var__temp_h'668| other) (sel var__temp_h666 other))))
      (a!3 (and (= (sel |var__temp_h'668| res) 10)
                (not (> (sel |var__temp_h'668| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h666 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************179
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v653:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v653:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2'foofoo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c2'
 	 --foo
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i652 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i652, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h651, res ) ==(sel)( , var_h651, res )
 	 , (sel)( , var_h_i652, other ) ==(sel)( , var_h651, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v670:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
bar
 *********************Enumeration Iteration*****************180
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i652 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i652, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h651, res ) ==(sel)( , var_h651, res )
 	 , (sel)( , var_h_i652, other ) ==(sel)( , var_h651, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v670:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i652 --->  Ty_heap  
 var_h651 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h671 --->  Ty_heap  
 var__temp_v672 --->  Ty_int  
 var__temp_h'673 --->  Ty_heap  
 var__temp_v_err674 --->  error  
 var_h651 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h651, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h671, res ) ==(v) AND 
 	 Rel (sel)( , var_h651, res ) ==(sel)( , var_h651, res ) AND 
 	 Rel (sel)( , var__temp_h671, other ) ==(sel)( , var_h651, other ) => 
 	 Rel (sel)( , var__temp_h671, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h671, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'673, res ) ==(var__temp_v672) AND 
 	 Rel (sel)( , var__temp_h'673, res ) ==((sel)( , var__temp_h671, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'673, other ) ==(sel)( , var__temp_h671, other ) => 
 	 True
 
VC_END(declare-const var_h_i652 T2431)
(declare-const var_h651 T2431)
(declare-const v Int)
(declare-const var_h_i616 T2431)
(declare-const var_h615 T2431)
(declare-const v Int)
(declare-const var_h_i92 T2431)
(declare-const var_h91 T2431)
(declare-const v Int)
(declare-const var_h_i44 T2431)
(declare-const var_h43 T2431)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h671 T2431)
(declare-const var__temp_v672 Int)
(declare-const |var__temp_h'673| T2431)
(declare-const var__temp_v_err674 T2432)
(declare-const var_h651 T2431)
(declare-const var_h615 T2431)
(declare-const var_h91 T2431)
(declare-const var_h43 T2431)
(declare-const err T2445)

solver 
 (declare-sort T2431)
(declare-fun sel (T2431 Int) Int)
(declare-fun res () Int)
(declare-fun var_h651 () T2431)
(declare-fun var_h91 () T2431)
(declare-fun var_h43 () T2431)
(declare-fun other () Int)
(declare-fun var__temp_h671 () T2431)
(declare-fun |var__temp_h'673| () T2431)
(declare-fun var__temp_v672 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h651 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h671 res) v)
                    (= (sel var_h651 res) (sel var_h651 res))
                    (= (sel var__temp_h671 other) (sel var_h651 other)))
               (= (sel var__temp_h671 res) 7)))
      (a!2 (and (= (sel |var__temp_h'673| res) var__temp_v672)
                (= (sel |var__temp_h'673| res) (+ (sel var__temp_h671 res) 3))
                (= (sel |var__temp_h'673| other) (sel var__temp_h671 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h671 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************181
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i652 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i652, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h651, res ) ==(sel)( , var_h651, res )
 	 , (sel)( , var_h_i652, other ) ==(sel)( , var_h651, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v670:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i652 --->  Ty_heap  
 var_h651 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h675 --->  Ty_heap  
 var__temp_v676 --->  Ty_int  
 var__temp_h'677 --->  Ty_heap  
 var__temp_v_err678 --->  error  
 var_h651 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h651, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h675, res ) ==(v) AND 
 	 Rel (sel)( , var_h651, res ) ==(sel)( , var_h651, res ) AND 
 	 Rel (sel)( , var__temp_h675, other ) ==(sel)( , var_h651, other ) => 
 	 Rel (sel)( , var__temp_h675, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h675, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'677, res ) ==(var__temp_v676) AND 
 	 Rel (sel)( , var__temp_h'677, res ) ==((sel)( , var__temp_h675, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'677, other ) ==(sel)( , var__temp_h675, other ) => 
 	 True
 
VC_END(declare-const var_h_i652 T2448)
(declare-const var_h651 T2448)
(declare-const v Int)
(declare-const var_h_i616 T2448)
(declare-const var_h615 T2448)
(declare-const v Int)
(declare-const var_h_i92 T2448)
(declare-const var_h91 T2448)
(declare-const v Int)
(declare-const var_h_i44 T2448)
(declare-const var_h43 T2448)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h675 T2448)
(declare-const var__temp_v676 Int)
(declare-const |var__temp_h'677| T2448)
(declare-const var__temp_v_err678 T2449)
(declare-const var_h651 T2448)
(declare-const var_h615 T2448)
(declare-const var_h91 T2448)
(declare-const var_h43 T2448)
(declare-const err T2462)

solver 
 (declare-sort T2448)
(declare-fun sel (T2448 Int) Int)
(declare-fun res () Int)
(declare-fun var_h651 () T2448)
(declare-fun var_h91 () T2448)
(declare-fun var_h43 () T2448)
(declare-fun other () Int)
(declare-fun var__temp_h675 () T2448)
(declare-fun |var__temp_h'677| () T2448)
(declare-fun var__temp_v676 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h651 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h675 res) v)
                    (= (sel var_h651 res) (sel var_h651 res))
                    (= (sel var__temp_h675 other) (sel var_h651 other)))
               (= (sel var__temp_h675 res) 7)))
      (a!2 (and (= (sel |var__temp_h'677| res) var__temp_v676)
                (= (sel |var__temp_h'677| res) (+ (sel var__temp_h675 res) 5))
                (= (sel |var__temp_h'677| other) (sel var__temp_h675 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h675 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************182
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i652 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i652, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h651, res ) ==(sel)( , var_h651, res )
 	 , (sel)( , var_h_i652, other ) ==(sel)( , var_h651, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v670:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i652 --->  Ty_heap  
 var_h651 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h679 --->  Ty_heap  
 var__temp_v680 --->  Ty_int  
 var__temp_h'681 --->  Ty_heap  
 var__temp_v_err682 --->  error  
 var_h651 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h651, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h679, res ) ==(v) AND 
 	 Rel (sel)( , var_h651, res ) ==(sel)( , var_h651, res ) AND 
 	 Rel (sel)( , var__temp_h679, other ) ==(sel)( , var_h651, other ) => 
 	 Rel (sel)( , var__temp_h679, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h679, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'681, res ) ==(var__temp_v680) AND 
 	 Rel (sel)( , var__temp_h'681, res ) ==((sel)( , var__temp_h679, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'681, other ) ==(sel)( , var__temp_h679, other ) => 
 	 True
 
VC_END(declare-const var_h_i652 T2465)
(declare-const var_h651 T2465)
(declare-const v Int)
(declare-const var_h_i616 T2465)
(declare-const var_h615 T2465)
(declare-const v Int)
(declare-const var_h_i92 T2465)
(declare-const var_h91 T2465)
(declare-const v Int)
(declare-const var_h_i44 T2465)
(declare-const var_h43 T2465)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h679 T2465)
(declare-const var__temp_v680 Int)
(declare-const |var__temp_h'681| T2465)
(declare-const var__temp_v_err682 T2466)
(declare-const var_h651 T2465)
(declare-const var_h615 T2465)
(declare-const var_h91 T2465)
(declare-const var_h43 T2465)
(declare-const err T2479)

solver 
 (declare-sort T2465)
(declare-fun sel (T2465 Int) Int)
(declare-fun res () Int)
(declare-fun var_h651 () T2465)
(declare-fun var_h91 () T2465)
(declare-fun var_h43 () T2465)
(declare-fun other () Int)
(declare-fun var__temp_h679 () T2465)
(declare-fun |var__temp_h'681| () T2465)
(declare-fun var__temp_v680 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h651 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h679 res) v)
                    (= (sel var_h651 res) (sel var_h651 res))
                    (= (sel var__temp_h679 other) (sel var_h651 other)))
               (> (sel var__temp_h679 res) 4)))
      (a!2 (and (= (sel |var__temp_h'681| res) var__temp_v680)
                (= (sel |var__temp_h'681| res) (+ (sel var__temp_h679 res) 10))
                (= (sel |var__temp_h'681| other) (sel var__temp_h679 other)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h679 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************183
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i652 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i652, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h651, res ) ==(sel)( , var_h651, res )
 	 , (sel)( , var_h_i652, other ) ==(sel)( , var_h651, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v670:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i652 --->  Ty_heap  
 var_h651 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h683 --->  Ty_heap  
 var__temp_v684 --->  Ty_int  
 var__temp_h'685 --->  Ty_heap  
 var__temp_v_err686 --->  error  
 var_h651 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h651, res ) > (20) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h683, res ) ==(v) AND 
 	 Rel (sel)( , var_h651, res ) ==(sel)( , var_h651, res ) AND 
 	 Rel (sel)( , var__temp_h683, other ) ==(sel)( , var_h651, other ) => 
 	 Rel (sel)( , var__temp_h683, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h683, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'685, res ) ==(var__temp_v684) AND 
 	 Rel (sel)( , var__temp_h'685, res ) ==((sel)( , var__temp_h683, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'685, other ) ==(sel)( , var__temp_h683, other ) => 
 	 True
 
VC_END(declare-const var_h_i652 T2482)
(declare-const var_h651 T2482)
(declare-const v Int)
(declare-const var_h_i616 T2482)
(declare-const var_h615 T2482)
(declare-const v Int)
(declare-const var_h_i92 T2482)
(declare-const var_h91 T2482)
(declare-const v Int)
(declare-const var_h_i44 T2482)
(declare-const var_h43 T2482)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h683 T2482)
(declare-const var__temp_v684 Int)
(declare-const |var__temp_h'685| T2482)
(declare-const var__temp_v_err686 T2483)
(declare-const var_h651 T2482)
(declare-const var_h615 T2482)
(declare-const var_h91 T2482)
(declare-const var_h43 T2482)
(declare-const err T2496)

solver 
 (declare-sort T2482)
(declare-fun sel (T2482 Int) Int)
(declare-fun res () Int)
(declare-fun var_h651 () T2482)
(declare-fun var_h91 () T2482)
(declare-fun var_h43 () T2482)
(declare-fun other () Int)
(declare-fun var__temp_h683 () T2482)
(declare-fun |var__temp_h'685| () T2482)
(declare-fun var__temp_v684 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h651 res) 20)))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h683 res) v)
                    (= (sel var_h651 res) (sel var_h651 res))
                    (= (sel var__temp_h683 other) (sel var_h651 other)))
               (= (sel var__temp_h683 res) 5)))
      (a!2 (and (= (sel |var__temp_h'685| res) var__temp_v684)
                (= (sel |var__temp_h'685| res) (+ (sel var__temp_h683 res) 2))
                (= (sel |var__temp_h'685| other) (sel var__temp_h683 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h683 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************184
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2'
PARTIAL PATH
SUB 
 	 --foo
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i616 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i616, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i616, other ) ==(sel)( , var_h615, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v687:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
bar
 *********************Enumeration Iteration*****************185
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i616 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i616, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i616, other ) ==(sel)( , var_h615, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v687:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h688 --->  Ty_heap  
 var__temp_v689 --->  Ty_int  
 var__temp_h'690 --->  Ty_heap  
 var__temp_v_err691 --->  error  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h688, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h688, other ) ==(sel)( , var_h615, other ) => 
 	 Rel (sel)( , var__temp_h688, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h688, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'690, res ) ==(var__temp_v689) AND 
 	 Rel (sel)( , var__temp_h'690, res ) ==((sel)( , var__temp_h688, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'690, other ) ==(sel)( , var__temp_h688, other ) => 
 	 True
 
VC_END(declare-const var_h_i616 T2499)
(declare-const var_h615 T2499)
(declare-const v Int)
(declare-const var_h_i92 T2499)
(declare-const var_h91 T2499)
(declare-const v Int)
(declare-const var_h_i44 T2499)
(declare-const var_h43 T2499)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h688 T2499)
(declare-const var__temp_v689 Int)
(declare-const |var__temp_h'690| T2499)
(declare-const var__temp_v_err691 T2500)
(declare-const var_h615 T2499)
(declare-const var_h91 T2499)
(declare-const var_h43 T2499)
(declare-const err T2513)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2499)
(declare-fun sel (T2499 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2499)
(declare-fun var_h43 () T2499)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h688 () T2499)
(declare-fun |var__temp_h'690| () T2499)
(declare-fun var__temp_v689 () Int)
(declare-fun var_h615 () T2499)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h688 res) v)
                    (= v |5|)
                    (= (sel var__temp_h688 other) (sel var_h615 other)))
               (= (sel var__temp_h688 res) 7)))
      (a!2 (and (= (sel |var__temp_h'690| res) var__temp_v689)
                (= (sel |var__temp_h'690| res) (+ (sel var__temp_h688 res) 3))
                (= (sel |var__temp_h'690| other) (sel var__temp_h688 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h688 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************186
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i616 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i616, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i616, other ) ==(sel)( , var_h615, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v687:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h692 --->  Ty_heap  
 var__temp_v693 --->  Ty_int  
 var__temp_h'694 --->  Ty_heap  
 var__temp_v_err695 --->  error  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h692, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h692, other ) ==(sel)( , var_h615, other ) => 
 	 Rel (sel)( , var__temp_h692, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h692, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'694, res ) ==(var__temp_v693) AND 
 	 Rel (sel)( , var__temp_h'694, res ) ==((sel)( , var__temp_h692, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'694, other ) ==(sel)( , var__temp_h692, other ) => 
 	 True
 
VC_END(declare-const var_h_i616 T2516)
(declare-const var_h615 T2516)
(declare-const v Int)
(declare-const var_h_i92 T2516)
(declare-const var_h91 T2516)
(declare-const v Int)
(declare-const var_h_i44 T2516)
(declare-const var_h43 T2516)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h692 T2516)
(declare-const var__temp_v693 Int)
(declare-const |var__temp_h'694| T2516)
(declare-const var__temp_v_err695 T2517)
(declare-const var_h615 T2516)
(declare-const var_h91 T2516)
(declare-const var_h43 T2516)
(declare-const err T2530)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2516)
(declare-fun sel (T2516 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2516)
(declare-fun var_h43 () T2516)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h692 () T2516)
(declare-fun |var__temp_h'694| () T2516)
(declare-fun var__temp_v693 () Int)
(declare-fun var_h615 () T2516)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h692 res) v)
                    (= v |5|)
                    (= (sel var__temp_h692 other) (sel var_h615 other)))
               (= (sel var__temp_h692 res) 7)))
      (a!2 (and (= (sel |var__temp_h'694| res) var__temp_v693)
                (= (sel |var__temp_h'694| res) (+ (sel var__temp_h692 res) 5))
                (= (sel |var__temp_h'694| other) (sel var__temp_h692 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h692 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************187
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i616 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i616, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i616, other ) ==(sel)( , var_h615, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v687:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h696 --->  Ty_heap  
 var__temp_v697 --->  Ty_int  
 var__temp_h'698 --->  Ty_heap  
 var__temp_v_err699 --->  error  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h696, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h696, other ) ==(sel)( , var_h615, other ) => 
 	 Rel (sel)( , var__temp_h696, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h696, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'698, res ) ==(var__temp_v697) AND 
 	 Rel (sel)( , var__temp_h'698, res ) ==((sel)( , var__temp_h696, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'698, other ) ==(sel)( , var__temp_h696, other ) => 
 	 True
 
VC_END(declare-const var_h_i616 T2533)
(declare-const var_h615 T2533)
(declare-const v Int)
(declare-const var_h_i92 T2533)
(declare-const var_h91 T2533)
(declare-const v Int)
(declare-const var_h_i44 T2533)
(declare-const var_h43 T2533)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h696 T2533)
(declare-const var__temp_v697 Int)
(declare-const |var__temp_h'698| T2533)
(declare-const var__temp_v_err699 T2534)
(declare-const var_h615 T2533)
(declare-const var_h91 T2533)
(declare-const var_h43 T2533)
(declare-const err T2547)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2533)
(declare-fun sel (T2533 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2533)
(declare-fun var_h43 () T2533)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h696 () T2533)
(declare-fun |var__temp_h'698| () T2533)
(declare-fun var__temp_v697 () Int)
(declare-fun var_h615 () T2533)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h696 res) v)
                    (= v |5|)
                    (= (sel var__temp_h696 other) (sel var_h615 other)))
               (> (sel var__temp_h696 res) 4)))
      (a!2 (and (= (sel |var__temp_h'698| res) var__temp_v697)
                (= (sel |var__temp_h'698| res) (+ (sel var__temp_h696 res) 10))
                (= (sel |var__temp_h'698| other) (sel var__temp_h696 other)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h696 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c2
PARTIAL PATH NEW
SUB 
 	 --c2
 	 --foo
 	 --c4
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i701 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i701 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i701, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i701, res ) ==((sel)( , var_h700, res ) + (10))
 	 , (sel)( , var_h_i701, other ) ==(sel)( , var_h700, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v702:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i701 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************188
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i701 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i701, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i701, res ) ==((sel)( , var_h700, res ) + (10))
 	 , (sel)( , var_h_i701, other ) ==(sel)( , var_h700, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v702:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i701 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i701 --->  Ty_heap  
 var_h700 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h703 --->  Ty_heap  
 var__temp_v704 --->  Ty_int  
 var__temp_h'705 --->  Ty_heap  
 var__temp_v_err706 --->  error  
 var_h700 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h700, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h703, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h703, res ) ==((sel)( , var_h700, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h703, other ) ==(sel)( , var_h700, other ) => 
 	 Rel (sel)( , var__temp_h703, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h703, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'705, res ) ==(var__temp_v704) AND 
 	 Rel (sel)( , var__temp_h'705, res ) ==((sel)( , var__temp_h703, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'705, other ) ==(sel)( , var__temp_h703, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'705, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'705, other ) > (4)
 
VC_END(declare-const var_h_i701 T2550)
(declare-const var_h700 T2550)
(declare-const v Int)
(declare-const var_h_i616 T2550)
(declare-const var_h615 T2550)
(declare-const v Int)
(declare-const var_h_i92 T2550)
(declare-const var_h91 T2550)
(declare-const v Int)
(declare-const var_h_i44 T2550)
(declare-const var_h43 T2550)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h703 T2550)
(declare-const var__temp_v704 Int)
(declare-const |var__temp_h'705| T2550)
(declare-const var__temp_v_err706 T2551)
(declare-const var_h700 T2550)
(declare-const var_h615 T2550)
(declare-const var_h91 T2550)
(declare-const var_h43 T2550)
(declare-const err T2564)

solver 
 (declare-sort T2550)
(declare-fun sel (T2550 Int) Int)
(declare-fun res () Int)
(declare-fun var_h700 () T2550)
(declare-fun var_h91 () T2550)
(declare-fun var_h43 () T2550)
(declare-fun other () Int)
(declare-fun |var__temp_h'705| () T2550)
(declare-fun var__temp_h703 () T2550)
(declare-fun var__temp_v704 () Int)
(declare-fun v () Int)
(assert (> (sel var_h700 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h703 res) v)
                (= (sel var__temp_h703 res) (+ (sel var_h700 res) 10))
                (= (sel var__temp_h703 other) (sel var_h700 other))))
      (a!2 (and (= (sel |var__temp_h'705| res) var__temp_v704)
                (= (sel |var__temp_h'705| res) (+ (sel var__temp_h703 res) 3))
                (= (sel |var__temp_h'705| other) (sel var__temp_h703 other))))
      (a!3 (and (= (sel |var__temp_h'705| res) 10)
                (not (> (sel |var__temp_h'705| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h703 res) 7))
                (=> (= (sel var__temp_h703 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************189
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i701 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i701, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i701, res ) ==((sel)( , var_h700, res ) + (10))
 	 , (sel)( , var_h_i701, other ) ==(sel)( , var_h700, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v702:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i701 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i701 --->  Ty_heap  
 var_h700 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h707 --->  Ty_heap  
 var__temp_v708 --->  Ty_int  
 var__temp_h'709 --->  Ty_heap  
 var__temp_v_err710 --->  error  
 var_h700 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h700, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h707, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h707, res ) ==((sel)( , var_h700, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h707, other ) ==(sel)( , var_h700, other ) => 
 	 Rel (sel)( , var__temp_h707, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h707, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'709, res ) ==(var__temp_v708) AND 
 	 Rel (sel)( , var__temp_h'709, res ) ==((sel)( , var__temp_h707, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'709, other ) ==(sel)( , var__temp_h707, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'709, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'709, other ) > (4)
 
VC_END(declare-const var_h_i701 T2567)
(declare-const var_h700 T2567)
(declare-const v Int)
(declare-const var_h_i616 T2567)
(declare-const var_h615 T2567)
(declare-const v Int)
(declare-const var_h_i92 T2567)
(declare-const var_h91 T2567)
(declare-const v Int)
(declare-const var_h_i44 T2567)
(declare-const var_h43 T2567)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h707 T2567)
(declare-const var__temp_v708 Int)
(declare-const |var__temp_h'709| T2567)
(declare-const var__temp_v_err710 T2568)
(declare-const var_h700 T2567)
(declare-const var_h615 T2567)
(declare-const var_h91 T2567)
(declare-const var_h43 T2567)
(declare-const err T2581)

solver 
 (declare-sort T2567)
(declare-fun sel (T2567 Int) Int)
(declare-fun res () Int)
(declare-fun var_h700 () T2567)
(declare-fun var_h91 () T2567)
(declare-fun var_h43 () T2567)
(declare-fun other () Int)
(declare-fun |var__temp_h'709| () T2567)
(declare-fun var__temp_h707 () T2567)
(declare-fun var__temp_v708 () Int)
(declare-fun v () Int)
(assert (> (sel var_h700 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h707 res) v)
                (= (sel var__temp_h707 res) (+ (sel var_h700 res) 10))
                (= (sel var__temp_h707 other) (sel var_h700 other))))
      (a!2 (and (= (sel |var__temp_h'709| res) var__temp_v708)
                (= (sel |var__temp_h'709| res) (+ (sel var__temp_h707 res) 5))
                (= (sel |var__temp_h'709| other) (sel var__temp_h707 other))))
      (a!3 (and (= (sel |var__temp_h'709| res) 10)
                (not (> (sel |var__temp_h'709| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h707 res) 7))
                (=> (= (sel var__temp_h707 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************190
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i701 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i701, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i701, res ) ==((sel)( , var_h700, res ) + (10))
 	 , (sel)( , var_h_i701, other ) ==(sel)( , var_h700, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v702:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i701 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i701 --->  Ty_heap  
 var_h700 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h711 --->  Ty_heap  
 var__temp_v712 --->  Ty_int  
 var__temp_h'713 --->  Ty_heap  
 var__temp_v_err714 --->  error  
 var_h700 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h700, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h711, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h711, res ) ==((sel)( , var_h700, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h711, other ) ==(sel)( , var_h700, other ) => 
 	 Rel (sel)( , var__temp_h711, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h711, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'713, res ) ==(var__temp_v712) AND 
 	 Rel (sel)( , var__temp_h'713, res ) ==((sel)( , var__temp_h711, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'713, other ) ==(sel)( , var__temp_h711, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'713, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'713, other ) > (4)
 
VC_END(declare-const var_h_i701 T2584)
(declare-const var_h700 T2584)
(declare-const v Int)
(declare-const var_h_i616 T2584)
(declare-const var_h615 T2584)
(declare-const v Int)
(declare-const var_h_i92 T2584)
(declare-const var_h91 T2584)
(declare-const v Int)
(declare-const var_h_i44 T2584)
(declare-const var_h43 T2584)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h711 T2584)
(declare-const var__temp_v712 Int)
(declare-const |var__temp_h'713| T2584)
(declare-const var__temp_v_err714 T2585)
(declare-const var_h700 T2584)
(declare-const var_h615 T2584)
(declare-const var_h91 T2584)
(declare-const var_h43 T2584)
(declare-const err T2598)

solver 
 (declare-sort T2584)
(declare-fun sel (T2584 Int) Int)
(declare-fun res () Int)
(declare-fun var_h700 () T2584)
(declare-fun var_h91 () T2584)
(declare-fun var_h43 () T2584)
(declare-fun other () Int)
(declare-fun |var__temp_h'713| () T2584)
(declare-fun var__temp_h711 () T2584)
(declare-fun var__temp_v712 () Int)
(declare-fun v () Int)
(assert (> (sel var_h700 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h711 res) v)
                (= (sel var__temp_h711 res) (+ (sel var_h700 res) 10))
                (= (sel var__temp_h711 other) (sel var_h700 other))))
      (a!2 (and (= (sel |var__temp_h'713| res) var__temp_v712)
                (= (sel |var__temp_h'713| res) (+ (sel var__temp_h711 res) 2))
                (= (sel |var__temp_h'713| other) (sel var__temp_h711 other))))
      (a!3 (and (= (sel |var__temp_h'713| res) 10)
                (not (> (sel |var__temp_h'713| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h711 res) 5))
                (=> (= (sel var__temp_h711 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************191
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v702:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v702:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2c2'foofoo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c2
 	 --foo
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i701 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i701, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i701, res ) ==((sel)( , var_h700, res ) + (10))
 	 , (sel)( , var_h_i701, other ) ==(sel)( , var_h700, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v715:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************192
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i701 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i701, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i701, res ) ==((sel)( , var_h700, res ) + (10))
 	 , (sel)( , var_h_i701, other ) ==(sel)( , var_h700, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v715:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i701 --->  Ty_heap  
 var_h700 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h716 --->  Ty_heap  
 var__temp_v717 --->  Ty_int  
 var__temp_h'718 --->  Ty_heap  
 var__temp_v_err719 --->  error  
 var_h700 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h700, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h716, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h716, res ) ==((sel)( , var_h700, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h716, other ) ==(sel)( , var_h700, other ) => 
 	 Rel (sel)( , var__temp_h716, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h716, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'718, res ) ==(var__temp_v717) AND 
 	 Rel (sel)( , var__temp_h'718, res ) ==((sel)( , var__temp_h716, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'718, other ) ==(sel)( , var__temp_h716, other ) => 
 	 True
 
VC_END(declare-const var_h_i701 T2601)
(declare-const var_h700 T2601)
(declare-const v Int)
(declare-const var_h_i616 T2601)
(declare-const var_h615 T2601)
(declare-const v Int)
(declare-const var_h_i92 T2601)
(declare-const var_h91 T2601)
(declare-const v Int)
(declare-const var_h_i44 T2601)
(declare-const var_h43 T2601)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h716 T2601)
(declare-const var__temp_v717 Int)
(declare-const |var__temp_h'718| T2601)
(declare-const var__temp_v_err719 T2602)
(declare-const var_h700 T2601)
(declare-const var_h615 T2601)
(declare-const var_h91 T2601)
(declare-const var_h43 T2601)
(declare-const err T2615)

solver 
 (declare-sort T2601)
(declare-fun sel (T2601 Int) Int)
(declare-fun res () Int)
(declare-fun var_h700 () T2601)
(declare-fun var_h91 () T2601)
(declare-fun var_h43 () T2601)
(declare-fun other () Int)
(declare-fun var__temp_h716 () T2601)
(declare-fun |var__temp_h'718| () T2601)
(declare-fun var__temp_v717 () Int)
(declare-fun v () Int)
(assert (> (sel var_h700 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h716 res) v)
                (= (sel var__temp_h716 res) (+ (sel var_h700 res) 10))
                (= (sel var__temp_h716 other) (sel var_h700 other))))
      (a!2 (and (= (sel |var__temp_h'718| res) var__temp_v717)
                (= (sel |var__temp_h'718| res) (+ (sel var__temp_h716 res) 3))
                (= (sel |var__temp_h'718| other) (sel var__temp_h716 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h716 res) 7))
                (=> (= (sel var__temp_h716 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************193
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i701 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i701, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i701, res ) ==((sel)( , var_h700, res ) + (10))
 	 , (sel)( , var_h_i701, other ) ==(sel)( , var_h700, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v715:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i701 --->  Ty_heap  
 var_h700 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h720 --->  Ty_heap  
 var__temp_v721 --->  Ty_int  
 var__temp_h'722 --->  Ty_heap  
 var__temp_v_err723 --->  error  
 var_h700 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h700, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h720, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h720, res ) ==((sel)( , var_h700, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h720, other ) ==(sel)( , var_h700, other ) => 
 	 Rel (sel)( , var__temp_h720, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h720, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'722, res ) ==(var__temp_v721) AND 
 	 Rel (sel)( , var__temp_h'722, res ) ==((sel)( , var__temp_h720, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'722, other ) ==(sel)( , var__temp_h720, other ) => 
 	 True
 
VC_END(declare-const var_h_i701 T2618)
(declare-const var_h700 T2618)
(declare-const v Int)
(declare-const var_h_i616 T2618)
(declare-const var_h615 T2618)
(declare-const v Int)
(declare-const var_h_i92 T2618)
(declare-const var_h91 T2618)
(declare-const v Int)
(declare-const var_h_i44 T2618)
(declare-const var_h43 T2618)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h720 T2618)
(declare-const var__temp_v721 Int)
(declare-const |var__temp_h'722| T2618)
(declare-const var__temp_v_err723 T2619)
(declare-const var_h700 T2618)
(declare-const var_h615 T2618)
(declare-const var_h91 T2618)
(declare-const var_h43 T2618)
(declare-const err T2632)

solver 
 (declare-sort T2618)
(declare-fun sel (T2618 Int) Int)
(declare-fun res () Int)
(declare-fun var_h700 () T2618)
(declare-fun var_h91 () T2618)
(declare-fun var_h43 () T2618)
(declare-fun other () Int)
(declare-fun var__temp_h720 () T2618)
(declare-fun |var__temp_h'722| () T2618)
(declare-fun var__temp_v721 () Int)
(declare-fun v () Int)
(assert (> (sel var_h700 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h720 res) v)
                (= (sel var__temp_h720 res) (+ (sel var_h700 res) 10))
                (= (sel var__temp_h720 other) (sel var_h700 other))))
      (a!2 (and (= (sel |var__temp_h'722| res) var__temp_v721)
                (= (sel |var__temp_h'722| res) (+ (sel var__temp_h720 res) 5))
                (= (sel |var__temp_h'722| other) (sel var__temp_h720 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h720 res) 7))
                (=> (= (sel var__temp_h720 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************194
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i701 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i701, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i701, res ) ==((sel)( , var_h700, res ) + (10))
 	 , (sel)( , var_h_i701, other ) ==(sel)( , var_h700, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v715:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i701 --->  Ty_heap  
 var_h700 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h724 --->  Ty_heap  
 var__temp_v725 --->  Ty_int  
 var__temp_h'726 --->  Ty_heap  
 var__temp_v_err727 --->  error  
 var_h700 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h700, res ) > (4) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h724, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h724, res ) ==((sel)( , var_h700, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h724, other ) ==(sel)( , var_h700, other ) => 
 	 Rel (sel)( , var__temp_h724, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h724, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'726, res ) ==(var__temp_v725) AND 
 	 Rel (sel)( , var__temp_h'726, res ) ==((sel)( , var__temp_h724, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'726, other ) ==(sel)( , var__temp_h724, other ) => 
 	 True
 
VC_END(declare-const var_h_i701 T2635)
(declare-const var_h700 T2635)
(declare-const v Int)
(declare-const var_h_i616 T2635)
(declare-const var_h615 T2635)
(declare-const v Int)
(declare-const var_h_i92 T2635)
(declare-const var_h91 T2635)
(declare-const v Int)
(declare-const var_h_i44 T2635)
(declare-const var_h43 T2635)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h724 T2635)
(declare-const var__temp_v725 Int)
(declare-const |var__temp_h'726| T2635)
(declare-const var__temp_v_err727 T2636)
(declare-const var_h700 T2635)
(declare-const var_h615 T2635)
(declare-const var_h91 T2635)
(declare-const var_h43 T2635)
(declare-const err T2649)

solver 
 (declare-sort T2635)
(declare-fun sel (T2635 Int) Int)
(declare-fun res () Int)
(declare-fun var_h700 () T2635)
(declare-fun var_h91 () T2635)
(declare-fun var_h43 () T2635)
(declare-fun other () Int)
(declare-fun var__temp_h724 () T2635)
(declare-fun |var__temp_h'726| () T2635)
(declare-fun var__temp_v725 () Int)
(declare-fun v () Int)
(assert (> (sel var_h700 res) 4))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h724 res) v)
                (= (sel var__temp_h724 res) (+ (sel var_h700 res) 10))
                (= (sel var__temp_h724 other) (sel var_h700 other))))
      (a!2 (and (= (sel |var__temp_h'726| res) var__temp_v725)
                (= (sel |var__temp_h'726| res) (+ (sel var__temp_h724 res) 2))
                (= (sel |var__temp_h'726| other) (sel var__temp_h724 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h724 res) 5))
                (=> (= (sel var__temp_h724 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************195
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 
 	 --foo
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i616 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i616, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i616, other ) ==(sel)( , var_h615, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v728:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************196
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i616 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i616, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i616, other ) ==(sel)( , var_h615, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v728:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h729 --->  Ty_heap  
 var__temp_v730 --->  Ty_int  
 var__temp_h'731 --->  Ty_heap  
 var__temp_v_err732 --->  error  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h729, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h729, other ) ==(sel)( , var_h615, other ) => 
 	 Rel (sel)( , var__temp_h729, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h729, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'731, res ) ==(var__temp_v730) AND 
 	 Rel (sel)( , var__temp_h'731, res ) ==((sel)( , var__temp_h729, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'731, other ) ==(sel)( , var__temp_h729, other ) => 
 	 True
 
VC_END(declare-const var_h_i616 T2652)
(declare-const var_h615 T2652)
(declare-const v Int)
(declare-const var_h_i92 T2652)
(declare-const var_h91 T2652)
(declare-const v Int)
(declare-const var_h_i44 T2652)
(declare-const var_h43 T2652)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h729 T2652)
(declare-const var__temp_v730 Int)
(declare-const |var__temp_h'731| T2652)
(declare-const var__temp_v_err732 T2653)
(declare-const var_h615 T2652)
(declare-const var_h91 T2652)
(declare-const var_h43 T2652)
(declare-const err T2666)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2652)
(declare-fun sel (T2652 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2652)
(declare-fun var_h43 () T2652)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h729 () T2652)
(declare-fun |var__temp_h'731| () T2652)
(declare-fun var__temp_v730 () Int)
(declare-fun var_h615 () T2652)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h729 res) v)
                    (= v |5|)
                    (= (sel var__temp_h729 other) (sel var_h615 other)))
               (= (sel var__temp_h729 res) 7)))
      (a!2 (and (= (sel |var__temp_h'731| res) var__temp_v730)
                (= (sel |var__temp_h'731| res) (+ (sel var__temp_h729 res) 3))
                (= (sel |var__temp_h'731| other) (sel var__temp_h729 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h729 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************197
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i616 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i616, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i616, other ) ==(sel)( , var_h615, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v728:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h733 --->  Ty_heap  
 var__temp_v734 --->  Ty_int  
 var__temp_h'735 --->  Ty_heap  
 var__temp_v_err736 --->  error  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h733, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h733, other ) ==(sel)( , var_h615, other ) => 
 	 Rel (sel)( , var__temp_h733, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h733, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'735, res ) ==(var__temp_v734) AND 
 	 Rel (sel)( , var__temp_h'735, res ) ==((sel)( , var__temp_h733, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'735, other ) ==(sel)( , var__temp_h733, other ) => 
 	 True
 
VC_END(declare-const var_h_i616 T2669)
(declare-const var_h615 T2669)
(declare-const v Int)
(declare-const var_h_i92 T2669)
(declare-const var_h91 T2669)
(declare-const v Int)
(declare-const var_h_i44 T2669)
(declare-const var_h43 T2669)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h733 T2669)
(declare-const var__temp_v734 Int)
(declare-const |var__temp_h'735| T2669)
(declare-const var__temp_v_err736 T2670)
(declare-const var_h615 T2669)
(declare-const var_h91 T2669)
(declare-const var_h43 T2669)
(declare-const err T2683)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2669)
(declare-fun sel (T2669 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2669)
(declare-fun var_h43 () T2669)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h733 () T2669)
(declare-fun |var__temp_h'735| () T2669)
(declare-fun var__temp_v734 () Int)
(declare-fun var_h615 () T2669)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h733 res) v)
                    (= v |5|)
                    (= (sel var__temp_h733 other) (sel var_h615 other)))
               (= (sel var__temp_h733 res) 7)))
      (a!2 (and (= (sel |var__temp_h'735| res) var__temp_v734)
                (= (sel |var__temp_h'735| res) (+ (sel var__temp_h733 res) 5))
                (= (sel |var__temp_h'735| other) (sel var__temp_h733 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h733 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************198
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i616 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i616, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i616, other ) ==(sel)( , var_h615, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v728:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h737 --->  Ty_heap  
 var__temp_v738 --->  Ty_int  
 var__temp_h'739 --->  Ty_heap  
 var__temp_v_err740 --->  error  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h737, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h737, other ) ==(sel)( , var_h615, other ) => 
 	 Rel (sel)( , var__temp_h737, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h737, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'739, res ) ==(var__temp_v738) AND 
 	 Rel (sel)( , var__temp_h'739, res ) ==((sel)( , var__temp_h737, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'739, other ) ==(sel)( , var__temp_h737, other ) => 
 	 True
 
VC_END(declare-const var_h_i616 T2686)
(declare-const var_h615 T2686)
(declare-const v Int)
(declare-const var_h_i92 T2686)
(declare-const var_h91 T2686)
(declare-const v Int)
(declare-const var_h_i44 T2686)
(declare-const var_h43 T2686)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h737 T2686)
(declare-const var__temp_v738 Int)
(declare-const |var__temp_h'739| T2686)
(declare-const var__temp_v_err740 T2687)
(declare-const var_h615 T2686)
(declare-const var_h91 T2686)
(declare-const var_h43 T2686)
(declare-const err T2700)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2686)
(declare-fun sel (T2686 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2686)
(declare-fun var_h43 () T2686)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h737 () T2686)
(declare-fun |var__temp_h'739| () T2686)
(declare-fun var__temp_v738 () Int)
(declare-fun var_h615 () T2686)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h737 res) v)
                    (= v |5|)
                    (= (sel var__temp_h737 other) (sel var_h615 other)))
               (= (sel var__temp_h737 res) 5)))
      (a!2 (and (= (sel |var__temp_h'739| res) var__temp_v738)
                (= (sel |var__temp_h'739| res) (+ (sel var__temp_h737 res) 2))
                (= (sel |var__temp_h'739| other) (sel var__temp_h737 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h737 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************bar
PARTIAL PATH NEW
SUB 
 	 --bar
 	 --foo
 	 --c4
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i742 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i742 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i742, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i742, res ) ==((sel)( , var_h741, res ) + (2))
 	 , (sel)( , var_h_i742, other ) ==(sel)( , var_h741, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v743:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i742 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************199
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i742 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i742, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i742, res ) ==((sel)( , var_h741, res ) + (2))
 	 , (sel)( , var_h_i742, other ) ==(sel)( , var_h741, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v743:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i742 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i742 --->  Ty_heap  
 var_h741 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h744 --->  Ty_heap  
 var__temp_v745 --->  Ty_int  
 var__temp_h'746 --->  Ty_heap  
 var__temp_v_err747 --->  error  
 var_h741 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h741, res ) ==(5) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h744, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h744, res ) ==((sel)( , var_h741, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h744, other ) ==(sel)( , var_h741, other ) => 
 	 Rel (sel)( , var__temp_h744, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h744, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'746, res ) ==(var__temp_v745) AND 
 	 Rel (sel)( , var__temp_h'746, res ) ==((sel)( , var__temp_h744, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'746, other ) ==(sel)( , var__temp_h744, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'746, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'746, other ) > (4)
 
VC_END(declare-const var_h_i742 T2703)
(declare-const var_h741 T2703)
(declare-const v Int)
(declare-const var_h_i616 T2703)
(declare-const var_h615 T2703)
(declare-const v Int)
(declare-const var_h_i92 T2703)
(declare-const var_h91 T2703)
(declare-const v Int)
(declare-const var_h_i44 T2703)
(declare-const var_h43 T2703)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h744 T2703)
(declare-const var__temp_v745 Int)
(declare-const |var__temp_h'746| T2703)
(declare-const var__temp_v_err747 T2704)
(declare-const var_h741 T2703)
(declare-const var_h615 T2703)
(declare-const var_h91 T2703)
(declare-const var_h43 T2703)
(declare-const err T2717)

solver 
 (declare-sort T2703)
(declare-fun sel (T2703 Int) Int)
(declare-fun res () Int)
(declare-fun var_h741 () T2703)
(declare-fun var_h91 () T2703)
(declare-fun var_h43 () T2703)
(declare-fun other () Int)
(declare-fun |var__temp_h'746| () T2703)
(declare-fun var__temp_h744 () T2703)
(declare-fun var__temp_v745 () Int)
(declare-fun v () Int)
(assert (= (sel var_h741 res) 5))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h744 res) v)
                (= (sel var__temp_h744 res) (+ (sel var_h741 res) 2))
                (= (sel var__temp_h744 other) (sel var_h741 other))))
      (a!2 (and (= (sel |var__temp_h'746| res) var__temp_v745)
                (= (sel |var__temp_h'746| res) (+ (sel var__temp_h744 res) 3))
                (= (sel |var__temp_h'746| other) (sel var__temp_h744 other))))
      (a!3 (and (= (sel |var__temp_h'746| res) 10)
                (not (> (sel |var__temp_h'746| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h744 res) 7))
                (=> (= (sel var__temp_h744 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************200
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i742 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i742, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i742, res ) ==((sel)( , var_h741, res ) + (2))
 	 , (sel)( , var_h_i742, other ) ==(sel)( , var_h741, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v743:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i742 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i742 --->  Ty_heap  
 var_h741 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h748 --->  Ty_heap  
 var__temp_v749 --->  Ty_int  
 var__temp_h'750 --->  Ty_heap  
 var__temp_v_err751 --->  error  
 var_h741 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h741, res ) ==(5) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h748, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h748, res ) ==((sel)( , var_h741, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h748, other ) ==(sel)( , var_h741, other ) => 
 	 Rel (sel)( , var__temp_h748, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h748, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'750, res ) ==(var__temp_v749) AND 
 	 Rel (sel)( , var__temp_h'750, res ) ==((sel)( , var__temp_h748, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'750, other ) ==(sel)( , var__temp_h748, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'750, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'750, other ) > (4)
 
VC_END(declare-const var_h_i742 T2720)
(declare-const var_h741 T2720)
(declare-const v Int)
(declare-const var_h_i616 T2720)
(declare-const var_h615 T2720)
(declare-const v Int)
(declare-const var_h_i92 T2720)
(declare-const var_h91 T2720)
(declare-const v Int)
(declare-const var_h_i44 T2720)
(declare-const var_h43 T2720)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h748 T2720)
(declare-const var__temp_v749 Int)
(declare-const |var__temp_h'750| T2720)
(declare-const var__temp_v_err751 T2721)
(declare-const var_h741 T2720)
(declare-const var_h615 T2720)
(declare-const var_h91 T2720)
(declare-const var_h43 T2720)
(declare-const err T2734)

solver 
 (declare-sort T2720)
(declare-fun sel (T2720 Int) Int)
(declare-fun res () Int)
(declare-fun var_h741 () T2720)
(declare-fun var_h91 () T2720)
(declare-fun var_h43 () T2720)
(declare-fun other () Int)
(declare-fun |var__temp_h'750| () T2720)
(declare-fun var__temp_h748 () T2720)
(declare-fun var__temp_v749 () Int)
(declare-fun v () Int)
(assert (= (sel var_h741 res) 5))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h748 res) v)
                (= (sel var__temp_h748 res) (+ (sel var_h741 res) 2))
                (= (sel var__temp_h748 other) (sel var_h741 other))))
      (a!2 (and (= (sel |var__temp_h'750| res) var__temp_v749)
                (= (sel |var__temp_h'750| res) (+ (sel var__temp_h748 res) 5))
                (= (sel |var__temp_h'750| other) (sel var__temp_h748 other))))
      (a!3 (and (= (sel |var__temp_h'750| res) 10)
                (not (> (sel |var__temp_h'750| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h748 res) 7))
                (=> (= (sel var__temp_h748 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************201
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v743:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v743:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbarc2c2'foofoo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i742 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i742, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i742, res ) ==((sel)( , var_h741, res ) + (2))
 	 , (sel)( , var_h_i742, other ) ==(sel)( , var_h741, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v752:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************202
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i742 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i742, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i742, res ) ==((sel)( , var_h741, res ) + (2))
 	 , (sel)( , var_h_i742, other ) ==(sel)( , var_h741, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v752:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i742 --->  Ty_heap  
 var_h741 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h753 --->  Ty_heap  
 var__temp_v754 --->  Ty_int  
 var__temp_h'755 --->  Ty_heap  
 var__temp_v_err756 --->  error  
 var_h741 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h741, res ) ==(5) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h753, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h753, res ) ==((sel)( , var_h741, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h753, other ) ==(sel)( , var_h741, other ) => 
 	 Rel (sel)( , var__temp_h753, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h753, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'755, res ) ==(var__temp_v754) AND 
 	 Rel (sel)( , var__temp_h'755, res ) ==((sel)( , var__temp_h753, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'755, other ) ==(sel)( , var__temp_h753, other ) => 
 	 True
 
VC_END(declare-const var_h_i742 T2737)
(declare-const var_h741 T2737)
(declare-const v Int)
(declare-const var_h_i616 T2737)
(declare-const var_h615 T2737)
(declare-const v Int)
(declare-const var_h_i92 T2737)
(declare-const var_h91 T2737)
(declare-const v Int)
(declare-const var_h_i44 T2737)
(declare-const var_h43 T2737)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h753 T2737)
(declare-const var__temp_v754 Int)
(declare-const |var__temp_h'755| T2737)
(declare-const var__temp_v_err756 T2738)
(declare-const var_h741 T2737)
(declare-const var_h615 T2737)
(declare-const var_h91 T2737)
(declare-const var_h43 T2737)
(declare-const err T2751)

solver 
 (declare-sort T2737)
(declare-fun sel (T2737 Int) Int)
(declare-fun res () Int)
(declare-fun var_h741 () T2737)
(declare-fun var_h91 () T2737)
(declare-fun var_h43 () T2737)
(declare-fun other () Int)
(declare-fun var__temp_h753 () T2737)
(declare-fun |var__temp_h'755| () T2737)
(declare-fun var__temp_v754 () Int)
(declare-fun v () Int)
(assert (= (sel var_h741 res) 5))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h753 res) v)
                (= (sel var__temp_h753 res) (+ (sel var_h741 res) 2))
                (= (sel var__temp_h753 other) (sel var_h741 other))))
      (a!2 (and (= (sel |var__temp_h'755| res) var__temp_v754)
                (= (sel |var__temp_h'755| res) (+ (sel var__temp_h753 res) 3))
                (= (sel |var__temp_h'755| other) (sel var__temp_h753 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h753 res) 7))
                (=> (= (sel var__temp_h753 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************baz
PARTIAL PATH NEW
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --c4
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i758 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i758 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i758, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i758, res ) ==((sel)( , var_h757, res ) + (3))
 	 , (sel)( , var_h_i758, other ) ==(sel)( , var_h757, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v759:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i758 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************203
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i758 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i758, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i758, res ) ==((sel)( , var_h757, res ) + (3))
 	 , (sel)( , var_h_i758, other ) ==(sel)( , var_h757, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v759:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i758 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i758 --->  Ty_heap  
 var_h757 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i742 --->  Ty_heap  
 var_h741 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h760 --->  Ty_heap  
 var__temp_v761 --->  Ty_int  
 var__temp_h'762 --->  Ty_heap  
 var__temp_v_err763 --->  error  
 var_h757 --->  Ty_heap  
 var_h741 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h757, res ) ==(7) AND 
 	 Rel (sel)( , var_h741, res ) ==(5) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h760, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h760, res ) ==((sel)( , var_h757, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h760, other ) ==(sel)( , var_h757, other ) => 
 	 Rel (sel)( , var__temp_h760, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h760, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'762, res ) ==(var__temp_v761) AND 
 	 Rel (sel)( , var__temp_h'762, res ) ==((sel)( , var__temp_h760, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'762, other ) ==(sel)( , var__temp_h760, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'762, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'762, other ) > (4)
 
VC_END(declare-const var_h_i758 T2754)
(declare-const var_h757 T2754)
(declare-const v Int)
(declare-const var_h_i742 T2754)
(declare-const var_h741 T2754)
(declare-const v Int)
(declare-const var_h_i616 T2754)
(declare-const var_h615 T2754)
(declare-const v Int)
(declare-const var_h_i92 T2754)
(declare-const var_h91 T2754)
(declare-const v Int)
(declare-const var_h_i44 T2754)
(declare-const var_h43 T2754)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h760 T2754)
(declare-const var__temp_v761 Int)
(declare-const |var__temp_h'762| T2754)
(declare-const var__temp_v_err763 T2755)
(declare-const var_h757 T2754)
(declare-const var_h741 T2754)
(declare-const var_h615 T2754)
(declare-const var_h91 T2754)
(declare-const var_h43 T2754)
(declare-const err T2768)

solver 
 (declare-sort T2754)
(declare-fun sel (T2754 Int) Int)
(declare-fun res () Int)
(declare-fun var_h757 () T2754)
(declare-fun var_h741 () T2754)
(declare-fun var_h91 () T2754)
(declare-fun var_h43 () T2754)
(declare-fun other () Int)
(declare-fun |var__temp_h'762| () T2754)
(declare-fun var__temp_h760 () T2754)
(declare-fun var__temp_v761 () Int)
(declare-fun v () Int)
(assert (= (sel var_h757 res) 7))
(assert (= (sel var_h741 res) 5))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h760 res) v)
                (= (sel var__temp_h760 res) (+ (sel var_h757 res) 3))
                (= (sel var__temp_h760 other) (sel var_h757 other))))
      (a!2 (and (= (sel |var__temp_h'762| res) var__temp_v761)
                (= (sel |var__temp_h'762| res) (+ (sel var__temp_h760 res) 5))
                (= (sel |var__temp_h'762| other) (sel var__temp_h760 other))))
      (a!3 (and (= (sel |var__temp_h'762| res) 10)
                (not (> (sel |var__temp_h'762| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h760 res) 7))
                (=> (= (sel var__temp_h760 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************204
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v759:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v759:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbazbarc2c2'foofoo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i758 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i758, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i758, res ) ==((sel)( , var_h757, res ) + (3))
 	 , (sel)( , var_h_i758, other ) ==(sel)( , var_h757, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v764:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************205
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i758 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i758, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i758, res ) ==((sel)( , var_h757, res ) + (3))
 	 , (sel)( , var_h_i758, other ) ==(sel)( , var_h757, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v764:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i758 --->  Ty_heap  
 var_h757 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i742 --->  Ty_heap  
 var_h741 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h765 --->  Ty_heap  
 var__temp_v766 --->  Ty_int  
 var__temp_h'767 --->  Ty_heap  
 var__temp_v_err768 --->  error  
 var_h757 --->  Ty_heap  
 var_h741 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h757, res ) ==(7) AND 
 	 Rel (sel)( , var_h741, res ) ==(5) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h765, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h765, res ) ==((sel)( , var_h757, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h765, other ) ==(sel)( , var_h757, other ) => 
 	 Rel (sel)( , var__temp_h765, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h765, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'767, res ) ==(var__temp_v766) AND 
 	 Rel (sel)( , var__temp_h'767, res ) ==((sel)( , var__temp_h765, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'767, other ) ==(sel)( , var__temp_h765, other ) => 
 	 True
 
VC_END(declare-const var_h_i758 T2771)
(declare-const var_h757 T2771)
(declare-const v Int)
(declare-const var_h_i742 T2771)
(declare-const var_h741 T2771)
(declare-const v Int)
(declare-const var_h_i616 T2771)
(declare-const var_h615 T2771)
(declare-const v Int)
(declare-const var_h_i92 T2771)
(declare-const var_h91 T2771)
(declare-const v Int)
(declare-const var_h_i44 T2771)
(declare-const var_h43 T2771)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h765 T2771)
(declare-const var__temp_v766 Int)
(declare-const |var__temp_h'767| T2771)
(declare-const var__temp_v_err768 T2772)
(declare-const var_h757 T2771)
(declare-const var_h741 T2771)
(declare-const var_h615 T2771)
(declare-const var_h91 T2771)
(declare-const var_h43 T2771)
(declare-const err T2785)

solver 
 (declare-sort T2771)
(declare-fun sel (T2771 Int) Int)
(declare-fun res () Int)
(declare-fun var_h757 () T2771)
(declare-fun var_h741 () T2771)
(declare-fun var_h91 () T2771)
(declare-fun var_h43 () T2771)
(declare-fun other () Int)
(declare-fun var__temp_h765 () T2771)
(declare-fun |var__temp_h'767| () T2771)
(declare-fun var__temp_v766 () Int)
(declare-fun v () Int)
(assert (= (sel var_h757 res) 7))
(assert (= (sel var_h741 res) 5))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h765 res) v)
                (= (sel var__temp_h765 res) (+ (sel var_h757 res) 3))
                (= (sel var__temp_h765 other) (sel var_h757 other))))
      (a!2 (and (= (sel |var__temp_h'767| res) var__temp_v766)
                (= (sel |var__temp_h'767| res) (+ (sel var__temp_h765 res) 5))
                (= (sel |var__temp_h'767| other) (sel var__temp_h765 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h765 res) 7))
                (=> (= (sel var__temp_h765 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************206
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT baz
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i742 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i742, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i742, res ) ==((sel)( , var_h741, res ) + (2))
 	 , (sel)( , var_h_i742, other ) ==(sel)( , var_h741, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v769:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************207
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i742 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i742, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i742, res ) ==((sel)( , var_h741, res ) + (2))
 	 , (sel)( , var_h_i742, other ) ==(sel)( , var_h741, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v769:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i742 --->  Ty_heap  
 var_h741 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h770 --->  Ty_heap  
 var__temp_v771 --->  Ty_int  
 var__temp_h'772 --->  Ty_heap  
 var__temp_v_err773 --->  error  
 var_h741 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h741, res ) ==(5) AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h770, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h770, res ) ==((sel)( , var_h741, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h770, other ) ==(sel)( , var_h741, other ) => 
 	 Rel (sel)( , var__temp_h770, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h770, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'772, res ) ==(var__temp_v771) AND 
 	 Rel (sel)( , var__temp_h'772, res ) ==((sel)( , var__temp_h770, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'772, other ) ==(sel)( , var__temp_h770, other ) => 
 	 True
 
VC_END(declare-const var_h_i742 T2788)
(declare-const var_h741 T2788)
(declare-const v Int)
(declare-const var_h_i616 T2788)
(declare-const var_h615 T2788)
(declare-const v Int)
(declare-const var_h_i92 T2788)
(declare-const var_h91 T2788)
(declare-const v Int)
(declare-const var_h_i44 T2788)
(declare-const var_h43 T2788)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h770 T2788)
(declare-const var__temp_v771 Int)
(declare-const |var__temp_h'772| T2788)
(declare-const var__temp_v_err773 T2789)
(declare-const var_h741 T2788)
(declare-const var_h615 T2788)
(declare-const var_h91 T2788)
(declare-const var_h43 T2788)
(declare-const err T2802)

solver 
 (declare-sort T2788)
(declare-fun sel (T2788 Int) Int)
(declare-fun res () Int)
(declare-fun var_h741 () T2788)
(declare-fun var_h91 () T2788)
(declare-fun var_h43 () T2788)
(declare-fun other () Int)
(declare-fun var__temp_h770 () T2788)
(declare-fun |var__temp_h'772| () T2788)
(declare-fun var__temp_v771 () Int)
(declare-fun v () Int)
(assert (= (sel var_h741 res) 5))
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h770 res) v)
                (= (sel var__temp_h770 res) (+ (sel var_h741 res) 2))
                (= (sel var__temp_h770 other) (sel var_h741 other))))
      (a!2 (and (= (sel |var__temp_h'772| res) var__temp_v771)
                (= (sel |var__temp_h'772| res) (+ (sel var__temp_h770 res) 5))
                (= (sel |var__temp_h'772| other) (sel var__temp_h770 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h770 res) 7))
                (=> (= (sel var__temp_h770 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c5
PARTIAL PATH NEW
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --c4
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i775 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i775 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i775, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i775, res ) ==((sel)( , var_h774, res ) + (5))
 	 , (sel)( , var_h_i775, other ) ==(sel)( , var_h774, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v776:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i775 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************208
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v776:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v776:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc5bazbarc2c2'foofoo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i775 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i775, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i775, res ) ==((sel)( , var_h774, res ) + (5))
 	 , (sel)( , var_h_i775, other ) ==(sel)( , var_h774, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v777:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************209
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i742 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i742, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i742, res ) ==((sel)( , var_h741, res ) + (2))
 	 , (sel)( , var_h_i742, other ) ==(sel)( , var_h741, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v778:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************210
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --foo
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i616 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i616, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i616, other ) ==(sel)( , var_h615, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v779:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************211
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i616 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i616, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i616, other ) ==(sel)( , var_h615, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v779:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h780 --->  Ty_heap  
 var__temp_v781 --->  Ty_int  
 var__temp_h'782 --->  Ty_heap  
 var__temp_v_err783 --->  error  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h780, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h780, other ) ==(sel)( , var_h615, other ) => 
 	 Rel (sel)( , var__temp_h780, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h780, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'782, res ) ==(var__temp_v781) AND 
 	 Rel (sel)( , var__temp_h'782, res ) ==((sel)( , var__temp_h780, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'782, other ) ==(sel)( , var__temp_h780, other ) => 
 	 True
 
VC_END(declare-const var_h_i616 T2805)
(declare-const var_h615 T2805)
(declare-const v Int)
(declare-const var_h_i92 T2805)
(declare-const var_h91 T2805)
(declare-const v Int)
(declare-const var_h_i44 T2805)
(declare-const var_h43 T2805)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h780 T2805)
(declare-const var__temp_v781 Int)
(declare-const |var__temp_h'782| T2805)
(declare-const var__temp_v_err783 T2806)
(declare-const var_h615 T2805)
(declare-const var_h91 T2805)
(declare-const var_h43 T2805)
(declare-const err T2819)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2805)
(declare-fun sel (T2805 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2805)
(declare-fun var_h43 () T2805)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h780 () T2805)
(declare-fun |var__temp_h'782| () T2805)
(declare-fun var__temp_v781 () Int)
(declare-fun var_h615 () T2805)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h780 res) v)
                    (= v |5|)
                    (= (sel var__temp_h780 other) (sel var_h615 other)))
               (= (sel var__temp_h780 res) 7)))
      (a!2 (and (= (sel |var__temp_h'782| res) var__temp_v781)
                (= (sel |var__temp_h'782| res) (+ (sel var__temp_h780 res) 3))
                (= (sel |var__temp_h'782| other) (sel var__temp_h780 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h780 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************212
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i616 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i616, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i616, other ) ==(sel)( , var_h615, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v779:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i616 --->  Ty_heap  
 var_h615 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h784 --->  Ty_heap  
 var__temp_v785 --->  Ty_int  
 var__temp_h'786 --->  Ty_heap  
 var__temp_v_err787 --->  error  
 var_h615 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h784, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h784, other ) ==(sel)( , var_h615, other ) => 
 	 Rel (sel)( , var__temp_h784, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h784, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'786, res ) ==(var__temp_v785) AND 
 	 Rel (sel)( , var__temp_h'786, res ) ==((sel)( , var__temp_h784, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'786, other ) ==(sel)( , var__temp_h784, other ) => 
 	 True
 
VC_END(declare-const var_h_i616 T2822)
(declare-const var_h615 T2822)
(declare-const v Int)
(declare-const var_h_i92 T2822)
(declare-const var_h91 T2822)
(declare-const v Int)
(declare-const var_h_i44 T2822)
(declare-const var_h43 T2822)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h784 T2822)
(declare-const var__temp_v785 Int)
(declare-const |var__temp_h'786| T2822)
(declare-const var__temp_v_err787 T2823)
(declare-const var_h615 T2822)
(declare-const var_h91 T2822)
(declare-const var_h43 T2822)
(declare-const err T2836)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2822)
(declare-fun sel (T2822 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2822)
(declare-fun var_h43 () T2822)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h784 () T2822)
(declare-fun |var__temp_h'786| () T2822)
(declare-fun var__temp_v785 () Int)
(declare-fun var_h615 () T2822)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h784 res) v)
                    (= v |5|)
                    (= (sel var__temp_h784 other) (sel var_h615 other)))
               (= (sel var__temp_h784 res) 7)))
      (a!2 (and (= (sel |var__temp_h'786| res) var__temp_v785)
                (= (sel |var__temp_h'786| res) (+ (sel var__temp_h784 res) 5))
                (= (sel |var__temp_h'786| other) (sel var__temp_h784 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h784 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************213
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT bar
PARTIAL PATH
SUB 
 	 --c4
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i92 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i92, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i92, res ) ==((sel)( , var_h91, res ) + (5))
 	 , (sel)( , var_h_i92, other ) ==(sel)( , var_h91, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v788:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
bar
 *********************Enumeration Iteration*****************214
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i92 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i92, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i92, res ) ==((sel)( , var_h91, res ) + (5))
 	 , (sel)( , var_h_i92, other ) ==(sel)( , var_h91, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v788:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h789 --->  Ty_heap  
 var__temp_v790 --->  Ty_int  
 var__temp_h'791 --->  Ty_heap  
 var__temp_v_err792 --->  error  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h789, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h789, res ) ==((sel)( , var_h91, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h789, other ) ==(sel)( , var_h91, other ) => 
 	 Rel (sel)( , var__temp_h789, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h789, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'791, res ) ==(var__temp_v790) AND 
 	 Rel (sel)( , var__temp_h'791, res ) ==((sel)( , var__temp_h789, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'791, other ) ==(sel)( , var__temp_h789, other ) => 
 	 True
 
VC_END(declare-const var_h_i92 T2839)
(declare-const var_h91 T2839)
(declare-const v Int)
(declare-const var_h_i44 T2839)
(declare-const var_h43 T2839)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h789 T2839)
(declare-const var__temp_v790 Int)
(declare-const |var__temp_h'791| T2839)
(declare-const var__temp_v_err792 T2840)
(declare-const var_h91 T2839)
(declare-const var_h43 T2839)
(declare-const err T2853)

solver 
 (declare-sort T2839)
(declare-fun sel (T2839 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2839)
(declare-fun var_h43 () T2839)
(declare-fun other () Int)
(declare-fun var__temp_h789 () T2839)
(declare-fun |var__temp_h'791| () T2839)
(declare-fun var__temp_v790 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h789 res) v)
                (= (sel var__temp_h789 res) (+ (sel var_h91 res) 5))
                (= (sel var__temp_h789 other) (sel var_h91 other))))
      (a!2 (and (= (sel |var__temp_h'791| res) var__temp_v790)
                (= (sel |var__temp_h'791| res) (+ (sel var__temp_h789 res) 3))
                (= (sel |var__temp_h'791| other) (sel var__temp_h789 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h789 res) 7))
                (=> (= (sel var__temp_h789 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************215
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i92 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i92, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i92, res ) ==((sel)( , var_h91, res ) + (5))
 	 , (sel)( , var_h_i92, other ) ==(sel)( , var_h91, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v788:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h793 --->  Ty_heap  
 var__temp_v794 --->  Ty_int  
 var__temp_h'795 --->  Ty_heap  
 var__temp_v_err796 --->  error  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h793, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h793, res ) ==((sel)( , var_h91, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h793, other ) ==(sel)( , var_h91, other ) => 
 	 Rel (sel)( , var__temp_h793, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h793, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'795, res ) ==(var__temp_v794) AND 
 	 Rel (sel)( , var__temp_h'795, res ) ==((sel)( , var__temp_h793, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'795, other ) ==(sel)( , var__temp_h793, other ) => 
 	 True
 
VC_END(declare-const var_h_i92 T2856)
(declare-const var_h91 T2856)
(declare-const v Int)
(declare-const var_h_i44 T2856)
(declare-const var_h43 T2856)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h793 T2856)
(declare-const var__temp_v794 Int)
(declare-const |var__temp_h'795| T2856)
(declare-const var__temp_v_err796 T2857)
(declare-const var_h91 T2856)
(declare-const var_h43 T2856)
(declare-const err T2870)

solver 
 (declare-sort T2856)
(declare-fun sel (T2856 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2856)
(declare-fun var_h43 () T2856)
(declare-fun other () Int)
(declare-fun var__temp_h793 () T2856)
(declare-fun |var__temp_h'795| () T2856)
(declare-fun var__temp_v794 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h793 res) v)
                (= (sel var__temp_h793 res) (+ (sel var_h91 res) 5))
                (= (sel var__temp_h793 other) (sel var_h91 other))))
      (a!2 (and (= (sel |var__temp_h'795| res) var__temp_v794)
                (= (sel |var__temp_h'795| res) (+ (sel var__temp_h793 res) 5))
                (= (sel |var__temp_h'795| other) (sel var__temp_h793 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h793 res) 7))
                (=> (= (sel var__temp_h793 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************216
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i92 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i92, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i92, res ) ==((sel)( , var_h91, res ) + (5))
 	 , (sel)( , var_h_i92, other ) ==(sel)( , var_h91, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v788:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h797 --->  Ty_heap  
 var__temp_v798 --->  Ty_int  
 var__temp_h'799 --->  Ty_heap  
 var__temp_v_err800 --->  error  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h797, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h797, res ) ==((sel)( , var_h91, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h797, other ) ==(sel)( , var_h91, other ) => 
 	 Rel (sel)( , var__temp_h797, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h797, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'799, res ) ==(var__temp_v798) AND 
 	 Rel (sel)( , var__temp_h797, res ) ==(sel)( , var__temp_h797, res ) AND 
 	 Rel (sel)( , var__temp_h'799, other ) ==(sel)( , var__temp_h797, other ) => 
 	 True
 
VC_END(declare-const var_h_i92 T2873)
(declare-const var_h91 T2873)
(declare-const v Int)
(declare-const var_h_i44 T2873)
(declare-const var_h43 T2873)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h797 T2873)
(declare-const var__temp_v798 Int)
(declare-const |var__temp_h'799| T2873)
(declare-const var__temp_v_err800 T2874)
(declare-const var_h91 T2873)
(declare-const var_h43 T2873)
(declare-const err T2887)

solver 
 (declare-sort T2873)
(declare-fun sel (T2873 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2873)
(declare-fun var_h43 () T2873)
(declare-fun other () Int)
(declare-fun var__temp_h797 () T2873)
(declare-fun |var__temp_h'799| () T2873)
(declare-fun var__temp_v798 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h797 res) v)
                (= (sel var__temp_h797 res) (+ (sel var_h91 res) 5))
                (= (sel var__temp_h797 other) (sel var_h91 other))))
      (a!3 (=> (and (= (sel |var__temp_h'799| res) var__temp_v798)
                    (= (sel var__temp_h797 res) (sel var__temp_h797 res))
                    (= (sel |var__temp_h'799| other) (sel var__temp_h797 other)))
               true)))
(let ((a!2 (=> a!1 (not (> (sel var__temp_h797 res) 20))))
      (a!4 (=> (not (> (sel var__temp_h797 res) 20)) a!3)))
  (not (and a!2 a!4)))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************217
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i92 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i92, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i92, res ) ==((sel)( , var_h91, res ) + (5))
 	 , (sel)( , var_h_i92, other ) ==(sel)( , var_h91, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v788:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h801 --->  Ty_heap  
 var__temp_v802 --->  Ty_int  
 var__temp_h'803 --->  Ty_heap  
 var__temp_v_err804 --->  error  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h801, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h801, res ) ==((sel)( , var_h91, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h801, other ) ==(sel)( , var_h91, other ) => 
 	 Rel (sel)( , var__temp_h801, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h801, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'803, res ) ==(var__temp_v802) AND 
 	 Rel (sel)( , var__temp_h'803, res ) ==((sel)( , var__temp_h801, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'803, other ) ==(sel)( , var__temp_h801, other ) => 
 	 True
 
VC_END(declare-const var_h_i92 T2890)
(declare-const var_h91 T2890)
(declare-const v Int)
(declare-const var_h_i44 T2890)
(declare-const var_h43 T2890)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h801 T2890)
(declare-const var__temp_v802 Int)
(declare-const |var__temp_h'803| T2890)
(declare-const var__temp_v_err804 T2891)
(declare-const var_h91 T2890)
(declare-const var_h43 T2890)
(declare-const err T2904)

solver 
 (declare-sort T2890)
(declare-fun sel (T2890 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2890)
(declare-fun var_h43 () T2890)
(declare-fun other () Int)
(declare-fun var__temp_h801 () T2890)
(declare-fun |var__temp_h'803| () T2890)
(declare-fun var__temp_v802 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h801 res) v)
                (= (sel var__temp_h801 res) (+ (sel var_h91 res) 5))
                (= (sel var__temp_h801 other) (sel var_h91 other))))
      (a!2 (and (= (sel |var__temp_h'803| res) var__temp_v802)
                (= (sel |var__temp_h'803| res) (+ (sel var__temp_h801 res) 10))
                (= (sel |var__temp_h'803| other) (sel var__temp_h801 other)))))
(let ((a!3 (and (=> a!1 (> (sel var__temp_h801 res) 4))
                (=> (> (sel var__temp_h801 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************218
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i92 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i92, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i92, res ) ==((sel)( , var_h91, res ) + (5))
 	 , (sel)( , var_h_i92, other ) ==(sel)( , var_h91, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v788:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i92 --->  Ty_heap  
 var_h91 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h805 --->  Ty_heap  
 var__temp_v806 --->  Ty_int  
 var__temp_h'807 --->  Ty_heap  
 var__temp_v_err808 --->  error  
 var_h91 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h91, res ) > (30) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h805, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h805, res ) ==((sel)( , var_h91, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h805, other ) ==(sel)( , var_h91, other ) => 
 	 Rel (sel)( , var__temp_h805, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h805, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'807, res ) ==(var__temp_v806) AND 
 	 Rel (sel)( , var__temp_h'807, res ) ==((sel)( , var__temp_h805, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'807, other ) ==(sel)( , var__temp_h805, other ) => 
 	 True
 
VC_END(declare-const var_h_i92 T2907)
(declare-const var_h91 T2907)
(declare-const v Int)
(declare-const var_h_i44 T2907)
(declare-const var_h43 T2907)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h805 T2907)
(declare-const var__temp_v806 Int)
(declare-const |var__temp_h'807| T2907)
(declare-const var__temp_v_err808 T2908)
(declare-const var_h91 T2907)
(declare-const var_h43 T2907)
(declare-const err T2921)

solver 
 (declare-sort T2907)
(declare-fun sel (T2907 Int) Int)
(declare-fun res () Int)
(declare-fun var_h91 () T2907)
(declare-fun var_h43 () T2907)
(declare-fun other () Int)
(declare-fun var__temp_h805 () T2907)
(declare-fun |var__temp_h'807| () T2907)
(declare-fun var__temp_v806 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h91 res) 30)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h805 res) v)
                (= (sel var__temp_h805 res) (+ (sel var_h91 res) 5))
                (= (sel var__temp_h805 other) (sel var_h91 other))))
      (a!2 (and (= (sel |var__temp_h'807| res) var__temp_v806)
                (= (sel |var__temp_h'807| res) (+ (sel var__temp_h805 res) 2))
                (= (sel |var__temp_h'807| other) (sel var__temp_h805 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h805 res) 5))
                (=> (= (sel var__temp_h805 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************219
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo
PARTIAL PATH
SUB 
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v809:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************220
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v809:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h810 --->  Ty_heap  
 var__temp_v811 --->  Ty_int  
 var__temp_h'812 --->  Ty_heap  
 var__temp_v_err813 --->  error  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h810, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h810, res ) ==((sel)( , var_h43, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h810, other ) ==((sel)( , var_h43, other ) + (5)) => 
 	 Rel (sel)( , var__temp_h810, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h810, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'812, res ) ==(var__temp_v811) AND 
 	 Rel (sel)( , var__temp_h'812, res ) ==((sel)( , var__temp_h810, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'812, other ) ==(sel)( , var__temp_h810, other ) => 
 	 True
 
VC_END(declare-const var_h_i44 T2924)
(declare-const var_h43 T2924)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h810 T2924)
(declare-const var__temp_v811 Int)
(declare-const |var__temp_h'812| T2924)
(declare-const var__temp_v_err813 T2925)
(declare-const var_h43 T2924)
(declare-const err T2938)

solver 
 (declare-sort T2924)
(declare-fun sel (T2924 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T2924)
(declare-fun other () Int)
(declare-fun var__temp_h810 () T2924)
(declare-fun |var__temp_h'812| () T2924)
(declare-fun var__temp_v811 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h810 res) v)
                (= (sel var__temp_h810 res) (+ (sel var_h43 res) 3))
                (= (sel var__temp_h810 other) (+ (sel var_h43 other) 5))))
      (a!2 (and (= (sel |var__temp_h'812| res) var__temp_v811)
                (= (sel |var__temp_h'812| res) (+ (sel var__temp_h810 res) 3))
                (= (sel |var__temp_h'812| other) (sel var__temp_h810 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h810 res) 7))
                (=> (= (sel var__temp_h810 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************221
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v809:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h814 --->  Ty_heap  
 var__temp_v815 --->  Ty_int  
 var__temp_h'816 --->  Ty_heap  
 var__temp_v_err817 --->  error  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h814, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h814, res ) ==((sel)( , var_h43, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h814, other ) ==((sel)( , var_h43, other ) + (5)) => 
 	 Rel (sel)( , var__temp_h814, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h814, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'816, res ) ==(var__temp_v815) AND 
 	 Rel (sel)( , var__temp_h'816, res ) ==((sel)( , var__temp_h814, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'816, other ) ==(sel)( , var__temp_h814, other ) => 
 	 True
 
VC_END(declare-const var_h_i44 T2941)
(declare-const var_h43 T2941)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h814 T2941)
(declare-const var__temp_v815 Int)
(declare-const |var__temp_h'816| T2941)
(declare-const var__temp_v_err817 T2942)
(declare-const var_h43 T2941)
(declare-const err T2955)

solver 
 (declare-sort T2941)
(declare-fun sel (T2941 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T2941)
(declare-fun other () Int)
(declare-fun var__temp_h814 () T2941)
(declare-fun |var__temp_h'816| () T2941)
(declare-fun var__temp_v815 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h814 res) v)
                (= (sel var__temp_h814 res) (+ (sel var_h43 res) 3))
                (= (sel var__temp_h814 other) (+ (sel var_h43 other) 5))))
      (a!2 (and (= (sel |var__temp_h'816| res) var__temp_v815)
                (= (sel |var__temp_h'816| res) (+ (sel var__temp_h814 res) 5))
                (= (sel |var__temp_h'816| other) (sel var__temp_h814 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h814 res) 7))
                (=> (= (sel var__temp_h814 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************222
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v809:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h818 --->  Ty_heap  
 var__temp_v819 --->  Ty_int  
 var__temp_h'820 --->  Ty_heap  
 var__temp_v_err821 --->  error  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h818, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h818, res ) ==((sel)( , var_h43, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h818, other ) ==((sel)( , var_h43, other ) + (5)) => 
 	 Rel (sel)( , var__temp_h818, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h818, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'820, res ) ==(var__temp_v819) AND 
 	 Rel (sel)( , var__temp_h818, res ) ==(sel)( , var__temp_h818, res ) AND 
 	 Rel (sel)( , var__temp_h'820, other ) ==(sel)( , var__temp_h818, other ) => 
 	 True
 
VC_END(declare-const var_h_i44 T2958)
(declare-const var_h43 T2958)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h818 T2958)
(declare-const var__temp_v819 Int)
(declare-const |var__temp_h'820| T2958)
(declare-const var__temp_v_err821 T2959)
(declare-const var_h43 T2958)
(declare-const err T2972)

solver 
 (declare-sort T2958)
(declare-fun sel (T2958 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T2958)
(declare-fun other () Int)
(declare-fun var__temp_h818 () T2958)
(declare-fun |var__temp_h'820| () T2958)
(declare-fun var__temp_v819 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h818 res) v)
                (= (sel var__temp_h818 res) (+ (sel var_h43 res) 3))
                (= (sel var__temp_h818 other) (+ (sel var_h43 other) 5))))
      (a!3 (=> (and (= (sel |var__temp_h'820| res) var__temp_v819)
                    (= (sel var__temp_h818 res) (sel var__temp_h818 res))
                    (= (sel |var__temp_h'820| other) (sel var__temp_h818 other)))
               true)))
(let ((a!2 (=> a!1 (not (> (sel var__temp_h818 res) 20))))
      (a!4 (=> (not (> (sel var__temp_h818 res) 20)) a!3)))
  (not (and a!2 a!4)))))

***************Selection Successful************c2'
PARTIAL PATH NEW
SUB 
 	 --c2'
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i823 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i823 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i823, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h822, res ) ==(sel)( , var_h822, res )
 	 , (sel)( , var_h_i823, other ) ==(sel)( , var_h822, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v824:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i823 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************223
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i823 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i823, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h822, res ) ==(sel)( , var_h822, res )
 	 , (sel)( , var_h_i823, other ) ==(sel)( , var_h822, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v824:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i823 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h825 --->  Ty_heap  
 var__temp_v826 --->  Ty_int  
 var__temp_h'827 --->  Ty_heap  
 var__temp_v_err828 --->  error  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h825, res ) ==(v) AND 
 	 Rel (sel)( , var_h822, res ) ==(sel)( , var_h822, res ) AND 
 	 Rel (sel)( , var__temp_h825, other ) ==(sel)( , var_h822, other ) => 
 	 Rel (sel)( , var__temp_h825, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h825, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'827, res ) ==(var__temp_v826) AND 
 	 Rel (sel)( , var__temp_h'827, res ) ==((sel)( , var__temp_h825, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'827, other ) ==(sel)( , var__temp_h825, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'827, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'827, other ) > (4)
 
VC_END(declare-const var_h_i823 T2975)
(declare-const var_h822 T2975)
(declare-const v Int)
(declare-const var_h_i44 T2975)
(declare-const var_h43 T2975)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h825 T2975)
(declare-const var__temp_v826 Int)
(declare-const |var__temp_h'827| T2975)
(declare-const var__temp_v_err828 T2976)
(declare-const var_h822 T2975)
(declare-const var_h43 T2975)
(declare-const err T2989)

solver 
 (declare-sort T2975)
(declare-fun sel (T2975 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T2975)
(declare-fun var_h43 () T2975)
(declare-fun other () Int)
(declare-fun |var__temp_h'827| () T2975)
(declare-fun var__temp_h825 () T2975)
(declare-fun var__temp_v826 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h825 res) v)
                    (= (sel var_h822 res) (sel var_h822 res))
                    (= (sel var__temp_h825 other) (sel var_h822 other)))
               (= (sel var__temp_h825 res) 7)))
      (a!2 (and (= (sel |var__temp_h'827| res) var__temp_v826)
                (= (sel |var__temp_h'827| res) (+ (sel var__temp_h825 res) 3))
                (= (sel |var__temp_h'827| other) (sel var__temp_h825 other))))
      (a!3 (and (= (sel |var__temp_h'827| res) 10)
                (not (> (sel |var__temp_h'827| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h825 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************224
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i823 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i823, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h822, res ) ==(sel)( , var_h822, res )
 	 , (sel)( , var_h_i823, other ) ==(sel)( , var_h822, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v824:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i823 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h829 --->  Ty_heap  
 var__temp_v830 --->  Ty_int  
 var__temp_h'831 --->  Ty_heap  
 var__temp_v_err832 --->  error  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h829, res ) ==(v) AND 
 	 Rel (sel)( , var_h822, res ) ==(sel)( , var_h822, res ) AND 
 	 Rel (sel)( , var__temp_h829, other ) ==(sel)( , var_h822, other ) => 
 	 Rel (sel)( , var__temp_h829, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h829, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'831, res ) ==(var__temp_v830) AND 
 	 Rel (sel)( , var__temp_h'831, res ) ==((sel)( , var__temp_h829, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'831, other ) ==(sel)( , var__temp_h829, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'831, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'831, other ) > (4)
 
VC_END(declare-const var_h_i823 T2992)
(declare-const var_h822 T2992)
(declare-const v Int)
(declare-const var_h_i44 T2992)
(declare-const var_h43 T2992)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h829 T2992)
(declare-const var__temp_v830 Int)
(declare-const |var__temp_h'831| T2992)
(declare-const var__temp_v_err832 T2993)
(declare-const var_h822 T2992)
(declare-const var_h43 T2992)
(declare-const err T3006)

solver 
 (declare-sort T2992)
(declare-fun sel (T2992 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T2992)
(declare-fun var_h43 () T2992)
(declare-fun other () Int)
(declare-fun |var__temp_h'831| () T2992)
(declare-fun var__temp_h829 () T2992)
(declare-fun var__temp_v830 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h829 res) v)
                    (= (sel var_h822 res) (sel var_h822 res))
                    (= (sel var__temp_h829 other) (sel var_h822 other)))
               (= (sel var__temp_h829 res) 7)))
      (a!2 (and (= (sel |var__temp_h'831| res) var__temp_v830)
                (= (sel |var__temp_h'831| res) (+ (sel var__temp_h829 res) 5))
                (= (sel |var__temp_h'831| other) (sel var__temp_h829 other))))
      (a!3 (and (= (sel |var__temp_h'831| res) 10)
                (not (> (sel |var__temp_h'831| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h829 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************225
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i823 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i823, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h822, res ) ==(sel)( , var_h822, res )
 	 , (sel)( , var_h_i823, other ) ==(sel)( , var_h822, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v824:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i823 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h833 --->  Ty_heap  
 var__temp_v834 --->  Ty_int  
 var__temp_h'835 --->  Ty_heap  
 var__temp_v_err836 --->  error  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h833, res ) ==(v) AND 
 	 Rel (sel)( , var_h822, res ) ==(sel)( , var_h822, res ) AND 
 	 Rel (sel)( , var__temp_h833, other ) ==(sel)( , var_h822, other ) => 
 	 Rel (sel)( , var__temp_h833, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h833, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'835, res ) ==(var__temp_v834) AND 
 	 Rel (sel)( , var__temp_h'835, res ) ==((sel)( , var__temp_h833, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'835, other ) ==(sel)( , var__temp_h833, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'835, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'835, other ) > (4)
 
VC_END(declare-const var_h_i823 T3009)
(declare-const var_h822 T3009)
(declare-const v Int)
(declare-const var_h_i44 T3009)
(declare-const var_h43 T3009)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h833 T3009)
(declare-const var__temp_v834 Int)
(declare-const |var__temp_h'835| T3009)
(declare-const var__temp_v_err836 T3010)
(declare-const var_h822 T3009)
(declare-const var_h43 T3009)
(declare-const err T3023)

solver 
 (declare-sort T3009)
(declare-fun sel (T3009 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T3009)
(declare-fun var_h43 () T3009)
(declare-fun other () Int)
(declare-fun |var__temp_h'835| () T3009)
(declare-fun var__temp_h833 () T3009)
(declare-fun var__temp_v834 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h833 res) v)
                    (= (sel var_h822 res) (sel var_h822 res))
                    (= (sel var__temp_h833 other) (sel var_h822 other)))
               (> (sel var__temp_h833 res) 4)))
      (a!2 (and (= (sel |var__temp_h'835| res) var__temp_v834)
                (= (sel |var__temp_h'835| res) (+ (sel var__temp_h833 res) 10))
                (= (sel |var__temp_h'835| other) (sel var__temp_h833 other))))
      (a!3 (and (= (sel |var__temp_h'835| res) 10)
                (not (> (sel |var__temp_h'835| other) 4)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h833 res) 4) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************226
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i823 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i823, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h822, res ) ==(sel)( , var_h822, res )
 	 , (sel)( , var_h_i823, other ) ==(sel)( , var_h822, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v824:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i823 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h837 --->  Ty_heap  
 var__temp_v838 --->  Ty_int  
 var__temp_h'839 --->  Ty_heap  
 var__temp_v_err840 --->  error  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h837, res ) ==(v) AND 
 	 Rel (sel)( , var_h822, res ) ==(sel)( , var_h822, res ) AND 
 	 Rel (sel)( , var__temp_h837, other ) ==(sel)( , var_h822, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'839, res ) ==(var__temp_v838) AND 
 	 Base var__temp_v838 = 20 AND 
 	 Rel (sel)( , var__temp_h'839, other ) ==(sel)( , var__temp_h837, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'839, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'839, other ) > (4)
 
VC_END(declare-const var_h_i823 T3026)
(declare-const var_h822 T3026)
(declare-const v Int)
(declare-const var_h_i44 T3026)
(declare-const var_h43 T3026)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h837 T3026)
(declare-const var__temp_v838 Int)
(declare-const |var__temp_h'839| T3026)
(declare-const var__temp_v_err840 T3027)
(declare-const var_h822 T3026)
(declare-const var_h43 T3026)
(declare-const err T3040)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3026)
(declare-fun sel (T3026 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T3026)
(declare-fun var_h43 () T3026)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'839| () T3026)
(declare-fun var__temp_h837 () T3026)
(declare-fun var__temp_v838 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h837 res) v)
                    (= (sel var_h822 res) (sel var_h822 res))
                    (= (sel var__temp_h837 other) (sel var_h822 other)))
               true))
      (a!2 (and (= (sel |var__temp_h'839| res) 10)
                (not (> (sel |var__temp_h'839| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'839| res) var__temp_v838)
                    (= var__temp_v838 |20|)
                    (= (sel |var__temp_h'839| other) (sel var__temp_h837 other)))
               a!2)))
  (not (and a!1 (=> true a!3))))))

***************Selection Failed************foo'
 *********************Enumeration Iteration*****************227
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i823 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i823, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h822, res ) ==(sel)( , var_h822, res )
 	 , (sel)( , var_h_i823, other ) ==(sel)( , var_h822, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v824:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i823 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h841 --->  Ty_heap  
 var__temp_v842 --->  Ty_int  
 var__temp_h'843 --->  Ty_heap  
 var__temp_v_err844 --->  error  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h841, res ) ==(v) AND 
 	 Rel (sel)( , var_h822, res ) ==(sel)( , var_h822, res ) AND 
 	 Rel (sel)( , var__temp_h841, other ) ==(sel)( , var_h822, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'843, res ) ==(var__temp_v842) AND 
 	 Base var__temp_v842 = 5 AND 
 	 Rel (sel)( , var__temp_h'843, other ) ==(sel)( , var__temp_h841, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'843, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'843, other ) > (4)
 
VC_END(declare-const var_h_i823 T3043)
(declare-const var_h822 T3043)
(declare-const v Int)
(declare-const var_h_i44 T3043)
(declare-const var_h43 T3043)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h841 T3043)
(declare-const var__temp_v842 Int)
(declare-const |var__temp_h'843| T3043)
(declare-const var__temp_v_err844 T3044)
(declare-const var_h822 T3043)
(declare-const var_h43 T3043)
(declare-const err T3057)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3043)
(declare-fun sel (T3043 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T3043)
(declare-fun var_h43 () T3043)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'843| () T3043)
(declare-fun var__temp_h841 () T3043)
(declare-fun var__temp_v842 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h841 res) v)
                    (= (sel var_h822 res) (sel var_h822 res))
                    (= (sel var__temp_h841 other) (sel var_h822 other)))
               true))
      (a!2 (and (= (sel |var__temp_h'843| res) 10)
                (not (> (sel |var__temp_h'843| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'843| res) var__temp_v842)
                    (= var__temp_v842 |5|)
                    (= (sel |var__temp_h'843| other) (sel var__temp_h841 other)))
               a!2)))
  (not (and a!1 (=> true a!3))))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************228
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i823 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i823, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h822, res ) ==(sel)( , var_h822, res )
 	 , (sel)( , var_h_i823, other ) ==(sel)( , var_h822, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v824:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i823 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h845 --->  Ty_heap  
 var__temp_v846 --->  Ty_int  
 var__temp_h'847 --->  Ty_heap  
 var__temp_v_err848 --->  error  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h845, res ) ==(v) AND 
 	 Rel (sel)( , var_h822, res ) ==(sel)( , var_h822, res ) AND 
 	 Rel (sel)( , var__temp_h845, other ) ==(sel)( , var_h822, other ) => 
 	 Rel (sel)( , var__temp_h845, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h845, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'847, res ) ==(var__temp_v846) AND 
 	 Rel (sel)( , var__temp_h'847, res ) ==((sel)( , var__temp_h845, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'847, other ) ==(sel)( , var__temp_h845, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'847, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'847, other ) > (4)
 
VC_END(declare-const var_h_i823 T3060)
(declare-const var_h822 T3060)
(declare-const v Int)
(declare-const var_h_i44 T3060)
(declare-const var_h43 T3060)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h845 T3060)
(declare-const var__temp_v846 Int)
(declare-const |var__temp_h'847| T3060)
(declare-const var__temp_v_err848 T3061)
(declare-const var_h822 T3060)
(declare-const var_h43 T3060)
(declare-const err T3074)

solver 
 (declare-sort T3060)
(declare-fun sel (T3060 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T3060)
(declare-fun var_h43 () T3060)
(declare-fun other () Int)
(declare-fun |var__temp_h'847| () T3060)
(declare-fun var__temp_h845 () T3060)
(declare-fun var__temp_v846 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h845 res) v)
                    (= (sel var_h822 res) (sel var_h822 res))
                    (= (sel var__temp_h845 other) (sel var_h822 other)))
               (= (sel var__temp_h845 res) 5)))
      (a!2 (and (= (sel |var__temp_h'847| res) var__temp_v846)
                (= (sel |var__temp_h'847| res) (+ (sel var__temp_h845 res) 2))
                (= (sel |var__temp_h'847| other) (sel var__temp_h845 other))))
      (a!3 (and (= (sel |var__temp_h'847| res) 10)
                (not (> (sel |var__temp_h'847| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h845 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************229
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v824:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v824:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i823 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i823, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h822, res ) ==(sel)( , var_h822, res )
 	 , (sel)( , var_h_i823, other ) ==(sel)( , var_h822, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v849:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************230
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i823 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i823, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h822, res ) ==(sel)( , var_h822, res )
 	 , (sel)( , var_h_i823, other ) ==(sel)( , var_h822, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v849:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h850 --->  Ty_heap  
 var__temp_v851 --->  Ty_int  
 var__temp_h'852 --->  Ty_heap  
 var__temp_v_err853 --->  error  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h850, res ) ==(v) AND 
 	 Rel (sel)( , var_h822, res ) ==(sel)( , var_h822, res ) AND 
 	 Rel (sel)( , var__temp_h850, other ) ==(sel)( , var_h822, other ) => 
 	 Rel (sel)( , var__temp_h850, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h850, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'852, res ) ==(var__temp_v851) AND 
 	 Rel (sel)( , var__temp_h'852, res ) ==((sel)( , var__temp_h850, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'852, other ) ==(sel)( , var__temp_h850, other ) => 
 	 True
 
VC_END(declare-const var_h_i823 T3077)
(declare-const var_h822 T3077)
(declare-const v Int)
(declare-const var_h_i44 T3077)
(declare-const var_h43 T3077)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h850 T3077)
(declare-const var__temp_v851 Int)
(declare-const |var__temp_h'852| T3077)
(declare-const var__temp_v_err853 T3078)
(declare-const var_h822 T3077)
(declare-const var_h43 T3077)
(declare-const err T3091)

solver 
 (declare-sort T3077)
(declare-fun sel (T3077 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T3077)
(declare-fun var_h43 () T3077)
(declare-fun other () Int)
(declare-fun var__temp_h850 () T3077)
(declare-fun |var__temp_h'852| () T3077)
(declare-fun var__temp_v851 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h850 res) v)
                    (= (sel var_h822 res) (sel var_h822 res))
                    (= (sel var__temp_h850 other) (sel var_h822 other)))
               (= (sel var__temp_h850 res) 7)))
      (a!2 (and (= (sel |var__temp_h'852| res) var__temp_v851)
                (= (sel |var__temp_h'852| res) (+ (sel var__temp_h850 res) 3))
                (= (sel |var__temp_h'852| other) (sel var__temp_h850 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h850 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************231
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i823 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i823, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h822, res ) ==(sel)( , var_h822, res )
 	 , (sel)( , var_h_i823, other ) ==(sel)( , var_h822, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v849:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h854 --->  Ty_heap  
 var__temp_v855 --->  Ty_int  
 var__temp_h'856 --->  Ty_heap  
 var__temp_v_err857 --->  error  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h854, res ) ==(v) AND 
 	 Rel (sel)( , var_h822, res ) ==(sel)( , var_h822, res ) AND 
 	 Rel (sel)( , var__temp_h854, other ) ==(sel)( , var_h822, other ) => 
 	 Rel (sel)( , var__temp_h854, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h854, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'856, res ) ==(var__temp_v855) AND 
 	 Rel (sel)( , var__temp_h'856, res ) ==((sel)( , var__temp_h854, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'856, other ) ==(sel)( , var__temp_h854, other ) => 
 	 True
 
VC_END(declare-const var_h_i823 T3094)
(declare-const var_h822 T3094)
(declare-const v Int)
(declare-const var_h_i44 T3094)
(declare-const var_h43 T3094)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h854 T3094)
(declare-const var__temp_v855 Int)
(declare-const |var__temp_h'856| T3094)
(declare-const var__temp_v_err857 T3095)
(declare-const var_h822 T3094)
(declare-const var_h43 T3094)
(declare-const err T3108)

solver 
 (declare-sort T3094)
(declare-fun sel (T3094 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T3094)
(declare-fun var_h43 () T3094)
(declare-fun other () Int)
(declare-fun var__temp_h854 () T3094)
(declare-fun |var__temp_h'856| () T3094)
(declare-fun var__temp_v855 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h854 res) v)
                    (= (sel var_h822 res) (sel var_h822 res))
                    (= (sel var__temp_h854 other) (sel var_h822 other)))
               (= (sel var__temp_h854 res) 7)))
      (a!2 (and (= (sel |var__temp_h'856| res) var__temp_v855)
                (= (sel |var__temp_h'856| res) (+ (sel var__temp_h854 res) 5))
                (= (sel |var__temp_h'856| other) (sel var__temp_h854 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h854 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************232
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i823 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i823, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h822, res ) ==(sel)( , var_h822, res )
 	 , (sel)( , var_h_i823, other ) ==(sel)( , var_h822, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v849:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h858 --->  Ty_heap  
 var__temp_v859 --->  Ty_int  
 var__temp_h'860 --->  Ty_heap  
 var__temp_v_err861 --->  error  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h858, res ) ==(v) AND 
 	 Rel (sel)( , var_h822, res ) ==(sel)( , var_h822, res ) AND 
 	 Rel (sel)( , var__temp_h858, other ) ==(sel)( , var_h822, other ) => 
 	 Rel (sel)( , var__temp_h858, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h858, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'860, res ) ==(var__temp_v859) AND 
 	 Rel (sel)( , var__temp_h'860, res ) ==((sel)( , var__temp_h858, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'860, other ) ==(sel)( , var__temp_h858, other ) => 
 	 True
 
VC_END(declare-const var_h_i823 T3111)
(declare-const var_h822 T3111)
(declare-const v Int)
(declare-const var_h_i44 T3111)
(declare-const var_h43 T3111)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h858 T3111)
(declare-const var__temp_v859 Int)
(declare-const |var__temp_h'860| T3111)
(declare-const var__temp_v_err861 T3112)
(declare-const var_h822 T3111)
(declare-const var_h43 T3111)
(declare-const err T3125)

solver 
 (declare-sort T3111)
(declare-fun sel (T3111 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T3111)
(declare-fun var_h43 () T3111)
(declare-fun other () Int)
(declare-fun var__temp_h858 () T3111)
(declare-fun |var__temp_h'860| () T3111)
(declare-fun var__temp_v859 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h858 res) v)
                    (= (sel var_h822 res) (sel var_h822 res))
                    (= (sel var__temp_h858 other) (sel var_h822 other)))
               (> (sel var__temp_h858 res) 4)))
      (a!2 (and (= (sel |var__temp_h'860| res) var__temp_v859)
                (= (sel |var__temp_h'860| res) (+ (sel var__temp_h858 res) 10))
                (= (sel |var__temp_h'860| other) (sel var__temp_h858 other)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h858 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************233
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i823 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i823, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h822, res ) ==(sel)( , var_h822, res )
 	 , (sel)( , var_h_i823, other ) ==(sel)( , var_h822, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v849:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h862 --->  Ty_heap  
 var__temp_v863 --->  Ty_int  
 var__temp_h'864 --->  Ty_heap  
 var__temp_v_err865 --->  error  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h862, res ) ==(v) AND 
 	 Rel (sel)( , var_h822, res ) ==(sel)( , var_h822, res ) AND 
 	 Rel (sel)( , var__temp_h862, other ) ==(sel)( , var_h822, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'864, res ) ==(var__temp_v863) AND 
 	 Base var__temp_v863 = 20 AND 
 	 Rel (sel)( , var__temp_h'864, other ) ==(sel)( , var__temp_h862, other ) => 
 	 True
 
VC_END(declare-const var_h_i823 T3128)
(declare-const var_h822 T3128)
(declare-const v Int)
(declare-const var_h_i44 T3128)
(declare-const var_h43 T3128)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h862 T3128)
(declare-const var__temp_v863 Int)
(declare-const |var__temp_h'864| T3128)
(declare-const var__temp_v_err865 T3129)
(declare-const var_h822 T3128)
(declare-const var_h43 T3128)
(declare-const err T3142)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3128)
(declare-fun sel (T3128 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T3128)
(declare-fun var_h43 () T3128)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h862 () T3128)
(declare-fun |var__temp_h'864| () T3128)
(declare-fun var__temp_v863 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h862 res) v)
                    (= (sel var_h822 res) (sel var_h822 res))
                    (= (sel var__temp_h862 other) (sel var_h822 other)))
               true))
      (a!2 (=> (and (= (sel |var__temp_h'864| res) var__temp_v863)
                    (= var__temp_v863 |20|)
                    (= (sel |var__temp_h'864| other) (sel var__temp_h862 other)))
               true)))
  (not (and a!1 (=> true a!2)))))

***************Selection Successful************foo'
PARTIAL PATH NEW
SUB 
 	 --foo'
 	 --c2'
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i867 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i867 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i867, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i867, other ) ==(sel)( , var_h866, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v868:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i867 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************234
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i867 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i867, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i867, other ) ==(sel)( , var_h866, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v868:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i867 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h869 --->  Ty_heap  
 var__temp_v870 --->  Ty_int  
 var__temp_h'871 --->  Ty_heap  
 var__temp_v_err872 --->  error  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h869, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h869, other ) ==(sel)( , var_h866, other ) => 
 	 Rel (sel)( , var__temp_h869, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h869, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'871, res ) ==(var__temp_v870) AND 
 	 Rel (sel)( , var__temp_h'871, res ) ==((sel)( , var__temp_h869, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'871, other ) ==(sel)( , var__temp_h869, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'871, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'871, other ) > (4)
 
VC_END(declare-const var_h_i867 T3145)
(declare-const var_h866 T3145)
(declare-const v Int)
(declare-const var_h_i823 T3145)
(declare-const var_h822 T3145)
(declare-const v Int)
(declare-const var_h_i44 T3145)
(declare-const var_h43 T3145)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h869 T3145)
(declare-const var__temp_v870 Int)
(declare-const |var__temp_h'871| T3145)
(declare-const var__temp_v_err872 T3146)
(declare-const var_h866 T3145)
(declare-const var_h822 T3145)
(declare-const var_h43 T3145)
(declare-const err T3159)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3145)
(declare-fun sel (T3145 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T3145)
(declare-fun var_h43 () T3145)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'871| () T3145)
(declare-fun var__temp_h869 () T3145)
(declare-fun var__temp_v870 () Int)
(declare-fun var_h866 () T3145)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h869 res) v)
                    (= v |20|)
                    (= (sel var__temp_h869 other) (sel var_h866 other)))
               (= (sel var__temp_h869 res) 7)))
      (a!2 (and (= (sel |var__temp_h'871| res) var__temp_v870)
                (= (sel |var__temp_h'871| res) (+ (sel var__temp_h869 res) 3))
                (= (sel |var__temp_h'871| other) (sel var__temp_h869 other))))
      (a!3 (and (= (sel |var__temp_h'871| res) 10)
                (not (> (sel |var__temp_h'871| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h869 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************235
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i867 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i867, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i867, other ) ==(sel)( , var_h866, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v868:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i867 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h873 --->  Ty_heap  
 var__temp_v874 --->  Ty_int  
 var__temp_h'875 --->  Ty_heap  
 var__temp_v_err876 --->  error  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h873, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h873, other ) ==(sel)( , var_h866, other ) => 
 	 Rel (sel)( , var__temp_h873, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h873, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'875, res ) ==(var__temp_v874) AND 
 	 Rel (sel)( , var__temp_h'875, res ) ==((sel)( , var__temp_h873, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'875, other ) ==(sel)( , var__temp_h873, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'875, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'875, other ) > (4)
 
VC_END(declare-const var_h_i867 T3162)
(declare-const var_h866 T3162)
(declare-const v Int)
(declare-const var_h_i823 T3162)
(declare-const var_h822 T3162)
(declare-const v Int)
(declare-const var_h_i44 T3162)
(declare-const var_h43 T3162)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h873 T3162)
(declare-const var__temp_v874 Int)
(declare-const |var__temp_h'875| T3162)
(declare-const var__temp_v_err876 T3163)
(declare-const var_h866 T3162)
(declare-const var_h822 T3162)
(declare-const var_h43 T3162)
(declare-const err T3176)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3162)
(declare-fun sel (T3162 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T3162)
(declare-fun var_h43 () T3162)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'875| () T3162)
(declare-fun var__temp_h873 () T3162)
(declare-fun var__temp_v874 () Int)
(declare-fun var_h866 () T3162)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h873 res) v)
                    (= v |20|)
                    (= (sel var__temp_h873 other) (sel var_h866 other)))
               (= (sel var__temp_h873 res) 7)))
      (a!2 (and (= (sel |var__temp_h'875| res) var__temp_v874)
                (= (sel |var__temp_h'875| res) (+ (sel var__temp_h873 res) 5))
                (= (sel |var__temp_h'875| other) (sel var__temp_h873 other))))
      (a!3 (and (= (sel |var__temp_h'875| res) 10)
                (not (> (sel |var__temp_h'875| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h873 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************236
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i867 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i867, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i867, other ) ==(sel)( , var_h866, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v868:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i867 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h877 --->  Ty_heap  
 var__temp_v878 --->  Ty_int  
 var__temp_h'879 --->  Ty_heap  
 var__temp_v_err880 --->  error  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h877, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h877, other ) ==(sel)( , var_h866, other ) => 
 	 Rel (sel)( , var__temp_h877, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h877, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'879, res ) ==(var__temp_v878) AND 
 	 Rel (sel)( , var__temp_h'879, res ) ==((sel)( , var__temp_h877, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'879, other ) ==(sel)( , var__temp_h877, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'879, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'879, other ) > (4)
 
VC_END(declare-const var_h_i867 T3179)
(declare-const var_h866 T3179)
(declare-const v Int)
(declare-const var_h_i823 T3179)
(declare-const var_h822 T3179)
(declare-const v Int)
(declare-const var_h_i44 T3179)
(declare-const var_h43 T3179)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h877 T3179)
(declare-const var__temp_v878 Int)
(declare-const |var__temp_h'879| T3179)
(declare-const var__temp_v_err880 T3180)
(declare-const var_h866 T3179)
(declare-const var_h822 T3179)
(declare-const var_h43 T3179)
(declare-const err T3193)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3179)
(declare-fun sel (T3179 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T3179)
(declare-fun var_h43 () T3179)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'879| () T3179)
(declare-fun var__temp_h877 () T3179)
(declare-fun var__temp_v878 () Int)
(declare-fun var_h866 () T3179)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h877 res) v)
                    (= v |20|)
                    (= (sel var__temp_h877 other) (sel var_h866 other)))
               (> (sel var__temp_h877 res) 4)))
      (a!2 (and (= (sel |var__temp_h'879| res) var__temp_v878)
                (= (sel |var__temp_h'879| res) (+ (sel var__temp_h877 res) 10))
                (= (sel |var__temp_h'879| other) (sel var__temp_h877 other))))
      (a!3 (and (= (sel |var__temp_h'879| res) 10)
                (not (> (sel |var__temp_h'879| other) 4)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h877 res) 4) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************237
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i867 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i867, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i867, other ) ==(sel)( , var_h866, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v868:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i867 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h881 --->  Ty_heap  
 var__temp_v882 --->  Ty_int  
 var__temp_h'883 --->  Ty_heap  
 var__temp_v_err884 --->  error  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h881, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h881, other ) ==(sel)( , var_h866, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'883, res ) ==(var__temp_v882) AND 
 	 Base var__temp_v882 = 5 AND 
 	 Rel (sel)( , var__temp_h'883, other ) ==(sel)( , var__temp_h881, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'883, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'883, other ) > (4)
 
VC_END(declare-const var_h_i867 T3196)
(declare-const var_h866 T3196)
(declare-const v Int)
(declare-const var_h_i823 T3196)
(declare-const var_h822 T3196)
(declare-const v Int)
(declare-const var_h_i44 T3196)
(declare-const var_h43 T3196)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h881 T3196)
(declare-const var__temp_v882 Int)
(declare-const |var__temp_h'883| T3196)
(declare-const var__temp_v_err884 T3197)
(declare-const var_h866 T3196)
(declare-const var_h822 T3196)
(declare-const var_h43 T3196)
(declare-const err T3210)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T3196)
(declare-fun sel (T3196 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T3196)
(declare-fun var_h43 () T3196)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'883| () T3196)
(declare-fun var__temp_h881 () T3196)
(declare-fun var__temp_v882 () Int)
(declare-fun var_h866 () T3196)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h881 res) v)
                    (= v |20|)
                    (= (sel var__temp_h881 other) (sel var_h866 other)))
               true))
      (a!2 (and (= (sel |var__temp_h'883| res) 10)
                (not (> (sel |var__temp_h'883| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'883| res) var__temp_v882)
                    (= var__temp_v882 |5|)
                    (= (sel |var__temp_h'883| other) (sel var__temp_h881 other)))
               a!2)))
  (not (and a!1 (=> true a!3))))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************238
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i867 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i867, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i867, other ) ==(sel)( , var_h866, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v868:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i867 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h885 --->  Ty_heap  
 var__temp_v886 --->  Ty_int  
 var__temp_h'887 --->  Ty_heap  
 var__temp_v_err888 --->  error  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h885, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h885, other ) ==(sel)( , var_h866, other ) => 
 	 Rel (sel)( , var__temp_h885, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h885, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'887, res ) ==(var__temp_v886) AND 
 	 Rel (sel)( , var__temp_h'887, res ) ==((sel)( , var__temp_h885, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'887, other ) ==(sel)( , var__temp_h885, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'887, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'887, other ) > (4)
 
VC_END(declare-const var_h_i867 T3213)
(declare-const var_h866 T3213)
(declare-const v Int)
(declare-const var_h_i823 T3213)
(declare-const var_h822 T3213)
(declare-const v Int)
(declare-const var_h_i44 T3213)
(declare-const var_h43 T3213)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h885 T3213)
(declare-const var__temp_v886 Int)
(declare-const |var__temp_h'887| T3213)
(declare-const var__temp_v_err888 T3214)
(declare-const var_h866 T3213)
(declare-const var_h822 T3213)
(declare-const var_h43 T3213)
(declare-const err T3227)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3213)
(declare-fun sel (T3213 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T3213)
(declare-fun var_h43 () T3213)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'887| () T3213)
(declare-fun var__temp_h885 () T3213)
(declare-fun var__temp_v886 () Int)
(declare-fun var_h866 () T3213)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h885 res) v)
                    (= v |20|)
                    (= (sel var__temp_h885 other) (sel var_h866 other)))
               (= (sel var__temp_h885 res) 5)))
      (a!2 (and (= (sel |var__temp_h'887| res) var__temp_v886)
                (= (sel |var__temp_h'887| res) (+ (sel var__temp_h885 res) 2))
                (= (sel |var__temp_h'887| other) (sel var__temp_h885 other))))
      (a!3 (and (= (sel |var__temp_h'887| res) 10)
                (not (> (sel |var__temp_h'887| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h885 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************239
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v868:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v868:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --foo'
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i867 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i867, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i867, other ) ==(sel)( , var_h866, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v889:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************240
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i867 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i867, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i867, other ) ==(sel)( , var_h866, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v889:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h890 --->  Ty_heap  
 var__temp_v891 --->  Ty_int  
 var__temp_h'892 --->  Ty_heap  
 var__temp_v_err893 --->  error  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h890, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h890, other ) ==(sel)( , var_h866, other ) => 
 	 Rel (sel)( , var__temp_h890, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h890, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'892, res ) ==(var__temp_v891) AND 
 	 Rel (sel)( , var__temp_h'892, res ) ==((sel)( , var__temp_h890, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'892, other ) ==(sel)( , var__temp_h890, other ) => 
 	 True
 
VC_END(declare-const var_h_i867 T3230)
(declare-const var_h866 T3230)
(declare-const v Int)
(declare-const var_h_i823 T3230)
(declare-const var_h822 T3230)
(declare-const v Int)
(declare-const var_h_i44 T3230)
(declare-const var_h43 T3230)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h890 T3230)
(declare-const var__temp_v891 Int)
(declare-const |var__temp_h'892| T3230)
(declare-const var__temp_v_err893 T3231)
(declare-const var_h866 T3230)
(declare-const var_h822 T3230)
(declare-const var_h43 T3230)
(declare-const err T3244)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3230)
(declare-fun sel (T3230 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T3230)
(declare-fun var_h43 () T3230)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h890 () T3230)
(declare-fun |var__temp_h'892| () T3230)
(declare-fun var__temp_v891 () Int)
(declare-fun var_h866 () T3230)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h890 res) v)
                    (= v |20|)
                    (= (sel var__temp_h890 other) (sel var_h866 other)))
               (= (sel var__temp_h890 res) 7)))
      (a!2 (and (= (sel |var__temp_h'892| res) var__temp_v891)
                (= (sel |var__temp_h'892| res) (+ (sel var__temp_h890 res) 3))
                (= (sel |var__temp_h'892| other) (sel var__temp_h890 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h890 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************241
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i867 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i867, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i867, other ) ==(sel)( , var_h866, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v889:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h894 --->  Ty_heap  
 var__temp_v895 --->  Ty_int  
 var__temp_h'896 --->  Ty_heap  
 var__temp_v_err897 --->  error  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h894, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h894, other ) ==(sel)( , var_h866, other ) => 
 	 Rel (sel)( , var__temp_h894, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h894, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'896, res ) ==(var__temp_v895) AND 
 	 Rel (sel)( , var__temp_h'896, res ) ==((sel)( , var__temp_h894, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'896, other ) ==(sel)( , var__temp_h894, other ) => 
 	 True
 
VC_END(declare-const var_h_i867 T3247)
(declare-const var_h866 T3247)
(declare-const v Int)
(declare-const var_h_i823 T3247)
(declare-const var_h822 T3247)
(declare-const v Int)
(declare-const var_h_i44 T3247)
(declare-const var_h43 T3247)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h894 T3247)
(declare-const var__temp_v895 Int)
(declare-const |var__temp_h'896| T3247)
(declare-const var__temp_v_err897 T3248)
(declare-const var_h866 T3247)
(declare-const var_h822 T3247)
(declare-const var_h43 T3247)
(declare-const err T3261)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3247)
(declare-fun sel (T3247 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T3247)
(declare-fun var_h43 () T3247)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h894 () T3247)
(declare-fun |var__temp_h'896| () T3247)
(declare-fun var__temp_v895 () Int)
(declare-fun var_h866 () T3247)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h894 res) v)
                    (= v |20|)
                    (= (sel var__temp_h894 other) (sel var_h866 other)))
               (= (sel var__temp_h894 res) 7)))
      (a!2 (and (= (sel |var__temp_h'896| res) var__temp_v895)
                (= (sel |var__temp_h'896| res) (+ (sel var__temp_h894 res) 5))
                (= (sel |var__temp_h'896| other) (sel var__temp_h894 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h894 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************242
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i867 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i867, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i867, other ) ==(sel)( , var_h866, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v889:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h898 --->  Ty_heap  
 var__temp_v899 --->  Ty_int  
 var__temp_h'900 --->  Ty_heap  
 var__temp_v_err901 --->  error  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h898, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h898, other ) ==(sel)( , var_h866, other ) => 
 	 Rel (sel)( , var__temp_h898, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h898, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'900, res ) ==(var__temp_v899) AND 
 	 Rel (sel)( , var__temp_h'900, res ) ==((sel)( , var__temp_h898, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'900, other ) ==(sel)( , var__temp_h898, other ) => 
 	 True
 
VC_END(declare-const var_h_i867 T3264)
(declare-const var_h866 T3264)
(declare-const v Int)
(declare-const var_h_i823 T3264)
(declare-const var_h822 T3264)
(declare-const v Int)
(declare-const var_h_i44 T3264)
(declare-const var_h43 T3264)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h898 T3264)
(declare-const var__temp_v899 Int)
(declare-const |var__temp_h'900| T3264)
(declare-const var__temp_v_err901 T3265)
(declare-const var_h866 T3264)
(declare-const var_h822 T3264)
(declare-const var_h43 T3264)
(declare-const err T3278)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3264)
(declare-fun sel (T3264 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T3264)
(declare-fun var_h43 () T3264)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h898 () T3264)
(declare-fun |var__temp_h'900| () T3264)
(declare-fun var__temp_v899 () Int)
(declare-fun var_h866 () T3264)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h898 res) v)
                    (= v |20|)
                    (= (sel var__temp_h898 other) (sel var_h866 other)))
               (> (sel var__temp_h898 res) 4)))
      (a!2 (and (= (sel |var__temp_h'900| res) var__temp_v899)
                (= (sel |var__temp_h'900| res) (+ (sel var__temp_h898 res) 10))
                (= (sel |var__temp_h'900| other) (sel var__temp_h898 other)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h898 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c2
PARTIAL PATH NEW
SUB 
 	 --c2
 	 --foo'
 	 --c2'
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i903 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i903 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i903, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i903, res ) ==((sel)( , var_h902, res ) + (10))
 	 , (sel)( , var_h_i903, other ) ==(sel)( , var_h902, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v904:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i903 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************243
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i903 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i903, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i903, res ) ==((sel)( , var_h902, res ) + (10))
 	 , (sel)( , var_h_i903, other ) ==(sel)( , var_h902, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v904:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i903 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i903 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h905 --->  Ty_heap  
 var__temp_v906 --->  Ty_int  
 var__temp_h'907 --->  Ty_heap  
 var__temp_v_err908 --->  error  
 var_h902 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h902, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h905, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h905, res ) ==((sel)( , var_h902, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h905, other ) ==(sel)( , var_h902, other ) => 
 	 Rel (sel)( , var__temp_h905, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h905, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'907, res ) ==(var__temp_v906) AND 
 	 Rel (sel)( , var__temp_h'907, res ) ==((sel)( , var__temp_h905, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'907, other ) ==(sel)( , var__temp_h905, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'907, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'907, other ) > (4)
 
VC_END(declare-const var_h_i903 T3281)
(declare-const var_h902 T3281)
(declare-const v Int)
(declare-const var_h_i867 T3281)
(declare-const var_h866 T3281)
(declare-const v Int)
(declare-const var_h_i823 T3281)
(declare-const var_h822 T3281)
(declare-const v Int)
(declare-const var_h_i44 T3281)
(declare-const var_h43 T3281)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h905 T3281)
(declare-const var__temp_v906 Int)
(declare-const |var__temp_h'907| T3281)
(declare-const var__temp_v_err908 T3282)
(declare-const var_h902 T3281)
(declare-const var_h866 T3281)
(declare-const var_h822 T3281)
(declare-const var_h43 T3281)
(declare-const err T3295)

solver 
 (declare-sort T3281)
(declare-fun sel (T3281 Int) Int)
(declare-fun res () Int)
(declare-fun var_h902 () T3281)
(declare-fun var_h822 () T3281)
(declare-fun var_h43 () T3281)
(declare-fun other () Int)
(declare-fun |var__temp_h'907| () T3281)
(declare-fun var__temp_h905 () T3281)
(declare-fun var__temp_v906 () Int)
(declare-fun v () Int)
(assert (> (sel var_h902 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h905 res) v)
                (= (sel var__temp_h905 res) (+ (sel var_h902 res) 10))
                (= (sel var__temp_h905 other) (sel var_h902 other))))
      (a!2 (and (= (sel |var__temp_h'907| res) var__temp_v906)
                (= (sel |var__temp_h'907| res) (+ (sel var__temp_h905 res) 3))
                (= (sel |var__temp_h'907| other) (sel var__temp_h905 other))))
      (a!3 (and (= (sel |var__temp_h'907| res) 10)
                (not (> (sel |var__temp_h'907| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h905 res) 7))
                (=> (= (sel var__temp_h905 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************244
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i903 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i903, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i903, res ) ==((sel)( , var_h902, res ) + (10))
 	 , (sel)( , var_h_i903, other ) ==(sel)( , var_h902, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v904:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i903 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i903 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h909 --->  Ty_heap  
 var__temp_v910 --->  Ty_int  
 var__temp_h'911 --->  Ty_heap  
 var__temp_v_err912 --->  error  
 var_h902 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h902, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h909, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h909, res ) ==((sel)( , var_h902, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h909, other ) ==(sel)( , var_h902, other ) => 
 	 Rel (sel)( , var__temp_h909, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h909, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'911, res ) ==(var__temp_v910) AND 
 	 Rel (sel)( , var__temp_h'911, res ) ==((sel)( , var__temp_h909, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'911, other ) ==(sel)( , var__temp_h909, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'911, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'911, other ) > (4)
 
VC_END(declare-const var_h_i903 T3298)
(declare-const var_h902 T3298)
(declare-const v Int)
(declare-const var_h_i867 T3298)
(declare-const var_h866 T3298)
(declare-const v Int)
(declare-const var_h_i823 T3298)
(declare-const var_h822 T3298)
(declare-const v Int)
(declare-const var_h_i44 T3298)
(declare-const var_h43 T3298)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h909 T3298)
(declare-const var__temp_v910 Int)
(declare-const |var__temp_h'911| T3298)
(declare-const var__temp_v_err912 T3299)
(declare-const var_h902 T3298)
(declare-const var_h866 T3298)
(declare-const var_h822 T3298)
(declare-const var_h43 T3298)
(declare-const err T3312)

solver 
 (declare-sort T3298)
(declare-fun sel (T3298 Int) Int)
(declare-fun res () Int)
(declare-fun var_h902 () T3298)
(declare-fun var_h822 () T3298)
(declare-fun var_h43 () T3298)
(declare-fun other () Int)
(declare-fun |var__temp_h'911| () T3298)
(declare-fun var__temp_h909 () T3298)
(declare-fun var__temp_v910 () Int)
(declare-fun v () Int)
(assert (> (sel var_h902 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h909 res) v)
                (= (sel var__temp_h909 res) (+ (sel var_h902 res) 10))
                (= (sel var__temp_h909 other) (sel var_h902 other))))
      (a!2 (and (= (sel |var__temp_h'911| res) var__temp_v910)
                (= (sel |var__temp_h'911| res) (+ (sel var__temp_h909 res) 5))
                (= (sel |var__temp_h'911| other) (sel var__temp_h909 other))))
      (a!3 (and (= (sel |var__temp_h'911| res) 10)
                (not (> (sel |var__temp_h'911| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h909 res) 7))
                (=> (= (sel var__temp_h909 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************245
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i903 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i903, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i903, res ) ==((sel)( , var_h902, res ) + (10))
 	 , (sel)( , var_h_i903, other ) ==(sel)( , var_h902, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v904:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i903 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i903 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h913 --->  Ty_heap  
 var__temp_v914 --->  Ty_int  
 var__temp_h'915 --->  Ty_heap  
 var__temp_v_err916 --->  error  
 var_h902 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h902, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h913, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h913, res ) ==((sel)( , var_h902, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h913, other ) ==(sel)( , var_h902, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'915, res ) ==(var__temp_v914) AND 
 	 Base var__temp_v914 = 5 AND 
 	 Rel (sel)( , var__temp_h'915, other ) ==(sel)( , var__temp_h913, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'915, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'915, other ) > (4)
 
VC_END(declare-const var_h_i903 T3315)
(declare-const var_h902 T3315)
(declare-const v Int)
(declare-const var_h_i867 T3315)
(declare-const var_h866 T3315)
(declare-const v Int)
(declare-const var_h_i823 T3315)
(declare-const var_h822 T3315)
(declare-const v Int)
(declare-const var_h_i44 T3315)
(declare-const var_h43 T3315)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h913 T3315)
(declare-const var__temp_v914 Int)
(declare-const |var__temp_h'915| T3315)
(declare-const var__temp_v_err916 T3316)
(declare-const var_h902 T3315)
(declare-const var_h866 T3315)
(declare-const var_h822 T3315)
(declare-const var_h43 T3315)
(declare-const err T3329)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3315)
(declare-fun sel (T3315 Int) Int)
(declare-fun res () Int)
(declare-fun var_h902 () T3315)
(declare-fun var_h822 () T3315)
(declare-fun var_h43 () T3315)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'915| () T3315)
(declare-fun var__temp_h913 () T3315)
(declare-fun var__temp_v914 () Int)
(declare-fun v () Int)
(assert (> (sel var_h902 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h913 res) v)
                (= (sel var__temp_h913 res) (+ (sel var_h902 res) 10))
                (= (sel var__temp_h913 other) (sel var_h902 other))))
      (a!2 (and (= (sel |var__temp_h'915| res) 10)
                (not (> (sel |var__temp_h'915| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'915| res) var__temp_v914)
                    (= var__temp_v914 |5|)
                    (= (sel |var__temp_h'915| other) (sel var__temp_h913 other)))
               a!2)))
  (not (and (=> a!1 true) (=> true a!3))))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************246
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i903 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i903, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i903, res ) ==((sel)( , var_h902, res ) + (10))
 	 , (sel)( , var_h_i903, other ) ==(sel)( , var_h902, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v904:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i903 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i903 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h917 --->  Ty_heap  
 var__temp_v918 --->  Ty_int  
 var__temp_h'919 --->  Ty_heap  
 var__temp_v_err920 --->  error  
 var_h902 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h902, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h917, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h917, res ) ==((sel)( , var_h902, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h917, other ) ==(sel)( , var_h902, other ) => 
 	 Rel (sel)( , var__temp_h917, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h917, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'919, res ) ==(var__temp_v918) AND 
 	 Rel (sel)( , var__temp_h'919, res ) ==((sel)( , var__temp_h917, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'919, other ) ==(sel)( , var__temp_h917, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'919, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'919, other ) > (4)
 
VC_END(declare-const var_h_i903 T3332)
(declare-const var_h902 T3332)
(declare-const v Int)
(declare-const var_h_i867 T3332)
(declare-const var_h866 T3332)
(declare-const v Int)
(declare-const var_h_i823 T3332)
(declare-const var_h822 T3332)
(declare-const v Int)
(declare-const var_h_i44 T3332)
(declare-const var_h43 T3332)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h917 T3332)
(declare-const var__temp_v918 Int)
(declare-const |var__temp_h'919| T3332)
(declare-const var__temp_v_err920 T3333)
(declare-const var_h902 T3332)
(declare-const var_h866 T3332)
(declare-const var_h822 T3332)
(declare-const var_h43 T3332)
(declare-const err T3346)

solver 
 (declare-sort T3332)
(declare-fun sel (T3332 Int) Int)
(declare-fun res () Int)
(declare-fun var_h902 () T3332)
(declare-fun var_h822 () T3332)
(declare-fun var_h43 () T3332)
(declare-fun other () Int)
(declare-fun |var__temp_h'919| () T3332)
(declare-fun var__temp_h917 () T3332)
(declare-fun var__temp_v918 () Int)
(declare-fun v () Int)
(assert (> (sel var_h902 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h917 res) v)
                (= (sel var__temp_h917 res) (+ (sel var_h902 res) 10))
                (= (sel var__temp_h917 other) (sel var_h902 other))))
      (a!2 (and (= (sel |var__temp_h'919| res) var__temp_v918)
                (= (sel |var__temp_h'919| res) (+ (sel var__temp_h917 res) 2))
                (= (sel |var__temp_h'919| other) (sel var__temp_h917 other))))
      (a!3 (and (= (sel |var__temp_h'919| res) 10)
                (not (> (sel |var__temp_h'919| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h917 res) 5))
                (=> (= (sel var__temp_h917 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************247
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v904:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v904:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c2
 	 --foo'
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i903 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i903, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i903, res ) ==((sel)( , var_h902, res ) + (10))
 	 , (sel)( , var_h_i903, other ) ==(sel)( , var_h902, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v921:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************248
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i903 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i903, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i903, res ) ==((sel)( , var_h902, res ) + (10))
 	 , (sel)( , var_h_i903, other ) ==(sel)( , var_h902, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v921:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i903 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h922 --->  Ty_heap  
 var__temp_v923 --->  Ty_int  
 var__temp_h'924 --->  Ty_heap  
 var__temp_v_err925 --->  error  
 var_h902 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h902, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h922, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h922, res ) ==((sel)( , var_h902, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h922, other ) ==(sel)( , var_h902, other ) => 
 	 Rel (sel)( , var__temp_h922, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h922, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'924, res ) ==(var__temp_v923) AND 
 	 Rel (sel)( , var__temp_h'924, res ) ==((sel)( , var__temp_h922, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'924, other ) ==(sel)( , var__temp_h922, other ) => 
 	 True
 
VC_END(declare-const var_h_i903 T3349)
(declare-const var_h902 T3349)
(declare-const v Int)
(declare-const var_h_i867 T3349)
(declare-const var_h866 T3349)
(declare-const v Int)
(declare-const var_h_i823 T3349)
(declare-const var_h822 T3349)
(declare-const v Int)
(declare-const var_h_i44 T3349)
(declare-const var_h43 T3349)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h922 T3349)
(declare-const var__temp_v923 Int)
(declare-const |var__temp_h'924| T3349)
(declare-const var__temp_v_err925 T3350)
(declare-const var_h902 T3349)
(declare-const var_h866 T3349)
(declare-const var_h822 T3349)
(declare-const var_h43 T3349)
(declare-const err T3363)

solver 
 (declare-sort T3349)
(declare-fun sel (T3349 Int) Int)
(declare-fun res () Int)
(declare-fun var_h902 () T3349)
(declare-fun var_h822 () T3349)
(declare-fun var_h43 () T3349)
(declare-fun other () Int)
(declare-fun var__temp_h922 () T3349)
(declare-fun |var__temp_h'924| () T3349)
(declare-fun var__temp_v923 () Int)
(declare-fun v () Int)
(assert (> (sel var_h902 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h922 res) v)
                (= (sel var__temp_h922 res) (+ (sel var_h902 res) 10))
                (= (sel var__temp_h922 other) (sel var_h902 other))))
      (a!2 (and (= (sel |var__temp_h'924| res) var__temp_v923)
                (= (sel |var__temp_h'924| res) (+ (sel var__temp_h922 res) 3))
                (= (sel |var__temp_h'924| other) (sel var__temp_h922 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h922 res) 7))
                (=> (= (sel var__temp_h922 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************249
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i903 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i903, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i903, res ) ==((sel)( , var_h902, res ) + (10))
 	 , (sel)( , var_h_i903, other ) ==(sel)( , var_h902, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v921:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i903 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h926 --->  Ty_heap  
 var__temp_v927 --->  Ty_int  
 var__temp_h'928 --->  Ty_heap  
 var__temp_v_err929 --->  error  
 var_h902 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h902, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h926, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h926, res ) ==((sel)( , var_h902, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h926, other ) ==(sel)( , var_h902, other ) => 
 	 Rel (sel)( , var__temp_h926, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h926, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'928, res ) ==(var__temp_v927) AND 
 	 Rel (sel)( , var__temp_h'928, res ) ==((sel)( , var__temp_h926, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'928, other ) ==(sel)( , var__temp_h926, other ) => 
 	 True
 
VC_END(declare-const var_h_i903 T3366)
(declare-const var_h902 T3366)
(declare-const v Int)
(declare-const var_h_i867 T3366)
(declare-const var_h866 T3366)
(declare-const v Int)
(declare-const var_h_i823 T3366)
(declare-const var_h822 T3366)
(declare-const v Int)
(declare-const var_h_i44 T3366)
(declare-const var_h43 T3366)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h926 T3366)
(declare-const var__temp_v927 Int)
(declare-const |var__temp_h'928| T3366)
(declare-const var__temp_v_err929 T3367)
(declare-const var_h902 T3366)
(declare-const var_h866 T3366)
(declare-const var_h822 T3366)
(declare-const var_h43 T3366)
(declare-const err T3380)

solver 
 (declare-sort T3366)
(declare-fun sel (T3366 Int) Int)
(declare-fun res () Int)
(declare-fun var_h902 () T3366)
(declare-fun var_h822 () T3366)
(declare-fun var_h43 () T3366)
(declare-fun other () Int)
(declare-fun var__temp_h926 () T3366)
(declare-fun |var__temp_h'928| () T3366)
(declare-fun var__temp_v927 () Int)
(declare-fun v () Int)
(assert (> (sel var_h902 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h926 res) v)
                (= (sel var__temp_h926 res) (+ (sel var_h902 res) 10))
                (= (sel var__temp_h926 other) (sel var_h902 other))))
      (a!2 (and (= (sel |var__temp_h'928| res) var__temp_v927)
                (= (sel |var__temp_h'928| res) (+ (sel var__temp_h926 res) 5))
                (= (sel |var__temp_h'928| other) (sel var__temp_h926 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h926 res) 7))
                (=> (= (sel var__temp_h926 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************250
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i903 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i903, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i903, res ) ==((sel)( , var_h902, res ) + (10))
 	 , (sel)( , var_h_i903, other ) ==(sel)( , var_h902, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v921:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i903 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h930 --->  Ty_heap  
 var__temp_v931 --->  Ty_int  
 var__temp_h'932 --->  Ty_heap  
 var__temp_v_err933 --->  error  
 var_h902 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h902, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h930, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h930, res ) ==((sel)( , var_h902, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h930, other ) ==(sel)( , var_h902, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'932, res ) ==(var__temp_v931) AND 
 	 Base var__temp_v931 = 5 AND 
 	 Rel (sel)( , var__temp_h'932, other ) ==(sel)( , var__temp_h930, other ) => 
 	 True
 
VC_END(declare-const var_h_i903 T3383)
(declare-const var_h902 T3383)
(declare-const v Int)
(declare-const var_h_i867 T3383)
(declare-const var_h866 T3383)
(declare-const v Int)
(declare-const var_h_i823 T3383)
(declare-const var_h822 T3383)
(declare-const v Int)
(declare-const var_h_i44 T3383)
(declare-const var_h43 T3383)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h930 T3383)
(declare-const var__temp_v931 Int)
(declare-const |var__temp_h'932| T3383)
(declare-const var__temp_v_err933 T3384)
(declare-const var_h902 T3383)
(declare-const var_h866 T3383)
(declare-const var_h822 T3383)
(declare-const var_h43 T3383)
(declare-const err T3397)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3383)
(declare-fun sel (T3383 Int) Int)
(declare-fun res () Int)
(declare-fun var_h902 () T3383)
(declare-fun var_h822 () T3383)
(declare-fun var_h43 () T3383)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h930 () T3383)
(declare-fun |var__temp_h'932| () T3383)
(declare-fun var__temp_v931 () Int)
(declare-fun v () Int)
(assert (> (sel var_h902 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h930 res) v)
                (= (sel var__temp_h930 res) (+ (sel var_h902 res) 10))
                (= (sel var__temp_h930 other) (sel var_h902 other))))
      (a!2 (=> (and (= (sel |var__temp_h'932| res) var__temp_v931)
                    (= var__temp_v931 |5|)
                    (= (sel |var__temp_h'932| other) (sel var__temp_h930 other)))
               true)))
  (not (and (=> a!1 true) (=> true a!2)))))

***************Selection Successful************foo
PARTIAL PATH NEW
SUB 
 	 --foo
 	 --c2
 	 --foo'
 	 --c2'
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i935 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i935 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i935, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i935, other ) ==(sel)( , var_h934, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v936:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i935 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************251
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i935 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i935, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i935, other ) ==(sel)( , var_h934, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v936:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i935 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i935 --->  Ty_heap  
 var_h934 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i903 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h937 --->  Ty_heap  
 var__temp_v938 --->  Ty_int  
 var__temp_h'939 --->  Ty_heap  
 var__temp_v_err940 --->  error  
 var_h934 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h902, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h937, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h937, other ) ==(sel)( , var_h934, other ) => 
 	 Rel (sel)( , var__temp_h937, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h937, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'939, res ) ==(var__temp_v938) AND 
 	 Rel (sel)( , var__temp_h'939, res ) ==((sel)( , var__temp_h937, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'939, other ) ==(sel)( , var__temp_h937, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'939, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'939, other ) > (4)
 
VC_END(declare-const var_h_i935 T3400)
(declare-const var_h934 T3400)
(declare-const v Int)
(declare-const var_h_i903 T3400)
(declare-const var_h902 T3400)
(declare-const v Int)
(declare-const var_h_i867 T3400)
(declare-const var_h866 T3400)
(declare-const v Int)
(declare-const var_h_i823 T3400)
(declare-const var_h822 T3400)
(declare-const v Int)
(declare-const var_h_i44 T3400)
(declare-const var_h43 T3400)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h937 T3400)
(declare-const var__temp_v938 Int)
(declare-const |var__temp_h'939| T3400)
(declare-const var__temp_v_err940 T3401)
(declare-const var_h934 T3400)
(declare-const var_h902 T3400)
(declare-const var_h866 T3400)
(declare-const var_h822 T3400)
(declare-const var_h43 T3400)
(declare-const err T3414)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3400)
(declare-fun sel (T3400 Int) Int)
(declare-fun res () Int)
(declare-fun var_h902 () T3400)
(declare-fun var_h822 () T3400)
(declare-fun var_h43 () T3400)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'939| () T3400)
(declare-fun var__temp_h937 () T3400)
(declare-fun var__temp_v938 () Int)
(declare-fun var_h934 () T3400)
(declare-fun v () Int)
(assert (> (sel var_h902 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h937 res) v)
                    (= v |5|)
                    (= (sel var__temp_h937 other) (sel var_h934 other)))
               (= (sel var__temp_h937 res) 7)))
      (a!2 (and (= (sel |var__temp_h'939| res) var__temp_v938)
                (= (sel |var__temp_h'939| res) (+ (sel var__temp_h937 res) 3))
                (= (sel |var__temp_h'939| other) (sel var__temp_h937 other))))
      (a!3 (and (= (sel |var__temp_h'939| res) 10)
                (not (> (sel |var__temp_h'939| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h937 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************252
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i935 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i935, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i935, other ) ==(sel)( , var_h934, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v936:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i935 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i935 --->  Ty_heap  
 var_h934 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i903 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h941 --->  Ty_heap  
 var__temp_v942 --->  Ty_int  
 var__temp_h'943 --->  Ty_heap  
 var__temp_v_err944 --->  error  
 var_h934 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h902, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h941, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h941, other ) ==(sel)( , var_h934, other ) => 
 	 Rel (sel)( , var__temp_h941, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h941, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'943, res ) ==(var__temp_v942) AND 
 	 Rel (sel)( , var__temp_h'943, res ) ==((sel)( , var__temp_h941, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'943, other ) ==(sel)( , var__temp_h941, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'943, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'943, other ) > (4)
 
VC_END(declare-const var_h_i935 T3417)
(declare-const var_h934 T3417)
(declare-const v Int)
(declare-const var_h_i903 T3417)
(declare-const var_h902 T3417)
(declare-const v Int)
(declare-const var_h_i867 T3417)
(declare-const var_h866 T3417)
(declare-const v Int)
(declare-const var_h_i823 T3417)
(declare-const var_h822 T3417)
(declare-const v Int)
(declare-const var_h_i44 T3417)
(declare-const var_h43 T3417)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h941 T3417)
(declare-const var__temp_v942 Int)
(declare-const |var__temp_h'943| T3417)
(declare-const var__temp_v_err944 T3418)
(declare-const var_h934 T3417)
(declare-const var_h902 T3417)
(declare-const var_h866 T3417)
(declare-const var_h822 T3417)
(declare-const var_h43 T3417)
(declare-const err T3431)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3417)
(declare-fun sel (T3417 Int) Int)
(declare-fun res () Int)
(declare-fun var_h902 () T3417)
(declare-fun var_h822 () T3417)
(declare-fun var_h43 () T3417)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'943| () T3417)
(declare-fun var__temp_h941 () T3417)
(declare-fun var__temp_v942 () Int)
(declare-fun var_h934 () T3417)
(declare-fun v () Int)
(assert (> (sel var_h902 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h941 res) v)
                    (= v |5|)
                    (= (sel var__temp_h941 other) (sel var_h934 other)))
               (= (sel var__temp_h941 res) 7)))
      (a!2 (and (= (sel |var__temp_h'943| res) var__temp_v942)
                (= (sel |var__temp_h'943| res) (+ (sel var__temp_h941 res) 5))
                (= (sel |var__temp_h'943| other) (sel var__temp_h941 other))))
      (a!3 (and (= (sel |var__temp_h'943| res) 10)
                (not (> (sel |var__temp_h'943| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h941 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************253
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i935 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i935, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i935, other ) ==(sel)( , var_h934, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v936:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i935 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i935 --->  Ty_heap  
 var_h934 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i903 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h945 --->  Ty_heap  
 var__temp_v946 --->  Ty_int  
 var__temp_h'947 --->  Ty_heap  
 var__temp_v_err948 --->  error  
 var_h934 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h902, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h945, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h945, other ) ==(sel)( , var_h934, other ) => 
 	 Rel (sel)( , var__temp_h945, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h945, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'947, res ) ==(var__temp_v946) AND 
 	 Rel (sel)( , var__temp_h'947, res ) ==((sel)( , var__temp_h945, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'947, other ) ==(sel)( , var__temp_h945, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'947, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'947, other ) > (4)
 
VC_END(declare-const var_h_i935 T3434)
(declare-const var_h934 T3434)
(declare-const v Int)
(declare-const var_h_i903 T3434)
(declare-const var_h902 T3434)
(declare-const v Int)
(declare-const var_h_i867 T3434)
(declare-const var_h866 T3434)
(declare-const v Int)
(declare-const var_h_i823 T3434)
(declare-const var_h822 T3434)
(declare-const v Int)
(declare-const var_h_i44 T3434)
(declare-const var_h43 T3434)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h945 T3434)
(declare-const var__temp_v946 Int)
(declare-const |var__temp_h'947| T3434)
(declare-const var__temp_v_err948 T3435)
(declare-const var_h934 T3434)
(declare-const var_h902 T3434)
(declare-const var_h866 T3434)
(declare-const var_h822 T3434)
(declare-const var_h43 T3434)
(declare-const err T3448)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3434)
(declare-fun sel (T3434 Int) Int)
(declare-fun res () Int)
(declare-fun var_h902 () T3434)
(declare-fun var_h822 () T3434)
(declare-fun var_h43 () T3434)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'947| () T3434)
(declare-fun var__temp_h945 () T3434)
(declare-fun var__temp_v946 () Int)
(declare-fun var_h934 () T3434)
(declare-fun v () Int)
(assert (> (sel var_h902 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h945 res) v)
                    (= v |5|)
                    (= (sel var__temp_h945 other) (sel var_h934 other)))
               (= (sel var__temp_h945 res) 5)))
      (a!2 (and (= (sel |var__temp_h'947| res) var__temp_v946)
                (= (sel |var__temp_h'947| res) (+ (sel var__temp_h945 res) 2))
                (= (sel |var__temp_h'947| other) (sel var__temp_h945 other))))
      (a!3 (and (= (sel |var__temp_h'947| res) 10)
                (not (> (sel |var__temp_h'947| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h945 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************254
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v936:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v936:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --foo
 	 --c2
 	 --foo'
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i935 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i935, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i935, other ) ==(sel)( , var_h934, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v949:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************255
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i935 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i935, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i935, other ) ==(sel)( , var_h934, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v949:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i935 --->  Ty_heap  
 var_h934 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i903 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h950 --->  Ty_heap  
 var__temp_v951 --->  Ty_int  
 var__temp_h'952 --->  Ty_heap  
 var__temp_v_err953 --->  error  
 var_h934 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h902, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h950, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h950, other ) ==(sel)( , var_h934, other ) => 
 	 Rel (sel)( , var__temp_h950, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h950, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'952, res ) ==(var__temp_v951) AND 
 	 Rel (sel)( , var__temp_h'952, res ) ==((sel)( , var__temp_h950, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'952, other ) ==(sel)( , var__temp_h950, other ) => 
 	 True
 
VC_END(declare-const var_h_i935 T3451)
(declare-const var_h934 T3451)
(declare-const v Int)
(declare-const var_h_i903 T3451)
(declare-const var_h902 T3451)
(declare-const v Int)
(declare-const var_h_i867 T3451)
(declare-const var_h866 T3451)
(declare-const v Int)
(declare-const var_h_i823 T3451)
(declare-const var_h822 T3451)
(declare-const v Int)
(declare-const var_h_i44 T3451)
(declare-const var_h43 T3451)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h950 T3451)
(declare-const var__temp_v951 Int)
(declare-const |var__temp_h'952| T3451)
(declare-const var__temp_v_err953 T3452)
(declare-const var_h934 T3451)
(declare-const var_h902 T3451)
(declare-const var_h866 T3451)
(declare-const var_h822 T3451)
(declare-const var_h43 T3451)
(declare-const err T3465)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3451)
(declare-fun sel (T3451 Int) Int)
(declare-fun res () Int)
(declare-fun var_h902 () T3451)
(declare-fun var_h822 () T3451)
(declare-fun var_h43 () T3451)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h950 () T3451)
(declare-fun |var__temp_h'952| () T3451)
(declare-fun var__temp_v951 () Int)
(declare-fun var_h934 () T3451)
(declare-fun v () Int)
(assert (> (sel var_h902 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h950 res) v)
                    (= v |5|)
                    (= (sel var__temp_h950 other) (sel var_h934 other)))
               (= (sel var__temp_h950 res) 7)))
      (a!2 (and (= (sel |var__temp_h'952| res) var__temp_v951)
                (= (sel |var__temp_h'952| res) (+ (sel var__temp_h950 res) 3))
                (= (sel |var__temp_h'952| other) (sel var__temp_h950 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h950 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************256
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i935 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i935, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i935, other ) ==(sel)( , var_h934, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v949:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i935 --->  Ty_heap  
 var_h934 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i903 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h954 --->  Ty_heap  
 var__temp_v955 --->  Ty_int  
 var__temp_h'956 --->  Ty_heap  
 var__temp_v_err957 --->  error  
 var_h934 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h902, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h954, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h954, other ) ==(sel)( , var_h934, other ) => 
 	 Rel (sel)( , var__temp_h954, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h954, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'956, res ) ==(var__temp_v955) AND 
 	 Rel (sel)( , var__temp_h'956, res ) ==((sel)( , var__temp_h954, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'956, other ) ==(sel)( , var__temp_h954, other ) => 
 	 True
 
VC_END(declare-const var_h_i935 T3468)
(declare-const var_h934 T3468)
(declare-const v Int)
(declare-const var_h_i903 T3468)
(declare-const var_h902 T3468)
(declare-const v Int)
(declare-const var_h_i867 T3468)
(declare-const var_h866 T3468)
(declare-const v Int)
(declare-const var_h_i823 T3468)
(declare-const var_h822 T3468)
(declare-const v Int)
(declare-const var_h_i44 T3468)
(declare-const var_h43 T3468)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h954 T3468)
(declare-const var__temp_v955 Int)
(declare-const |var__temp_h'956| T3468)
(declare-const var__temp_v_err957 T3469)
(declare-const var_h934 T3468)
(declare-const var_h902 T3468)
(declare-const var_h866 T3468)
(declare-const var_h822 T3468)
(declare-const var_h43 T3468)
(declare-const err T3482)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3468)
(declare-fun sel (T3468 Int) Int)
(declare-fun res () Int)
(declare-fun var_h902 () T3468)
(declare-fun var_h822 () T3468)
(declare-fun var_h43 () T3468)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h954 () T3468)
(declare-fun |var__temp_h'956| () T3468)
(declare-fun var__temp_v955 () Int)
(declare-fun var_h934 () T3468)
(declare-fun v () Int)
(assert (> (sel var_h902 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h954 res) v)
                    (= v |5|)
                    (= (sel var__temp_h954 other) (sel var_h934 other)))
               (= (sel var__temp_h954 res) 7)))
      (a!2 (and (= (sel |var__temp_h'956| res) var__temp_v955)
                (= (sel |var__temp_h'956| res) (+ (sel var__temp_h954 res) 5))
                (= (sel |var__temp_h'956| other) (sel var__temp_h954 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h954 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************257
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i935 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i935, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i935, other ) ==(sel)( , var_h934, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v949:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i935 --->  Ty_heap  
 var_h934 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i903 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h958 --->  Ty_heap  
 var__temp_v959 --->  Ty_int  
 var__temp_h'960 --->  Ty_heap  
 var__temp_v_err961 --->  error  
 var_h934 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h902, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h958, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h958, other ) ==(sel)( , var_h934, other ) => 
 	 Rel (sel)( , var__temp_h958, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h958, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'960, res ) ==(var__temp_v959) AND 
 	 Rel (sel)( , var__temp_h'960, res ) ==((sel)( , var__temp_h958, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'960, other ) ==(sel)( , var__temp_h958, other ) => 
 	 True
 
VC_END(declare-const var_h_i935 T3485)
(declare-const var_h934 T3485)
(declare-const v Int)
(declare-const var_h_i903 T3485)
(declare-const var_h902 T3485)
(declare-const v Int)
(declare-const var_h_i867 T3485)
(declare-const var_h866 T3485)
(declare-const v Int)
(declare-const var_h_i823 T3485)
(declare-const var_h822 T3485)
(declare-const v Int)
(declare-const var_h_i44 T3485)
(declare-const var_h43 T3485)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h958 T3485)
(declare-const var__temp_v959 Int)
(declare-const |var__temp_h'960| T3485)
(declare-const var__temp_v_err961 T3486)
(declare-const var_h934 T3485)
(declare-const var_h902 T3485)
(declare-const var_h866 T3485)
(declare-const var_h822 T3485)
(declare-const var_h43 T3485)
(declare-const err T3499)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3485)
(declare-fun sel (T3485 Int) Int)
(declare-fun res () Int)
(declare-fun var_h902 () T3485)
(declare-fun var_h822 () T3485)
(declare-fun var_h43 () T3485)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h958 () T3485)
(declare-fun |var__temp_h'960| () T3485)
(declare-fun var__temp_v959 () Int)
(declare-fun var_h934 () T3485)
(declare-fun v () Int)
(assert (> (sel var_h902 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h958 res) v)
                    (= v |5|)
                    (= (sel var__temp_h958 other) (sel var_h934 other)))
               (= (sel var__temp_h958 res) 5)))
      (a!2 (and (= (sel |var__temp_h'960| res) var__temp_v959)
                (= (sel |var__temp_h'960| res) (+ (sel var__temp_h958 res) 2))
                (= (sel |var__temp_h'960| other) (sel var__temp_h958 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h958 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************bar
PARTIAL PATH NEW
SUB 
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c2'
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i963 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i963 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i963, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i963, res ) ==((sel)( , var_h962, res ) + (2))
 	 , (sel)( , var_h_i963, other ) ==(sel)( , var_h962, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v964:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i963 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************258
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i963 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i963, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i963, res ) ==((sel)( , var_h962, res ) + (2))
 	 , (sel)( , var_h_i963, other ) ==(sel)( , var_h962, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v964:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i963 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i963 --->  Ty_heap  
 var_h962 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i935 --->  Ty_heap  
 var_h934 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i903 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h965 --->  Ty_heap  
 var__temp_v966 --->  Ty_int  
 var__temp_h'967 --->  Ty_heap  
 var__temp_v_err968 --->  error  
 var_h962 --->  Ty_heap  
 var_h934 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h962, res ) ==(5) AND 
 	 Rel (sel)( , var_h902, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h965, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h965, res ) ==((sel)( , var_h962, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h965, other ) ==(sel)( , var_h962, other ) => 
 	 Rel (sel)( , var__temp_h965, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h965, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'967, res ) ==(var__temp_v966) AND 
 	 Rel (sel)( , var__temp_h'967, res ) ==((sel)( , var__temp_h965, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'967, other ) ==(sel)( , var__temp_h965, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'967, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'967, other ) > (4)
 
VC_END(declare-const var_h_i963 T3502)
(declare-const var_h962 T3502)
(declare-const v Int)
(declare-const var_h_i935 T3502)
(declare-const var_h934 T3502)
(declare-const v Int)
(declare-const var_h_i903 T3502)
(declare-const var_h902 T3502)
(declare-const v Int)
(declare-const var_h_i867 T3502)
(declare-const var_h866 T3502)
(declare-const v Int)
(declare-const var_h_i823 T3502)
(declare-const var_h822 T3502)
(declare-const v Int)
(declare-const var_h_i44 T3502)
(declare-const var_h43 T3502)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h965 T3502)
(declare-const var__temp_v966 Int)
(declare-const |var__temp_h'967| T3502)
(declare-const var__temp_v_err968 T3503)
(declare-const var_h962 T3502)
(declare-const var_h934 T3502)
(declare-const var_h902 T3502)
(declare-const var_h866 T3502)
(declare-const var_h822 T3502)
(declare-const var_h43 T3502)
(declare-const err T3516)

solver 
 (declare-sort T3502)
(declare-fun sel (T3502 Int) Int)
(declare-fun res () Int)
(declare-fun var_h962 () T3502)
(declare-fun var_h902 () T3502)
(declare-fun var_h822 () T3502)
(declare-fun var_h43 () T3502)
(declare-fun other () Int)
(declare-fun |var__temp_h'967| () T3502)
(declare-fun var__temp_h965 () T3502)
(declare-fun var__temp_v966 () Int)
(declare-fun v () Int)
(assert (= (sel var_h962 res) 5))
(assert (> (sel var_h902 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h965 res) v)
                (= (sel var__temp_h965 res) (+ (sel var_h962 res) 2))
                (= (sel var__temp_h965 other) (sel var_h962 other))))
      (a!2 (and (= (sel |var__temp_h'967| res) var__temp_v966)
                (= (sel |var__temp_h'967| res) (+ (sel var__temp_h965 res) 3))
                (= (sel |var__temp_h'967| other) (sel var__temp_h965 other))))
      (a!3 (and (= (sel |var__temp_h'967| res) 10)
                (not (> (sel |var__temp_h'967| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h965 res) 7))
                (=> (= (sel var__temp_h965 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************259
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i963 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i963, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i963, res ) ==((sel)( , var_h962, res ) + (2))
 	 , (sel)( , var_h_i963, other ) ==(sel)( , var_h962, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v964:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i963 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i963 --->  Ty_heap  
 var_h962 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i935 --->  Ty_heap  
 var_h934 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i903 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h969 --->  Ty_heap  
 var__temp_v970 --->  Ty_int  
 var__temp_h'971 --->  Ty_heap  
 var__temp_v_err972 --->  error  
 var_h962 --->  Ty_heap  
 var_h934 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h962, res ) ==(5) AND 
 	 Rel (sel)( , var_h902, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h969, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h969, res ) ==((sel)( , var_h962, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h969, other ) ==(sel)( , var_h962, other ) => 
 	 Rel (sel)( , var__temp_h969, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h969, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'971, res ) ==(var__temp_v970) AND 
 	 Rel (sel)( , var__temp_h'971, res ) ==((sel)( , var__temp_h969, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'971, other ) ==(sel)( , var__temp_h969, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'971, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'971, other ) > (4)
 
VC_END(declare-const var_h_i963 T3519)
(declare-const var_h962 T3519)
(declare-const v Int)
(declare-const var_h_i935 T3519)
(declare-const var_h934 T3519)
(declare-const v Int)
(declare-const var_h_i903 T3519)
(declare-const var_h902 T3519)
(declare-const v Int)
(declare-const var_h_i867 T3519)
(declare-const var_h866 T3519)
(declare-const v Int)
(declare-const var_h_i823 T3519)
(declare-const var_h822 T3519)
(declare-const v Int)
(declare-const var_h_i44 T3519)
(declare-const var_h43 T3519)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h969 T3519)
(declare-const var__temp_v970 Int)
(declare-const |var__temp_h'971| T3519)
(declare-const var__temp_v_err972 T3520)
(declare-const var_h962 T3519)
(declare-const var_h934 T3519)
(declare-const var_h902 T3519)
(declare-const var_h866 T3519)
(declare-const var_h822 T3519)
(declare-const var_h43 T3519)
(declare-const err T3533)

solver 
 (declare-sort T3519)
(declare-fun sel (T3519 Int) Int)
(declare-fun res () Int)
(declare-fun var_h962 () T3519)
(declare-fun var_h902 () T3519)
(declare-fun var_h822 () T3519)
(declare-fun var_h43 () T3519)
(declare-fun other () Int)
(declare-fun |var__temp_h'971| () T3519)
(declare-fun var__temp_h969 () T3519)
(declare-fun var__temp_v970 () Int)
(declare-fun v () Int)
(assert (= (sel var_h962 res) 5))
(assert (> (sel var_h902 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h969 res) v)
                (= (sel var__temp_h969 res) (+ (sel var_h962 res) 2))
                (= (sel var__temp_h969 other) (sel var_h962 other))))
      (a!2 (and (= (sel |var__temp_h'971| res) var__temp_v970)
                (= (sel |var__temp_h'971| res) (+ (sel var__temp_h969 res) 5))
                (= (sel |var__temp_h'971| other) (sel var__temp_h969 other))))
      (a!3 (and (= (sel |var__temp_h'971| res) 10)
                (not (> (sel |var__temp_h'971| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h969 res) 7))
                (=> (= (sel var__temp_h969 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************260
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v964:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v964:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbarfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i963 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i963, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i963, res ) ==((sel)( , var_h962, res ) + (2))
 	 , (sel)( , var_h_i963, other ) ==(sel)( , var_h962, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v973:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************261
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i963 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i963, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i963, res ) ==((sel)( , var_h962, res ) + (2))
 	 , (sel)( , var_h_i963, other ) ==(sel)( , var_h962, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v973:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i963 --->  Ty_heap  
 var_h962 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i935 --->  Ty_heap  
 var_h934 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i903 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h974 --->  Ty_heap  
 var__temp_v975 --->  Ty_int  
 var__temp_h'976 --->  Ty_heap  
 var__temp_v_err977 --->  error  
 var_h962 --->  Ty_heap  
 var_h934 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h962, res ) ==(5) AND 
 	 Rel (sel)( , var_h902, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h974, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h974, res ) ==((sel)( , var_h962, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h974, other ) ==(sel)( , var_h962, other ) => 
 	 Rel (sel)( , var__temp_h974, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h974, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'976, res ) ==(var__temp_v975) AND 
 	 Rel (sel)( , var__temp_h'976, res ) ==((sel)( , var__temp_h974, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'976, other ) ==(sel)( , var__temp_h974, other ) => 
 	 True
 
VC_END(declare-const var_h_i963 T3536)
(declare-const var_h962 T3536)
(declare-const v Int)
(declare-const var_h_i935 T3536)
(declare-const var_h934 T3536)
(declare-const v Int)
(declare-const var_h_i903 T3536)
(declare-const var_h902 T3536)
(declare-const v Int)
(declare-const var_h_i867 T3536)
(declare-const var_h866 T3536)
(declare-const v Int)
(declare-const var_h_i823 T3536)
(declare-const var_h822 T3536)
(declare-const v Int)
(declare-const var_h_i44 T3536)
(declare-const var_h43 T3536)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h974 T3536)
(declare-const var__temp_v975 Int)
(declare-const |var__temp_h'976| T3536)
(declare-const var__temp_v_err977 T3537)
(declare-const var_h962 T3536)
(declare-const var_h934 T3536)
(declare-const var_h902 T3536)
(declare-const var_h866 T3536)
(declare-const var_h822 T3536)
(declare-const var_h43 T3536)
(declare-const err T3550)

solver 
 (declare-sort T3536)
(declare-fun sel (T3536 Int) Int)
(declare-fun res () Int)
(declare-fun var_h962 () T3536)
(declare-fun var_h902 () T3536)
(declare-fun var_h822 () T3536)
(declare-fun var_h43 () T3536)
(declare-fun other () Int)
(declare-fun var__temp_h974 () T3536)
(declare-fun |var__temp_h'976| () T3536)
(declare-fun var__temp_v975 () Int)
(declare-fun v () Int)
(assert (= (sel var_h962 res) 5))
(assert (> (sel var_h902 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h974 res) v)
                (= (sel var__temp_h974 res) (+ (sel var_h962 res) 2))
                (= (sel var__temp_h974 other) (sel var_h962 other))))
      (a!2 (and (= (sel |var__temp_h'976| res) var__temp_v975)
                (= (sel |var__temp_h'976| res) (+ (sel var__temp_h974 res) 3))
                (= (sel |var__temp_h'976| other) (sel var__temp_h974 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h974 res) 7))
                (=> (= (sel var__temp_h974 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************baz
PARTIAL PATH NEW
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c2'
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i979 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i979 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i979, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i979, res ) ==((sel)( , var_h978, res ) + (3))
 	 , (sel)( , var_h_i979, other ) ==(sel)( , var_h978, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v980:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i979 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************262
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i979 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i979, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i979, res ) ==((sel)( , var_h978, res ) + (3))
 	 , (sel)( , var_h_i979, other ) ==(sel)( , var_h978, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v980:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i979 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i979 --->  Ty_heap  
 var_h978 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i963 --->  Ty_heap  
 var_h962 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i935 --->  Ty_heap  
 var_h934 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i903 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h981 --->  Ty_heap  
 var__temp_v982 --->  Ty_int  
 var__temp_h'983 --->  Ty_heap  
 var__temp_v_err984 --->  error  
 var_h978 --->  Ty_heap  
 var_h962 --->  Ty_heap  
 var_h934 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h978, res ) ==(7) AND 
 	 Rel (sel)( , var_h962, res ) ==(5) AND 
 	 Rel (sel)( , var_h902, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h981, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h981, res ) ==((sel)( , var_h978, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h981, other ) ==(sel)( , var_h978, other ) => 
 	 Rel (sel)( , var__temp_h981, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h981, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'983, res ) ==(var__temp_v982) AND 
 	 Rel (sel)( , var__temp_h'983, res ) ==((sel)( , var__temp_h981, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'983, other ) ==(sel)( , var__temp_h981, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'983, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'983, other ) > (4)
 
VC_END(declare-const var_h_i979 T3553)
(declare-const var_h978 T3553)
(declare-const v Int)
(declare-const var_h_i963 T3553)
(declare-const var_h962 T3553)
(declare-const v Int)
(declare-const var_h_i935 T3553)
(declare-const var_h934 T3553)
(declare-const v Int)
(declare-const var_h_i903 T3553)
(declare-const var_h902 T3553)
(declare-const v Int)
(declare-const var_h_i867 T3553)
(declare-const var_h866 T3553)
(declare-const v Int)
(declare-const var_h_i823 T3553)
(declare-const var_h822 T3553)
(declare-const v Int)
(declare-const var_h_i44 T3553)
(declare-const var_h43 T3553)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h981 T3553)
(declare-const var__temp_v982 Int)
(declare-const |var__temp_h'983| T3553)
(declare-const var__temp_v_err984 T3554)
(declare-const var_h978 T3553)
(declare-const var_h962 T3553)
(declare-const var_h934 T3553)
(declare-const var_h902 T3553)
(declare-const var_h866 T3553)
(declare-const var_h822 T3553)
(declare-const var_h43 T3553)
(declare-const err T3567)

solver 
 (declare-sort T3553)
(declare-fun sel (T3553 Int) Int)
(declare-fun res () Int)
(declare-fun var_h978 () T3553)
(declare-fun var_h962 () T3553)
(declare-fun var_h902 () T3553)
(declare-fun var_h822 () T3553)
(declare-fun var_h43 () T3553)
(declare-fun other () Int)
(declare-fun |var__temp_h'983| () T3553)
(declare-fun var__temp_h981 () T3553)
(declare-fun var__temp_v982 () Int)
(declare-fun v () Int)
(assert (= (sel var_h978 res) 7))
(assert (= (sel var_h962 res) 5))
(assert (> (sel var_h902 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h981 res) v)
                (= (sel var__temp_h981 res) (+ (sel var_h978 res) 3))
                (= (sel var__temp_h981 other) (sel var_h978 other))))
      (a!2 (and (= (sel |var__temp_h'983| res) var__temp_v982)
                (= (sel |var__temp_h'983| res) (+ (sel var__temp_h981 res) 5))
                (= (sel |var__temp_h'983| other) (sel var__temp_h981 other))))
      (a!3 (and (= (sel |var__temp_h'983| res) 10)
                (not (> (sel |var__temp_h'983| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h981 res) 7))
                (=> (= (sel var__temp_h981 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************263
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v980:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v980:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbazbarfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i979 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i979, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i979, res ) ==((sel)( , var_h978, res ) + (3))
 	 , (sel)( , var_h_i979, other ) ==(sel)( , var_h978, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v985:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************264
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i979 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i979, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i979, res ) ==((sel)( , var_h978, res ) + (3))
 	 , (sel)( , var_h_i979, other ) ==(sel)( , var_h978, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v985:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i979 --->  Ty_heap  
 var_h978 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i963 --->  Ty_heap  
 var_h962 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i935 --->  Ty_heap  
 var_h934 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i903 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h986 --->  Ty_heap  
 var__temp_v987 --->  Ty_int  
 var__temp_h'988 --->  Ty_heap  
 var__temp_v_err989 --->  error  
 var_h978 --->  Ty_heap  
 var_h962 --->  Ty_heap  
 var_h934 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h978, res ) ==(7) AND 
 	 Rel (sel)( , var_h962, res ) ==(5) AND 
 	 Rel (sel)( , var_h902, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h986, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h986, res ) ==((sel)( , var_h978, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h986, other ) ==(sel)( , var_h978, other ) => 
 	 Rel (sel)( , var__temp_h986, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h986, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'988, res ) ==(var__temp_v987) AND 
 	 Rel (sel)( , var__temp_h'988, res ) ==((sel)( , var__temp_h986, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'988, other ) ==(sel)( , var__temp_h986, other ) => 
 	 True
 
VC_END(declare-const var_h_i979 T3570)
(declare-const var_h978 T3570)
(declare-const v Int)
(declare-const var_h_i963 T3570)
(declare-const var_h962 T3570)
(declare-const v Int)
(declare-const var_h_i935 T3570)
(declare-const var_h934 T3570)
(declare-const v Int)
(declare-const var_h_i903 T3570)
(declare-const var_h902 T3570)
(declare-const v Int)
(declare-const var_h_i867 T3570)
(declare-const var_h866 T3570)
(declare-const v Int)
(declare-const var_h_i823 T3570)
(declare-const var_h822 T3570)
(declare-const v Int)
(declare-const var_h_i44 T3570)
(declare-const var_h43 T3570)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h986 T3570)
(declare-const var__temp_v987 Int)
(declare-const |var__temp_h'988| T3570)
(declare-const var__temp_v_err989 T3571)
(declare-const var_h978 T3570)
(declare-const var_h962 T3570)
(declare-const var_h934 T3570)
(declare-const var_h902 T3570)
(declare-const var_h866 T3570)
(declare-const var_h822 T3570)
(declare-const var_h43 T3570)
(declare-const err T3584)

solver 
 (declare-sort T3570)
(declare-fun sel (T3570 Int) Int)
(declare-fun res () Int)
(declare-fun var_h978 () T3570)
(declare-fun var_h962 () T3570)
(declare-fun var_h902 () T3570)
(declare-fun var_h822 () T3570)
(declare-fun var_h43 () T3570)
(declare-fun other () Int)
(declare-fun var__temp_h986 () T3570)
(declare-fun |var__temp_h'988| () T3570)
(declare-fun var__temp_v987 () Int)
(declare-fun v () Int)
(assert (= (sel var_h978 res) 7))
(assert (= (sel var_h962 res) 5))
(assert (> (sel var_h902 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h986 res) v)
                (= (sel var__temp_h986 res) (+ (sel var_h978 res) 3))
                (= (sel var__temp_h986 other) (sel var_h978 other))))
      (a!2 (and (= (sel |var__temp_h'988| res) var__temp_v987)
                (= (sel |var__temp_h'988| res) (+ (sel var__temp_h986 res) 5))
                (= (sel |var__temp_h'988| other) (sel var__temp_h986 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h986 res) 7))
                (=> (= (sel var__temp_h986 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************265
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT baz
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i963 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i963, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i963, res ) ==((sel)( , var_h962, res ) + (2))
 	 , (sel)( , var_h_i963, other ) ==(sel)( , var_h962, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v990:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************266
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i963 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i963, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i963, res ) ==((sel)( , var_h962, res ) + (2))
 	 , (sel)( , var_h_i963, other ) ==(sel)( , var_h962, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v990:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i963 --->  Ty_heap  
 var_h962 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i935 --->  Ty_heap  
 var_h934 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i903 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h991 --->  Ty_heap  
 var__temp_v992 --->  Ty_int  
 var__temp_h'993 --->  Ty_heap  
 var__temp_v_err994 --->  error  
 var_h962 --->  Ty_heap  
 var_h934 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h962, res ) ==(5) AND 
 	 Rel (sel)( , var_h902, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h991, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h991, res ) ==((sel)( , var_h962, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h991, other ) ==(sel)( , var_h962, other ) => 
 	 Rel (sel)( , var__temp_h991, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h991, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'993, res ) ==(var__temp_v992) AND 
 	 Rel (sel)( , var__temp_h'993, res ) ==((sel)( , var__temp_h991, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'993, other ) ==(sel)( , var__temp_h991, other ) => 
 	 True
 
VC_END(declare-const var_h_i963 T3587)
(declare-const var_h962 T3587)
(declare-const v Int)
(declare-const var_h_i935 T3587)
(declare-const var_h934 T3587)
(declare-const v Int)
(declare-const var_h_i903 T3587)
(declare-const var_h902 T3587)
(declare-const v Int)
(declare-const var_h_i867 T3587)
(declare-const var_h866 T3587)
(declare-const v Int)
(declare-const var_h_i823 T3587)
(declare-const var_h822 T3587)
(declare-const v Int)
(declare-const var_h_i44 T3587)
(declare-const var_h43 T3587)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h991 T3587)
(declare-const var__temp_v992 Int)
(declare-const |var__temp_h'993| T3587)
(declare-const var__temp_v_err994 T3588)
(declare-const var_h962 T3587)
(declare-const var_h934 T3587)
(declare-const var_h902 T3587)
(declare-const var_h866 T3587)
(declare-const var_h822 T3587)
(declare-const var_h43 T3587)
(declare-const err T3601)

solver 
 (declare-sort T3587)
(declare-fun sel (T3587 Int) Int)
(declare-fun res () Int)
(declare-fun var_h962 () T3587)
(declare-fun var_h902 () T3587)
(declare-fun var_h822 () T3587)
(declare-fun var_h43 () T3587)
(declare-fun other () Int)
(declare-fun var__temp_h991 () T3587)
(declare-fun |var__temp_h'993| () T3587)
(declare-fun var__temp_v992 () Int)
(declare-fun v () Int)
(assert (= (sel var_h962 res) 5))
(assert (> (sel var_h902 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h991 res) v)
                (= (sel var__temp_h991 res) (+ (sel var_h962 res) 2))
                (= (sel var__temp_h991 other) (sel var_h962 other))))
      (a!2 (and (= (sel |var__temp_h'993| res) var__temp_v992)
                (= (sel |var__temp_h'993| res) (+ (sel var__temp_h991 res) 5))
                (= (sel |var__temp_h'993| other) (sel var__temp_h991 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h991 res) 7))
                (=> (= (sel var__temp_h991 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c5
PARTIAL PATH NEW
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c2'
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i996 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i996 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i996, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i996, res ) ==((sel)( , var_h995, res ) + (5))
 	 , (sel)( , var_h_i996, other ) ==(sel)( , var_h995, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v997:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i996 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************267
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v997:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v997:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc5bazbarfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i996 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i996, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i996, res ) ==((sel)( , var_h995, res ) + (5))
 	 , (sel)( , var_h_i996, other ) ==(sel)( , var_h995, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v998:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************268
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i963 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i963, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i963, res ) ==((sel)( , var_h962, res ) + (2))
 	 , (sel)( , var_h_i963, other ) ==(sel)( , var_h962, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v999:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************269
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --foo
 	 --c2
 	 --foo'
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i935 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i935, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i935, other ) ==(sel)( , var_h934, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1000:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************270
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i935 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i935, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i935, other ) ==(sel)( , var_h934, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1000:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i935 --->  Ty_heap  
 var_h934 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i903 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1001 --->  Ty_heap  
 var__temp_v1002 --->  Ty_int  
 var__temp_h'1003 --->  Ty_heap  
 var__temp_v_err1004 --->  error  
 var_h934 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h902, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1001, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1001, other ) ==(sel)( , var_h934, other ) => 
 	 Rel (sel)( , var__temp_h1001, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1001, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1003, res ) ==(var__temp_v1002) AND 
 	 Rel (sel)( , var__temp_h'1003, res ) ==((sel)( , var__temp_h1001, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1003, other ) ==(sel)( , var__temp_h1001, other ) => 
 	 True
 
VC_END(declare-const var_h_i935 T3604)
(declare-const var_h934 T3604)
(declare-const v Int)
(declare-const var_h_i903 T3604)
(declare-const var_h902 T3604)
(declare-const v Int)
(declare-const var_h_i867 T3604)
(declare-const var_h866 T3604)
(declare-const v Int)
(declare-const var_h_i823 T3604)
(declare-const var_h822 T3604)
(declare-const v Int)
(declare-const var_h_i44 T3604)
(declare-const var_h43 T3604)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1001 T3604)
(declare-const var__temp_v1002 Int)
(declare-const |var__temp_h'1003| T3604)
(declare-const var__temp_v_err1004 T3605)
(declare-const var_h934 T3604)
(declare-const var_h902 T3604)
(declare-const var_h866 T3604)
(declare-const var_h822 T3604)
(declare-const var_h43 T3604)
(declare-const err T3618)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3604)
(declare-fun sel (T3604 Int) Int)
(declare-fun res () Int)
(declare-fun var_h902 () T3604)
(declare-fun var_h822 () T3604)
(declare-fun var_h43 () T3604)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1001 () T3604)
(declare-fun |var__temp_h'1003| () T3604)
(declare-fun var__temp_v1002 () Int)
(declare-fun var_h934 () T3604)
(declare-fun v () Int)
(assert (> (sel var_h902 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1001 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1001 other) (sel var_h934 other)))
               (= (sel var__temp_h1001 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1003| res) var__temp_v1002)
                (= (sel |var__temp_h'1003| res) (+ (sel var__temp_h1001 res) 3))
                (= (sel |var__temp_h'1003| other) (sel var__temp_h1001 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1001 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************271
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i935 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i935, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i935, other ) ==(sel)( , var_h934, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1000:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i935 --->  Ty_heap  
 var_h934 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i903 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1005 --->  Ty_heap  
 var__temp_v1006 --->  Ty_int  
 var__temp_h'1007 --->  Ty_heap  
 var__temp_v_err1008 --->  error  
 var_h934 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h902, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1005, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1005, other ) ==(sel)( , var_h934, other ) => 
 	 Rel (sel)( , var__temp_h1005, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1005, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1007, res ) ==(var__temp_v1006) AND 
 	 Rel (sel)( , var__temp_h'1007, res ) ==((sel)( , var__temp_h1005, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1007, other ) ==(sel)( , var__temp_h1005, other ) => 
 	 True
 
VC_END(declare-const var_h_i935 T3621)
(declare-const var_h934 T3621)
(declare-const v Int)
(declare-const var_h_i903 T3621)
(declare-const var_h902 T3621)
(declare-const v Int)
(declare-const var_h_i867 T3621)
(declare-const var_h866 T3621)
(declare-const v Int)
(declare-const var_h_i823 T3621)
(declare-const var_h822 T3621)
(declare-const v Int)
(declare-const var_h_i44 T3621)
(declare-const var_h43 T3621)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1005 T3621)
(declare-const var__temp_v1006 Int)
(declare-const |var__temp_h'1007| T3621)
(declare-const var__temp_v_err1008 T3622)
(declare-const var_h934 T3621)
(declare-const var_h902 T3621)
(declare-const var_h866 T3621)
(declare-const var_h822 T3621)
(declare-const var_h43 T3621)
(declare-const err T3635)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3621)
(declare-fun sel (T3621 Int) Int)
(declare-fun res () Int)
(declare-fun var_h902 () T3621)
(declare-fun var_h822 () T3621)
(declare-fun var_h43 () T3621)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1005 () T3621)
(declare-fun |var__temp_h'1007| () T3621)
(declare-fun var__temp_v1006 () Int)
(declare-fun var_h934 () T3621)
(declare-fun v () Int)
(assert (> (sel var_h902 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1005 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1005 other) (sel var_h934 other)))
               (= (sel var__temp_h1005 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1007| res) var__temp_v1006)
                (= (sel |var__temp_h'1007| res) (+ (sel var__temp_h1005 res) 5))
                (= (sel |var__temp_h'1007| other) (sel var__temp_h1005 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1005 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************272
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT bar
PARTIAL PATH
SUB 
 	 --c2
 	 --foo'
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i903 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i903, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i903, res ) ==((sel)( , var_h902, res ) + (10))
 	 , (sel)( , var_h_i903, other ) ==(sel)( , var_h902, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1009:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************273
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i903 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i903, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i903, res ) ==((sel)( , var_h902, res ) + (10))
 	 , (sel)( , var_h_i903, other ) ==(sel)( , var_h902, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1009:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i903 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1010 --->  Ty_heap  
 var__temp_v1011 --->  Ty_int  
 var__temp_h'1012 --->  Ty_heap  
 var__temp_v_err1013 --->  error  
 var_h902 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h902, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1010, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1010, res ) ==((sel)( , var_h902, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1010, other ) ==(sel)( , var_h902, other ) => 
 	 Rel (sel)( , var__temp_h1010, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1010, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1012, res ) ==(var__temp_v1011) AND 
 	 Rel (sel)( , var__temp_h'1012, res ) ==((sel)( , var__temp_h1010, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1012, other ) ==(sel)( , var__temp_h1010, other ) => 
 	 True
 
VC_END(declare-const var_h_i903 T3638)
(declare-const var_h902 T3638)
(declare-const v Int)
(declare-const var_h_i867 T3638)
(declare-const var_h866 T3638)
(declare-const v Int)
(declare-const var_h_i823 T3638)
(declare-const var_h822 T3638)
(declare-const v Int)
(declare-const var_h_i44 T3638)
(declare-const var_h43 T3638)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1010 T3638)
(declare-const var__temp_v1011 Int)
(declare-const |var__temp_h'1012| T3638)
(declare-const var__temp_v_err1013 T3639)
(declare-const var_h902 T3638)
(declare-const var_h866 T3638)
(declare-const var_h822 T3638)
(declare-const var_h43 T3638)
(declare-const err T3652)

solver 
 (declare-sort T3638)
(declare-fun sel (T3638 Int) Int)
(declare-fun res () Int)
(declare-fun var_h902 () T3638)
(declare-fun var_h822 () T3638)
(declare-fun var_h43 () T3638)
(declare-fun other () Int)
(declare-fun var__temp_h1010 () T3638)
(declare-fun |var__temp_h'1012| () T3638)
(declare-fun var__temp_v1011 () Int)
(declare-fun v () Int)
(assert (> (sel var_h902 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1010 res) v)
                (= (sel var__temp_h1010 res) (+ (sel var_h902 res) 10))
                (= (sel var__temp_h1010 other) (sel var_h902 other))))
      (a!2 (and (= (sel |var__temp_h'1012| res) var__temp_v1011)
                (= (sel |var__temp_h'1012| res) (+ (sel var__temp_h1010 res) 3))
                (= (sel |var__temp_h'1012| other) (sel var__temp_h1010 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1010 res) 7))
                (=> (= (sel var__temp_h1010 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************274
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i903 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i903, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i903, res ) ==((sel)( , var_h902, res ) + (10))
 	 , (sel)( , var_h_i903, other ) ==(sel)( , var_h902, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1009:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i903 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1014 --->  Ty_heap  
 var__temp_v1015 --->  Ty_int  
 var__temp_h'1016 --->  Ty_heap  
 var__temp_v_err1017 --->  error  
 var_h902 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h902, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1014, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1014, res ) ==((sel)( , var_h902, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1014, other ) ==(sel)( , var_h902, other ) => 
 	 Rel (sel)( , var__temp_h1014, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1014, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1016, res ) ==(var__temp_v1015) AND 
 	 Rel (sel)( , var__temp_h'1016, res ) ==((sel)( , var__temp_h1014, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1016, other ) ==(sel)( , var__temp_h1014, other ) => 
 	 True
 
VC_END(declare-const var_h_i903 T3655)
(declare-const var_h902 T3655)
(declare-const v Int)
(declare-const var_h_i867 T3655)
(declare-const var_h866 T3655)
(declare-const v Int)
(declare-const var_h_i823 T3655)
(declare-const var_h822 T3655)
(declare-const v Int)
(declare-const var_h_i44 T3655)
(declare-const var_h43 T3655)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1014 T3655)
(declare-const var__temp_v1015 Int)
(declare-const |var__temp_h'1016| T3655)
(declare-const var__temp_v_err1017 T3656)
(declare-const var_h902 T3655)
(declare-const var_h866 T3655)
(declare-const var_h822 T3655)
(declare-const var_h43 T3655)
(declare-const err T3669)

solver 
 (declare-sort T3655)
(declare-fun sel (T3655 Int) Int)
(declare-fun res () Int)
(declare-fun var_h902 () T3655)
(declare-fun var_h822 () T3655)
(declare-fun var_h43 () T3655)
(declare-fun other () Int)
(declare-fun var__temp_h1014 () T3655)
(declare-fun |var__temp_h'1016| () T3655)
(declare-fun var__temp_v1015 () Int)
(declare-fun v () Int)
(assert (> (sel var_h902 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1014 res) v)
                (= (sel var__temp_h1014 res) (+ (sel var_h902 res) 10))
                (= (sel var__temp_h1014 other) (sel var_h902 other))))
      (a!2 (and (= (sel |var__temp_h'1016| res) var__temp_v1015)
                (= (sel |var__temp_h'1016| res) (+ (sel var__temp_h1014 res) 5))
                (= (sel |var__temp_h'1016| other) (sel var__temp_h1014 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1014 res) 7))
                (=> (= (sel var__temp_h1014 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************275
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i903 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i903, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i903, res ) ==((sel)( , var_h902, res ) + (10))
 	 , (sel)( , var_h_i903, other ) ==(sel)( , var_h902, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1009:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i903 --->  Ty_heap  
 var_h902 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1018 --->  Ty_heap  
 var__temp_v1019 --->  Ty_int  
 var__temp_h'1020 --->  Ty_heap  
 var__temp_v_err1021 --->  error  
 var_h902 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h902, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1018, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1018, res ) ==((sel)( , var_h902, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1018, other ) ==(sel)( , var_h902, other ) => 
 	 Rel (sel)( , var__temp_h1018, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1018, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1020, res ) ==(var__temp_v1019) AND 
 	 Rel (sel)( , var__temp_h'1020, res ) ==((sel)( , var__temp_h1018, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1020, other ) ==(sel)( , var__temp_h1018, other ) => 
 	 True
 
VC_END(declare-const var_h_i903 T3672)
(declare-const var_h902 T3672)
(declare-const v Int)
(declare-const var_h_i867 T3672)
(declare-const var_h866 T3672)
(declare-const v Int)
(declare-const var_h_i823 T3672)
(declare-const var_h822 T3672)
(declare-const v Int)
(declare-const var_h_i44 T3672)
(declare-const var_h43 T3672)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1018 T3672)
(declare-const var__temp_v1019 Int)
(declare-const |var__temp_h'1020| T3672)
(declare-const var__temp_v_err1021 T3673)
(declare-const var_h902 T3672)
(declare-const var_h866 T3672)
(declare-const var_h822 T3672)
(declare-const var_h43 T3672)
(declare-const err T3686)

solver 
 (declare-sort T3672)
(declare-fun sel (T3672 Int) Int)
(declare-fun res () Int)
(declare-fun var_h902 () T3672)
(declare-fun var_h822 () T3672)
(declare-fun var_h43 () T3672)
(declare-fun other () Int)
(declare-fun var__temp_h1018 () T3672)
(declare-fun |var__temp_h'1020| () T3672)
(declare-fun var__temp_v1019 () Int)
(declare-fun v () Int)
(assert (> (sel var_h902 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1018 res) v)
                (= (sel var__temp_h1018 res) (+ (sel var_h902 res) 10))
                (= (sel var__temp_h1018 other) (sel var_h902 other))))
      (a!2 (and (= (sel |var__temp_h'1020| res) var__temp_v1019)
                (= (sel |var__temp_h'1020| res) (+ (sel var__temp_h1018 res) 2))
                (= (sel |var__temp_h'1020| other) (sel var__temp_h1018 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1018 res) 5))
                (=> (= (sel var__temp_h1018 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************276
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo
PARTIAL PATH
SUB 
 	 --foo'
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i867 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i867, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i867, other ) ==(sel)( , var_h866, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1022:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************277
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i867 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i867, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i867, other ) ==(sel)( , var_h866, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1022:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1023 --->  Ty_heap  
 var__temp_v1024 --->  Ty_int  
 var__temp_h'1025 --->  Ty_heap  
 var__temp_v_err1026 --->  error  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1023, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1023, other ) ==(sel)( , var_h866, other ) => 
 	 Rel (sel)( , var__temp_h1023, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1023, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1025, res ) ==(var__temp_v1024) AND 
 	 Rel (sel)( , var__temp_h'1025, res ) ==((sel)( , var__temp_h1023, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1025, other ) ==(sel)( , var__temp_h1023, other ) => 
 	 True
 
VC_END(declare-const var_h_i867 T3689)
(declare-const var_h866 T3689)
(declare-const v Int)
(declare-const var_h_i823 T3689)
(declare-const var_h822 T3689)
(declare-const v Int)
(declare-const var_h_i44 T3689)
(declare-const var_h43 T3689)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1023 T3689)
(declare-const var__temp_v1024 Int)
(declare-const |var__temp_h'1025| T3689)
(declare-const var__temp_v_err1026 T3690)
(declare-const var_h866 T3689)
(declare-const var_h822 T3689)
(declare-const var_h43 T3689)
(declare-const err T3703)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3689)
(declare-fun sel (T3689 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T3689)
(declare-fun var_h43 () T3689)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h1023 () T3689)
(declare-fun |var__temp_h'1025| () T3689)
(declare-fun var__temp_v1024 () Int)
(declare-fun var_h866 () T3689)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1023 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1023 other) (sel var_h866 other)))
               (= (sel var__temp_h1023 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1025| res) var__temp_v1024)
                (= (sel |var__temp_h'1025| res) (+ (sel var__temp_h1023 res) 3))
                (= (sel |var__temp_h'1025| other) (sel var__temp_h1023 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1023 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************278
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i867 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i867, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i867, other ) ==(sel)( , var_h866, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1022:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1027 --->  Ty_heap  
 var__temp_v1028 --->  Ty_int  
 var__temp_h'1029 --->  Ty_heap  
 var__temp_v_err1030 --->  error  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1027, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1027, other ) ==(sel)( , var_h866, other ) => 
 	 Rel (sel)( , var__temp_h1027, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1027, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1029, res ) ==(var__temp_v1028) AND 
 	 Rel (sel)( , var__temp_h'1029, res ) ==((sel)( , var__temp_h1027, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1029, other ) ==(sel)( , var__temp_h1027, other ) => 
 	 True
 
VC_END(declare-const var_h_i867 T3706)
(declare-const var_h866 T3706)
(declare-const v Int)
(declare-const var_h_i823 T3706)
(declare-const var_h822 T3706)
(declare-const v Int)
(declare-const var_h_i44 T3706)
(declare-const var_h43 T3706)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1027 T3706)
(declare-const var__temp_v1028 Int)
(declare-const |var__temp_h'1029| T3706)
(declare-const var__temp_v_err1030 T3707)
(declare-const var_h866 T3706)
(declare-const var_h822 T3706)
(declare-const var_h43 T3706)
(declare-const err T3720)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3706)
(declare-fun sel (T3706 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T3706)
(declare-fun var_h43 () T3706)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h1027 () T3706)
(declare-fun |var__temp_h'1029| () T3706)
(declare-fun var__temp_v1028 () Int)
(declare-fun var_h866 () T3706)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1027 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1027 other) (sel var_h866 other)))
               (= (sel var__temp_h1027 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1029| res) var__temp_v1028)
                (= (sel |var__temp_h'1029| res) (+ (sel var__temp_h1027 res) 5))
                (= (sel |var__temp_h'1029| other) (sel var__temp_h1027 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1027 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************279
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i867 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i867, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i867, other ) ==(sel)( , var_h866, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1022:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1031 --->  Ty_heap  
 var__temp_v1032 --->  Ty_int  
 var__temp_h'1033 --->  Ty_heap  
 var__temp_v_err1034 --->  error  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1031, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1031, other ) ==(sel)( , var_h866, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1033, res ) ==(var__temp_v1032) AND 
 	 Base var__temp_v1032 = 5 AND 
 	 Rel (sel)( , var__temp_h'1033, other ) ==(sel)( , var__temp_h1031, other ) => 
 	 True
 
VC_END(declare-const var_h_i867 T3723)
(declare-const var_h866 T3723)
(declare-const v Int)
(declare-const var_h_i823 T3723)
(declare-const var_h822 T3723)
(declare-const v Int)
(declare-const var_h_i44 T3723)
(declare-const var_h43 T3723)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1031 T3723)
(declare-const var__temp_v1032 Int)
(declare-const |var__temp_h'1033| T3723)
(declare-const var__temp_v_err1034 T3724)
(declare-const var_h866 T3723)
(declare-const var_h822 T3723)
(declare-const var_h43 T3723)
(declare-const err T3737)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T3723)
(declare-fun sel (T3723 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T3723)
(declare-fun var_h43 () T3723)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1031 () T3723)
(declare-fun |var__temp_h'1033| () T3723)
(declare-fun var__temp_v1032 () Int)
(declare-fun var_h866 () T3723)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1031 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1031 other) (sel var_h866 other)))
               true))
      (a!2 (=> (and (= (sel |var__temp_h'1033| res) var__temp_v1032)
                    (= var__temp_v1032 |5|)
                    (= (sel |var__temp_h'1033| other)
                       (sel var__temp_h1031 other)))
               true)))
  (not (and a!1 (=> true a!2)))))

***************Selection Successful************foo
PARTIAL PATH NEW
SUB 
 	 --foo
 	 --foo'
 	 --c2'
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1036, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1036, other ) ==(sel)( , var_h1035, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1037:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************280
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1036, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1036, other ) ==(sel)( , var_h1035, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1037:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1038 --->  Ty_heap  
 var__temp_v1039 --->  Ty_int  
 var__temp_h'1040 --->  Ty_heap  
 var__temp_v_err1041 --->  error  
 var_h1035 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1038, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1038, other ) ==(sel)( , var_h1035, other ) => 
 	 Rel (sel)( , var__temp_h1038, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1038, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1040, res ) ==(var__temp_v1039) AND 
 	 Rel (sel)( , var__temp_h'1040, res ) ==((sel)( , var__temp_h1038, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1040, other ) ==(sel)( , var__temp_h1038, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1040, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1040, other ) > (4)
 
VC_END(declare-const var_h_i1036 T3740)
(declare-const var_h1035 T3740)
(declare-const v Int)
(declare-const var_h_i867 T3740)
(declare-const var_h866 T3740)
(declare-const v Int)
(declare-const var_h_i823 T3740)
(declare-const var_h822 T3740)
(declare-const v Int)
(declare-const var_h_i44 T3740)
(declare-const var_h43 T3740)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1038 T3740)
(declare-const var__temp_v1039 Int)
(declare-const |var__temp_h'1040| T3740)
(declare-const var__temp_v_err1041 T3741)
(declare-const var_h1035 T3740)
(declare-const var_h866 T3740)
(declare-const var_h822 T3740)
(declare-const var_h43 T3740)
(declare-const err T3754)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3740)
(declare-fun sel (T3740 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T3740)
(declare-fun var_h43 () T3740)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1040| () T3740)
(declare-fun var__temp_h1038 () T3740)
(declare-fun var__temp_v1039 () Int)
(declare-fun var_h1035 () T3740)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1038 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1038 other) (sel var_h1035 other)))
               (= (sel var__temp_h1038 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1040| res) var__temp_v1039)
                (= (sel |var__temp_h'1040| res) (+ (sel var__temp_h1038 res) 3))
                (= (sel |var__temp_h'1040| other) (sel var__temp_h1038 other))))
      (a!3 (and (= (sel |var__temp_h'1040| res) 10)
                (not (> (sel |var__temp_h'1040| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1038 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************281
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1036, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1036, other ) ==(sel)( , var_h1035, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1037:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1042 --->  Ty_heap  
 var__temp_v1043 --->  Ty_int  
 var__temp_h'1044 --->  Ty_heap  
 var__temp_v_err1045 --->  error  
 var_h1035 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1042, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1042, other ) ==(sel)( , var_h1035, other ) => 
 	 Rel (sel)( , var__temp_h1042, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1042, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1044, res ) ==(var__temp_v1043) AND 
 	 Rel (sel)( , var__temp_h'1044, res ) ==((sel)( , var__temp_h1042, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1044, other ) ==(sel)( , var__temp_h1042, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1044, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1044, other ) > (4)
 
VC_END(declare-const var_h_i1036 T3757)
(declare-const var_h1035 T3757)
(declare-const v Int)
(declare-const var_h_i867 T3757)
(declare-const var_h866 T3757)
(declare-const v Int)
(declare-const var_h_i823 T3757)
(declare-const var_h822 T3757)
(declare-const v Int)
(declare-const var_h_i44 T3757)
(declare-const var_h43 T3757)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1042 T3757)
(declare-const var__temp_v1043 Int)
(declare-const |var__temp_h'1044| T3757)
(declare-const var__temp_v_err1045 T3758)
(declare-const var_h1035 T3757)
(declare-const var_h866 T3757)
(declare-const var_h822 T3757)
(declare-const var_h43 T3757)
(declare-const err T3771)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3757)
(declare-fun sel (T3757 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T3757)
(declare-fun var_h43 () T3757)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1044| () T3757)
(declare-fun var__temp_h1042 () T3757)
(declare-fun var__temp_v1043 () Int)
(declare-fun var_h1035 () T3757)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1042 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1042 other) (sel var_h1035 other)))
               (= (sel var__temp_h1042 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1044| res) var__temp_v1043)
                (= (sel |var__temp_h'1044| res) (+ (sel var__temp_h1042 res) 5))
                (= (sel |var__temp_h'1044| other) (sel var__temp_h1042 other))))
      (a!3 (and (= (sel |var__temp_h'1044| res) 10)
                (not (> (sel |var__temp_h'1044| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1042 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************282
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1036, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1036, other ) ==(sel)( , var_h1035, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1037:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1046 --->  Ty_heap  
 var__temp_v1047 --->  Ty_int  
 var__temp_h'1048 --->  Ty_heap  
 var__temp_v_err1049 --->  error  
 var_h1035 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1046, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1046, other ) ==(sel)( , var_h1035, other ) => 
 	 Rel (sel)( , var__temp_h1046, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1046, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1048, res ) ==(var__temp_v1047) AND 
 	 Rel (sel)( , var__temp_h'1048, res ) ==((sel)( , var__temp_h1046, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1048, other ) ==(sel)( , var__temp_h1046, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1048, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1048, other ) > (4)
 
VC_END(declare-const var_h_i1036 T3774)
(declare-const var_h1035 T3774)
(declare-const v Int)
(declare-const var_h_i867 T3774)
(declare-const var_h866 T3774)
(declare-const v Int)
(declare-const var_h_i823 T3774)
(declare-const var_h822 T3774)
(declare-const v Int)
(declare-const var_h_i44 T3774)
(declare-const var_h43 T3774)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1046 T3774)
(declare-const var__temp_v1047 Int)
(declare-const |var__temp_h'1048| T3774)
(declare-const var__temp_v_err1049 T3775)
(declare-const var_h1035 T3774)
(declare-const var_h866 T3774)
(declare-const var_h822 T3774)
(declare-const var_h43 T3774)
(declare-const err T3788)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3774)
(declare-fun sel (T3774 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T3774)
(declare-fun var_h43 () T3774)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1048| () T3774)
(declare-fun var__temp_h1046 () T3774)
(declare-fun var__temp_v1047 () Int)
(declare-fun var_h1035 () T3774)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1046 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1046 other) (sel var_h1035 other)))
               (= (sel var__temp_h1046 res) 5)))
      (a!2 (and (= (sel |var__temp_h'1048| res) var__temp_v1047)
                (= (sel |var__temp_h'1048| res) (+ (sel var__temp_h1046 res) 2))
                (= (sel |var__temp_h'1048| other) (sel var__temp_h1046 other))))
      (a!3 (and (= (sel |var__temp_h'1048| res) 10)
                (not (> (sel |var__temp_h'1048| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1046 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************283
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1037:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1037:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --foo
 	 --foo'
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1036, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1036, other ) ==(sel)( , var_h1035, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1050:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************284
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1036, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1036, other ) ==(sel)( , var_h1035, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1050:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1051 --->  Ty_heap  
 var__temp_v1052 --->  Ty_int  
 var__temp_h'1053 --->  Ty_heap  
 var__temp_v_err1054 --->  error  
 var_h1035 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1051, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1051, other ) ==(sel)( , var_h1035, other ) => 
 	 Rel (sel)( , var__temp_h1051, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1051, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1053, res ) ==(var__temp_v1052) AND 
 	 Rel (sel)( , var__temp_h'1053, res ) ==((sel)( , var__temp_h1051, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1053, other ) ==(sel)( , var__temp_h1051, other ) => 
 	 True
 
VC_END(declare-const var_h_i1036 T3791)
(declare-const var_h1035 T3791)
(declare-const v Int)
(declare-const var_h_i867 T3791)
(declare-const var_h866 T3791)
(declare-const v Int)
(declare-const var_h_i823 T3791)
(declare-const var_h822 T3791)
(declare-const v Int)
(declare-const var_h_i44 T3791)
(declare-const var_h43 T3791)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1051 T3791)
(declare-const var__temp_v1052 Int)
(declare-const |var__temp_h'1053| T3791)
(declare-const var__temp_v_err1054 T3792)
(declare-const var_h1035 T3791)
(declare-const var_h866 T3791)
(declare-const var_h822 T3791)
(declare-const var_h43 T3791)
(declare-const err T3805)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3791)
(declare-fun sel (T3791 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T3791)
(declare-fun var_h43 () T3791)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1051 () T3791)
(declare-fun |var__temp_h'1053| () T3791)
(declare-fun var__temp_v1052 () Int)
(declare-fun var_h1035 () T3791)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1051 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1051 other) (sel var_h1035 other)))
               (= (sel var__temp_h1051 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1053| res) var__temp_v1052)
                (= (sel |var__temp_h'1053| res) (+ (sel var__temp_h1051 res) 3))
                (= (sel |var__temp_h'1053| other) (sel var__temp_h1051 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1051 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************285
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1036, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1036, other ) ==(sel)( , var_h1035, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1050:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1055 --->  Ty_heap  
 var__temp_v1056 --->  Ty_int  
 var__temp_h'1057 --->  Ty_heap  
 var__temp_v_err1058 --->  error  
 var_h1035 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1055, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1055, other ) ==(sel)( , var_h1035, other ) => 
 	 Rel (sel)( , var__temp_h1055, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1055, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1057, res ) ==(var__temp_v1056) AND 
 	 Rel (sel)( , var__temp_h'1057, res ) ==((sel)( , var__temp_h1055, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1057, other ) ==(sel)( , var__temp_h1055, other ) => 
 	 True
 
VC_END(declare-const var_h_i1036 T3808)
(declare-const var_h1035 T3808)
(declare-const v Int)
(declare-const var_h_i867 T3808)
(declare-const var_h866 T3808)
(declare-const v Int)
(declare-const var_h_i823 T3808)
(declare-const var_h822 T3808)
(declare-const v Int)
(declare-const var_h_i44 T3808)
(declare-const var_h43 T3808)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1055 T3808)
(declare-const var__temp_v1056 Int)
(declare-const |var__temp_h'1057| T3808)
(declare-const var__temp_v_err1058 T3809)
(declare-const var_h1035 T3808)
(declare-const var_h866 T3808)
(declare-const var_h822 T3808)
(declare-const var_h43 T3808)
(declare-const err T3822)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3808)
(declare-fun sel (T3808 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T3808)
(declare-fun var_h43 () T3808)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1055 () T3808)
(declare-fun |var__temp_h'1057| () T3808)
(declare-fun var__temp_v1056 () Int)
(declare-fun var_h1035 () T3808)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1055 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1055 other) (sel var_h1035 other)))
               (= (sel var__temp_h1055 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1057| res) var__temp_v1056)
                (= (sel |var__temp_h'1057| res) (+ (sel var__temp_h1055 res) 5))
                (= (sel |var__temp_h'1057| other) (sel var__temp_h1055 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1055 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************286
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1036, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1036, other ) ==(sel)( , var_h1035, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1050:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1059 --->  Ty_heap  
 var__temp_v1060 --->  Ty_int  
 var__temp_h'1061 --->  Ty_heap  
 var__temp_v_err1062 --->  error  
 var_h1035 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1059, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1059, other ) ==(sel)( , var_h1035, other ) => 
 	 Rel (sel)( , var__temp_h1059, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1059, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1061, res ) ==(var__temp_v1060) AND 
 	 Rel (sel)( , var__temp_h'1061, res ) ==((sel)( , var__temp_h1059, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1061, other ) ==(sel)( , var__temp_h1059, other ) => 
 	 True
 
VC_END(declare-const var_h_i1036 T3825)
(declare-const var_h1035 T3825)
(declare-const v Int)
(declare-const var_h_i867 T3825)
(declare-const var_h866 T3825)
(declare-const v Int)
(declare-const var_h_i823 T3825)
(declare-const var_h822 T3825)
(declare-const v Int)
(declare-const var_h_i44 T3825)
(declare-const var_h43 T3825)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1059 T3825)
(declare-const var__temp_v1060 Int)
(declare-const |var__temp_h'1061| T3825)
(declare-const var__temp_v_err1062 T3826)
(declare-const var_h1035 T3825)
(declare-const var_h866 T3825)
(declare-const var_h822 T3825)
(declare-const var_h43 T3825)
(declare-const err T3839)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3825)
(declare-fun sel (T3825 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T3825)
(declare-fun var_h43 () T3825)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1059 () T3825)
(declare-fun |var__temp_h'1061| () T3825)
(declare-fun var__temp_v1060 () Int)
(declare-fun var_h1035 () T3825)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1059 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1059 other) (sel var_h1035 other)))
               (= (sel var__temp_h1059 res) 5)))
      (a!2 (and (= (sel |var__temp_h'1061| res) var__temp_v1060)
                (= (sel |var__temp_h'1061| res) (+ (sel var__temp_h1059 res) 2))
                (= (sel |var__temp_h'1061| other) (sel var__temp_h1059 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1059 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************bar
PARTIAL PATH NEW
SUB 
 	 --bar
 	 --foo
 	 --foo'
 	 --c2'
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1064 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1064 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1064, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1064, res ) ==((sel)( , var_h1063, res ) + (2))
 	 , (sel)( , var_h_i1064, other ) ==(sel)( , var_h1063, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1065:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1064 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************287
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1064 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1064, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1064, res ) ==((sel)( , var_h1063, res ) + (2))
 	 , (sel)( , var_h_i1064, other ) ==(sel)( , var_h1063, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1065:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1064 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1064 --->  Ty_heap  
 var_h1063 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1066 --->  Ty_heap  
 var__temp_v1067 --->  Ty_int  
 var__temp_h'1068 --->  Ty_heap  
 var__temp_v_err1069 --->  error  
 var_h1063 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1063, res ) ==(5) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1066, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1066, res ) ==((sel)( , var_h1063, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h1066, other ) ==(sel)( , var_h1063, other ) => 
 	 Rel (sel)( , var__temp_h1066, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1066, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1068, res ) ==(var__temp_v1067) AND 
 	 Rel (sel)( , var__temp_h'1068, res ) ==((sel)( , var__temp_h1066, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1068, other ) ==(sel)( , var__temp_h1066, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1068, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1068, other ) > (4)
 
VC_END(declare-const var_h_i1064 T3842)
(declare-const var_h1063 T3842)
(declare-const v Int)
(declare-const var_h_i1036 T3842)
(declare-const var_h1035 T3842)
(declare-const v Int)
(declare-const var_h_i867 T3842)
(declare-const var_h866 T3842)
(declare-const v Int)
(declare-const var_h_i823 T3842)
(declare-const var_h822 T3842)
(declare-const v Int)
(declare-const var_h_i44 T3842)
(declare-const var_h43 T3842)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1066 T3842)
(declare-const var__temp_v1067 Int)
(declare-const |var__temp_h'1068| T3842)
(declare-const var__temp_v_err1069 T3843)
(declare-const var_h1063 T3842)
(declare-const var_h1035 T3842)
(declare-const var_h866 T3842)
(declare-const var_h822 T3842)
(declare-const var_h43 T3842)
(declare-const err T3856)

solver 
 (declare-sort T3842)
(declare-fun sel (T3842 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1063 () T3842)
(declare-fun var_h822 () T3842)
(declare-fun var_h43 () T3842)
(declare-fun other () Int)
(declare-fun |var__temp_h'1068| () T3842)
(declare-fun var__temp_h1066 () T3842)
(declare-fun var__temp_v1067 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1063 res) 5))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1066 res) v)
                (= (sel var__temp_h1066 res) (+ (sel var_h1063 res) 2))
                (= (sel var__temp_h1066 other) (sel var_h1063 other))))
      (a!2 (and (= (sel |var__temp_h'1068| res) var__temp_v1067)
                (= (sel |var__temp_h'1068| res) (+ (sel var__temp_h1066 res) 3))
                (= (sel |var__temp_h'1068| other) (sel var__temp_h1066 other))))
      (a!3 (and (= (sel |var__temp_h'1068| res) 10)
                (not (> (sel |var__temp_h'1068| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1066 res) 7))
                (=> (= (sel var__temp_h1066 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************288
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1064 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1064, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1064, res ) ==((sel)( , var_h1063, res ) + (2))
 	 , (sel)( , var_h_i1064, other ) ==(sel)( , var_h1063, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1065:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1064 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1064 --->  Ty_heap  
 var_h1063 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1070 --->  Ty_heap  
 var__temp_v1071 --->  Ty_int  
 var__temp_h'1072 --->  Ty_heap  
 var__temp_v_err1073 --->  error  
 var_h1063 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1063, res ) ==(5) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1070, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1070, res ) ==((sel)( , var_h1063, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h1070, other ) ==(sel)( , var_h1063, other ) => 
 	 Rel (sel)( , var__temp_h1070, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1070, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1072, res ) ==(var__temp_v1071) AND 
 	 Rel (sel)( , var__temp_h'1072, res ) ==((sel)( , var__temp_h1070, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1072, other ) ==(sel)( , var__temp_h1070, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1072, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1072, other ) > (4)
 
VC_END(declare-const var_h_i1064 T3859)
(declare-const var_h1063 T3859)
(declare-const v Int)
(declare-const var_h_i1036 T3859)
(declare-const var_h1035 T3859)
(declare-const v Int)
(declare-const var_h_i867 T3859)
(declare-const var_h866 T3859)
(declare-const v Int)
(declare-const var_h_i823 T3859)
(declare-const var_h822 T3859)
(declare-const v Int)
(declare-const var_h_i44 T3859)
(declare-const var_h43 T3859)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1070 T3859)
(declare-const var__temp_v1071 Int)
(declare-const |var__temp_h'1072| T3859)
(declare-const var__temp_v_err1073 T3860)
(declare-const var_h1063 T3859)
(declare-const var_h1035 T3859)
(declare-const var_h866 T3859)
(declare-const var_h822 T3859)
(declare-const var_h43 T3859)
(declare-const err T3873)

solver 
 (declare-sort T3859)
(declare-fun sel (T3859 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1063 () T3859)
(declare-fun var_h822 () T3859)
(declare-fun var_h43 () T3859)
(declare-fun other () Int)
(declare-fun |var__temp_h'1072| () T3859)
(declare-fun var__temp_h1070 () T3859)
(declare-fun var__temp_v1071 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1063 res) 5))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1070 res) v)
                (= (sel var__temp_h1070 res) (+ (sel var_h1063 res) 2))
                (= (sel var__temp_h1070 other) (sel var_h1063 other))))
      (a!2 (and (= (sel |var__temp_h'1072| res) var__temp_v1071)
                (= (sel |var__temp_h'1072| res) (+ (sel var__temp_h1070 res) 5))
                (= (sel |var__temp_h'1072| other) (sel var__temp_h1070 other))))
      (a!3 (and (= (sel |var__temp_h'1072| res) 10)
                (not (> (sel |var__temp_h'1072| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1070 res) 7))
                (=> (= (sel var__temp_h1070 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************289
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1065:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1065:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbarfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --foo'
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1064 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1064, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1064, res ) ==((sel)( , var_h1063, res ) + (2))
 	 , (sel)( , var_h_i1064, other ) ==(sel)( , var_h1063, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1074:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************290
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1064 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1064, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1064, res ) ==((sel)( , var_h1063, res ) + (2))
 	 , (sel)( , var_h_i1064, other ) ==(sel)( , var_h1063, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1074:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1064 --->  Ty_heap  
 var_h1063 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1075 --->  Ty_heap  
 var__temp_v1076 --->  Ty_int  
 var__temp_h'1077 --->  Ty_heap  
 var__temp_v_err1078 --->  error  
 var_h1063 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1063, res ) ==(5) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1075, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1075, res ) ==((sel)( , var_h1063, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h1075, other ) ==(sel)( , var_h1063, other ) => 
 	 Rel (sel)( , var__temp_h1075, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1075, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1077, res ) ==(var__temp_v1076) AND 
 	 Rel (sel)( , var__temp_h'1077, res ) ==((sel)( , var__temp_h1075, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1077, other ) ==(sel)( , var__temp_h1075, other ) => 
 	 True
 
VC_END(declare-const var_h_i1064 T3876)
(declare-const var_h1063 T3876)
(declare-const v Int)
(declare-const var_h_i1036 T3876)
(declare-const var_h1035 T3876)
(declare-const v Int)
(declare-const var_h_i867 T3876)
(declare-const var_h866 T3876)
(declare-const v Int)
(declare-const var_h_i823 T3876)
(declare-const var_h822 T3876)
(declare-const v Int)
(declare-const var_h_i44 T3876)
(declare-const var_h43 T3876)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1075 T3876)
(declare-const var__temp_v1076 Int)
(declare-const |var__temp_h'1077| T3876)
(declare-const var__temp_v_err1078 T3877)
(declare-const var_h1063 T3876)
(declare-const var_h1035 T3876)
(declare-const var_h866 T3876)
(declare-const var_h822 T3876)
(declare-const var_h43 T3876)
(declare-const err T3890)

solver 
 (declare-sort T3876)
(declare-fun sel (T3876 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1063 () T3876)
(declare-fun var_h822 () T3876)
(declare-fun var_h43 () T3876)
(declare-fun other () Int)
(declare-fun var__temp_h1075 () T3876)
(declare-fun |var__temp_h'1077| () T3876)
(declare-fun var__temp_v1076 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1063 res) 5))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1075 res) v)
                (= (sel var__temp_h1075 res) (+ (sel var_h1063 res) 2))
                (= (sel var__temp_h1075 other) (sel var_h1063 other))))
      (a!2 (and (= (sel |var__temp_h'1077| res) var__temp_v1076)
                (= (sel |var__temp_h'1077| res) (+ (sel var__temp_h1075 res) 3))
                (= (sel |var__temp_h'1077| other) (sel var__temp_h1075 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1075 res) 7))
                (=> (= (sel var__temp_h1075 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************baz
PARTIAL PATH NEW
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --foo'
 	 --c2'
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1080 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1080 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1080, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1080, res ) ==((sel)( , var_h1079, res ) + (3))
 	 , (sel)( , var_h_i1080, other ) ==(sel)( , var_h1079, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1081:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1080 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************291
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1080 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1080, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1080, res ) ==((sel)( , var_h1079, res ) + (3))
 	 , (sel)( , var_h_i1080, other ) ==(sel)( , var_h1079, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1081:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1080 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1080 --->  Ty_heap  
 var_h1079 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1064 --->  Ty_heap  
 var_h1063 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1082 --->  Ty_heap  
 var__temp_v1083 --->  Ty_int  
 var__temp_h'1084 --->  Ty_heap  
 var__temp_v_err1085 --->  error  
 var_h1079 --->  Ty_heap  
 var_h1063 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h1079, res ) ==(7) AND 
 	 Rel (sel)( , var_h1063, res ) ==(5) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1082, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1082, res ) ==((sel)( , var_h1079, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h1082, other ) ==(sel)( , var_h1079, other ) => 
 	 Rel (sel)( , var__temp_h1082, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1082, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1084, res ) ==(var__temp_v1083) AND 
 	 Rel (sel)( , var__temp_h'1084, res ) ==((sel)( , var__temp_h1082, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1084, other ) ==(sel)( , var__temp_h1082, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1084, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1084, other ) > (4)
 
VC_END(declare-const var_h_i1080 T3893)
(declare-const var_h1079 T3893)
(declare-const v Int)
(declare-const var_h_i1064 T3893)
(declare-const var_h1063 T3893)
(declare-const v Int)
(declare-const var_h_i1036 T3893)
(declare-const var_h1035 T3893)
(declare-const v Int)
(declare-const var_h_i867 T3893)
(declare-const var_h866 T3893)
(declare-const v Int)
(declare-const var_h_i823 T3893)
(declare-const var_h822 T3893)
(declare-const v Int)
(declare-const var_h_i44 T3893)
(declare-const var_h43 T3893)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1082 T3893)
(declare-const var__temp_v1083 Int)
(declare-const |var__temp_h'1084| T3893)
(declare-const var__temp_v_err1085 T3894)
(declare-const var_h1079 T3893)
(declare-const var_h1063 T3893)
(declare-const var_h1035 T3893)
(declare-const var_h866 T3893)
(declare-const var_h822 T3893)
(declare-const var_h43 T3893)
(declare-const err T3907)

solver 
 (declare-sort T3893)
(declare-fun sel (T3893 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1079 () T3893)
(declare-fun var_h1063 () T3893)
(declare-fun var_h822 () T3893)
(declare-fun var_h43 () T3893)
(declare-fun other () Int)
(declare-fun |var__temp_h'1084| () T3893)
(declare-fun var__temp_h1082 () T3893)
(declare-fun var__temp_v1083 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1079 res) 7))
(assert (= (sel var_h1063 res) 5))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1082 res) v)
                (= (sel var__temp_h1082 res) (+ (sel var_h1079 res) 3))
                (= (sel var__temp_h1082 other) (sel var_h1079 other))))
      (a!2 (and (= (sel |var__temp_h'1084| res) var__temp_v1083)
                (= (sel |var__temp_h'1084| res) (+ (sel var__temp_h1082 res) 5))
                (= (sel |var__temp_h'1084| other) (sel var__temp_h1082 other))))
      (a!3 (and (= (sel |var__temp_h'1084| res) 10)
                (not (> (sel |var__temp_h'1084| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1082 res) 7))
                (=> (= (sel var__temp_h1082 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************292
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1081:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1081:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbazbarfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --foo'
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1080 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1080, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1080, res ) ==((sel)( , var_h1079, res ) + (3))
 	 , (sel)( , var_h_i1080, other ) ==(sel)( , var_h1079, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1086:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************293
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1080 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1080, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1080, res ) ==((sel)( , var_h1079, res ) + (3))
 	 , (sel)( , var_h_i1080, other ) ==(sel)( , var_h1079, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1086:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1080 --->  Ty_heap  
 var_h1079 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1064 --->  Ty_heap  
 var_h1063 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1087 --->  Ty_heap  
 var__temp_v1088 --->  Ty_int  
 var__temp_h'1089 --->  Ty_heap  
 var__temp_v_err1090 --->  error  
 var_h1079 --->  Ty_heap  
 var_h1063 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h1079, res ) ==(7) AND 
 	 Rel (sel)( , var_h1063, res ) ==(5) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1087, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1087, res ) ==((sel)( , var_h1079, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h1087, other ) ==(sel)( , var_h1079, other ) => 
 	 Rel (sel)( , var__temp_h1087, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1087, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1089, res ) ==(var__temp_v1088) AND 
 	 Rel (sel)( , var__temp_h'1089, res ) ==((sel)( , var__temp_h1087, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1089, other ) ==(sel)( , var__temp_h1087, other ) => 
 	 True
 
VC_END(declare-const var_h_i1080 T3910)
(declare-const var_h1079 T3910)
(declare-const v Int)
(declare-const var_h_i1064 T3910)
(declare-const var_h1063 T3910)
(declare-const v Int)
(declare-const var_h_i1036 T3910)
(declare-const var_h1035 T3910)
(declare-const v Int)
(declare-const var_h_i867 T3910)
(declare-const var_h866 T3910)
(declare-const v Int)
(declare-const var_h_i823 T3910)
(declare-const var_h822 T3910)
(declare-const v Int)
(declare-const var_h_i44 T3910)
(declare-const var_h43 T3910)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1087 T3910)
(declare-const var__temp_v1088 Int)
(declare-const |var__temp_h'1089| T3910)
(declare-const var__temp_v_err1090 T3911)
(declare-const var_h1079 T3910)
(declare-const var_h1063 T3910)
(declare-const var_h1035 T3910)
(declare-const var_h866 T3910)
(declare-const var_h822 T3910)
(declare-const var_h43 T3910)
(declare-const err T3924)

solver 
 (declare-sort T3910)
(declare-fun sel (T3910 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1079 () T3910)
(declare-fun var_h1063 () T3910)
(declare-fun var_h822 () T3910)
(declare-fun var_h43 () T3910)
(declare-fun other () Int)
(declare-fun var__temp_h1087 () T3910)
(declare-fun |var__temp_h'1089| () T3910)
(declare-fun var__temp_v1088 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1079 res) 7))
(assert (= (sel var_h1063 res) 5))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1087 res) v)
                (= (sel var__temp_h1087 res) (+ (sel var_h1079 res) 3))
                (= (sel var__temp_h1087 other) (sel var_h1079 other))))
      (a!2 (and (= (sel |var__temp_h'1089| res) var__temp_v1088)
                (= (sel |var__temp_h'1089| res) (+ (sel var__temp_h1087 res) 5))
                (= (sel |var__temp_h'1089| other) (sel var__temp_h1087 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1087 res) 7))
                (=> (= (sel var__temp_h1087 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************294
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT baz
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --foo'
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1064 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1064, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1064, res ) ==((sel)( , var_h1063, res ) + (2))
 	 , (sel)( , var_h_i1064, other ) ==(sel)( , var_h1063, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1091:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************295
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1064 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1064, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1064, res ) ==((sel)( , var_h1063, res ) + (2))
 	 , (sel)( , var_h_i1064, other ) ==(sel)( , var_h1063, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1091:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1064 --->  Ty_heap  
 var_h1063 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1092 --->  Ty_heap  
 var__temp_v1093 --->  Ty_int  
 var__temp_h'1094 --->  Ty_heap  
 var__temp_v_err1095 --->  error  
 var_h1063 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1063, res ) ==(5) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1092, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1092, res ) ==((sel)( , var_h1063, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h1092, other ) ==(sel)( , var_h1063, other ) => 
 	 Rel (sel)( , var__temp_h1092, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1092, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1094, res ) ==(var__temp_v1093) AND 
 	 Rel (sel)( , var__temp_h'1094, res ) ==((sel)( , var__temp_h1092, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1094, other ) ==(sel)( , var__temp_h1092, other ) => 
 	 True
 
VC_END(declare-const var_h_i1064 T3927)
(declare-const var_h1063 T3927)
(declare-const v Int)
(declare-const var_h_i1036 T3927)
(declare-const var_h1035 T3927)
(declare-const v Int)
(declare-const var_h_i867 T3927)
(declare-const var_h866 T3927)
(declare-const v Int)
(declare-const var_h_i823 T3927)
(declare-const var_h822 T3927)
(declare-const v Int)
(declare-const var_h_i44 T3927)
(declare-const var_h43 T3927)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1092 T3927)
(declare-const var__temp_v1093 Int)
(declare-const |var__temp_h'1094| T3927)
(declare-const var__temp_v_err1095 T3928)
(declare-const var_h1063 T3927)
(declare-const var_h1035 T3927)
(declare-const var_h866 T3927)
(declare-const var_h822 T3927)
(declare-const var_h43 T3927)
(declare-const err T3941)

solver 
 (declare-sort T3927)
(declare-fun sel (T3927 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1063 () T3927)
(declare-fun var_h822 () T3927)
(declare-fun var_h43 () T3927)
(declare-fun other () Int)
(declare-fun var__temp_h1092 () T3927)
(declare-fun |var__temp_h'1094| () T3927)
(declare-fun var__temp_v1093 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1063 res) 5))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1092 res) v)
                (= (sel var__temp_h1092 res) (+ (sel var_h1063 res) 2))
                (= (sel var__temp_h1092 other) (sel var_h1063 other))))
      (a!2 (and (= (sel |var__temp_h'1094| res) var__temp_v1093)
                (= (sel |var__temp_h'1094| res) (+ (sel var__temp_h1092 res) 5))
                (= (sel |var__temp_h'1094| other) (sel var__temp_h1092 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1092 res) 7))
                (=> (= (sel var__temp_h1092 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c5
PARTIAL PATH NEW
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --foo'
 	 --c2'
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1097 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1097 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1097, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1097, res ) ==((sel)( , var_h1096, res ) + (5))
 	 , (sel)( , var_h_i1097, other ) ==(sel)( , var_h1096, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1098:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1097 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************296
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1098:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1098:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc5bazbarfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --foo'
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1097 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1097, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1097, res ) ==((sel)( , var_h1096, res ) + (5))
 	 , (sel)( , var_h_i1097, other ) ==(sel)( , var_h1096, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1099:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************297
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --foo'
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1064 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1064, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1064, res ) ==((sel)( , var_h1063, res ) + (2))
 	 , (sel)( , var_h_i1064, other ) ==(sel)( , var_h1063, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1100:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************298
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --foo
 	 --foo'
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1036, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1036, other ) ==(sel)( , var_h1035, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1101:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************299
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1036, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1036, other ) ==(sel)( , var_h1035, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1101:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1102 --->  Ty_heap  
 var__temp_v1103 --->  Ty_int  
 var__temp_h'1104 --->  Ty_heap  
 var__temp_v_err1105 --->  error  
 var_h1035 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1102, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1102, other ) ==(sel)( , var_h1035, other ) => 
 	 Rel (sel)( , var__temp_h1102, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1102, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1104, res ) ==(var__temp_v1103) AND 
 	 Rel (sel)( , var__temp_h'1104, res ) ==((sel)( , var__temp_h1102, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1104, other ) ==(sel)( , var__temp_h1102, other ) => 
 	 True
 
VC_END(declare-const var_h_i1036 T3944)
(declare-const var_h1035 T3944)
(declare-const v Int)
(declare-const var_h_i867 T3944)
(declare-const var_h866 T3944)
(declare-const v Int)
(declare-const var_h_i823 T3944)
(declare-const var_h822 T3944)
(declare-const v Int)
(declare-const var_h_i44 T3944)
(declare-const var_h43 T3944)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1102 T3944)
(declare-const var__temp_v1103 Int)
(declare-const |var__temp_h'1104| T3944)
(declare-const var__temp_v_err1105 T3945)
(declare-const var_h1035 T3944)
(declare-const var_h866 T3944)
(declare-const var_h822 T3944)
(declare-const var_h43 T3944)
(declare-const err T3958)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3944)
(declare-fun sel (T3944 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T3944)
(declare-fun var_h43 () T3944)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1102 () T3944)
(declare-fun |var__temp_h'1104| () T3944)
(declare-fun var__temp_v1103 () Int)
(declare-fun var_h1035 () T3944)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1102 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1102 other) (sel var_h1035 other)))
               (= (sel var__temp_h1102 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1104| res) var__temp_v1103)
                (= (sel |var__temp_h'1104| res) (+ (sel var__temp_h1102 res) 3))
                (= (sel |var__temp_h'1104| other) (sel var__temp_h1102 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1102 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************300
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1036 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1036, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1036, other ) ==(sel)( , var_h1035, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1101:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1036 --->  Ty_heap  
 var_h1035 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1106 --->  Ty_heap  
 var__temp_v1107 --->  Ty_int  
 var__temp_h'1108 --->  Ty_heap  
 var__temp_v_err1109 --->  error  
 var_h1035 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1106, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1106, other ) ==(sel)( , var_h1035, other ) => 
 	 Rel (sel)( , var__temp_h1106, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1106, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1108, res ) ==(var__temp_v1107) AND 
 	 Rel (sel)( , var__temp_h'1108, res ) ==((sel)( , var__temp_h1106, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1108, other ) ==(sel)( , var__temp_h1106, other ) => 
 	 True
 
VC_END(declare-const var_h_i1036 T3961)
(declare-const var_h1035 T3961)
(declare-const v Int)
(declare-const var_h_i867 T3961)
(declare-const var_h866 T3961)
(declare-const v Int)
(declare-const var_h_i823 T3961)
(declare-const var_h822 T3961)
(declare-const v Int)
(declare-const var_h_i44 T3961)
(declare-const var_h43 T3961)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1106 T3961)
(declare-const var__temp_v1107 Int)
(declare-const |var__temp_h'1108| T3961)
(declare-const var__temp_v_err1109 T3962)
(declare-const var_h1035 T3961)
(declare-const var_h866 T3961)
(declare-const var_h822 T3961)
(declare-const var_h43 T3961)
(declare-const err T3975)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3961)
(declare-fun sel (T3961 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T3961)
(declare-fun var_h43 () T3961)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1106 () T3961)
(declare-fun |var__temp_h'1108| () T3961)
(declare-fun var__temp_v1107 () Int)
(declare-fun var_h1035 () T3961)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1106 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1106 other) (sel var_h1035 other)))
               (= (sel var__temp_h1106 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1108| res) var__temp_v1107)
                (= (sel |var__temp_h'1108| res) (+ (sel var__temp_h1106 res) 5))
                (= (sel |var__temp_h'1108| other) (sel var__temp_h1106 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1106 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************301
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT bar
PARTIAL PATH
SUB 
 	 --foo'
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i867 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i867, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i867, other ) ==(sel)( , var_h866, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1110:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************302
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i867 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i867, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i867, other ) ==(sel)( , var_h866, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1110:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1111 --->  Ty_heap  
 var__temp_v1112 --->  Ty_int  
 var__temp_h'1113 --->  Ty_heap  
 var__temp_v_err1114 --->  error  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1111, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1111, other ) ==(sel)( , var_h866, other ) => 
 	 Rel (sel)( , var__temp_h1111, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1111, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1113, res ) ==(var__temp_v1112) AND 
 	 Rel (sel)( , var__temp_h'1113, res ) ==((sel)( , var__temp_h1111, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1113, other ) ==(sel)( , var__temp_h1111, other ) => 
 	 True
 
VC_END(declare-const var_h_i867 T3978)
(declare-const var_h866 T3978)
(declare-const v Int)
(declare-const var_h_i823 T3978)
(declare-const var_h822 T3978)
(declare-const v Int)
(declare-const var_h_i44 T3978)
(declare-const var_h43 T3978)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1111 T3978)
(declare-const var__temp_v1112 Int)
(declare-const |var__temp_h'1113| T3978)
(declare-const var__temp_v_err1114 T3979)
(declare-const var_h866 T3978)
(declare-const var_h822 T3978)
(declare-const var_h43 T3978)
(declare-const err T3992)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3978)
(declare-fun sel (T3978 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T3978)
(declare-fun var_h43 () T3978)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h1111 () T3978)
(declare-fun |var__temp_h'1113| () T3978)
(declare-fun var__temp_v1112 () Int)
(declare-fun var_h866 () T3978)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1111 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1111 other) (sel var_h866 other)))
               (= (sel var__temp_h1111 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1113| res) var__temp_v1112)
                (= (sel |var__temp_h'1113| res) (+ (sel var__temp_h1111 res) 3))
                (= (sel |var__temp_h'1113| other) (sel var__temp_h1111 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1111 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************303
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i867 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i867, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i867, other ) ==(sel)( , var_h866, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1110:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1115 --->  Ty_heap  
 var__temp_v1116 --->  Ty_int  
 var__temp_h'1117 --->  Ty_heap  
 var__temp_v_err1118 --->  error  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1115, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1115, other ) ==(sel)( , var_h866, other ) => 
 	 Rel (sel)( , var__temp_h1115, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1115, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1117, res ) ==(var__temp_v1116) AND 
 	 Rel (sel)( , var__temp_h'1117, res ) ==((sel)( , var__temp_h1115, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1117, other ) ==(sel)( , var__temp_h1115, other ) => 
 	 True
 
VC_END(declare-const var_h_i867 T3995)
(declare-const var_h866 T3995)
(declare-const v Int)
(declare-const var_h_i823 T3995)
(declare-const var_h822 T3995)
(declare-const v Int)
(declare-const var_h_i44 T3995)
(declare-const var_h43 T3995)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1115 T3995)
(declare-const var__temp_v1116 Int)
(declare-const |var__temp_h'1117| T3995)
(declare-const var__temp_v_err1118 T3996)
(declare-const var_h866 T3995)
(declare-const var_h822 T3995)
(declare-const var_h43 T3995)
(declare-const err T4009)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3995)
(declare-fun sel (T3995 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T3995)
(declare-fun var_h43 () T3995)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h1115 () T3995)
(declare-fun |var__temp_h'1117| () T3995)
(declare-fun var__temp_v1116 () Int)
(declare-fun var_h866 () T3995)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1115 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1115 other) (sel var_h866 other)))
               (= (sel var__temp_h1115 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1117| res) var__temp_v1116)
                (= (sel |var__temp_h'1117| res) (+ (sel var__temp_h1115 res) 5))
                (= (sel |var__temp_h'1117| other) (sel var__temp_h1115 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1115 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************304
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i867 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i867, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i867, other ) ==(sel)( , var_h866, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1110:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i867 --->  Ty_heap  
 var_h866 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1119 --->  Ty_heap  
 var__temp_v1120 --->  Ty_int  
 var__temp_h'1121 --->  Ty_heap  
 var__temp_v_err1122 --->  error  
 var_h866 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1119, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1119, other ) ==(sel)( , var_h866, other ) => 
 	 Rel (sel)( , var__temp_h1119, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1119, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1121, res ) ==(var__temp_v1120) AND 
 	 Rel (sel)( , var__temp_h'1121, res ) ==((sel)( , var__temp_h1119, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1121, other ) ==(sel)( , var__temp_h1119, other ) => 
 	 True
 
VC_END(declare-const var_h_i867 T4012)
(declare-const var_h866 T4012)
(declare-const v Int)
(declare-const var_h_i823 T4012)
(declare-const var_h822 T4012)
(declare-const v Int)
(declare-const var_h_i44 T4012)
(declare-const var_h43 T4012)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1119 T4012)
(declare-const var__temp_v1120 Int)
(declare-const |var__temp_h'1121| T4012)
(declare-const var__temp_v_err1122 T4013)
(declare-const var_h866 T4012)
(declare-const var_h822 T4012)
(declare-const var_h43 T4012)
(declare-const err T4026)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4012)
(declare-fun sel (T4012 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T4012)
(declare-fun var_h43 () T4012)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h1119 () T4012)
(declare-fun |var__temp_h'1121| () T4012)
(declare-fun var__temp_v1120 () Int)
(declare-fun var_h866 () T4012)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1119 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1119 other) (sel var_h866 other)))
               (= (sel var__temp_h1119 res) 5)))
      (a!2 (and (= (sel |var__temp_h'1121| res) var__temp_v1120)
                (= (sel |var__temp_h'1121| res) (+ (sel var__temp_h1119 res) 2))
                (= (sel |var__temp_h'1121| other) (sel var__temp_h1119 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1119 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************305
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo
PARTIAL PATH
SUB 
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i823 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i823, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h822, res ) ==(sel)( , var_h822, res )
 	 , (sel)( , var_h_i823, other ) ==(sel)( , var_h822, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1123:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************306
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i823 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i823, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h822, res ) ==(sel)( , var_h822, res )
 	 , (sel)( , var_h_i823, other ) ==(sel)( , var_h822, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1123:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1124 --->  Ty_heap  
 var__temp_v1125 --->  Ty_int  
 var__temp_h'1126 --->  Ty_heap  
 var__temp_v_err1127 --->  error  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1124, res ) ==(v) AND 
 	 Rel (sel)( , var_h822, res ) ==(sel)( , var_h822, res ) AND 
 	 Rel (sel)( , var__temp_h1124, other ) ==(sel)( , var_h822, other ) => 
 	 Rel (sel)( , var__temp_h1124, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1124, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1126, res ) ==(var__temp_v1125) AND 
 	 Rel (sel)( , var__temp_h'1126, res ) ==((sel)( , var__temp_h1124, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1126, other ) ==(sel)( , var__temp_h1124, other ) => 
 	 True
 
VC_END(declare-const var_h_i823 T4029)
(declare-const var_h822 T4029)
(declare-const v Int)
(declare-const var_h_i44 T4029)
(declare-const var_h43 T4029)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1124 T4029)
(declare-const var__temp_v1125 Int)
(declare-const |var__temp_h'1126| T4029)
(declare-const var__temp_v_err1127 T4030)
(declare-const var_h822 T4029)
(declare-const var_h43 T4029)
(declare-const err T4043)

solver 
 (declare-sort T4029)
(declare-fun sel (T4029 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T4029)
(declare-fun var_h43 () T4029)
(declare-fun other () Int)
(declare-fun var__temp_h1124 () T4029)
(declare-fun |var__temp_h'1126| () T4029)
(declare-fun var__temp_v1125 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1124 res) v)
                    (= (sel var_h822 res) (sel var_h822 res))
                    (= (sel var__temp_h1124 other) (sel var_h822 other)))
               (= (sel var__temp_h1124 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1126| res) var__temp_v1125)
                (= (sel |var__temp_h'1126| res) (+ (sel var__temp_h1124 res) 3))
                (= (sel |var__temp_h'1126| other) (sel var__temp_h1124 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1124 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************307
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i823 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i823, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h822, res ) ==(sel)( , var_h822, res )
 	 , (sel)( , var_h_i823, other ) ==(sel)( , var_h822, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1123:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1128 --->  Ty_heap  
 var__temp_v1129 --->  Ty_int  
 var__temp_h'1130 --->  Ty_heap  
 var__temp_v_err1131 --->  error  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1128, res ) ==(v) AND 
 	 Rel (sel)( , var_h822, res ) ==(sel)( , var_h822, res ) AND 
 	 Rel (sel)( , var__temp_h1128, other ) ==(sel)( , var_h822, other ) => 
 	 Rel (sel)( , var__temp_h1128, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1128, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1130, res ) ==(var__temp_v1129) AND 
 	 Rel (sel)( , var__temp_h'1130, res ) ==((sel)( , var__temp_h1128, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1130, other ) ==(sel)( , var__temp_h1128, other ) => 
 	 True
 
VC_END(declare-const var_h_i823 T4046)
(declare-const var_h822 T4046)
(declare-const v Int)
(declare-const var_h_i44 T4046)
(declare-const var_h43 T4046)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1128 T4046)
(declare-const var__temp_v1129 Int)
(declare-const |var__temp_h'1130| T4046)
(declare-const var__temp_v_err1131 T4047)
(declare-const var_h822 T4046)
(declare-const var_h43 T4046)
(declare-const err T4060)

solver 
 (declare-sort T4046)
(declare-fun sel (T4046 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T4046)
(declare-fun var_h43 () T4046)
(declare-fun other () Int)
(declare-fun var__temp_h1128 () T4046)
(declare-fun |var__temp_h'1130| () T4046)
(declare-fun var__temp_v1129 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1128 res) v)
                    (= (sel var_h822 res) (sel var_h822 res))
                    (= (sel var__temp_h1128 other) (sel var_h822 other)))
               (= (sel var__temp_h1128 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1130| res) var__temp_v1129)
                (= (sel |var__temp_h'1130| res) (+ (sel var__temp_h1128 res) 5))
                (= (sel |var__temp_h'1130| other) (sel var__temp_h1128 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1128 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************308
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i823 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i823, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h822, res ) ==(sel)( , var_h822, res )
 	 , (sel)( , var_h_i823, other ) ==(sel)( , var_h822, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1123:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1132 --->  Ty_heap  
 var__temp_v1133 --->  Ty_int  
 var__temp_h'1134 --->  Ty_heap  
 var__temp_v_err1135 --->  error  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1132, res ) ==(v) AND 
 	 Rel (sel)( , var_h822, res ) ==(sel)( , var_h822, res ) AND 
 	 Rel (sel)( , var__temp_h1132, other ) ==(sel)( , var_h822, other ) => 
 	 Rel (sel)( , var__temp_h1132, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1132, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1134, res ) ==(var__temp_v1133) AND 
 	 Rel (sel)( , var__temp_h'1134, res ) ==((sel)( , var__temp_h1132, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'1134, other ) ==(sel)( , var__temp_h1132, other ) => 
 	 True
 
VC_END(declare-const var_h_i823 T4063)
(declare-const var_h822 T4063)
(declare-const v Int)
(declare-const var_h_i44 T4063)
(declare-const var_h43 T4063)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1132 T4063)
(declare-const var__temp_v1133 Int)
(declare-const |var__temp_h'1134| T4063)
(declare-const var__temp_v_err1135 T4064)
(declare-const var_h822 T4063)
(declare-const var_h43 T4063)
(declare-const err T4077)

solver 
 (declare-sort T4063)
(declare-fun sel (T4063 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T4063)
(declare-fun var_h43 () T4063)
(declare-fun other () Int)
(declare-fun var__temp_h1132 () T4063)
(declare-fun |var__temp_h'1134| () T4063)
(declare-fun var__temp_v1133 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1132 res) v)
                    (= (sel var_h822 res) (sel var_h822 res))
                    (= (sel var__temp_h1132 other) (sel var_h822 other)))
               (> (sel var__temp_h1132 res) 4)))
      (a!2 (and (= (sel |var__temp_h'1134| res) var__temp_v1133)
                (= (sel |var__temp_h'1134| res)
                   (+ (sel var__temp_h1132 res) 10))
                (= (sel |var__temp_h'1134| other) (sel var__temp_h1132 other)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h1132 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************309
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i823 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i823, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h822, res ) ==(sel)( , var_h822, res )
 	 , (sel)( , var_h_i823, other ) ==(sel)( , var_h822, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1123:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1136 --->  Ty_heap  
 var__temp_v1137 --->  Ty_int  
 var__temp_h'1138 --->  Ty_heap  
 var__temp_v_err1139 --->  error  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1136, res ) ==(v) AND 
 	 Rel (sel)( , var_h822, res ) ==(sel)( , var_h822, res ) AND 
 	 Rel (sel)( , var__temp_h1136, other ) ==(sel)( , var_h822, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1138, res ) ==(var__temp_v1137) AND 
 	 Base var__temp_v1137 = 5 AND 
 	 Rel (sel)( , var__temp_h'1138, other ) ==(sel)( , var__temp_h1136, other ) => 
 	 True
 
VC_END(declare-const var_h_i823 T4080)
(declare-const var_h822 T4080)
(declare-const v Int)
(declare-const var_h_i44 T4080)
(declare-const var_h43 T4080)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1136 T4080)
(declare-const var__temp_v1137 Int)
(declare-const |var__temp_h'1138| T4080)
(declare-const var__temp_v_err1139 T4081)
(declare-const var_h822 T4080)
(declare-const var_h43 T4080)
(declare-const err T4094)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4080)
(declare-fun sel (T4080 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T4080)
(declare-fun var_h43 () T4080)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1136 () T4080)
(declare-fun |var__temp_h'1138| () T4080)
(declare-fun var__temp_v1137 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1136 res) v)
                    (= (sel var_h822 res) (sel var_h822 res))
                    (= (sel var__temp_h1136 other) (sel var_h822 other)))
               true))
      (a!2 (=> (and (= (sel |var__temp_h'1138| res) var__temp_v1137)
                    (= var__temp_v1137 |5|)
                    (= (sel |var__temp_h'1138| other)
                       (sel var__temp_h1136 other)))
               true)))
  (not (and a!1 (=> true a!2)))))

***************Selection Successful************foo
PARTIAL PATH NEW
SUB 
 	 --foo
 	 --c2'
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1141 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1141 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1141, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1141, other ) ==(sel)( , var_h1140, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1142:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1141 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
bar
 *********************Enumeration Iteration*****************310
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1141 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1141, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1141, other ) ==(sel)( , var_h1140, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1142:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1141 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1141 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1143 --->  Ty_heap  
 var__temp_v1144 --->  Ty_int  
 var__temp_h'1145 --->  Ty_heap  
 var__temp_v_err1146 --->  error  
 var_h1140 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1143, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1143, other ) ==(sel)( , var_h1140, other ) => 
 	 Rel (sel)( , var__temp_h1143, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1143, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1145, res ) ==(var__temp_v1144) AND 
 	 Rel (sel)( , var__temp_h'1145, res ) ==((sel)( , var__temp_h1143, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1145, other ) ==(sel)( , var__temp_h1143, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1145, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1145, other ) > (4)
 
VC_END(declare-const var_h_i1141 T4097)
(declare-const var_h1140 T4097)
(declare-const v Int)
(declare-const var_h_i823 T4097)
(declare-const var_h822 T4097)
(declare-const v Int)
(declare-const var_h_i44 T4097)
(declare-const var_h43 T4097)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1143 T4097)
(declare-const var__temp_v1144 Int)
(declare-const |var__temp_h'1145| T4097)
(declare-const var__temp_v_err1146 T4098)
(declare-const var_h1140 T4097)
(declare-const var_h822 T4097)
(declare-const var_h43 T4097)
(declare-const err T4111)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4097)
(declare-fun sel (T4097 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T4097)
(declare-fun var_h43 () T4097)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1145| () T4097)
(declare-fun var__temp_h1143 () T4097)
(declare-fun var__temp_v1144 () Int)
(declare-fun var_h1140 () T4097)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1143 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1143 other) (sel var_h1140 other)))
               (= (sel var__temp_h1143 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1145| res) var__temp_v1144)
                (= (sel |var__temp_h'1145| res) (+ (sel var__temp_h1143 res) 3))
                (= (sel |var__temp_h'1145| other) (sel var__temp_h1143 other))))
      (a!3 (and (= (sel |var__temp_h'1145| res) 10)
                (not (> (sel |var__temp_h'1145| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1143 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************311
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1141 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1141, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1141, other ) ==(sel)( , var_h1140, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1142:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1141 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1141 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1147 --->  Ty_heap  
 var__temp_v1148 --->  Ty_int  
 var__temp_h'1149 --->  Ty_heap  
 var__temp_v_err1150 --->  error  
 var_h1140 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1147, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1147, other ) ==(sel)( , var_h1140, other ) => 
 	 Rel (sel)( , var__temp_h1147, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1147, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1149, res ) ==(var__temp_v1148) AND 
 	 Rel (sel)( , var__temp_h'1149, res ) ==((sel)( , var__temp_h1147, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1149, other ) ==(sel)( , var__temp_h1147, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1149, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1149, other ) > (4)
 
VC_END(declare-const var_h_i1141 T4114)
(declare-const var_h1140 T4114)
(declare-const v Int)
(declare-const var_h_i823 T4114)
(declare-const var_h822 T4114)
(declare-const v Int)
(declare-const var_h_i44 T4114)
(declare-const var_h43 T4114)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1147 T4114)
(declare-const var__temp_v1148 Int)
(declare-const |var__temp_h'1149| T4114)
(declare-const var__temp_v_err1150 T4115)
(declare-const var_h1140 T4114)
(declare-const var_h822 T4114)
(declare-const var_h43 T4114)
(declare-const err T4128)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4114)
(declare-fun sel (T4114 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T4114)
(declare-fun var_h43 () T4114)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1149| () T4114)
(declare-fun var__temp_h1147 () T4114)
(declare-fun var__temp_v1148 () Int)
(declare-fun var_h1140 () T4114)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1147 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1147 other) (sel var_h1140 other)))
               (= (sel var__temp_h1147 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1149| res) var__temp_v1148)
                (= (sel |var__temp_h'1149| res) (+ (sel var__temp_h1147 res) 5))
                (= (sel |var__temp_h'1149| other) (sel var__temp_h1147 other))))
      (a!3 (and (= (sel |var__temp_h'1149| res) 10)
                (not (> (sel |var__temp_h'1149| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1147 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************312
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1141 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1141, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1141, other ) ==(sel)( , var_h1140, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1142:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1141 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1141 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1151 --->  Ty_heap  
 var__temp_v1152 --->  Ty_int  
 var__temp_h'1153 --->  Ty_heap  
 var__temp_v_err1154 --->  error  
 var_h1140 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1151, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1151, other ) ==(sel)( , var_h1140, other ) => 
 	 Rel (sel)( , var__temp_h1151, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1151, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1153, res ) ==(var__temp_v1152) AND 
 	 Rel (sel)( , var__temp_h'1153, res ) ==((sel)( , var__temp_h1151, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'1153, other ) ==(sel)( , var__temp_h1151, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1153, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1153, other ) > (4)
 
VC_END(declare-const var_h_i1141 T4131)
(declare-const var_h1140 T4131)
(declare-const v Int)
(declare-const var_h_i823 T4131)
(declare-const var_h822 T4131)
(declare-const v Int)
(declare-const var_h_i44 T4131)
(declare-const var_h43 T4131)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1151 T4131)
(declare-const var__temp_v1152 Int)
(declare-const |var__temp_h'1153| T4131)
(declare-const var__temp_v_err1154 T4132)
(declare-const var_h1140 T4131)
(declare-const var_h822 T4131)
(declare-const var_h43 T4131)
(declare-const err T4145)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4131)
(declare-fun sel (T4131 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T4131)
(declare-fun var_h43 () T4131)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1153| () T4131)
(declare-fun var__temp_h1151 () T4131)
(declare-fun var__temp_v1152 () Int)
(declare-fun var_h1140 () T4131)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1151 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1151 other) (sel var_h1140 other)))
               (> (sel var__temp_h1151 res) 4)))
      (a!2 (and (= (sel |var__temp_h'1153| res) var__temp_v1152)
                (= (sel |var__temp_h'1153| res)
                   (+ (sel var__temp_h1151 res) 10))
                (= (sel |var__temp_h'1153| other) (sel var__temp_h1151 other))))
      (a!3 (and (= (sel |var__temp_h'1153| res) 10)
                (not (> (sel |var__temp_h'1153| other) 4)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h1151 res) 4) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************313
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1141 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1141, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1141, other ) ==(sel)( , var_h1140, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1142:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1141 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1141 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1155 --->  Ty_heap  
 var__temp_v1156 --->  Ty_int  
 var__temp_h'1157 --->  Ty_heap  
 var__temp_v_err1158 --->  error  
 var_h1140 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1155, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1155, other ) ==(sel)( , var_h1140, other ) => 
 	 Rel (sel)( , var__temp_h1155, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1155, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1157, res ) ==(var__temp_v1156) AND 
 	 Rel (sel)( , var__temp_h'1157, res ) ==((sel)( , var__temp_h1155, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1157, other ) ==(sel)( , var__temp_h1155, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1157, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1157, other ) > (4)
 
VC_END(declare-const var_h_i1141 T4148)
(declare-const var_h1140 T4148)
(declare-const v Int)
(declare-const var_h_i823 T4148)
(declare-const var_h822 T4148)
(declare-const v Int)
(declare-const var_h_i44 T4148)
(declare-const var_h43 T4148)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1155 T4148)
(declare-const var__temp_v1156 Int)
(declare-const |var__temp_h'1157| T4148)
(declare-const var__temp_v_err1158 T4149)
(declare-const var_h1140 T4148)
(declare-const var_h822 T4148)
(declare-const var_h43 T4148)
(declare-const err T4162)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4148)
(declare-fun sel (T4148 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T4148)
(declare-fun var_h43 () T4148)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1157| () T4148)
(declare-fun var__temp_h1155 () T4148)
(declare-fun var__temp_v1156 () Int)
(declare-fun var_h1140 () T4148)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1155 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1155 other) (sel var_h1140 other)))
               (= (sel var__temp_h1155 res) 5)))
      (a!2 (and (= (sel |var__temp_h'1157| res) var__temp_v1156)
                (= (sel |var__temp_h'1157| res) (+ (sel var__temp_h1155 res) 2))
                (= (sel |var__temp_h'1157| other) (sel var__temp_h1155 other))))
      (a!3 (and (= (sel |var__temp_h'1157| res) 10)
                (not (> (sel |var__temp_h'1157| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1155 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************314
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1142:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1142:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfoofoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --foo
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1141 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1141, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1141, other ) ==(sel)( , var_h1140, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1159:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
bar
 *********************Enumeration Iteration*****************315
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1141 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1141, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1141, other ) ==(sel)( , var_h1140, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1159:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1141 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1160 --->  Ty_heap  
 var__temp_v1161 --->  Ty_int  
 var__temp_h'1162 --->  Ty_heap  
 var__temp_v_err1163 --->  error  
 var_h1140 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1160, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1160, other ) ==(sel)( , var_h1140, other ) => 
 	 Rel (sel)( , var__temp_h1160, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1160, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1162, res ) ==(var__temp_v1161) AND 
 	 Rel (sel)( , var__temp_h'1162, res ) ==((sel)( , var__temp_h1160, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1162, other ) ==(sel)( , var__temp_h1160, other ) => 
 	 True
 
VC_END(declare-const var_h_i1141 T4165)
(declare-const var_h1140 T4165)
(declare-const v Int)
(declare-const var_h_i823 T4165)
(declare-const var_h822 T4165)
(declare-const v Int)
(declare-const var_h_i44 T4165)
(declare-const var_h43 T4165)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1160 T4165)
(declare-const var__temp_v1161 Int)
(declare-const |var__temp_h'1162| T4165)
(declare-const var__temp_v_err1163 T4166)
(declare-const var_h1140 T4165)
(declare-const var_h822 T4165)
(declare-const var_h43 T4165)
(declare-const err T4179)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4165)
(declare-fun sel (T4165 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T4165)
(declare-fun var_h43 () T4165)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1160 () T4165)
(declare-fun |var__temp_h'1162| () T4165)
(declare-fun var__temp_v1161 () Int)
(declare-fun var_h1140 () T4165)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1160 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1160 other) (sel var_h1140 other)))
               (= (sel var__temp_h1160 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1162| res) var__temp_v1161)
                (= (sel |var__temp_h'1162| res) (+ (sel var__temp_h1160 res) 3))
                (= (sel |var__temp_h'1162| other) (sel var__temp_h1160 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1160 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************316
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1141 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1141, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1141, other ) ==(sel)( , var_h1140, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1159:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1141 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1164 --->  Ty_heap  
 var__temp_v1165 --->  Ty_int  
 var__temp_h'1166 --->  Ty_heap  
 var__temp_v_err1167 --->  error  
 var_h1140 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1164, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1164, other ) ==(sel)( , var_h1140, other ) => 
 	 Rel (sel)( , var__temp_h1164, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1164, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1166, res ) ==(var__temp_v1165) AND 
 	 Rel (sel)( , var__temp_h'1166, res ) ==((sel)( , var__temp_h1164, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1166, other ) ==(sel)( , var__temp_h1164, other ) => 
 	 True
 
VC_END(declare-const var_h_i1141 T4182)
(declare-const var_h1140 T4182)
(declare-const v Int)
(declare-const var_h_i823 T4182)
(declare-const var_h822 T4182)
(declare-const v Int)
(declare-const var_h_i44 T4182)
(declare-const var_h43 T4182)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1164 T4182)
(declare-const var__temp_v1165 Int)
(declare-const |var__temp_h'1166| T4182)
(declare-const var__temp_v_err1167 T4183)
(declare-const var_h1140 T4182)
(declare-const var_h822 T4182)
(declare-const var_h43 T4182)
(declare-const err T4196)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4182)
(declare-fun sel (T4182 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T4182)
(declare-fun var_h43 () T4182)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1164 () T4182)
(declare-fun |var__temp_h'1166| () T4182)
(declare-fun var__temp_v1165 () Int)
(declare-fun var_h1140 () T4182)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1164 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1164 other) (sel var_h1140 other)))
               (= (sel var__temp_h1164 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1166| res) var__temp_v1165)
                (= (sel |var__temp_h'1166| res) (+ (sel var__temp_h1164 res) 5))
                (= (sel |var__temp_h'1166| other) (sel var__temp_h1164 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1164 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************317
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1141 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1141, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1141, other ) ==(sel)( , var_h1140, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1159:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1141 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1168 --->  Ty_heap  
 var__temp_v1169 --->  Ty_int  
 var__temp_h'1170 --->  Ty_heap  
 var__temp_v_err1171 --->  error  
 var_h1140 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1168, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1168, other ) ==(sel)( , var_h1140, other ) => 
 	 Rel (sel)( , var__temp_h1168, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1168, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1170, res ) ==(var__temp_v1169) AND 
 	 Rel (sel)( , var__temp_h'1170, res ) ==((sel)( , var__temp_h1168, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'1170, other ) ==(sel)( , var__temp_h1168, other ) => 
 	 True
 
VC_END(declare-const var_h_i1141 T4199)
(declare-const var_h1140 T4199)
(declare-const v Int)
(declare-const var_h_i823 T4199)
(declare-const var_h822 T4199)
(declare-const v Int)
(declare-const var_h_i44 T4199)
(declare-const var_h43 T4199)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1168 T4199)
(declare-const var__temp_v1169 Int)
(declare-const |var__temp_h'1170| T4199)
(declare-const var__temp_v_err1171 T4200)
(declare-const var_h1140 T4199)
(declare-const var_h822 T4199)
(declare-const var_h43 T4199)
(declare-const err T4213)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4199)
(declare-fun sel (T4199 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T4199)
(declare-fun var_h43 () T4199)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1168 () T4199)
(declare-fun |var__temp_h'1170| () T4199)
(declare-fun var__temp_v1169 () Int)
(declare-fun var_h1140 () T4199)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1168 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1168 other) (sel var_h1140 other)))
               (> (sel var__temp_h1168 res) 4)))
      (a!2 (and (= (sel |var__temp_h'1170| res) var__temp_v1169)
                (= (sel |var__temp_h'1170| res)
                   (+ (sel var__temp_h1168 res) 10))
                (= (sel |var__temp_h'1170| other) (sel var__temp_h1168 other)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h1168 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c2
PARTIAL PATH NEW
SUB 
 	 --c2
 	 --foo
 	 --c2'
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1173 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1173 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1173, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1173, res ) ==((sel)( , var_h1172, res ) + (10))
 	 , (sel)( , var_h_i1173, other ) ==(sel)( , var_h1172, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1174:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1173 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************318
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1173 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1173, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1173, res ) ==((sel)( , var_h1172, res ) + (10))
 	 , (sel)( , var_h_i1173, other ) ==(sel)( , var_h1172, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1174:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1173 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1173 --->  Ty_heap  
 var_h1172 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1141 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1175 --->  Ty_heap  
 var__temp_v1176 --->  Ty_int  
 var__temp_h'1177 --->  Ty_heap  
 var__temp_v_err1178 --->  error  
 var_h1172 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1172, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1175, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1175, res ) ==((sel)( , var_h1172, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1175, other ) ==(sel)( , var_h1172, other ) => 
 	 Rel (sel)( , var__temp_h1175, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1175, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1177, res ) ==(var__temp_v1176) AND 
 	 Rel (sel)( , var__temp_h'1177, res ) ==((sel)( , var__temp_h1175, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1177, other ) ==(sel)( , var__temp_h1175, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1177, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1177, other ) > (4)
 
VC_END(declare-const var_h_i1173 T4216)
(declare-const var_h1172 T4216)
(declare-const v Int)
(declare-const var_h_i1141 T4216)
(declare-const var_h1140 T4216)
(declare-const v Int)
(declare-const var_h_i823 T4216)
(declare-const var_h822 T4216)
(declare-const v Int)
(declare-const var_h_i44 T4216)
(declare-const var_h43 T4216)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1175 T4216)
(declare-const var__temp_v1176 Int)
(declare-const |var__temp_h'1177| T4216)
(declare-const var__temp_v_err1178 T4217)
(declare-const var_h1172 T4216)
(declare-const var_h1140 T4216)
(declare-const var_h822 T4216)
(declare-const var_h43 T4216)
(declare-const err T4230)

solver 
 (declare-sort T4216)
(declare-fun sel (T4216 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1172 () T4216)
(declare-fun var_h822 () T4216)
(declare-fun var_h43 () T4216)
(declare-fun other () Int)
(declare-fun |var__temp_h'1177| () T4216)
(declare-fun var__temp_h1175 () T4216)
(declare-fun var__temp_v1176 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1172 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1175 res) v)
                (= (sel var__temp_h1175 res) (+ (sel var_h1172 res) 10))
                (= (sel var__temp_h1175 other) (sel var_h1172 other))))
      (a!2 (and (= (sel |var__temp_h'1177| res) var__temp_v1176)
                (= (sel |var__temp_h'1177| res) (+ (sel var__temp_h1175 res) 3))
                (= (sel |var__temp_h'1177| other) (sel var__temp_h1175 other))))
      (a!3 (and (= (sel |var__temp_h'1177| res) 10)
                (not (> (sel |var__temp_h'1177| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1175 res) 7))
                (=> (= (sel var__temp_h1175 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************319
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1173 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1173, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1173, res ) ==((sel)( , var_h1172, res ) + (10))
 	 , (sel)( , var_h_i1173, other ) ==(sel)( , var_h1172, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1174:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1173 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1173 --->  Ty_heap  
 var_h1172 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1141 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1179 --->  Ty_heap  
 var__temp_v1180 --->  Ty_int  
 var__temp_h'1181 --->  Ty_heap  
 var__temp_v_err1182 --->  error  
 var_h1172 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1172, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1179, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1179, res ) ==((sel)( , var_h1172, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1179, other ) ==(sel)( , var_h1172, other ) => 
 	 Rel (sel)( , var__temp_h1179, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1179, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1181, res ) ==(var__temp_v1180) AND 
 	 Rel (sel)( , var__temp_h'1181, res ) ==((sel)( , var__temp_h1179, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1181, other ) ==(sel)( , var__temp_h1179, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1181, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1181, other ) > (4)
 
VC_END(declare-const var_h_i1173 T4233)
(declare-const var_h1172 T4233)
(declare-const v Int)
(declare-const var_h_i1141 T4233)
(declare-const var_h1140 T4233)
(declare-const v Int)
(declare-const var_h_i823 T4233)
(declare-const var_h822 T4233)
(declare-const v Int)
(declare-const var_h_i44 T4233)
(declare-const var_h43 T4233)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1179 T4233)
(declare-const var__temp_v1180 Int)
(declare-const |var__temp_h'1181| T4233)
(declare-const var__temp_v_err1182 T4234)
(declare-const var_h1172 T4233)
(declare-const var_h1140 T4233)
(declare-const var_h822 T4233)
(declare-const var_h43 T4233)
(declare-const err T4247)

solver 
 (declare-sort T4233)
(declare-fun sel (T4233 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1172 () T4233)
(declare-fun var_h822 () T4233)
(declare-fun var_h43 () T4233)
(declare-fun other () Int)
(declare-fun |var__temp_h'1181| () T4233)
(declare-fun var__temp_h1179 () T4233)
(declare-fun var__temp_v1180 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1172 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1179 res) v)
                (= (sel var__temp_h1179 res) (+ (sel var_h1172 res) 10))
                (= (sel var__temp_h1179 other) (sel var_h1172 other))))
      (a!2 (and (= (sel |var__temp_h'1181| res) var__temp_v1180)
                (= (sel |var__temp_h'1181| res) (+ (sel var__temp_h1179 res) 5))
                (= (sel |var__temp_h'1181| other) (sel var__temp_h1179 other))))
      (a!3 (and (= (sel |var__temp_h'1181| res) 10)
                (not (> (sel |var__temp_h'1181| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1179 res) 7))
                (=> (= (sel var__temp_h1179 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************320
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1173 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1173, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1173, res ) ==((sel)( , var_h1172, res ) + (10))
 	 , (sel)( , var_h_i1173, other ) ==(sel)( , var_h1172, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1174:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1173 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1173 --->  Ty_heap  
 var_h1172 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1141 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1183 --->  Ty_heap  
 var__temp_v1184 --->  Ty_int  
 var__temp_h'1185 --->  Ty_heap  
 var__temp_v_err1186 --->  error  
 var_h1172 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1172, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1183, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1183, res ) ==((sel)( , var_h1172, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1183, other ) ==(sel)( , var_h1172, other ) => 
 	 Rel (sel)( , var__temp_h1183, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1183, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1185, res ) ==(var__temp_v1184) AND 
 	 Rel (sel)( , var__temp_h'1185, res ) ==((sel)( , var__temp_h1183, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1185, other ) ==(sel)( , var__temp_h1183, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1185, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1185, other ) > (4)
 
VC_END(declare-const var_h_i1173 T4250)
(declare-const var_h1172 T4250)
(declare-const v Int)
(declare-const var_h_i1141 T4250)
(declare-const var_h1140 T4250)
(declare-const v Int)
(declare-const var_h_i823 T4250)
(declare-const var_h822 T4250)
(declare-const v Int)
(declare-const var_h_i44 T4250)
(declare-const var_h43 T4250)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1183 T4250)
(declare-const var__temp_v1184 Int)
(declare-const |var__temp_h'1185| T4250)
(declare-const var__temp_v_err1186 T4251)
(declare-const var_h1172 T4250)
(declare-const var_h1140 T4250)
(declare-const var_h822 T4250)
(declare-const var_h43 T4250)
(declare-const err T4264)

solver 
 (declare-sort T4250)
(declare-fun sel (T4250 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1172 () T4250)
(declare-fun var_h822 () T4250)
(declare-fun var_h43 () T4250)
(declare-fun other () Int)
(declare-fun |var__temp_h'1185| () T4250)
(declare-fun var__temp_h1183 () T4250)
(declare-fun var__temp_v1184 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1172 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1183 res) v)
                (= (sel var__temp_h1183 res) (+ (sel var_h1172 res) 10))
                (= (sel var__temp_h1183 other) (sel var_h1172 other))))
      (a!2 (and (= (sel |var__temp_h'1185| res) var__temp_v1184)
                (= (sel |var__temp_h'1185| res) (+ (sel var__temp_h1183 res) 2))
                (= (sel |var__temp_h'1185| other) (sel var__temp_h1183 other))))
      (a!3 (and (= (sel |var__temp_h'1185| res) 10)
                (not (> (sel |var__temp_h'1185| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1183 res) 5))
                (=> (= (sel var__temp_h1183 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************321
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1174:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1174:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2foofoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c2
 	 --foo
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1173 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1173, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1173, res ) ==((sel)( , var_h1172, res ) + (10))
 	 , (sel)( , var_h_i1173, other ) ==(sel)( , var_h1172, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1187:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************322
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1173 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1173, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1173, res ) ==((sel)( , var_h1172, res ) + (10))
 	 , (sel)( , var_h_i1173, other ) ==(sel)( , var_h1172, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1187:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1173 --->  Ty_heap  
 var_h1172 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1141 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1188 --->  Ty_heap  
 var__temp_v1189 --->  Ty_int  
 var__temp_h'1190 --->  Ty_heap  
 var__temp_v_err1191 --->  error  
 var_h1172 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1172, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1188, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1188, res ) ==((sel)( , var_h1172, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1188, other ) ==(sel)( , var_h1172, other ) => 
 	 Rel (sel)( , var__temp_h1188, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1188, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1190, res ) ==(var__temp_v1189) AND 
 	 Rel (sel)( , var__temp_h'1190, res ) ==((sel)( , var__temp_h1188, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1190, other ) ==(sel)( , var__temp_h1188, other ) => 
 	 True
 
VC_END(declare-const var_h_i1173 T4267)
(declare-const var_h1172 T4267)
(declare-const v Int)
(declare-const var_h_i1141 T4267)
(declare-const var_h1140 T4267)
(declare-const v Int)
(declare-const var_h_i823 T4267)
(declare-const var_h822 T4267)
(declare-const v Int)
(declare-const var_h_i44 T4267)
(declare-const var_h43 T4267)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1188 T4267)
(declare-const var__temp_v1189 Int)
(declare-const |var__temp_h'1190| T4267)
(declare-const var__temp_v_err1191 T4268)
(declare-const var_h1172 T4267)
(declare-const var_h1140 T4267)
(declare-const var_h822 T4267)
(declare-const var_h43 T4267)
(declare-const err T4281)

solver 
 (declare-sort T4267)
(declare-fun sel (T4267 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1172 () T4267)
(declare-fun var_h822 () T4267)
(declare-fun var_h43 () T4267)
(declare-fun other () Int)
(declare-fun var__temp_h1188 () T4267)
(declare-fun |var__temp_h'1190| () T4267)
(declare-fun var__temp_v1189 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1172 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1188 res) v)
                (= (sel var__temp_h1188 res) (+ (sel var_h1172 res) 10))
                (= (sel var__temp_h1188 other) (sel var_h1172 other))))
      (a!2 (and (= (sel |var__temp_h'1190| res) var__temp_v1189)
                (= (sel |var__temp_h'1190| res) (+ (sel var__temp_h1188 res) 3))
                (= (sel |var__temp_h'1190| other) (sel var__temp_h1188 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1188 res) 7))
                (=> (= (sel var__temp_h1188 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************323
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1173 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1173, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1173, res ) ==((sel)( , var_h1172, res ) + (10))
 	 , (sel)( , var_h_i1173, other ) ==(sel)( , var_h1172, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1187:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1173 --->  Ty_heap  
 var_h1172 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1141 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1192 --->  Ty_heap  
 var__temp_v1193 --->  Ty_int  
 var__temp_h'1194 --->  Ty_heap  
 var__temp_v_err1195 --->  error  
 var_h1172 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1172, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1192, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1192, res ) ==((sel)( , var_h1172, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1192, other ) ==(sel)( , var_h1172, other ) => 
 	 Rel (sel)( , var__temp_h1192, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1192, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1194, res ) ==(var__temp_v1193) AND 
 	 Rel (sel)( , var__temp_h'1194, res ) ==((sel)( , var__temp_h1192, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1194, other ) ==(sel)( , var__temp_h1192, other ) => 
 	 True
 
VC_END(declare-const var_h_i1173 T4284)
(declare-const var_h1172 T4284)
(declare-const v Int)
(declare-const var_h_i1141 T4284)
(declare-const var_h1140 T4284)
(declare-const v Int)
(declare-const var_h_i823 T4284)
(declare-const var_h822 T4284)
(declare-const v Int)
(declare-const var_h_i44 T4284)
(declare-const var_h43 T4284)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1192 T4284)
(declare-const var__temp_v1193 Int)
(declare-const |var__temp_h'1194| T4284)
(declare-const var__temp_v_err1195 T4285)
(declare-const var_h1172 T4284)
(declare-const var_h1140 T4284)
(declare-const var_h822 T4284)
(declare-const var_h43 T4284)
(declare-const err T4298)

solver 
 (declare-sort T4284)
(declare-fun sel (T4284 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1172 () T4284)
(declare-fun var_h822 () T4284)
(declare-fun var_h43 () T4284)
(declare-fun other () Int)
(declare-fun var__temp_h1192 () T4284)
(declare-fun |var__temp_h'1194| () T4284)
(declare-fun var__temp_v1193 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1172 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1192 res) v)
                (= (sel var__temp_h1192 res) (+ (sel var_h1172 res) 10))
                (= (sel var__temp_h1192 other) (sel var_h1172 other))))
      (a!2 (and (= (sel |var__temp_h'1194| res) var__temp_v1193)
                (= (sel |var__temp_h'1194| res) (+ (sel var__temp_h1192 res) 5))
                (= (sel |var__temp_h'1194| other) (sel var__temp_h1192 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1192 res) 7))
                (=> (= (sel var__temp_h1192 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************324
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1173 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1173, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1173, res ) ==((sel)( , var_h1172, res ) + (10))
 	 , (sel)( , var_h_i1173, other ) ==(sel)( , var_h1172, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1187:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1173 --->  Ty_heap  
 var_h1172 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1141 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1196 --->  Ty_heap  
 var__temp_v1197 --->  Ty_int  
 var__temp_h'1198 --->  Ty_heap  
 var__temp_v_err1199 --->  error  
 var_h1172 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1172, res ) > (4) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1196, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1196, res ) ==((sel)( , var_h1172, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1196, other ) ==(sel)( , var_h1172, other ) => 
 	 Rel (sel)( , var__temp_h1196, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1196, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1198, res ) ==(var__temp_v1197) AND 
 	 Rel (sel)( , var__temp_h'1198, res ) ==((sel)( , var__temp_h1196, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1198, other ) ==(sel)( , var__temp_h1196, other ) => 
 	 True
 
VC_END(declare-const var_h_i1173 T4301)
(declare-const var_h1172 T4301)
(declare-const v Int)
(declare-const var_h_i1141 T4301)
(declare-const var_h1140 T4301)
(declare-const v Int)
(declare-const var_h_i823 T4301)
(declare-const var_h822 T4301)
(declare-const v Int)
(declare-const var_h_i44 T4301)
(declare-const var_h43 T4301)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1196 T4301)
(declare-const var__temp_v1197 Int)
(declare-const |var__temp_h'1198| T4301)
(declare-const var__temp_v_err1199 T4302)
(declare-const var_h1172 T4301)
(declare-const var_h1140 T4301)
(declare-const var_h822 T4301)
(declare-const var_h43 T4301)
(declare-const err T4315)

solver 
 (declare-sort T4301)
(declare-fun sel (T4301 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1172 () T4301)
(declare-fun var_h822 () T4301)
(declare-fun var_h43 () T4301)
(declare-fun other () Int)
(declare-fun var__temp_h1196 () T4301)
(declare-fun |var__temp_h'1198| () T4301)
(declare-fun var__temp_v1197 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1172 res) 4))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1196 res) v)
                (= (sel var__temp_h1196 res) (+ (sel var_h1172 res) 10))
                (= (sel var__temp_h1196 other) (sel var_h1172 other))))
      (a!2 (and (= (sel |var__temp_h'1198| res) var__temp_v1197)
                (= (sel |var__temp_h'1198| res) (+ (sel var__temp_h1196 res) 2))
                (= (sel |var__temp_h'1198| other) (sel var__temp_h1196 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1196 res) 5))
                (=> (= (sel var__temp_h1196 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************325
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 
 	 --foo
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1141 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1141, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1141, other ) ==(sel)( , var_h1140, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1200:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************326
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1141 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1141, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1141, other ) ==(sel)( , var_h1140, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1200:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1141 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1201 --->  Ty_heap  
 var__temp_v1202 --->  Ty_int  
 var__temp_h'1203 --->  Ty_heap  
 var__temp_v_err1204 --->  error  
 var_h1140 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1201, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1201, other ) ==(sel)( , var_h1140, other ) => 
 	 Rel (sel)( , var__temp_h1201, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1201, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1203, res ) ==(var__temp_v1202) AND 
 	 Rel (sel)( , var__temp_h'1203, res ) ==((sel)( , var__temp_h1201, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1203, other ) ==(sel)( , var__temp_h1201, other ) => 
 	 True
 
VC_END(declare-const var_h_i1141 T4318)
(declare-const var_h1140 T4318)
(declare-const v Int)
(declare-const var_h_i823 T4318)
(declare-const var_h822 T4318)
(declare-const v Int)
(declare-const var_h_i44 T4318)
(declare-const var_h43 T4318)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1201 T4318)
(declare-const var__temp_v1202 Int)
(declare-const |var__temp_h'1203| T4318)
(declare-const var__temp_v_err1204 T4319)
(declare-const var_h1140 T4318)
(declare-const var_h822 T4318)
(declare-const var_h43 T4318)
(declare-const err T4332)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4318)
(declare-fun sel (T4318 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T4318)
(declare-fun var_h43 () T4318)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1201 () T4318)
(declare-fun |var__temp_h'1203| () T4318)
(declare-fun var__temp_v1202 () Int)
(declare-fun var_h1140 () T4318)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1201 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1201 other) (sel var_h1140 other)))
               (= (sel var__temp_h1201 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1203| res) var__temp_v1202)
                (= (sel |var__temp_h'1203| res) (+ (sel var__temp_h1201 res) 3))
                (= (sel |var__temp_h'1203| other) (sel var__temp_h1201 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1201 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************327
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1141 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1141, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1141, other ) ==(sel)( , var_h1140, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1200:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1141 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1205 --->  Ty_heap  
 var__temp_v1206 --->  Ty_int  
 var__temp_h'1207 --->  Ty_heap  
 var__temp_v_err1208 --->  error  
 var_h1140 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1205, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1205, other ) ==(sel)( , var_h1140, other ) => 
 	 Rel (sel)( , var__temp_h1205, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1205, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1207, res ) ==(var__temp_v1206) AND 
 	 Rel (sel)( , var__temp_h'1207, res ) ==((sel)( , var__temp_h1205, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1207, other ) ==(sel)( , var__temp_h1205, other ) => 
 	 True
 
VC_END(declare-const var_h_i1141 T4335)
(declare-const var_h1140 T4335)
(declare-const v Int)
(declare-const var_h_i823 T4335)
(declare-const var_h822 T4335)
(declare-const v Int)
(declare-const var_h_i44 T4335)
(declare-const var_h43 T4335)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1205 T4335)
(declare-const var__temp_v1206 Int)
(declare-const |var__temp_h'1207| T4335)
(declare-const var__temp_v_err1208 T4336)
(declare-const var_h1140 T4335)
(declare-const var_h822 T4335)
(declare-const var_h43 T4335)
(declare-const err T4349)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4335)
(declare-fun sel (T4335 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T4335)
(declare-fun var_h43 () T4335)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1205 () T4335)
(declare-fun |var__temp_h'1207| () T4335)
(declare-fun var__temp_v1206 () Int)
(declare-fun var_h1140 () T4335)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1205 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1205 other) (sel var_h1140 other)))
               (= (sel var__temp_h1205 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1207| res) var__temp_v1206)
                (= (sel |var__temp_h'1207| res) (+ (sel var__temp_h1205 res) 5))
                (= (sel |var__temp_h'1207| other) (sel var__temp_h1205 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1205 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************328
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1141 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1141, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1141, other ) ==(sel)( , var_h1140, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1200:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1141 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1209 --->  Ty_heap  
 var__temp_v1210 --->  Ty_int  
 var__temp_h'1211 --->  Ty_heap  
 var__temp_v_err1212 --->  error  
 var_h1140 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1209, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1209, other ) ==(sel)( , var_h1140, other ) => 
 	 Rel (sel)( , var__temp_h1209, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1209, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1211, res ) ==(var__temp_v1210) AND 
 	 Rel (sel)( , var__temp_h'1211, res ) ==((sel)( , var__temp_h1209, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1211, other ) ==(sel)( , var__temp_h1209, other ) => 
 	 True
 
VC_END(declare-const var_h_i1141 T4352)
(declare-const var_h1140 T4352)
(declare-const v Int)
(declare-const var_h_i823 T4352)
(declare-const var_h822 T4352)
(declare-const v Int)
(declare-const var_h_i44 T4352)
(declare-const var_h43 T4352)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1209 T4352)
(declare-const var__temp_v1210 Int)
(declare-const |var__temp_h'1211| T4352)
(declare-const var__temp_v_err1212 T4353)
(declare-const var_h1140 T4352)
(declare-const var_h822 T4352)
(declare-const var_h43 T4352)
(declare-const err T4366)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4352)
(declare-fun sel (T4352 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T4352)
(declare-fun var_h43 () T4352)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1209 () T4352)
(declare-fun |var__temp_h'1211| () T4352)
(declare-fun var__temp_v1210 () Int)
(declare-fun var_h1140 () T4352)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1209 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1209 other) (sel var_h1140 other)))
               (= (sel var__temp_h1209 res) 5)))
      (a!2 (and (= (sel |var__temp_h'1211| res) var__temp_v1210)
                (= (sel |var__temp_h'1211| res) (+ (sel var__temp_h1209 res) 2))
                (= (sel |var__temp_h'1211| other) (sel var__temp_h1209 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1209 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************bar
PARTIAL PATH NEW
SUB 
 	 --bar
 	 --foo
 	 --c2'
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1214 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1214 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1214, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1214, res ) ==((sel)( , var_h1213, res ) + (2))
 	 , (sel)( , var_h_i1214, other ) ==(sel)( , var_h1213, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1215:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1214 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************329
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1214 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1214, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1214, res ) ==((sel)( , var_h1213, res ) + (2))
 	 , (sel)( , var_h_i1214, other ) ==(sel)( , var_h1213, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1215:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1214 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1214 --->  Ty_heap  
 var_h1213 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1141 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1216 --->  Ty_heap  
 var__temp_v1217 --->  Ty_int  
 var__temp_h'1218 --->  Ty_heap  
 var__temp_v_err1219 --->  error  
 var_h1213 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1213, res ) ==(5) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1216, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1216, res ) ==((sel)( , var_h1213, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h1216, other ) ==(sel)( , var_h1213, other ) => 
 	 Rel (sel)( , var__temp_h1216, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1216, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1218, res ) ==(var__temp_v1217) AND 
 	 Rel (sel)( , var__temp_h'1218, res ) ==((sel)( , var__temp_h1216, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1218, other ) ==(sel)( , var__temp_h1216, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1218, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1218, other ) > (4)
 
VC_END(declare-const var_h_i1214 T4369)
(declare-const var_h1213 T4369)
(declare-const v Int)
(declare-const var_h_i1141 T4369)
(declare-const var_h1140 T4369)
(declare-const v Int)
(declare-const var_h_i823 T4369)
(declare-const var_h822 T4369)
(declare-const v Int)
(declare-const var_h_i44 T4369)
(declare-const var_h43 T4369)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1216 T4369)
(declare-const var__temp_v1217 Int)
(declare-const |var__temp_h'1218| T4369)
(declare-const var__temp_v_err1219 T4370)
(declare-const var_h1213 T4369)
(declare-const var_h1140 T4369)
(declare-const var_h822 T4369)
(declare-const var_h43 T4369)
(declare-const err T4383)

solver 
 (declare-sort T4369)
(declare-fun sel (T4369 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1213 () T4369)
(declare-fun var_h822 () T4369)
(declare-fun var_h43 () T4369)
(declare-fun other () Int)
(declare-fun |var__temp_h'1218| () T4369)
(declare-fun var__temp_h1216 () T4369)
(declare-fun var__temp_v1217 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1213 res) 5))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1216 res) v)
                (= (sel var__temp_h1216 res) (+ (sel var_h1213 res) 2))
                (= (sel var__temp_h1216 other) (sel var_h1213 other))))
      (a!2 (and (= (sel |var__temp_h'1218| res) var__temp_v1217)
                (= (sel |var__temp_h'1218| res) (+ (sel var__temp_h1216 res) 3))
                (= (sel |var__temp_h'1218| other) (sel var__temp_h1216 other))))
      (a!3 (and (= (sel |var__temp_h'1218| res) 10)
                (not (> (sel |var__temp_h'1218| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1216 res) 7))
                (=> (= (sel var__temp_h1216 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************330
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1214 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1214, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1214, res ) ==((sel)( , var_h1213, res ) + (2))
 	 , (sel)( , var_h_i1214, other ) ==(sel)( , var_h1213, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1215:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1214 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1214 --->  Ty_heap  
 var_h1213 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1141 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1220 --->  Ty_heap  
 var__temp_v1221 --->  Ty_int  
 var__temp_h'1222 --->  Ty_heap  
 var__temp_v_err1223 --->  error  
 var_h1213 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1213, res ) ==(5) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1220, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1220, res ) ==((sel)( , var_h1213, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h1220, other ) ==(sel)( , var_h1213, other ) => 
 	 Rel (sel)( , var__temp_h1220, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1220, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1222, res ) ==(var__temp_v1221) AND 
 	 Rel (sel)( , var__temp_h'1222, res ) ==((sel)( , var__temp_h1220, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1222, other ) ==(sel)( , var__temp_h1220, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1222, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1222, other ) > (4)
 
VC_END(declare-const var_h_i1214 T4386)
(declare-const var_h1213 T4386)
(declare-const v Int)
(declare-const var_h_i1141 T4386)
(declare-const var_h1140 T4386)
(declare-const v Int)
(declare-const var_h_i823 T4386)
(declare-const var_h822 T4386)
(declare-const v Int)
(declare-const var_h_i44 T4386)
(declare-const var_h43 T4386)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1220 T4386)
(declare-const var__temp_v1221 Int)
(declare-const |var__temp_h'1222| T4386)
(declare-const var__temp_v_err1223 T4387)
(declare-const var_h1213 T4386)
(declare-const var_h1140 T4386)
(declare-const var_h822 T4386)
(declare-const var_h43 T4386)
(declare-const err T4400)

solver 
 (declare-sort T4386)
(declare-fun sel (T4386 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1213 () T4386)
(declare-fun var_h822 () T4386)
(declare-fun var_h43 () T4386)
(declare-fun other () Int)
(declare-fun |var__temp_h'1222| () T4386)
(declare-fun var__temp_h1220 () T4386)
(declare-fun var__temp_v1221 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1213 res) 5))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1220 res) v)
                (= (sel var__temp_h1220 res) (+ (sel var_h1213 res) 2))
                (= (sel var__temp_h1220 other) (sel var_h1213 other))))
      (a!2 (and (= (sel |var__temp_h'1222| res) var__temp_v1221)
                (= (sel |var__temp_h'1222| res) (+ (sel var__temp_h1220 res) 5))
                (= (sel |var__temp_h'1222| other) (sel var__temp_h1220 other))))
      (a!3 (and (= (sel |var__temp_h'1222| res) 10)
                (not (> (sel |var__temp_h'1222| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1220 res) 7))
                (=> (= (sel var__temp_h1220 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************331
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1215:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1215:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbarc2foofoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1214 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1214, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1214, res ) ==((sel)( , var_h1213, res ) + (2))
 	 , (sel)( , var_h_i1214, other ) ==(sel)( , var_h1213, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1224:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************332
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1214 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1214, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1214, res ) ==((sel)( , var_h1213, res ) + (2))
 	 , (sel)( , var_h_i1214, other ) ==(sel)( , var_h1213, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1224:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1214 --->  Ty_heap  
 var_h1213 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1141 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1225 --->  Ty_heap  
 var__temp_v1226 --->  Ty_int  
 var__temp_h'1227 --->  Ty_heap  
 var__temp_v_err1228 --->  error  
 var_h1213 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1213, res ) ==(5) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1225, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1225, res ) ==((sel)( , var_h1213, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h1225, other ) ==(sel)( , var_h1213, other ) => 
 	 Rel (sel)( , var__temp_h1225, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1225, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1227, res ) ==(var__temp_v1226) AND 
 	 Rel (sel)( , var__temp_h'1227, res ) ==((sel)( , var__temp_h1225, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1227, other ) ==(sel)( , var__temp_h1225, other ) => 
 	 True
 
VC_END(declare-const var_h_i1214 T4403)
(declare-const var_h1213 T4403)
(declare-const v Int)
(declare-const var_h_i1141 T4403)
(declare-const var_h1140 T4403)
(declare-const v Int)
(declare-const var_h_i823 T4403)
(declare-const var_h822 T4403)
(declare-const v Int)
(declare-const var_h_i44 T4403)
(declare-const var_h43 T4403)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1225 T4403)
(declare-const var__temp_v1226 Int)
(declare-const |var__temp_h'1227| T4403)
(declare-const var__temp_v_err1228 T4404)
(declare-const var_h1213 T4403)
(declare-const var_h1140 T4403)
(declare-const var_h822 T4403)
(declare-const var_h43 T4403)
(declare-const err T4417)

solver 
 (declare-sort T4403)
(declare-fun sel (T4403 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1213 () T4403)
(declare-fun var_h822 () T4403)
(declare-fun var_h43 () T4403)
(declare-fun other () Int)
(declare-fun var__temp_h1225 () T4403)
(declare-fun |var__temp_h'1227| () T4403)
(declare-fun var__temp_v1226 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1213 res) 5))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1225 res) v)
                (= (sel var__temp_h1225 res) (+ (sel var_h1213 res) 2))
                (= (sel var__temp_h1225 other) (sel var_h1213 other))))
      (a!2 (and (= (sel |var__temp_h'1227| res) var__temp_v1226)
                (= (sel |var__temp_h'1227| res) (+ (sel var__temp_h1225 res) 3))
                (= (sel |var__temp_h'1227| other) (sel var__temp_h1225 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1225 res) 7))
                (=> (= (sel var__temp_h1225 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************baz
PARTIAL PATH NEW
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --c2'
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1230 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1230 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1230, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1230, res ) ==((sel)( , var_h1229, res ) + (3))
 	 , (sel)( , var_h_i1230, other ) ==(sel)( , var_h1229, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1231:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1230 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************333
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1230 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1230, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1230, res ) ==((sel)( , var_h1229, res ) + (3))
 	 , (sel)( , var_h_i1230, other ) ==(sel)( , var_h1229, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1231:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1230 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1230 --->  Ty_heap  
 var_h1229 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1214 --->  Ty_heap  
 var_h1213 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1141 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1232 --->  Ty_heap  
 var__temp_v1233 --->  Ty_int  
 var__temp_h'1234 --->  Ty_heap  
 var__temp_v_err1235 --->  error  
 var_h1229 --->  Ty_heap  
 var_h1213 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h1229, res ) ==(7) AND 
 	 Rel (sel)( , var_h1213, res ) ==(5) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1232, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1232, res ) ==((sel)( , var_h1229, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h1232, other ) ==(sel)( , var_h1229, other ) => 
 	 Rel (sel)( , var__temp_h1232, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1232, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1234, res ) ==(var__temp_v1233) AND 
 	 Rel (sel)( , var__temp_h'1234, res ) ==((sel)( , var__temp_h1232, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1234, other ) ==(sel)( , var__temp_h1232, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1234, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1234, other ) > (4)
 
VC_END(declare-const var_h_i1230 T4420)
(declare-const var_h1229 T4420)
(declare-const v Int)
(declare-const var_h_i1214 T4420)
(declare-const var_h1213 T4420)
(declare-const v Int)
(declare-const var_h_i1141 T4420)
(declare-const var_h1140 T4420)
(declare-const v Int)
(declare-const var_h_i823 T4420)
(declare-const var_h822 T4420)
(declare-const v Int)
(declare-const var_h_i44 T4420)
(declare-const var_h43 T4420)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1232 T4420)
(declare-const var__temp_v1233 Int)
(declare-const |var__temp_h'1234| T4420)
(declare-const var__temp_v_err1235 T4421)
(declare-const var_h1229 T4420)
(declare-const var_h1213 T4420)
(declare-const var_h1140 T4420)
(declare-const var_h822 T4420)
(declare-const var_h43 T4420)
(declare-const err T4434)

solver 
 (declare-sort T4420)
(declare-fun sel (T4420 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1229 () T4420)
(declare-fun var_h1213 () T4420)
(declare-fun var_h822 () T4420)
(declare-fun var_h43 () T4420)
(declare-fun other () Int)
(declare-fun |var__temp_h'1234| () T4420)
(declare-fun var__temp_h1232 () T4420)
(declare-fun var__temp_v1233 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1229 res) 7))
(assert (= (sel var_h1213 res) 5))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1232 res) v)
                (= (sel var__temp_h1232 res) (+ (sel var_h1229 res) 3))
                (= (sel var__temp_h1232 other) (sel var_h1229 other))))
      (a!2 (and (= (sel |var__temp_h'1234| res) var__temp_v1233)
                (= (sel |var__temp_h'1234| res) (+ (sel var__temp_h1232 res) 5))
                (= (sel |var__temp_h'1234| other) (sel var__temp_h1232 other))))
      (a!3 (and (= (sel |var__temp_h'1234| res) 10)
                (not (> (sel |var__temp_h'1234| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1232 res) 7))
                (=> (= (sel var__temp_h1232 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************334
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1231:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1231:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbazbarc2foofoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1230 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1230, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1230, res ) ==((sel)( , var_h1229, res ) + (3))
 	 , (sel)( , var_h_i1230, other ) ==(sel)( , var_h1229, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1236:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************335
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1230 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1230, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1230, res ) ==((sel)( , var_h1229, res ) + (3))
 	 , (sel)( , var_h_i1230, other ) ==(sel)( , var_h1229, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1236:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1230 --->  Ty_heap  
 var_h1229 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1214 --->  Ty_heap  
 var_h1213 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1141 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1237 --->  Ty_heap  
 var__temp_v1238 --->  Ty_int  
 var__temp_h'1239 --->  Ty_heap  
 var__temp_v_err1240 --->  error  
 var_h1229 --->  Ty_heap  
 var_h1213 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h1229, res ) ==(7) AND 
 	 Rel (sel)( , var_h1213, res ) ==(5) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1237, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1237, res ) ==((sel)( , var_h1229, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h1237, other ) ==(sel)( , var_h1229, other ) => 
 	 Rel (sel)( , var__temp_h1237, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1237, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1239, res ) ==(var__temp_v1238) AND 
 	 Rel (sel)( , var__temp_h'1239, res ) ==((sel)( , var__temp_h1237, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1239, other ) ==(sel)( , var__temp_h1237, other ) => 
 	 True
 
VC_END(declare-const var_h_i1230 T4437)
(declare-const var_h1229 T4437)
(declare-const v Int)
(declare-const var_h_i1214 T4437)
(declare-const var_h1213 T4437)
(declare-const v Int)
(declare-const var_h_i1141 T4437)
(declare-const var_h1140 T4437)
(declare-const v Int)
(declare-const var_h_i823 T4437)
(declare-const var_h822 T4437)
(declare-const v Int)
(declare-const var_h_i44 T4437)
(declare-const var_h43 T4437)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1237 T4437)
(declare-const var__temp_v1238 Int)
(declare-const |var__temp_h'1239| T4437)
(declare-const var__temp_v_err1240 T4438)
(declare-const var_h1229 T4437)
(declare-const var_h1213 T4437)
(declare-const var_h1140 T4437)
(declare-const var_h822 T4437)
(declare-const var_h43 T4437)
(declare-const err T4451)

solver 
 (declare-sort T4437)
(declare-fun sel (T4437 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1229 () T4437)
(declare-fun var_h1213 () T4437)
(declare-fun var_h822 () T4437)
(declare-fun var_h43 () T4437)
(declare-fun other () Int)
(declare-fun var__temp_h1237 () T4437)
(declare-fun |var__temp_h'1239| () T4437)
(declare-fun var__temp_v1238 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1229 res) 7))
(assert (= (sel var_h1213 res) 5))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1237 res) v)
                (= (sel var__temp_h1237 res) (+ (sel var_h1229 res) 3))
                (= (sel var__temp_h1237 other) (sel var_h1229 other))))
      (a!2 (and (= (sel |var__temp_h'1239| res) var__temp_v1238)
                (= (sel |var__temp_h'1239| res) (+ (sel var__temp_h1237 res) 5))
                (= (sel |var__temp_h'1239| other) (sel var__temp_h1237 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1237 res) 7))
                (=> (= (sel var__temp_h1237 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************336
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT baz
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1214 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1214, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1214, res ) ==((sel)( , var_h1213, res ) + (2))
 	 , (sel)( , var_h_i1214, other ) ==(sel)( , var_h1213, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1241:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************337
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1214 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1214, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1214, res ) ==((sel)( , var_h1213, res ) + (2))
 	 , (sel)( , var_h_i1214, other ) ==(sel)( , var_h1213, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1241:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1214 --->  Ty_heap  
 var_h1213 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1141 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1242 --->  Ty_heap  
 var__temp_v1243 --->  Ty_int  
 var__temp_h'1244 --->  Ty_heap  
 var__temp_v_err1245 --->  error  
 var_h1213 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1213, res ) ==(5) AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1242, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1242, res ) ==((sel)( , var_h1213, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h1242, other ) ==(sel)( , var_h1213, other ) => 
 	 Rel (sel)( , var__temp_h1242, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1242, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1244, res ) ==(var__temp_v1243) AND 
 	 Rel (sel)( , var__temp_h'1244, res ) ==((sel)( , var__temp_h1242, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1244, other ) ==(sel)( , var__temp_h1242, other ) => 
 	 True
 
VC_END(declare-const var_h_i1214 T4454)
(declare-const var_h1213 T4454)
(declare-const v Int)
(declare-const var_h_i1141 T4454)
(declare-const var_h1140 T4454)
(declare-const v Int)
(declare-const var_h_i823 T4454)
(declare-const var_h822 T4454)
(declare-const v Int)
(declare-const var_h_i44 T4454)
(declare-const var_h43 T4454)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1242 T4454)
(declare-const var__temp_v1243 Int)
(declare-const |var__temp_h'1244| T4454)
(declare-const var__temp_v_err1245 T4455)
(declare-const var_h1213 T4454)
(declare-const var_h1140 T4454)
(declare-const var_h822 T4454)
(declare-const var_h43 T4454)
(declare-const err T4468)

solver 
 (declare-sort T4454)
(declare-fun sel (T4454 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1213 () T4454)
(declare-fun var_h822 () T4454)
(declare-fun var_h43 () T4454)
(declare-fun other () Int)
(declare-fun var__temp_h1242 () T4454)
(declare-fun |var__temp_h'1244| () T4454)
(declare-fun var__temp_v1243 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1213 res) 5))
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1242 res) v)
                (= (sel var__temp_h1242 res) (+ (sel var_h1213 res) 2))
                (= (sel var__temp_h1242 other) (sel var_h1213 other))))
      (a!2 (and (= (sel |var__temp_h'1244| res) var__temp_v1243)
                (= (sel |var__temp_h'1244| res) (+ (sel var__temp_h1242 res) 5))
                (= (sel |var__temp_h'1244| other) (sel var__temp_h1242 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1242 res) 7))
                (=> (= (sel var__temp_h1242 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c5
PARTIAL PATH NEW
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --c2'
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1247 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1247 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1247, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1247, res ) ==((sel)( , var_h1246, res ) + (5))
 	 , (sel)( , var_h_i1247, other ) ==(sel)( , var_h1246, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1248:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1247 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************338
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1248:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1248:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc5bazbarc2foofoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1247 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1247, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1247, res ) ==((sel)( , var_h1246, res ) + (5))
 	 , (sel)( , var_h_i1247, other ) ==(sel)( , var_h1246, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1249:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************339
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1214 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1214, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1214, res ) ==((sel)( , var_h1213, res ) + (2))
 	 , (sel)( , var_h_i1214, other ) ==(sel)( , var_h1213, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1250:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************340
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --foo
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1141 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1141, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1141, other ) ==(sel)( , var_h1140, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1251:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************341
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1141 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1141, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1141, other ) ==(sel)( , var_h1140, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1251:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1141 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1252 --->  Ty_heap  
 var__temp_v1253 --->  Ty_int  
 var__temp_h'1254 --->  Ty_heap  
 var__temp_v_err1255 --->  error  
 var_h1140 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1252, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1252, other ) ==(sel)( , var_h1140, other ) => 
 	 Rel (sel)( , var__temp_h1252, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1252, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1254, res ) ==(var__temp_v1253) AND 
 	 Rel (sel)( , var__temp_h'1254, res ) ==((sel)( , var__temp_h1252, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1254, other ) ==(sel)( , var__temp_h1252, other ) => 
 	 True
 
VC_END(declare-const var_h_i1141 T4471)
(declare-const var_h1140 T4471)
(declare-const v Int)
(declare-const var_h_i823 T4471)
(declare-const var_h822 T4471)
(declare-const v Int)
(declare-const var_h_i44 T4471)
(declare-const var_h43 T4471)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1252 T4471)
(declare-const var__temp_v1253 Int)
(declare-const |var__temp_h'1254| T4471)
(declare-const var__temp_v_err1255 T4472)
(declare-const var_h1140 T4471)
(declare-const var_h822 T4471)
(declare-const var_h43 T4471)
(declare-const err T4485)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4471)
(declare-fun sel (T4471 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T4471)
(declare-fun var_h43 () T4471)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1252 () T4471)
(declare-fun |var__temp_h'1254| () T4471)
(declare-fun var__temp_v1253 () Int)
(declare-fun var_h1140 () T4471)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1252 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1252 other) (sel var_h1140 other)))
               (= (sel var__temp_h1252 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1254| res) var__temp_v1253)
                (= (sel |var__temp_h'1254| res) (+ (sel var__temp_h1252 res) 3))
                (= (sel |var__temp_h'1254| other) (sel var__temp_h1252 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1252 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************342
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1141 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1141, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1141, other ) ==(sel)( , var_h1140, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1251:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1141 --->  Ty_heap  
 var_h1140 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1256 --->  Ty_heap  
 var__temp_v1257 --->  Ty_int  
 var__temp_h'1258 --->  Ty_heap  
 var__temp_v_err1259 --->  error  
 var_h1140 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1256, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1256, other ) ==(sel)( , var_h1140, other ) => 
 	 Rel (sel)( , var__temp_h1256, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1256, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1258, res ) ==(var__temp_v1257) AND 
 	 Rel (sel)( , var__temp_h'1258, res ) ==((sel)( , var__temp_h1256, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1258, other ) ==(sel)( , var__temp_h1256, other ) => 
 	 True
 
VC_END(declare-const var_h_i1141 T4488)
(declare-const var_h1140 T4488)
(declare-const v Int)
(declare-const var_h_i823 T4488)
(declare-const var_h822 T4488)
(declare-const v Int)
(declare-const var_h_i44 T4488)
(declare-const var_h43 T4488)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1256 T4488)
(declare-const var__temp_v1257 Int)
(declare-const |var__temp_h'1258| T4488)
(declare-const var__temp_v_err1259 T4489)
(declare-const var_h1140 T4488)
(declare-const var_h822 T4488)
(declare-const var_h43 T4488)
(declare-const err T4502)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4488)
(declare-fun sel (T4488 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T4488)
(declare-fun var_h43 () T4488)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1256 () T4488)
(declare-fun |var__temp_h'1258| () T4488)
(declare-fun var__temp_v1257 () Int)
(declare-fun var_h1140 () T4488)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1256 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1256 other) (sel var_h1140 other)))
               (= (sel var__temp_h1256 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1258| res) var__temp_v1257)
                (= (sel |var__temp_h'1258| res) (+ (sel var__temp_h1256 res) 5))
                (= (sel |var__temp_h'1258| other) (sel var__temp_h1256 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1256 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************343
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT bar
PARTIAL PATH
SUB 
 	 --c2'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i823 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i823, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h822, res ) ==(sel)( , var_h822, res )
 	 , (sel)( , var_h_i823, other ) ==(sel)( , var_h822, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1260:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
bar
 *********************Enumeration Iteration*****************344
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i823 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i823, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h822, res ) ==(sel)( , var_h822, res )
 	 , (sel)( , var_h_i823, other ) ==(sel)( , var_h822, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1260:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1261 --->  Ty_heap  
 var__temp_v1262 --->  Ty_int  
 var__temp_h'1263 --->  Ty_heap  
 var__temp_v_err1264 --->  error  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1261, res ) ==(v) AND 
 	 Rel (sel)( , var_h822, res ) ==(sel)( , var_h822, res ) AND 
 	 Rel (sel)( , var__temp_h1261, other ) ==(sel)( , var_h822, other ) => 
 	 Rel (sel)( , var__temp_h1261, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1261, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1263, res ) ==(var__temp_v1262) AND 
 	 Rel (sel)( , var__temp_h'1263, res ) ==((sel)( , var__temp_h1261, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1263, other ) ==(sel)( , var__temp_h1261, other ) => 
 	 True
 
VC_END(declare-const var_h_i823 T4505)
(declare-const var_h822 T4505)
(declare-const v Int)
(declare-const var_h_i44 T4505)
(declare-const var_h43 T4505)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1261 T4505)
(declare-const var__temp_v1262 Int)
(declare-const |var__temp_h'1263| T4505)
(declare-const var__temp_v_err1264 T4506)
(declare-const var_h822 T4505)
(declare-const var_h43 T4505)
(declare-const err T4519)

solver 
 (declare-sort T4505)
(declare-fun sel (T4505 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T4505)
(declare-fun var_h43 () T4505)
(declare-fun other () Int)
(declare-fun var__temp_h1261 () T4505)
(declare-fun |var__temp_h'1263| () T4505)
(declare-fun var__temp_v1262 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1261 res) v)
                    (= (sel var_h822 res) (sel var_h822 res))
                    (= (sel var__temp_h1261 other) (sel var_h822 other)))
               (= (sel var__temp_h1261 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1263| res) var__temp_v1262)
                (= (sel |var__temp_h'1263| res) (+ (sel var__temp_h1261 res) 3))
                (= (sel |var__temp_h'1263| other) (sel var__temp_h1261 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1261 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************345
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i823 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i823, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h822, res ) ==(sel)( , var_h822, res )
 	 , (sel)( , var_h_i823, other ) ==(sel)( , var_h822, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1260:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1265 --->  Ty_heap  
 var__temp_v1266 --->  Ty_int  
 var__temp_h'1267 --->  Ty_heap  
 var__temp_v_err1268 --->  error  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1265, res ) ==(v) AND 
 	 Rel (sel)( , var_h822, res ) ==(sel)( , var_h822, res ) AND 
 	 Rel (sel)( , var__temp_h1265, other ) ==(sel)( , var_h822, other ) => 
 	 Rel (sel)( , var__temp_h1265, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1265, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1267, res ) ==(var__temp_v1266) AND 
 	 Rel (sel)( , var__temp_h'1267, res ) ==((sel)( , var__temp_h1265, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1267, other ) ==(sel)( , var__temp_h1265, other ) => 
 	 True
 
VC_END(declare-const var_h_i823 T4522)
(declare-const var_h822 T4522)
(declare-const v Int)
(declare-const var_h_i44 T4522)
(declare-const var_h43 T4522)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1265 T4522)
(declare-const var__temp_v1266 Int)
(declare-const |var__temp_h'1267| T4522)
(declare-const var__temp_v_err1268 T4523)
(declare-const var_h822 T4522)
(declare-const var_h43 T4522)
(declare-const err T4536)

solver 
 (declare-sort T4522)
(declare-fun sel (T4522 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T4522)
(declare-fun var_h43 () T4522)
(declare-fun other () Int)
(declare-fun var__temp_h1265 () T4522)
(declare-fun |var__temp_h'1267| () T4522)
(declare-fun var__temp_v1266 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1265 res) v)
                    (= (sel var_h822 res) (sel var_h822 res))
                    (= (sel var__temp_h1265 other) (sel var_h822 other)))
               (= (sel var__temp_h1265 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1267| res) var__temp_v1266)
                (= (sel |var__temp_h'1267| res) (+ (sel var__temp_h1265 res) 5))
                (= (sel |var__temp_h'1267| other) (sel var__temp_h1265 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1265 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************346
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i823 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i823, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h822, res ) ==(sel)( , var_h822, res )
 	 , (sel)( , var_h_i823, other ) ==(sel)( , var_h822, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1260:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1269 --->  Ty_heap  
 var__temp_v1270 --->  Ty_int  
 var__temp_h'1271 --->  Ty_heap  
 var__temp_v_err1272 --->  error  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1269, res ) ==(v) AND 
 	 Rel (sel)( , var_h822, res ) ==(sel)( , var_h822, res ) AND 
 	 Rel (sel)( , var__temp_h1269, other ) ==(sel)( , var_h822, other ) => 
 	 Rel (sel)( , var__temp_h1269, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1269, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1271, res ) ==(var__temp_v1270) AND 
 	 Rel (sel)( , var__temp_h'1271, res ) ==((sel)( , var__temp_h1269, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'1271, other ) ==(sel)( , var__temp_h1269, other ) => 
 	 True
 
VC_END(declare-const var_h_i823 T4539)
(declare-const var_h822 T4539)
(declare-const v Int)
(declare-const var_h_i44 T4539)
(declare-const var_h43 T4539)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1269 T4539)
(declare-const var__temp_v1270 Int)
(declare-const |var__temp_h'1271| T4539)
(declare-const var__temp_v_err1272 T4540)
(declare-const var_h822 T4539)
(declare-const var_h43 T4539)
(declare-const err T4553)

solver 
 (declare-sort T4539)
(declare-fun sel (T4539 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T4539)
(declare-fun var_h43 () T4539)
(declare-fun other () Int)
(declare-fun var__temp_h1269 () T4539)
(declare-fun |var__temp_h'1271| () T4539)
(declare-fun var__temp_v1270 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1269 res) v)
                    (= (sel var_h822 res) (sel var_h822 res))
                    (= (sel var__temp_h1269 other) (sel var_h822 other)))
               (> (sel var__temp_h1269 res) 4)))
      (a!2 (and (= (sel |var__temp_h'1271| res) var__temp_v1270)
                (= (sel |var__temp_h'1271| res)
                   (+ (sel var__temp_h1269 res) 10))
                (= (sel |var__temp_h'1271| other) (sel var__temp_h1269 other)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h1269 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************347
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i823 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i823, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h822, res ) ==(sel)( , var_h822, res )
 	 , (sel)( , var_h_i823, other ) ==(sel)( , var_h822, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1260:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i823 --->  Ty_heap  
 var_h822 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1273 --->  Ty_heap  
 var__temp_v1274 --->  Ty_int  
 var__temp_h'1275 --->  Ty_heap  
 var__temp_v_err1276 --->  error  
 var_h822 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h822, res ) > (20) AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1273, res ) ==(v) AND 
 	 Rel (sel)( , var_h822, res ) ==(sel)( , var_h822, res ) AND 
 	 Rel (sel)( , var__temp_h1273, other ) ==(sel)( , var_h822, other ) => 
 	 Rel (sel)( , var__temp_h1273, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1273, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1275, res ) ==(var__temp_v1274) AND 
 	 Rel (sel)( , var__temp_h'1275, res ) ==((sel)( , var__temp_h1273, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1275, other ) ==(sel)( , var__temp_h1273, other ) => 
 	 True
 
VC_END(declare-const var_h_i823 T4556)
(declare-const var_h822 T4556)
(declare-const v Int)
(declare-const var_h_i44 T4556)
(declare-const var_h43 T4556)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1273 T4556)
(declare-const var__temp_v1274 Int)
(declare-const |var__temp_h'1275| T4556)
(declare-const var__temp_v_err1276 T4557)
(declare-const var_h822 T4556)
(declare-const var_h43 T4556)
(declare-const err T4570)

solver 
 (declare-sort T4556)
(declare-fun sel (T4556 Int) Int)
(declare-fun res () Int)
(declare-fun var_h822 () T4556)
(declare-fun var_h43 () T4556)
(declare-fun other () Int)
(declare-fun var__temp_h1273 () T4556)
(declare-fun |var__temp_h'1275| () T4556)
(declare-fun var__temp_v1274 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h822 res) 20)))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1273 res) v)
                    (= (sel var_h822 res) (sel var_h822 res))
                    (= (sel var__temp_h1273 other) (sel var_h822 other)))
               (= (sel var__temp_h1273 res) 5)))
      (a!2 (and (= (sel |var__temp_h'1275| res) var__temp_v1274)
                (= (sel |var__temp_h'1275| res) (+ (sel var__temp_h1273 res) 2))
                (= (sel |var__temp_h'1275| other) (sel var__temp_h1273 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1273 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************348
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo
PARTIAL PATH
SUB 
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1277:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************349
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1277:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1278 --->  Ty_heap  
 var__temp_v1279 --->  Ty_int  
 var__temp_h'1280 --->  Ty_heap  
 var__temp_v_err1281 --->  error  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1278, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1278, res ) ==((sel)( , var_h43, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h1278, other ) ==((sel)( , var_h43, other ) + (5)) => 
 	 Rel (sel)( , var__temp_h1278, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1278, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1280, res ) ==(var__temp_v1279) AND 
 	 Rel (sel)( , var__temp_h'1280, res ) ==((sel)( , var__temp_h1278, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1280, other ) ==(sel)( , var__temp_h1278, other ) => 
 	 True
 
VC_END(declare-const var_h_i44 T4573)
(declare-const var_h43 T4573)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1278 T4573)
(declare-const var__temp_v1279 Int)
(declare-const |var__temp_h'1280| T4573)
(declare-const var__temp_v_err1281 T4574)
(declare-const var_h43 T4573)
(declare-const err T4587)

solver 
 (declare-sort T4573)
(declare-fun sel (T4573 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T4573)
(declare-fun other () Int)
(declare-fun var__temp_h1278 () T4573)
(declare-fun |var__temp_h'1280| () T4573)
(declare-fun var__temp_v1279 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1278 res) v)
                (= (sel var__temp_h1278 res) (+ (sel var_h43 res) 3))
                (= (sel var__temp_h1278 other) (+ (sel var_h43 other) 5))))
      (a!2 (and (= (sel |var__temp_h'1280| res) var__temp_v1279)
                (= (sel |var__temp_h'1280| res) (+ (sel var__temp_h1278 res) 3))
                (= (sel |var__temp_h'1280| other) (sel var__temp_h1278 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1278 res) 7))
                (=> (= (sel var__temp_h1278 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************350
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1277:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1282 --->  Ty_heap  
 var__temp_v1283 --->  Ty_int  
 var__temp_h'1284 --->  Ty_heap  
 var__temp_v_err1285 --->  error  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1282, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1282, res ) ==((sel)( , var_h43, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h1282, other ) ==((sel)( , var_h43, other ) + (5)) => 
 	 Rel (sel)( , var__temp_h1282, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1282, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1284, res ) ==(var__temp_v1283) AND 
 	 Rel (sel)( , var__temp_h'1284, res ) ==((sel)( , var__temp_h1282, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1284, other ) ==(sel)( , var__temp_h1282, other ) => 
 	 True
 
VC_END(declare-const var_h_i44 T4590)
(declare-const var_h43 T4590)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1282 T4590)
(declare-const var__temp_v1283 Int)
(declare-const |var__temp_h'1284| T4590)
(declare-const var__temp_v_err1285 T4591)
(declare-const var_h43 T4590)
(declare-const err T4604)

solver 
 (declare-sort T4590)
(declare-fun sel (T4590 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T4590)
(declare-fun other () Int)
(declare-fun var__temp_h1282 () T4590)
(declare-fun |var__temp_h'1284| () T4590)
(declare-fun var__temp_v1283 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1282 res) v)
                (= (sel var__temp_h1282 res) (+ (sel var_h43 res) 3))
                (= (sel var__temp_h1282 other) (+ (sel var_h43 other) 5))))
      (a!2 (and (= (sel |var__temp_h'1284| res) var__temp_v1283)
                (= (sel |var__temp_h'1284| res) (+ (sel var__temp_h1282 res) 5))
                (= (sel |var__temp_h'1284| other) (sel var__temp_h1282 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1282 res) 7))
                (=> (= (sel var__temp_h1282 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************351
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1277:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1286 --->  Ty_heap  
 var__temp_v1287 --->  Ty_int  
 var__temp_h'1288 --->  Ty_heap  
 var__temp_v_err1289 --->  error  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1286, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1286, res ) ==((sel)( , var_h43, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h1286, other ) ==((sel)( , var_h43, other ) + (5)) => 
 	 Rel (sel)( , var__temp_h1286, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1286, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1288, res ) ==(var__temp_v1287) AND 
 	 Rel (sel)( , var__temp_h'1288, res ) ==((sel)( , var__temp_h1286, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'1288, other ) ==(sel)( , var__temp_h1286, other ) => 
 	 True
 
VC_END(declare-const var_h_i44 T4607)
(declare-const var_h43 T4607)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1286 T4607)
(declare-const var__temp_v1287 Int)
(declare-const |var__temp_h'1288| T4607)
(declare-const var__temp_v_err1289 T4608)
(declare-const var_h43 T4607)
(declare-const err T4621)

solver 
 (declare-sort T4607)
(declare-fun sel (T4607 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T4607)
(declare-fun other () Int)
(declare-fun var__temp_h1286 () T4607)
(declare-fun |var__temp_h'1288| () T4607)
(declare-fun var__temp_v1287 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1286 res) v)
                (= (sel var__temp_h1286 res) (+ (sel var_h43 res) 3))
                (= (sel var__temp_h1286 other) (+ (sel var_h43 other) 5))))
      (a!2 (and (= (sel |var__temp_h'1288| res) var__temp_v1287)
                (= (sel |var__temp_h'1288| res)
                   (+ (sel var__temp_h1286 res) 10))
                (= (sel |var__temp_h'1288| other) (sel var__temp_h1286 other)))))
(let ((a!3 (and (=> a!1 (> (sel var__temp_h1286 res) 4))
                (=> (> (sel var__temp_h1286 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************352
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1277:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1290 --->  Ty_heap  
 var__temp_v1291 --->  Ty_int  
 var__temp_h'1292 --->  Ty_heap  
 var__temp_v_err1293 --->  error  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1290, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1290, res ) ==((sel)( , var_h43, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h1290, other ) ==((sel)( , var_h43, other ) + (5)) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1292, res ) ==(var__temp_v1291) AND 
 	 Base var__temp_v1291 = 20 AND 
 	 Rel (sel)( , var__temp_h'1292, other ) ==(sel)( , var__temp_h1290, other ) => 
 	 True
 
VC_END(declare-const var_h_i44 T4624)
(declare-const var_h43 T4624)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1290 T4624)
(declare-const var__temp_v1291 Int)
(declare-const |var__temp_h'1292| T4624)
(declare-const var__temp_v_err1293 T4625)
(declare-const var_h43 T4624)
(declare-const err T4638)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4624)
(declare-fun sel (T4624 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T4624)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h1290 () T4624)
(declare-fun |var__temp_h'1292| () T4624)
(declare-fun var__temp_v1291 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (and (= (sel var__temp_h1290 res) v)
                (= (sel var__temp_h1290 res) (+ (sel var_h43 res) 3))
                (= (sel var__temp_h1290 other) (+ (sel var_h43 other) 5))))
      (a!2 (=> (and (= (sel |var__temp_h'1292| res) var__temp_v1291)
                    (= var__temp_v1291 |20|)
                    (= (sel |var__temp_h'1292| other)
                       (sel var__temp_h1290 other)))
               true)))
  (not (and (=> a!1 true) (=> true a!2)))))

***************Selection Successful************foo'
PARTIAL PATH NEW
SUB 
 	 --foo'
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1295 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1295 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1295, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1295, other ) ==(sel)( , var_h1294, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1296:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1295 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************353
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1295 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1295, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1295, other ) ==(sel)( , var_h1294, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1296:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1295 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1297 --->  Ty_heap  
 var__temp_v1298 --->  Ty_int  
 var__temp_h'1299 --->  Ty_heap  
 var__temp_v_err1300 --->  error  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1297, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1297, other ) ==(sel)( , var_h1294, other ) => 
 	 Rel (sel)( , var__temp_h1297, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1297, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1299, res ) ==(var__temp_v1298) AND 
 	 Rel (sel)( , var__temp_h'1299, res ) ==((sel)( , var__temp_h1297, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1299, other ) ==(sel)( , var__temp_h1297, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1299, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1299, other ) > (4)
 
VC_END(declare-const var_h_i1295 T4641)
(declare-const var_h1294 T4641)
(declare-const v Int)
(declare-const var_h_i44 T4641)
(declare-const var_h43 T4641)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1297 T4641)
(declare-const var__temp_v1298 Int)
(declare-const |var__temp_h'1299| T4641)
(declare-const var__temp_v_err1300 T4642)
(declare-const var_h1294 T4641)
(declare-const var_h43 T4641)
(declare-const err T4655)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4641)
(declare-fun sel (T4641 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T4641)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'1299| () T4641)
(declare-fun var__temp_h1297 () T4641)
(declare-fun var__temp_v1298 () Int)
(declare-fun var_h1294 () T4641)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1297 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1297 other) (sel var_h1294 other)))
               (= (sel var__temp_h1297 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1299| res) var__temp_v1298)
                (= (sel |var__temp_h'1299| res) (+ (sel var__temp_h1297 res) 3))
                (= (sel |var__temp_h'1299| other) (sel var__temp_h1297 other))))
      (a!3 (and (= (sel |var__temp_h'1299| res) 10)
                (not (> (sel |var__temp_h'1299| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1297 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************354
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1295 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1295, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1295, other ) ==(sel)( , var_h1294, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1296:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1295 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1301 --->  Ty_heap  
 var__temp_v1302 --->  Ty_int  
 var__temp_h'1303 --->  Ty_heap  
 var__temp_v_err1304 --->  error  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1301, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1301, other ) ==(sel)( , var_h1294, other ) => 
 	 Rel (sel)( , var__temp_h1301, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1301, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1303, res ) ==(var__temp_v1302) AND 
 	 Rel (sel)( , var__temp_h'1303, res ) ==((sel)( , var__temp_h1301, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1303, other ) ==(sel)( , var__temp_h1301, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1303, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1303, other ) > (4)
 
VC_END(declare-const var_h_i1295 T4658)
(declare-const var_h1294 T4658)
(declare-const v Int)
(declare-const var_h_i44 T4658)
(declare-const var_h43 T4658)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1301 T4658)
(declare-const var__temp_v1302 Int)
(declare-const |var__temp_h'1303| T4658)
(declare-const var__temp_v_err1304 T4659)
(declare-const var_h1294 T4658)
(declare-const var_h43 T4658)
(declare-const err T4672)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4658)
(declare-fun sel (T4658 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T4658)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'1303| () T4658)
(declare-fun var__temp_h1301 () T4658)
(declare-fun var__temp_v1302 () Int)
(declare-fun var_h1294 () T4658)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1301 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1301 other) (sel var_h1294 other)))
               (= (sel var__temp_h1301 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1303| res) var__temp_v1302)
                (= (sel |var__temp_h'1303| res) (+ (sel var__temp_h1301 res) 5))
                (= (sel |var__temp_h'1303| other) (sel var__temp_h1301 other))))
      (a!3 (and (= (sel |var__temp_h'1303| res) 10)
                (not (> (sel |var__temp_h'1303| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1301 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************355
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1295 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1295, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1295, other ) ==(sel)( , var_h1294, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1296:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1295 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1305 --->  Ty_heap  
 var__temp_v1306 --->  Ty_int  
 var__temp_h'1307 --->  Ty_heap  
 var__temp_v_err1308 --->  error  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1305, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1305, other ) ==(sel)( , var_h1294, other ) => 
 	 Rel (sel)( , var__temp_h1305, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1305, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1307, res ) ==(var__temp_v1306) AND 
 	 Rel (sel)( , var__temp_h'1307, res ) ==((sel)( , var__temp_h1305, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'1307, other ) ==(sel)( , var__temp_h1305, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1307, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1307, other ) > (4)
 
VC_END(declare-const var_h_i1295 T4675)
(declare-const var_h1294 T4675)
(declare-const v Int)
(declare-const var_h_i44 T4675)
(declare-const var_h43 T4675)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1305 T4675)
(declare-const var__temp_v1306 Int)
(declare-const |var__temp_h'1307| T4675)
(declare-const var__temp_v_err1308 T4676)
(declare-const var_h1294 T4675)
(declare-const var_h43 T4675)
(declare-const err T4689)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4675)
(declare-fun sel (T4675 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T4675)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'1307| () T4675)
(declare-fun var__temp_h1305 () T4675)
(declare-fun var__temp_v1306 () Int)
(declare-fun var_h1294 () T4675)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1305 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1305 other) (sel var_h1294 other)))
               (> (sel var__temp_h1305 res) 4)))
      (a!2 (and (= (sel |var__temp_h'1307| res) var__temp_v1306)
                (= (sel |var__temp_h'1307| res)
                   (+ (sel var__temp_h1305 res) 10))
                (= (sel |var__temp_h'1307| other) (sel var__temp_h1305 other))))
      (a!3 (and (= (sel |var__temp_h'1307| res) 10)
                (not (> (sel |var__temp_h'1307| other) 4)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h1305 res) 4) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************356
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1295 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1295, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1295, other ) ==(sel)( , var_h1294, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1296:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1295 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1309 --->  Ty_heap  
 var__temp_v1310 --->  Ty_int  
 var__temp_h'1311 --->  Ty_heap  
 var__temp_v_err1312 --->  error  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1309, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1309, other ) ==(sel)( , var_h1294, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1311, res ) ==(var__temp_v1310) AND 
 	 Base var__temp_v1310 = 5 AND 
 	 Rel (sel)( , var__temp_h'1311, other ) ==(sel)( , var__temp_h1309, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1311, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1311, other ) > (4)
 
VC_END(declare-const var_h_i1295 T4692)
(declare-const var_h1294 T4692)
(declare-const v Int)
(declare-const var_h_i44 T4692)
(declare-const var_h43 T4692)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1309 T4692)
(declare-const var__temp_v1310 Int)
(declare-const |var__temp_h'1311| T4692)
(declare-const var__temp_v_err1312 T4693)
(declare-const var_h1294 T4692)
(declare-const var_h43 T4692)
(declare-const err T4706)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T4692)
(declare-fun sel (T4692 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T4692)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1311| () T4692)
(declare-fun var__temp_h1309 () T4692)
(declare-fun var__temp_v1310 () Int)
(declare-fun var_h1294 () T4692)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1309 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1309 other) (sel var_h1294 other)))
               true))
      (a!2 (and (= (sel |var__temp_h'1311| res) 10)
                (not (> (sel |var__temp_h'1311| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'1311| res) var__temp_v1310)
                    (= var__temp_v1310 |5|)
                    (= (sel |var__temp_h'1311| other)
                       (sel var__temp_h1309 other)))
               a!2)))
  (not (and a!1 (=> true a!3))))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************357
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1295 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1295, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1295, other ) ==(sel)( , var_h1294, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1296:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1295 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1313 --->  Ty_heap  
 var__temp_v1314 --->  Ty_int  
 var__temp_h'1315 --->  Ty_heap  
 var__temp_v_err1316 --->  error  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1313, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1313, other ) ==(sel)( , var_h1294, other ) => 
 	 Rel (sel)( , var__temp_h1313, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1313, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1315, res ) ==(var__temp_v1314) AND 
 	 Rel (sel)( , var__temp_h'1315, res ) ==((sel)( , var__temp_h1313, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1315, other ) ==(sel)( , var__temp_h1313, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1315, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1315, other ) > (4)
 
VC_END(declare-const var_h_i1295 T4709)
(declare-const var_h1294 T4709)
(declare-const v Int)
(declare-const var_h_i44 T4709)
(declare-const var_h43 T4709)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1313 T4709)
(declare-const var__temp_v1314 Int)
(declare-const |var__temp_h'1315| T4709)
(declare-const var__temp_v_err1316 T4710)
(declare-const var_h1294 T4709)
(declare-const var_h43 T4709)
(declare-const err T4723)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4709)
(declare-fun sel (T4709 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T4709)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'1315| () T4709)
(declare-fun var__temp_h1313 () T4709)
(declare-fun var__temp_v1314 () Int)
(declare-fun var_h1294 () T4709)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1313 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1313 other) (sel var_h1294 other)))
               (= (sel var__temp_h1313 res) 5)))
      (a!2 (and (= (sel |var__temp_h'1315| res) var__temp_v1314)
                (= (sel |var__temp_h'1315| res) (+ (sel var__temp_h1313 res) 2))
                (= (sel |var__temp_h'1315| other) (sel var__temp_h1313 other))))
      (a!3 (and (= (sel |var__temp_h'1315| res) 10)
                (not (> (sel |var__temp_h'1315| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1313 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************358
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1296:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1296:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --foo'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1295 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1295, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1295, other ) ==(sel)( , var_h1294, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1317:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************359
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1295 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1295, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1295, other ) ==(sel)( , var_h1294, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1317:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1318 --->  Ty_heap  
 var__temp_v1319 --->  Ty_int  
 var__temp_h'1320 --->  Ty_heap  
 var__temp_v_err1321 --->  error  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1318, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1318, other ) ==(sel)( , var_h1294, other ) => 
 	 Rel (sel)( , var__temp_h1318, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1318, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1320, res ) ==(var__temp_v1319) AND 
 	 Rel (sel)( , var__temp_h'1320, res ) ==((sel)( , var__temp_h1318, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1320, other ) ==(sel)( , var__temp_h1318, other ) => 
 	 True
 
VC_END(declare-const var_h_i1295 T4726)
(declare-const var_h1294 T4726)
(declare-const v Int)
(declare-const var_h_i44 T4726)
(declare-const var_h43 T4726)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1318 T4726)
(declare-const var__temp_v1319 Int)
(declare-const |var__temp_h'1320| T4726)
(declare-const var__temp_v_err1321 T4727)
(declare-const var_h1294 T4726)
(declare-const var_h43 T4726)
(declare-const err T4740)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4726)
(declare-fun sel (T4726 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T4726)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h1318 () T4726)
(declare-fun |var__temp_h'1320| () T4726)
(declare-fun var__temp_v1319 () Int)
(declare-fun var_h1294 () T4726)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1318 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1318 other) (sel var_h1294 other)))
               (= (sel var__temp_h1318 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1320| res) var__temp_v1319)
                (= (sel |var__temp_h'1320| res) (+ (sel var__temp_h1318 res) 3))
                (= (sel |var__temp_h'1320| other) (sel var__temp_h1318 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1318 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************360
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1295 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1295, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1295, other ) ==(sel)( , var_h1294, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1317:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1322 --->  Ty_heap  
 var__temp_v1323 --->  Ty_int  
 var__temp_h'1324 --->  Ty_heap  
 var__temp_v_err1325 --->  error  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1322, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1322, other ) ==(sel)( , var_h1294, other ) => 
 	 Rel (sel)( , var__temp_h1322, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1322, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1324, res ) ==(var__temp_v1323) AND 
 	 Rel (sel)( , var__temp_h'1324, res ) ==((sel)( , var__temp_h1322, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1324, other ) ==(sel)( , var__temp_h1322, other ) => 
 	 True
 
VC_END(declare-const var_h_i1295 T4743)
(declare-const var_h1294 T4743)
(declare-const v Int)
(declare-const var_h_i44 T4743)
(declare-const var_h43 T4743)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1322 T4743)
(declare-const var__temp_v1323 Int)
(declare-const |var__temp_h'1324| T4743)
(declare-const var__temp_v_err1325 T4744)
(declare-const var_h1294 T4743)
(declare-const var_h43 T4743)
(declare-const err T4757)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4743)
(declare-fun sel (T4743 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T4743)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h1322 () T4743)
(declare-fun |var__temp_h'1324| () T4743)
(declare-fun var__temp_v1323 () Int)
(declare-fun var_h1294 () T4743)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1322 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1322 other) (sel var_h1294 other)))
               (= (sel var__temp_h1322 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1324| res) var__temp_v1323)
                (= (sel |var__temp_h'1324| res) (+ (sel var__temp_h1322 res) 5))
                (= (sel |var__temp_h'1324| other) (sel var__temp_h1322 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1322 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************361
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1295 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1295, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1295, other ) ==(sel)( , var_h1294, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1317:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1326 --->  Ty_heap  
 var__temp_v1327 --->  Ty_int  
 var__temp_h'1328 --->  Ty_heap  
 var__temp_v_err1329 --->  error  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1326, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1326, other ) ==(sel)( , var_h1294, other ) => 
 	 Rel (sel)( , var__temp_h1326, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1326, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1328, res ) ==(var__temp_v1327) AND 
 	 Rel (sel)( , var__temp_h'1328, res ) ==((sel)( , var__temp_h1326, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'1328, other ) ==(sel)( , var__temp_h1326, other ) => 
 	 True
 
VC_END(declare-const var_h_i1295 T4760)
(declare-const var_h1294 T4760)
(declare-const v Int)
(declare-const var_h_i44 T4760)
(declare-const var_h43 T4760)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1326 T4760)
(declare-const var__temp_v1327 Int)
(declare-const |var__temp_h'1328| T4760)
(declare-const var__temp_v_err1329 T4761)
(declare-const var_h1294 T4760)
(declare-const var_h43 T4760)
(declare-const err T4774)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4760)
(declare-fun sel (T4760 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T4760)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h1326 () T4760)
(declare-fun |var__temp_h'1328| () T4760)
(declare-fun var__temp_v1327 () Int)
(declare-fun var_h1294 () T4760)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1326 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1326 other) (sel var_h1294 other)))
               (> (sel var__temp_h1326 res) 4)))
      (a!2 (and (= (sel |var__temp_h'1328| res) var__temp_v1327)
                (= (sel |var__temp_h'1328| res)
                   (+ (sel var__temp_h1326 res) 10))
                (= (sel |var__temp_h'1328| other) (sel var__temp_h1326 other)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h1326 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c2
PARTIAL PATH NEW
SUB 
 	 --c2
 	 --foo'
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1331 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1331, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1331, res ) ==((sel)( , var_h1330, res ) + (10))
 	 , (sel)( , var_h_i1331, other ) ==(sel)( , var_h1330, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1332:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1331 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************362
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1331, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1331, res ) ==((sel)( , var_h1330, res ) + (10))
 	 , (sel)( , var_h_i1331, other ) ==(sel)( , var_h1330, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1332:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1331 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1331 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1333 --->  Ty_heap  
 var__temp_v1334 --->  Ty_int  
 var__temp_h'1335 --->  Ty_heap  
 var__temp_v_err1336 --->  error  
 var_h1330 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1330, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1333, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1333, res ) ==((sel)( , var_h1330, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1333, other ) ==(sel)( , var_h1330, other ) => 
 	 Rel (sel)( , var__temp_h1333, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1333, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1335, res ) ==(var__temp_v1334) AND 
 	 Rel (sel)( , var__temp_h'1335, res ) ==((sel)( , var__temp_h1333, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1335, other ) ==(sel)( , var__temp_h1333, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1335, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1335, other ) > (4)
 
VC_END(declare-const var_h_i1331 T4777)
(declare-const var_h1330 T4777)
(declare-const v Int)
(declare-const var_h_i1295 T4777)
(declare-const var_h1294 T4777)
(declare-const v Int)
(declare-const var_h_i44 T4777)
(declare-const var_h43 T4777)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1333 T4777)
(declare-const var__temp_v1334 Int)
(declare-const |var__temp_h'1335| T4777)
(declare-const var__temp_v_err1336 T4778)
(declare-const var_h1330 T4777)
(declare-const var_h1294 T4777)
(declare-const var_h43 T4777)
(declare-const err T4791)

solver 
 (declare-sort T4777)
(declare-fun sel (T4777 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1330 () T4777)
(declare-fun var_h43 () T4777)
(declare-fun other () Int)
(declare-fun |var__temp_h'1335| () T4777)
(declare-fun var__temp_h1333 () T4777)
(declare-fun var__temp_v1334 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1330 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1333 res) v)
                (= (sel var__temp_h1333 res) (+ (sel var_h1330 res) 10))
                (= (sel var__temp_h1333 other) (sel var_h1330 other))))
      (a!2 (and (= (sel |var__temp_h'1335| res) var__temp_v1334)
                (= (sel |var__temp_h'1335| res) (+ (sel var__temp_h1333 res) 3))
                (= (sel |var__temp_h'1335| other) (sel var__temp_h1333 other))))
      (a!3 (and (= (sel |var__temp_h'1335| res) 10)
                (not (> (sel |var__temp_h'1335| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1333 res) 7))
                (=> (= (sel var__temp_h1333 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************363
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1331, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1331, res ) ==((sel)( , var_h1330, res ) + (10))
 	 , (sel)( , var_h_i1331, other ) ==(sel)( , var_h1330, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1332:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1331 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1331 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1337 --->  Ty_heap  
 var__temp_v1338 --->  Ty_int  
 var__temp_h'1339 --->  Ty_heap  
 var__temp_v_err1340 --->  error  
 var_h1330 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1330, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1337, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1337, res ) ==((sel)( , var_h1330, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1337, other ) ==(sel)( , var_h1330, other ) => 
 	 Rel (sel)( , var__temp_h1337, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1337, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1339, res ) ==(var__temp_v1338) AND 
 	 Rel (sel)( , var__temp_h'1339, res ) ==((sel)( , var__temp_h1337, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1339, other ) ==(sel)( , var__temp_h1337, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1339, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1339, other ) > (4)
 
VC_END(declare-const var_h_i1331 T4794)
(declare-const var_h1330 T4794)
(declare-const v Int)
(declare-const var_h_i1295 T4794)
(declare-const var_h1294 T4794)
(declare-const v Int)
(declare-const var_h_i44 T4794)
(declare-const var_h43 T4794)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1337 T4794)
(declare-const var__temp_v1338 Int)
(declare-const |var__temp_h'1339| T4794)
(declare-const var__temp_v_err1340 T4795)
(declare-const var_h1330 T4794)
(declare-const var_h1294 T4794)
(declare-const var_h43 T4794)
(declare-const err T4808)

solver 
 (declare-sort T4794)
(declare-fun sel (T4794 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1330 () T4794)
(declare-fun var_h43 () T4794)
(declare-fun other () Int)
(declare-fun |var__temp_h'1339| () T4794)
(declare-fun var__temp_h1337 () T4794)
(declare-fun var__temp_v1338 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1330 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1337 res) v)
                (= (sel var__temp_h1337 res) (+ (sel var_h1330 res) 10))
                (= (sel var__temp_h1337 other) (sel var_h1330 other))))
      (a!2 (and (= (sel |var__temp_h'1339| res) var__temp_v1338)
                (= (sel |var__temp_h'1339| res) (+ (sel var__temp_h1337 res) 5))
                (= (sel |var__temp_h'1339| other) (sel var__temp_h1337 other))))
      (a!3 (and (= (sel |var__temp_h'1339| res) 10)
                (not (> (sel |var__temp_h'1339| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1337 res) 7))
                (=> (= (sel var__temp_h1337 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************364
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1331, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1331, res ) ==((sel)( , var_h1330, res ) + (10))
 	 , (sel)( , var_h_i1331, other ) ==(sel)( , var_h1330, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1332:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1331 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1331 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1341 --->  Ty_heap  
 var__temp_v1342 --->  Ty_int  
 var__temp_h'1343 --->  Ty_heap  
 var__temp_v_err1344 --->  error  
 var_h1330 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1330, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1341, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1341, res ) ==((sel)( , var_h1330, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1341, other ) ==(sel)( , var_h1330, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1343, res ) ==(var__temp_v1342) AND 
 	 Base var__temp_v1342 = 5 AND 
 	 Rel (sel)( , var__temp_h'1343, other ) ==(sel)( , var__temp_h1341, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1343, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1343, other ) > (4)
 
VC_END(declare-const var_h_i1331 T4811)
(declare-const var_h1330 T4811)
(declare-const v Int)
(declare-const var_h_i1295 T4811)
(declare-const var_h1294 T4811)
(declare-const v Int)
(declare-const var_h_i44 T4811)
(declare-const var_h43 T4811)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1341 T4811)
(declare-const var__temp_v1342 Int)
(declare-const |var__temp_h'1343| T4811)
(declare-const var__temp_v_err1344 T4812)
(declare-const var_h1330 T4811)
(declare-const var_h1294 T4811)
(declare-const var_h43 T4811)
(declare-const err T4825)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4811)
(declare-fun sel (T4811 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1330 () T4811)
(declare-fun var_h43 () T4811)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1343| () T4811)
(declare-fun var__temp_h1341 () T4811)
(declare-fun var__temp_v1342 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1330 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h1341 res) v)
                (= (sel var__temp_h1341 res) (+ (sel var_h1330 res) 10))
                (= (sel var__temp_h1341 other) (sel var_h1330 other))))
      (a!2 (and (= (sel |var__temp_h'1343| res) 10)
                (not (> (sel |var__temp_h'1343| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'1343| res) var__temp_v1342)
                    (= var__temp_v1342 |5|)
                    (= (sel |var__temp_h'1343| other)
                       (sel var__temp_h1341 other)))
               a!2)))
  (not (and (=> a!1 true) (=> true a!3))))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************365
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1331, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1331, res ) ==((sel)( , var_h1330, res ) + (10))
 	 , (sel)( , var_h_i1331, other ) ==(sel)( , var_h1330, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1332:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1331 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1331 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1345 --->  Ty_heap  
 var__temp_v1346 --->  Ty_int  
 var__temp_h'1347 --->  Ty_heap  
 var__temp_v_err1348 --->  error  
 var_h1330 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1330, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1345, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1345, res ) ==((sel)( , var_h1330, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1345, other ) ==(sel)( , var_h1330, other ) => 
 	 Rel (sel)( , var__temp_h1345, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1345, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1347, res ) ==(var__temp_v1346) AND 
 	 Rel (sel)( , var__temp_h'1347, res ) ==((sel)( , var__temp_h1345, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1347, other ) ==(sel)( , var__temp_h1345, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1347, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1347, other ) > (4)
 
VC_END(declare-const var_h_i1331 T4828)
(declare-const var_h1330 T4828)
(declare-const v Int)
(declare-const var_h_i1295 T4828)
(declare-const var_h1294 T4828)
(declare-const v Int)
(declare-const var_h_i44 T4828)
(declare-const var_h43 T4828)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1345 T4828)
(declare-const var__temp_v1346 Int)
(declare-const |var__temp_h'1347| T4828)
(declare-const var__temp_v_err1348 T4829)
(declare-const var_h1330 T4828)
(declare-const var_h1294 T4828)
(declare-const var_h43 T4828)
(declare-const err T4842)

solver 
 (declare-sort T4828)
(declare-fun sel (T4828 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1330 () T4828)
(declare-fun var_h43 () T4828)
(declare-fun other () Int)
(declare-fun |var__temp_h'1347| () T4828)
(declare-fun var__temp_h1345 () T4828)
(declare-fun var__temp_v1346 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1330 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1345 res) v)
                (= (sel var__temp_h1345 res) (+ (sel var_h1330 res) 10))
                (= (sel var__temp_h1345 other) (sel var_h1330 other))))
      (a!2 (and (= (sel |var__temp_h'1347| res) var__temp_v1346)
                (= (sel |var__temp_h'1347| res) (+ (sel var__temp_h1345 res) 2))
                (= (sel |var__temp_h'1347| other) (sel var__temp_h1345 other))))
      (a!3 (and (= (sel |var__temp_h'1347| res) 10)
                (not (> (sel |var__temp_h'1347| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1345 res) 5))
                (=> (= (sel var__temp_h1345 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************366
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1332:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1332:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c2
 	 --foo'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1331, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1331, res ) ==((sel)( , var_h1330, res ) + (10))
 	 , (sel)( , var_h_i1331, other ) ==(sel)( , var_h1330, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1349:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************367
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1331, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1331, res ) ==((sel)( , var_h1330, res ) + (10))
 	 , (sel)( , var_h_i1331, other ) ==(sel)( , var_h1330, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1349:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1331 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1350 --->  Ty_heap  
 var__temp_v1351 --->  Ty_int  
 var__temp_h'1352 --->  Ty_heap  
 var__temp_v_err1353 --->  error  
 var_h1330 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1330, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1350, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1350, res ) ==((sel)( , var_h1330, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1350, other ) ==(sel)( , var_h1330, other ) => 
 	 Rel (sel)( , var__temp_h1350, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1350, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1352, res ) ==(var__temp_v1351) AND 
 	 Rel (sel)( , var__temp_h'1352, res ) ==((sel)( , var__temp_h1350, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1352, other ) ==(sel)( , var__temp_h1350, other ) => 
 	 True
 
VC_END(declare-const var_h_i1331 T4845)
(declare-const var_h1330 T4845)
(declare-const v Int)
(declare-const var_h_i1295 T4845)
(declare-const var_h1294 T4845)
(declare-const v Int)
(declare-const var_h_i44 T4845)
(declare-const var_h43 T4845)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1350 T4845)
(declare-const var__temp_v1351 Int)
(declare-const |var__temp_h'1352| T4845)
(declare-const var__temp_v_err1353 T4846)
(declare-const var_h1330 T4845)
(declare-const var_h1294 T4845)
(declare-const var_h43 T4845)
(declare-const err T4859)

solver 
 (declare-sort T4845)
(declare-fun sel (T4845 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1330 () T4845)
(declare-fun var_h43 () T4845)
(declare-fun other () Int)
(declare-fun var__temp_h1350 () T4845)
(declare-fun |var__temp_h'1352| () T4845)
(declare-fun var__temp_v1351 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1330 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1350 res) v)
                (= (sel var__temp_h1350 res) (+ (sel var_h1330 res) 10))
                (= (sel var__temp_h1350 other) (sel var_h1330 other))))
      (a!2 (and (= (sel |var__temp_h'1352| res) var__temp_v1351)
                (= (sel |var__temp_h'1352| res) (+ (sel var__temp_h1350 res) 3))
                (= (sel |var__temp_h'1352| other) (sel var__temp_h1350 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1350 res) 7))
                (=> (= (sel var__temp_h1350 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************368
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1331, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1331, res ) ==((sel)( , var_h1330, res ) + (10))
 	 , (sel)( , var_h_i1331, other ) ==(sel)( , var_h1330, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1349:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1331 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1354 --->  Ty_heap  
 var__temp_v1355 --->  Ty_int  
 var__temp_h'1356 --->  Ty_heap  
 var__temp_v_err1357 --->  error  
 var_h1330 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1330, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1354, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1354, res ) ==((sel)( , var_h1330, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1354, other ) ==(sel)( , var_h1330, other ) => 
 	 Rel (sel)( , var__temp_h1354, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1354, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1356, res ) ==(var__temp_v1355) AND 
 	 Rel (sel)( , var__temp_h'1356, res ) ==((sel)( , var__temp_h1354, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1356, other ) ==(sel)( , var__temp_h1354, other ) => 
 	 True
 
VC_END(declare-const var_h_i1331 T4862)
(declare-const var_h1330 T4862)
(declare-const v Int)
(declare-const var_h_i1295 T4862)
(declare-const var_h1294 T4862)
(declare-const v Int)
(declare-const var_h_i44 T4862)
(declare-const var_h43 T4862)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1354 T4862)
(declare-const var__temp_v1355 Int)
(declare-const |var__temp_h'1356| T4862)
(declare-const var__temp_v_err1357 T4863)
(declare-const var_h1330 T4862)
(declare-const var_h1294 T4862)
(declare-const var_h43 T4862)
(declare-const err T4876)

solver 
 (declare-sort T4862)
(declare-fun sel (T4862 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1330 () T4862)
(declare-fun var_h43 () T4862)
(declare-fun other () Int)
(declare-fun var__temp_h1354 () T4862)
(declare-fun |var__temp_h'1356| () T4862)
(declare-fun var__temp_v1355 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1330 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1354 res) v)
                (= (sel var__temp_h1354 res) (+ (sel var_h1330 res) 10))
                (= (sel var__temp_h1354 other) (sel var_h1330 other))))
      (a!2 (and (= (sel |var__temp_h'1356| res) var__temp_v1355)
                (= (sel |var__temp_h'1356| res) (+ (sel var__temp_h1354 res) 5))
                (= (sel |var__temp_h'1356| other) (sel var__temp_h1354 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1354 res) 7))
                (=> (= (sel var__temp_h1354 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************369
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1331, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1331, res ) ==((sel)( , var_h1330, res ) + (10))
 	 , (sel)( , var_h_i1331, other ) ==(sel)( , var_h1330, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1349:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1331 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1358 --->  Ty_heap  
 var__temp_v1359 --->  Ty_int  
 var__temp_h'1360 --->  Ty_heap  
 var__temp_v_err1361 --->  error  
 var_h1330 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1330, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1358, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1358, res ) ==((sel)( , var_h1330, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1358, other ) ==(sel)( , var_h1330, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1360, res ) ==(var__temp_v1359) AND 
 	 Base var__temp_v1359 = 5 AND 
 	 Rel (sel)( , var__temp_h'1360, other ) ==(sel)( , var__temp_h1358, other ) => 
 	 True
 
VC_END(declare-const var_h_i1331 T4879)
(declare-const var_h1330 T4879)
(declare-const v Int)
(declare-const var_h_i1295 T4879)
(declare-const var_h1294 T4879)
(declare-const v Int)
(declare-const var_h_i44 T4879)
(declare-const var_h43 T4879)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1358 T4879)
(declare-const var__temp_v1359 Int)
(declare-const |var__temp_h'1360| T4879)
(declare-const var__temp_v_err1361 T4880)
(declare-const var_h1330 T4879)
(declare-const var_h1294 T4879)
(declare-const var_h43 T4879)
(declare-const err T4893)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4879)
(declare-fun sel (T4879 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1330 () T4879)
(declare-fun var_h43 () T4879)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1358 () T4879)
(declare-fun |var__temp_h'1360| () T4879)
(declare-fun var__temp_v1359 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1330 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h1358 res) v)
                (= (sel var__temp_h1358 res) (+ (sel var_h1330 res) 10))
                (= (sel var__temp_h1358 other) (sel var_h1330 other))))
      (a!2 (=> (and (= (sel |var__temp_h'1360| res) var__temp_v1359)
                    (= var__temp_v1359 |5|)
                    (= (sel |var__temp_h'1360| other)
                       (sel var__temp_h1358 other)))
               true)))
  (not (and (=> a!1 true) (=> true a!2)))))

***************Selection Successful************foo
PARTIAL PATH NEW
SUB 
 	 --foo
 	 --c2
 	 --foo'
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1363 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1363 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1363, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1363, other ) ==(sel)( , var_h1362, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1364:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1363 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************370
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1363 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1363, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1363, other ) ==(sel)( , var_h1362, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1364:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1363 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1363 --->  Ty_heap  
 var_h1362 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1331 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1365 --->  Ty_heap  
 var__temp_v1366 --->  Ty_int  
 var__temp_h'1367 --->  Ty_heap  
 var__temp_v_err1368 --->  error  
 var_h1362 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1330, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1365, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1365, other ) ==(sel)( , var_h1362, other ) => 
 	 Rel (sel)( , var__temp_h1365, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1365, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1367, res ) ==(var__temp_v1366) AND 
 	 Rel (sel)( , var__temp_h'1367, res ) ==((sel)( , var__temp_h1365, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1367, other ) ==(sel)( , var__temp_h1365, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1367, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1367, other ) > (4)
 
VC_END(declare-const var_h_i1363 T4896)
(declare-const var_h1362 T4896)
(declare-const v Int)
(declare-const var_h_i1331 T4896)
(declare-const var_h1330 T4896)
(declare-const v Int)
(declare-const var_h_i1295 T4896)
(declare-const var_h1294 T4896)
(declare-const v Int)
(declare-const var_h_i44 T4896)
(declare-const var_h43 T4896)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1365 T4896)
(declare-const var__temp_v1366 Int)
(declare-const |var__temp_h'1367| T4896)
(declare-const var__temp_v_err1368 T4897)
(declare-const var_h1362 T4896)
(declare-const var_h1330 T4896)
(declare-const var_h1294 T4896)
(declare-const var_h43 T4896)
(declare-const err T4910)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4896)
(declare-fun sel (T4896 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1330 () T4896)
(declare-fun var_h43 () T4896)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1367| () T4896)
(declare-fun var__temp_h1365 () T4896)
(declare-fun var__temp_v1366 () Int)
(declare-fun var_h1362 () T4896)
(declare-fun v () Int)
(assert (> (sel var_h1330 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1365 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1365 other) (sel var_h1362 other)))
               (= (sel var__temp_h1365 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1367| res) var__temp_v1366)
                (= (sel |var__temp_h'1367| res) (+ (sel var__temp_h1365 res) 3))
                (= (sel |var__temp_h'1367| other) (sel var__temp_h1365 other))))
      (a!3 (and (= (sel |var__temp_h'1367| res) 10)
                (not (> (sel |var__temp_h'1367| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1365 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************371
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1363 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1363, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1363, other ) ==(sel)( , var_h1362, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1364:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1363 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1363 --->  Ty_heap  
 var_h1362 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1331 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1369 --->  Ty_heap  
 var__temp_v1370 --->  Ty_int  
 var__temp_h'1371 --->  Ty_heap  
 var__temp_v_err1372 --->  error  
 var_h1362 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1330, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1369, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1369, other ) ==(sel)( , var_h1362, other ) => 
 	 Rel (sel)( , var__temp_h1369, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1369, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1371, res ) ==(var__temp_v1370) AND 
 	 Rel (sel)( , var__temp_h'1371, res ) ==((sel)( , var__temp_h1369, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1371, other ) ==(sel)( , var__temp_h1369, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1371, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1371, other ) > (4)
 
VC_END(declare-const var_h_i1363 T4913)
(declare-const var_h1362 T4913)
(declare-const v Int)
(declare-const var_h_i1331 T4913)
(declare-const var_h1330 T4913)
(declare-const v Int)
(declare-const var_h_i1295 T4913)
(declare-const var_h1294 T4913)
(declare-const v Int)
(declare-const var_h_i44 T4913)
(declare-const var_h43 T4913)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1369 T4913)
(declare-const var__temp_v1370 Int)
(declare-const |var__temp_h'1371| T4913)
(declare-const var__temp_v_err1372 T4914)
(declare-const var_h1362 T4913)
(declare-const var_h1330 T4913)
(declare-const var_h1294 T4913)
(declare-const var_h43 T4913)
(declare-const err T4927)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4913)
(declare-fun sel (T4913 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1330 () T4913)
(declare-fun var_h43 () T4913)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1371| () T4913)
(declare-fun var__temp_h1369 () T4913)
(declare-fun var__temp_v1370 () Int)
(declare-fun var_h1362 () T4913)
(declare-fun v () Int)
(assert (> (sel var_h1330 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1369 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1369 other) (sel var_h1362 other)))
               (= (sel var__temp_h1369 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1371| res) var__temp_v1370)
                (= (sel |var__temp_h'1371| res) (+ (sel var__temp_h1369 res) 5))
                (= (sel |var__temp_h'1371| other) (sel var__temp_h1369 other))))
      (a!3 (and (= (sel |var__temp_h'1371| res) 10)
                (not (> (sel |var__temp_h'1371| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1369 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************372
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1363 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1363, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1363, other ) ==(sel)( , var_h1362, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1364:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1363 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1363 --->  Ty_heap  
 var_h1362 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1331 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1373 --->  Ty_heap  
 var__temp_v1374 --->  Ty_int  
 var__temp_h'1375 --->  Ty_heap  
 var__temp_v_err1376 --->  error  
 var_h1362 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1330, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1373, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1373, other ) ==(sel)( , var_h1362, other ) => 
 	 Rel (sel)( , var__temp_h1373, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1373, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1375, res ) ==(var__temp_v1374) AND 
 	 Rel (sel)( , var__temp_h'1375, res ) ==((sel)( , var__temp_h1373, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1375, other ) ==(sel)( , var__temp_h1373, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1375, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1375, other ) > (4)
 
VC_END(declare-const var_h_i1363 T4930)
(declare-const var_h1362 T4930)
(declare-const v Int)
(declare-const var_h_i1331 T4930)
(declare-const var_h1330 T4930)
(declare-const v Int)
(declare-const var_h_i1295 T4930)
(declare-const var_h1294 T4930)
(declare-const v Int)
(declare-const var_h_i44 T4930)
(declare-const var_h43 T4930)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1373 T4930)
(declare-const var__temp_v1374 Int)
(declare-const |var__temp_h'1375| T4930)
(declare-const var__temp_v_err1376 T4931)
(declare-const var_h1362 T4930)
(declare-const var_h1330 T4930)
(declare-const var_h1294 T4930)
(declare-const var_h43 T4930)
(declare-const err T4944)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4930)
(declare-fun sel (T4930 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1330 () T4930)
(declare-fun var_h43 () T4930)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1375| () T4930)
(declare-fun var__temp_h1373 () T4930)
(declare-fun var__temp_v1374 () Int)
(declare-fun var_h1362 () T4930)
(declare-fun v () Int)
(assert (> (sel var_h1330 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1373 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1373 other) (sel var_h1362 other)))
               (= (sel var__temp_h1373 res) 5)))
      (a!2 (and (= (sel |var__temp_h'1375| res) var__temp_v1374)
                (= (sel |var__temp_h'1375| res) (+ (sel var__temp_h1373 res) 2))
                (= (sel |var__temp_h'1375| other) (sel var__temp_h1373 other))))
      (a!3 (and (= (sel |var__temp_h'1375| res) 10)
                (not (> (sel |var__temp_h'1375| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1373 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************373
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1364:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1364:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --foo
 	 --c2
 	 --foo'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1363 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1363, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1363, other ) ==(sel)( , var_h1362, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1377:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************374
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1363 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1363, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1363, other ) ==(sel)( , var_h1362, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1377:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1363 --->  Ty_heap  
 var_h1362 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1331 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1378 --->  Ty_heap  
 var__temp_v1379 --->  Ty_int  
 var__temp_h'1380 --->  Ty_heap  
 var__temp_v_err1381 --->  error  
 var_h1362 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1330, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1378, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1378, other ) ==(sel)( , var_h1362, other ) => 
 	 Rel (sel)( , var__temp_h1378, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1378, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1380, res ) ==(var__temp_v1379) AND 
 	 Rel (sel)( , var__temp_h'1380, res ) ==((sel)( , var__temp_h1378, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1380, other ) ==(sel)( , var__temp_h1378, other ) => 
 	 True
 
VC_END(declare-const var_h_i1363 T4947)
(declare-const var_h1362 T4947)
(declare-const v Int)
(declare-const var_h_i1331 T4947)
(declare-const var_h1330 T4947)
(declare-const v Int)
(declare-const var_h_i1295 T4947)
(declare-const var_h1294 T4947)
(declare-const v Int)
(declare-const var_h_i44 T4947)
(declare-const var_h43 T4947)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1378 T4947)
(declare-const var__temp_v1379 Int)
(declare-const |var__temp_h'1380| T4947)
(declare-const var__temp_v_err1381 T4948)
(declare-const var_h1362 T4947)
(declare-const var_h1330 T4947)
(declare-const var_h1294 T4947)
(declare-const var_h43 T4947)
(declare-const err T4961)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4947)
(declare-fun sel (T4947 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1330 () T4947)
(declare-fun var_h43 () T4947)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1378 () T4947)
(declare-fun |var__temp_h'1380| () T4947)
(declare-fun var__temp_v1379 () Int)
(declare-fun var_h1362 () T4947)
(declare-fun v () Int)
(assert (> (sel var_h1330 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1378 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1378 other) (sel var_h1362 other)))
               (= (sel var__temp_h1378 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1380| res) var__temp_v1379)
                (= (sel |var__temp_h'1380| res) (+ (sel var__temp_h1378 res) 3))
                (= (sel |var__temp_h'1380| other) (sel var__temp_h1378 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1378 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************375
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1363 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1363, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1363, other ) ==(sel)( , var_h1362, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1377:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1363 --->  Ty_heap  
 var_h1362 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1331 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1382 --->  Ty_heap  
 var__temp_v1383 --->  Ty_int  
 var__temp_h'1384 --->  Ty_heap  
 var__temp_v_err1385 --->  error  
 var_h1362 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1330, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1382, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1382, other ) ==(sel)( , var_h1362, other ) => 
 	 Rel (sel)( , var__temp_h1382, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1382, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1384, res ) ==(var__temp_v1383) AND 
 	 Rel (sel)( , var__temp_h'1384, res ) ==((sel)( , var__temp_h1382, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1384, other ) ==(sel)( , var__temp_h1382, other ) => 
 	 True
 
VC_END(declare-const var_h_i1363 T4964)
(declare-const var_h1362 T4964)
(declare-const v Int)
(declare-const var_h_i1331 T4964)
(declare-const var_h1330 T4964)
(declare-const v Int)
(declare-const var_h_i1295 T4964)
(declare-const var_h1294 T4964)
(declare-const v Int)
(declare-const var_h_i44 T4964)
(declare-const var_h43 T4964)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1382 T4964)
(declare-const var__temp_v1383 Int)
(declare-const |var__temp_h'1384| T4964)
(declare-const var__temp_v_err1385 T4965)
(declare-const var_h1362 T4964)
(declare-const var_h1330 T4964)
(declare-const var_h1294 T4964)
(declare-const var_h43 T4964)
(declare-const err T4978)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4964)
(declare-fun sel (T4964 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1330 () T4964)
(declare-fun var_h43 () T4964)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1382 () T4964)
(declare-fun |var__temp_h'1384| () T4964)
(declare-fun var__temp_v1383 () Int)
(declare-fun var_h1362 () T4964)
(declare-fun v () Int)
(assert (> (sel var_h1330 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1382 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1382 other) (sel var_h1362 other)))
               (= (sel var__temp_h1382 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1384| res) var__temp_v1383)
                (= (sel |var__temp_h'1384| res) (+ (sel var__temp_h1382 res) 5))
                (= (sel |var__temp_h'1384| other) (sel var__temp_h1382 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1382 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************376
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1363 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1363, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1363, other ) ==(sel)( , var_h1362, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1377:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1363 --->  Ty_heap  
 var_h1362 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1331 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1386 --->  Ty_heap  
 var__temp_v1387 --->  Ty_int  
 var__temp_h'1388 --->  Ty_heap  
 var__temp_v_err1389 --->  error  
 var_h1362 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1330, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1386, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1386, other ) ==(sel)( , var_h1362, other ) => 
 	 Rel (sel)( , var__temp_h1386, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1386, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1388, res ) ==(var__temp_v1387) AND 
 	 Rel (sel)( , var__temp_h'1388, res ) ==((sel)( , var__temp_h1386, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1388, other ) ==(sel)( , var__temp_h1386, other ) => 
 	 True
 
VC_END(declare-const var_h_i1363 T4981)
(declare-const var_h1362 T4981)
(declare-const v Int)
(declare-const var_h_i1331 T4981)
(declare-const var_h1330 T4981)
(declare-const v Int)
(declare-const var_h_i1295 T4981)
(declare-const var_h1294 T4981)
(declare-const v Int)
(declare-const var_h_i44 T4981)
(declare-const var_h43 T4981)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1386 T4981)
(declare-const var__temp_v1387 Int)
(declare-const |var__temp_h'1388| T4981)
(declare-const var__temp_v_err1389 T4982)
(declare-const var_h1362 T4981)
(declare-const var_h1330 T4981)
(declare-const var_h1294 T4981)
(declare-const var_h43 T4981)
(declare-const err T4995)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4981)
(declare-fun sel (T4981 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1330 () T4981)
(declare-fun var_h43 () T4981)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1386 () T4981)
(declare-fun |var__temp_h'1388| () T4981)
(declare-fun var__temp_v1387 () Int)
(declare-fun var_h1362 () T4981)
(declare-fun v () Int)
(assert (> (sel var_h1330 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1386 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1386 other) (sel var_h1362 other)))
               (= (sel var__temp_h1386 res) 5)))
      (a!2 (and (= (sel |var__temp_h'1388| res) var__temp_v1387)
                (= (sel |var__temp_h'1388| res) (+ (sel var__temp_h1386 res) 2))
                (= (sel |var__temp_h'1388| other) (sel var__temp_h1386 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1386 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************bar
PARTIAL PATH NEW
SUB 
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1391 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1391 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1391, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1391, res ) ==((sel)( , var_h1390, res ) + (2))
 	 , (sel)( , var_h_i1391, other ) ==(sel)( , var_h1390, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1392:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1391 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************377
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1391 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1391, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1391, res ) ==((sel)( , var_h1390, res ) + (2))
 	 , (sel)( , var_h_i1391, other ) ==(sel)( , var_h1390, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1392:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1391 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1391 --->  Ty_heap  
 var_h1390 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1363 --->  Ty_heap  
 var_h1362 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1331 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1393 --->  Ty_heap  
 var__temp_v1394 --->  Ty_int  
 var__temp_h'1395 --->  Ty_heap  
 var__temp_v_err1396 --->  error  
 var_h1390 --->  Ty_heap  
 var_h1362 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1390, res ) ==(5) AND 
 	 Rel (sel)( , var_h1330, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1393, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1393, res ) ==((sel)( , var_h1390, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h1393, other ) ==(sel)( , var_h1390, other ) => 
 	 Rel (sel)( , var__temp_h1393, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1393, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1395, res ) ==(var__temp_v1394) AND 
 	 Rel (sel)( , var__temp_h'1395, res ) ==((sel)( , var__temp_h1393, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1395, other ) ==(sel)( , var__temp_h1393, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1395, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1395, other ) > (4)
 
VC_END(declare-const var_h_i1391 T4998)
(declare-const var_h1390 T4998)
(declare-const v Int)
(declare-const var_h_i1363 T4998)
(declare-const var_h1362 T4998)
(declare-const v Int)
(declare-const var_h_i1331 T4998)
(declare-const var_h1330 T4998)
(declare-const v Int)
(declare-const var_h_i1295 T4998)
(declare-const var_h1294 T4998)
(declare-const v Int)
(declare-const var_h_i44 T4998)
(declare-const var_h43 T4998)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1393 T4998)
(declare-const var__temp_v1394 Int)
(declare-const |var__temp_h'1395| T4998)
(declare-const var__temp_v_err1396 T4999)
(declare-const var_h1390 T4998)
(declare-const var_h1362 T4998)
(declare-const var_h1330 T4998)
(declare-const var_h1294 T4998)
(declare-const var_h43 T4998)
(declare-const err T5012)

solver 
 (declare-sort T4998)
(declare-fun sel (T4998 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1390 () T4998)
(declare-fun var_h1330 () T4998)
(declare-fun var_h43 () T4998)
(declare-fun other () Int)
(declare-fun |var__temp_h'1395| () T4998)
(declare-fun var__temp_h1393 () T4998)
(declare-fun var__temp_v1394 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1390 res) 5))
(assert (> (sel var_h1330 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1393 res) v)
                (= (sel var__temp_h1393 res) (+ (sel var_h1390 res) 2))
                (= (sel var__temp_h1393 other) (sel var_h1390 other))))
      (a!2 (and (= (sel |var__temp_h'1395| res) var__temp_v1394)
                (= (sel |var__temp_h'1395| res) (+ (sel var__temp_h1393 res) 3))
                (= (sel |var__temp_h'1395| other) (sel var__temp_h1393 other))))
      (a!3 (and (= (sel |var__temp_h'1395| res) 10)
                (not (> (sel |var__temp_h'1395| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1393 res) 7))
                (=> (= (sel var__temp_h1393 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************378
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1391 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1391, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1391, res ) ==((sel)( , var_h1390, res ) + (2))
 	 , (sel)( , var_h_i1391, other ) ==(sel)( , var_h1390, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1392:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1391 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1391 --->  Ty_heap  
 var_h1390 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1363 --->  Ty_heap  
 var_h1362 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1331 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1397 --->  Ty_heap  
 var__temp_v1398 --->  Ty_int  
 var__temp_h'1399 --->  Ty_heap  
 var__temp_v_err1400 --->  error  
 var_h1390 --->  Ty_heap  
 var_h1362 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1390, res ) ==(5) AND 
 	 Rel (sel)( , var_h1330, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1397, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1397, res ) ==((sel)( , var_h1390, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h1397, other ) ==(sel)( , var_h1390, other ) => 
 	 Rel (sel)( , var__temp_h1397, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1397, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1399, res ) ==(var__temp_v1398) AND 
 	 Rel (sel)( , var__temp_h'1399, res ) ==((sel)( , var__temp_h1397, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1399, other ) ==(sel)( , var__temp_h1397, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1399, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1399, other ) > (4)
 
VC_END(declare-const var_h_i1391 T5015)
(declare-const var_h1390 T5015)
(declare-const v Int)
(declare-const var_h_i1363 T5015)
(declare-const var_h1362 T5015)
(declare-const v Int)
(declare-const var_h_i1331 T5015)
(declare-const var_h1330 T5015)
(declare-const v Int)
(declare-const var_h_i1295 T5015)
(declare-const var_h1294 T5015)
(declare-const v Int)
(declare-const var_h_i44 T5015)
(declare-const var_h43 T5015)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1397 T5015)
(declare-const var__temp_v1398 Int)
(declare-const |var__temp_h'1399| T5015)
(declare-const var__temp_v_err1400 T5016)
(declare-const var_h1390 T5015)
(declare-const var_h1362 T5015)
(declare-const var_h1330 T5015)
(declare-const var_h1294 T5015)
(declare-const var_h43 T5015)
(declare-const err T5029)

solver 
 (declare-sort T5015)
(declare-fun sel (T5015 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1390 () T5015)
(declare-fun var_h1330 () T5015)
(declare-fun var_h43 () T5015)
(declare-fun other () Int)
(declare-fun |var__temp_h'1399| () T5015)
(declare-fun var__temp_h1397 () T5015)
(declare-fun var__temp_v1398 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1390 res) 5))
(assert (> (sel var_h1330 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1397 res) v)
                (= (sel var__temp_h1397 res) (+ (sel var_h1390 res) 2))
                (= (sel var__temp_h1397 other) (sel var_h1390 other))))
      (a!2 (and (= (sel |var__temp_h'1399| res) var__temp_v1398)
                (= (sel |var__temp_h'1399| res) (+ (sel var__temp_h1397 res) 5))
                (= (sel |var__temp_h'1399| other) (sel var__temp_h1397 other))))
      (a!3 (and (= (sel |var__temp_h'1399| res) 10)
                (not (> (sel |var__temp_h'1399| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1397 res) 7))
                (=> (= (sel var__temp_h1397 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************379
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1392:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1392:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbarfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1391 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1391, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1391, res ) ==((sel)( , var_h1390, res ) + (2))
 	 , (sel)( , var_h_i1391, other ) ==(sel)( , var_h1390, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1401:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************380
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1391 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1391, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1391, res ) ==((sel)( , var_h1390, res ) + (2))
 	 , (sel)( , var_h_i1391, other ) ==(sel)( , var_h1390, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1401:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1391 --->  Ty_heap  
 var_h1390 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1363 --->  Ty_heap  
 var_h1362 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1331 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1402 --->  Ty_heap  
 var__temp_v1403 --->  Ty_int  
 var__temp_h'1404 --->  Ty_heap  
 var__temp_v_err1405 --->  error  
 var_h1390 --->  Ty_heap  
 var_h1362 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1390, res ) ==(5) AND 
 	 Rel (sel)( , var_h1330, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1402, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1402, res ) ==((sel)( , var_h1390, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h1402, other ) ==(sel)( , var_h1390, other ) => 
 	 Rel (sel)( , var__temp_h1402, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1402, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1404, res ) ==(var__temp_v1403) AND 
 	 Rel (sel)( , var__temp_h'1404, res ) ==((sel)( , var__temp_h1402, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1404, other ) ==(sel)( , var__temp_h1402, other ) => 
 	 True
 
VC_END(declare-const var_h_i1391 T5032)
(declare-const var_h1390 T5032)
(declare-const v Int)
(declare-const var_h_i1363 T5032)
(declare-const var_h1362 T5032)
(declare-const v Int)
(declare-const var_h_i1331 T5032)
(declare-const var_h1330 T5032)
(declare-const v Int)
(declare-const var_h_i1295 T5032)
(declare-const var_h1294 T5032)
(declare-const v Int)
(declare-const var_h_i44 T5032)
(declare-const var_h43 T5032)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1402 T5032)
(declare-const var__temp_v1403 Int)
(declare-const |var__temp_h'1404| T5032)
(declare-const var__temp_v_err1405 T5033)
(declare-const var_h1390 T5032)
(declare-const var_h1362 T5032)
(declare-const var_h1330 T5032)
(declare-const var_h1294 T5032)
(declare-const var_h43 T5032)
(declare-const err T5046)

solver 
 (declare-sort T5032)
(declare-fun sel (T5032 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1390 () T5032)
(declare-fun var_h1330 () T5032)
(declare-fun var_h43 () T5032)
(declare-fun other () Int)
(declare-fun var__temp_h1402 () T5032)
(declare-fun |var__temp_h'1404| () T5032)
(declare-fun var__temp_v1403 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1390 res) 5))
(assert (> (sel var_h1330 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1402 res) v)
                (= (sel var__temp_h1402 res) (+ (sel var_h1390 res) 2))
                (= (sel var__temp_h1402 other) (sel var_h1390 other))))
      (a!2 (and (= (sel |var__temp_h'1404| res) var__temp_v1403)
                (= (sel |var__temp_h'1404| res) (+ (sel var__temp_h1402 res) 3))
                (= (sel |var__temp_h'1404| other) (sel var__temp_h1402 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1402 res) 7))
                (=> (= (sel var__temp_h1402 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************baz
PARTIAL PATH NEW
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1407 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1407 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1407, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1407, res ) ==((sel)( , var_h1406, res ) + (3))
 	 , (sel)( , var_h_i1407, other ) ==(sel)( , var_h1406, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1408:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1407 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************381
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1407 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1407, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1407, res ) ==((sel)( , var_h1406, res ) + (3))
 	 , (sel)( , var_h_i1407, other ) ==(sel)( , var_h1406, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1408:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1407 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1407 --->  Ty_heap  
 var_h1406 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1391 --->  Ty_heap  
 var_h1390 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1363 --->  Ty_heap  
 var_h1362 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1331 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1409 --->  Ty_heap  
 var__temp_v1410 --->  Ty_int  
 var__temp_h'1411 --->  Ty_heap  
 var__temp_v_err1412 --->  error  
 var_h1406 --->  Ty_heap  
 var_h1390 --->  Ty_heap  
 var_h1362 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1406, res ) ==(7) AND 
 	 Rel (sel)( , var_h1390, res ) ==(5) AND 
 	 Rel (sel)( , var_h1330, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1409, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1409, res ) ==((sel)( , var_h1406, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h1409, other ) ==(sel)( , var_h1406, other ) => 
 	 Rel (sel)( , var__temp_h1409, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1409, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1411, res ) ==(var__temp_v1410) AND 
 	 Rel (sel)( , var__temp_h'1411, res ) ==((sel)( , var__temp_h1409, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1411, other ) ==(sel)( , var__temp_h1409, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1411, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1411, other ) > (4)
 
VC_END(declare-const var_h_i1407 T5049)
(declare-const var_h1406 T5049)
(declare-const v Int)
(declare-const var_h_i1391 T5049)
(declare-const var_h1390 T5049)
(declare-const v Int)
(declare-const var_h_i1363 T5049)
(declare-const var_h1362 T5049)
(declare-const v Int)
(declare-const var_h_i1331 T5049)
(declare-const var_h1330 T5049)
(declare-const v Int)
(declare-const var_h_i1295 T5049)
(declare-const var_h1294 T5049)
(declare-const v Int)
(declare-const var_h_i44 T5049)
(declare-const var_h43 T5049)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1409 T5049)
(declare-const var__temp_v1410 Int)
(declare-const |var__temp_h'1411| T5049)
(declare-const var__temp_v_err1412 T5050)
(declare-const var_h1406 T5049)
(declare-const var_h1390 T5049)
(declare-const var_h1362 T5049)
(declare-const var_h1330 T5049)
(declare-const var_h1294 T5049)
(declare-const var_h43 T5049)
(declare-const err T5063)

solver 
 (declare-sort T5049)
(declare-fun sel (T5049 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1406 () T5049)
(declare-fun var_h1390 () T5049)
(declare-fun var_h1330 () T5049)
(declare-fun var_h43 () T5049)
(declare-fun other () Int)
(declare-fun |var__temp_h'1411| () T5049)
(declare-fun var__temp_h1409 () T5049)
(declare-fun var__temp_v1410 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1406 res) 7))
(assert (= (sel var_h1390 res) 5))
(assert (> (sel var_h1330 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1409 res) v)
                (= (sel var__temp_h1409 res) (+ (sel var_h1406 res) 3))
                (= (sel var__temp_h1409 other) (sel var_h1406 other))))
      (a!2 (and (= (sel |var__temp_h'1411| res) var__temp_v1410)
                (= (sel |var__temp_h'1411| res) (+ (sel var__temp_h1409 res) 5))
                (= (sel |var__temp_h'1411| other) (sel var__temp_h1409 other))))
      (a!3 (and (= (sel |var__temp_h'1411| res) 10)
                (not (> (sel |var__temp_h'1411| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1409 res) 7))
                (=> (= (sel var__temp_h1409 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************382
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1408:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1408:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbazbarfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1407 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1407, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1407, res ) ==((sel)( , var_h1406, res ) + (3))
 	 , (sel)( , var_h_i1407, other ) ==(sel)( , var_h1406, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1413:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************383
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1407 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1407, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1407, res ) ==((sel)( , var_h1406, res ) + (3))
 	 , (sel)( , var_h_i1407, other ) ==(sel)( , var_h1406, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1413:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1407 --->  Ty_heap  
 var_h1406 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1391 --->  Ty_heap  
 var_h1390 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1363 --->  Ty_heap  
 var_h1362 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1331 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1414 --->  Ty_heap  
 var__temp_v1415 --->  Ty_int  
 var__temp_h'1416 --->  Ty_heap  
 var__temp_v_err1417 --->  error  
 var_h1406 --->  Ty_heap  
 var_h1390 --->  Ty_heap  
 var_h1362 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1406, res ) ==(7) AND 
 	 Rel (sel)( , var_h1390, res ) ==(5) AND 
 	 Rel (sel)( , var_h1330, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1414, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1414, res ) ==((sel)( , var_h1406, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h1414, other ) ==(sel)( , var_h1406, other ) => 
 	 Rel (sel)( , var__temp_h1414, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1414, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1416, res ) ==(var__temp_v1415) AND 
 	 Rel (sel)( , var__temp_h'1416, res ) ==((sel)( , var__temp_h1414, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1416, other ) ==(sel)( , var__temp_h1414, other ) => 
 	 True
 
VC_END(declare-const var_h_i1407 T5066)
(declare-const var_h1406 T5066)
(declare-const v Int)
(declare-const var_h_i1391 T5066)
(declare-const var_h1390 T5066)
(declare-const v Int)
(declare-const var_h_i1363 T5066)
(declare-const var_h1362 T5066)
(declare-const v Int)
(declare-const var_h_i1331 T5066)
(declare-const var_h1330 T5066)
(declare-const v Int)
(declare-const var_h_i1295 T5066)
(declare-const var_h1294 T5066)
(declare-const v Int)
(declare-const var_h_i44 T5066)
(declare-const var_h43 T5066)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1414 T5066)
(declare-const var__temp_v1415 Int)
(declare-const |var__temp_h'1416| T5066)
(declare-const var__temp_v_err1417 T5067)
(declare-const var_h1406 T5066)
(declare-const var_h1390 T5066)
(declare-const var_h1362 T5066)
(declare-const var_h1330 T5066)
(declare-const var_h1294 T5066)
(declare-const var_h43 T5066)
(declare-const err T5080)

solver 
 (declare-sort T5066)
(declare-fun sel (T5066 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1406 () T5066)
(declare-fun var_h1390 () T5066)
(declare-fun var_h1330 () T5066)
(declare-fun var_h43 () T5066)
(declare-fun other () Int)
(declare-fun var__temp_h1414 () T5066)
(declare-fun |var__temp_h'1416| () T5066)
(declare-fun var__temp_v1415 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1406 res) 7))
(assert (= (sel var_h1390 res) 5))
(assert (> (sel var_h1330 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1414 res) v)
                (= (sel var__temp_h1414 res) (+ (sel var_h1406 res) 3))
                (= (sel var__temp_h1414 other) (sel var_h1406 other))))
      (a!2 (and (= (sel |var__temp_h'1416| res) var__temp_v1415)
                (= (sel |var__temp_h'1416| res) (+ (sel var__temp_h1414 res) 5))
                (= (sel |var__temp_h'1416| other) (sel var__temp_h1414 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1414 res) 7))
                (=> (= (sel var__temp_h1414 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************384
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT baz
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1391 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1391, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1391, res ) ==((sel)( , var_h1390, res ) + (2))
 	 , (sel)( , var_h_i1391, other ) ==(sel)( , var_h1390, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1418:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************385
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1391 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1391, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1391, res ) ==((sel)( , var_h1390, res ) + (2))
 	 , (sel)( , var_h_i1391, other ) ==(sel)( , var_h1390, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1418:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1391 --->  Ty_heap  
 var_h1390 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1363 --->  Ty_heap  
 var_h1362 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1331 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1419 --->  Ty_heap  
 var__temp_v1420 --->  Ty_int  
 var__temp_h'1421 --->  Ty_heap  
 var__temp_v_err1422 --->  error  
 var_h1390 --->  Ty_heap  
 var_h1362 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1390, res ) ==(5) AND 
 	 Rel (sel)( , var_h1330, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1419, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1419, res ) ==((sel)( , var_h1390, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h1419, other ) ==(sel)( , var_h1390, other ) => 
 	 Rel (sel)( , var__temp_h1419, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1419, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1421, res ) ==(var__temp_v1420) AND 
 	 Rel (sel)( , var__temp_h'1421, res ) ==((sel)( , var__temp_h1419, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1421, other ) ==(sel)( , var__temp_h1419, other ) => 
 	 True
 
VC_END(declare-const var_h_i1391 T5083)
(declare-const var_h1390 T5083)
(declare-const v Int)
(declare-const var_h_i1363 T5083)
(declare-const var_h1362 T5083)
(declare-const v Int)
(declare-const var_h_i1331 T5083)
(declare-const var_h1330 T5083)
(declare-const v Int)
(declare-const var_h_i1295 T5083)
(declare-const var_h1294 T5083)
(declare-const v Int)
(declare-const var_h_i44 T5083)
(declare-const var_h43 T5083)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1419 T5083)
(declare-const var__temp_v1420 Int)
(declare-const |var__temp_h'1421| T5083)
(declare-const var__temp_v_err1422 T5084)
(declare-const var_h1390 T5083)
(declare-const var_h1362 T5083)
(declare-const var_h1330 T5083)
(declare-const var_h1294 T5083)
(declare-const var_h43 T5083)
(declare-const err T5097)

solver 
 (declare-sort T5083)
(declare-fun sel (T5083 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1390 () T5083)
(declare-fun var_h1330 () T5083)
(declare-fun var_h43 () T5083)
(declare-fun other () Int)
(declare-fun var__temp_h1419 () T5083)
(declare-fun |var__temp_h'1421| () T5083)
(declare-fun var__temp_v1420 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1390 res) 5))
(assert (> (sel var_h1330 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1419 res) v)
                (= (sel var__temp_h1419 res) (+ (sel var_h1390 res) 2))
                (= (sel var__temp_h1419 other) (sel var_h1390 other))))
      (a!2 (and (= (sel |var__temp_h'1421| res) var__temp_v1420)
                (= (sel |var__temp_h'1421| res) (+ (sel var__temp_h1419 res) 5))
                (= (sel |var__temp_h'1421| other) (sel var__temp_h1419 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1419 res) 7))
                (=> (= (sel var__temp_h1419 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c5
PARTIAL PATH NEW
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1424 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1424 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1424, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1424, res ) ==((sel)( , var_h1423, res ) + (5))
 	 , (sel)( , var_h_i1424, other ) ==(sel)( , var_h1423, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1425:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1424 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************386
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1425:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1425:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc5bazbarfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1424 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1424, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1424, res ) ==((sel)( , var_h1423, res ) + (5))
 	 , (sel)( , var_h_i1424, other ) ==(sel)( , var_h1423, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1426:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************387
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1391 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1391, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1391, res ) ==((sel)( , var_h1390, res ) + (2))
 	 , (sel)( , var_h_i1391, other ) ==(sel)( , var_h1390, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1427:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************388
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --foo
 	 --c2
 	 --foo'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1363 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1363, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1363, other ) ==(sel)( , var_h1362, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1428:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************389
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1363 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1363, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1363, other ) ==(sel)( , var_h1362, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1428:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1363 --->  Ty_heap  
 var_h1362 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1331 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1429 --->  Ty_heap  
 var__temp_v1430 --->  Ty_int  
 var__temp_h'1431 --->  Ty_heap  
 var__temp_v_err1432 --->  error  
 var_h1362 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1330, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1429, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1429, other ) ==(sel)( , var_h1362, other ) => 
 	 Rel (sel)( , var__temp_h1429, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1429, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1431, res ) ==(var__temp_v1430) AND 
 	 Rel (sel)( , var__temp_h'1431, res ) ==((sel)( , var__temp_h1429, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1431, other ) ==(sel)( , var__temp_h1429, other ) => 
 	 True
 
VC_END(declare-const var_h_i1363 T5100)
(declare-const var_h1362 T5100)
(declare-const v Int)
(declare-const var_h_i1331 T5100)
(declare-const var_h1330 T5100)
(declare-const v Int)
(declare-const var_h_i1295 T5100)
(declare-const var_h1294 T5100)
(declare-const v Int)
(declare-const var_h_i44 T5100)
(declare-const var_h43 T5100)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1429 T5100)
(declare-const var__temp_v1430 Int)
(declare-const |var__temp_h'1431| T5100)
(declare-const var__temp_v_err1432 T5101)
(declare-const var_h1362 T5100)
(declare-const var_h1330 T5100)
(declare-const var_h1294 T5100)
(declare-const var_h43 T5100)
(declare-const err T5114)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5100)
(declare-fun sel (T5100 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1330 () T5100)
(declare-fun var_h43 () T5100)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1429 () T5100)
(declare-fun |var__temp_h'1431| () T5100)
(declare-fun var__temp_v1430 () Int)
(declare-fun var_h1362 () T5100)
(declare-fun v () Int)
(assert (> (sel var_h1330 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1429 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1429 other) (sel var_h1362 other)))
               (= (sel var__temp_h1429 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1431| res) var__temp_v1430)
                (= (sel |var__temp_h'1431| res) (+ (sel var__temp_h1429 res) 3))
                (= (sel |var__temp_h'1431| other) (sel var__temp_h1429 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1429 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************390
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1363 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1363, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1363, other ) ==(sel)( , var_h1362, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1428:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1363 --->  Ty_heap  
 var_h1362 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1331 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1433 --->  Ty_heap  
 var__temp_v1434 --->  Ty_int  
 var__temp_h'1435 --->  Ty_heap  
 var__temp_v_err1436 --->  error  
 var_h1362 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1330, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1433, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1433, other ) ==(sel)( , var_h1362, other ) => 
 	 Rel (sel)( , var__temp_h1433, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1433, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1435, res ) ==(var__temp_v1434) AND 
 	 Rel (sel)( , var__temp_h'1435, res ) ==((sel)( , var__temp_h1433, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1435, other ) ==(sel)( , var__temp_h1433, other ) => 
 	 True
 
VC_END(declare-const var_h_i1363 T5117)
(declare-const var_h1362 T5117)
(declare-const v Int)
(declare-const var_h_i1331 T5117)
(declare-const var_h1330 T5117)
(declare-const v Int)
(declare-const var_h_i1295 T5117)
(declare-const var_h1294 T5117)
(declare-const v Int)
(declare-const var_h_i44 T5117)
(declare-const var_h43 T5117)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1433 T5117)
(declare-const var__temp_v1434 Int)
(declare-const |var__temp_h'1435| T5117)
(declare-const var__temp_v_err1436 T5118)
(declare-const var_h1362 T5117)
(declare-const var_h1330 T5117)
(declare-const var_h1294 T5117)
(declare-const var_h43 T5117)
(declare-const err T5131)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5117)
(declare-fun sel (T5117 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1330 () T5117)
(declare-fun var_h43 () T5117)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1433 () T5117)
(declare-fun |var__temp_h'1435| () T5117)
(declare-fun var__temp_v1434 () Int)
(declare-fun var_h1362 () T5117)
(declare-fun v () Int)
(assert (> (sel var_h1330 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1433 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1433 other) (sel var_h1362 other)))
               (= (sel var__temp_h1433 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1435| res) var__temp_v1434)
                (= (sel |var__temp_h'1435| res) (+ (sel var__temp_h1433 res) 5))
                (= (sel |var__temp_h'1435| other) (sel var__temp_h1433 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1433 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************391
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT bar
PARTIAL PATH
SUB 
 	 --c2
 	 --foo'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1331, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1331, res ) ==((sel)( , var_h1330, res ) + (10))
 	 , (sel)( , var_h_i1331, other ) ==(sel)( , var_h1330, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1437:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************392
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1331, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1331, res ) ==((sel)( , var_h1330, res ) + (10))
 	 , (sel)( , var_h_i1331, other ) ==(sel)( , var_h1330, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1437:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1331 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1438 --->  Ty_heap  
 var__temp_v1439 --->  Ty_int  
 var__temp_h'1440 --->  Ty_heap  
 var__temp_v_err1441 --->  error  
 var_h1330 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1330, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1438, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1438, res ) ==((sel)( , var_h1330, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1438, other ) ==(sel)( , var_h1330, other ) => 
 	 Rel (sel)( , var__temp_h1438, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1438, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1440, res ) ==(var__temp_v1439) AND 
 	 Rel (sel)( , var__temp_h'1440, res ) ==((sel)( , var__temp_h1438, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1440, other ) ==(sel)( , var__temp_h1438, other ) => 
 	 True
 
VC_END(declare-const var_h_i1331 T5134)
(declare-const var_h1330 T5134)
(declare-const v Int)
(declare-const var_h_i1295 T5134)
(declare-const var_h1294 T5134)
(declare-const v Int)
(declare-const var_h_i44 T5134)
(declare-const var_h43 T5134)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1438 T5134)
(declare-const var__temp_v1439 Int)
(declare-const |var__temp_h'1440| T5134)
(declare-const var__temp_v_err1441 T5135)
(declare-const var_h1330 T5134)
(declare-const var_h1294 T5134)
(declare-const var_h43 T5134)
(declare-const err T5148)

solver 
 (declare-sort T5134)
(declare-fun sel (T5134 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1330 () T5134)
(declare-fun var_h43 () T5134)
(declare-fun other () Int)
(declare-fun var__temp_h1438 () T5134)
(declare-fun |var__temp_h'1440| () T5134)
(declare-fun var__temp_v1439 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1330 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1438 res) v)
                (= (sel var__temp_h1438 res) (+ (sel var_h1330 res) 10))
                (= (sel var__temp_h1438 other) (sel var_h1330 other))))
      (a!2 (and (= (sel |var__temp_h'1440| res) var__temp_v1439)
                (= (sel |var__temp_h'1440| res) (+ (sel var__temp_h1438 res) 3))
                (= (sel |var__temp_h'1440| other) (sel var__temp_h1438 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1438 res) 7))
                (=> (= (sel var__temp_h1438 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************393
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1331, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1331, res ) ==((sel)( , var_h1330, res ) + (10))
 	 , (sel)( , var_h_i1331, other ) ==(sel)( , var_h1330, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1437:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1331 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1442 --->  Ty_heap  
 var__temp_v1443 --->  Ty_int  
 var__temp_h'1444 --->  Ty_heap  
 var__temp_v_err1445 --->  error  
 var_h1330 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1330, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1442, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1442, res ) ==((sel)( , var_h1330, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1442, other ) ==(sel)( , var_h1330, other ) => 
 	 Rel (sel)( , var__temp_h1442, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1442, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1444, res ) ==(var__temp_v1443) AND 
 	 Rel (sel)( , var__temp_h'1444, res ) ==((sel)( , var__temp_h1442, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1444, other ) ==(sel)( , var__temp_h1442, other ) => 
 	 True
 
VC_END(declare-const var_h_i1331 T5151)
(declare-const var_h1330 T5151)
(declare-const v Int)
(declare-const var_h_i1295 T5151)
(declare-const var_h1294 T5151)
(declare-const v Int)
(declare-const var_h_i44 T5151)
(declare-const var_h43 T5151)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1442 T5151)
(declare-const var__temp_v1443 Int)
(declare-const |var__temp_h'1444| T5151)
(declare-const var__temp_v_err1445 T5152)
(declare-const var_h1330 T5151)
(declare-const var_h1294 T5151)
(declare-const var_h43 T5151)
(declare-const err T5165)

solver 
 (declare-sort T5151)
(declare-fun sel (T5151 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1330 () T5151)
(declare-fun var_h43 () T5151)
(declare-fun other () Int)
(declare-fun var__temp_h1442 () T5151)
(declare-fun |var__temp_h'1444| () T5151)
(declare-fun var__temp_v1443 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1330 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1442 res) v)
                (= (sel var__temp_h1442 res) (+ (sel var_h1330 res) 10))
                (= (sel var__temp_h1442 other) (sel var_h1330 other))))
      (a!2 (and (= (sel |var__temp_h'1444| res) var__temp_v1443)
                (= (sel |var__temp_h'1444| res) (+ (sel var__temp_h1442 res) 5))
                (= (sel |var__temp_h'1444| other) (sel var__temp_h1442 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1442 res) 7))
                (=> (= (sel var__temp_h1442 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************394
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1331, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1331, res ) ==((sel)( , var_h1330, res ) + (10))
 	 , (sel)( , var_h_i1331, other ) ==(sel)( , var_h1330, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1437:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1331 --->  Ty_heap  
 var_h1330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1446 --->  Ty_heap  
 var__temp_v1447 --->  Ty_int  
 var__temp_h'1448 --->  Ty_heap  
 var__temp_v_err1449 --->  error  
 var_h1330 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1330, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1446, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1446, res ) ==((sel)( , var_h1330, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1446, other ) ==(sel)( , var_h1330, other ) => 
 	 Rel (sel)( , var__temp_h1446, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1446, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1448, res ) ==(var__temp_v1447) AND 
 	 Rel (sel)( , var__temp_h'1448, res ) ==((sel)( , var__temp_h1446, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1448, other ) ==(sel)( , var__temp_h1446, other ) => 
 	 True
 
VC_END(declare-const var_h_i1331 T5168)
(declare-const var_h1330 T5168)
(declare-const v Int)
(declare-const var_h_i1295 T5168)
(declare-const var_h1294 T5168)
(declare-const v Int)
(declare-const var_h_i44 T5168)
(declare-const var_h43 T5168)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1446 T5168)
(declare-const var__temp_v1447 Int)
(declare-const |var__temp_h'1448| T5168)
(declare-const var__temp_v_err1449 T5169)
(declare-const var_h1330 T5168)
(declare-const var_h1294 T5168)
(declare-const var_h43 T5168)
(declare-const err T5182)

solver 
 (declare-sort T5168)
(declare-fun sel (T5168 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1330 () T5168)
(declare-fun var_h43 () T5168)
(declare-fun other () Int)
(declare-fun var__temp_h1446 () T5168)
(declare-fun |var__temp_h'1448| () T5168)
(declare-fun var__temp_v1447 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1330 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1446 res) v)
                (= (sel var__temp_h1446 res) (+ (sel var_h1330 res) 10))
                (= (sel var__temp_h1446 other) (sel var_h1330 other))))
      (a!2 (and (= (sel |var__temp_h'1448| res) var__temp_v1447)
                (= (sel |var__temp_h'1448| res) (+ (sel var__temp_h1446 res) 2))
                (= (sel |var__temp_h'1448| other) (sel var__temp_h1446 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1446 res) 5))
                (=> (= (sel var__temp_h1446 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************395
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo
PARTIAL PATH
SUB 
 	 --foo'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1295 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1295, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1295, other ) ==(sel)( , var_h1294, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1450:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************396
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1295 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1295, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1295, other ) ==(sel)( , var_h1294, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1450:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1451 --->  Ty_heap  
 var__temp_v1452 --->  Ty_int  
 var__temp_h'1453 --->  Ty_heap  
 var__temp_v_err1454 --->  error  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1451, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1451, other ) ==(sel)( , var_h1294, other ) => 
 	 Rel (sel)( , var__temp_h1451, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1451, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1453, res ) ==(var__temp_v1452) AND 
 	 Rel (sel)( , var__temp_h'1453, res ) ==((sel)( , var__temp_h1451, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1453, other ) ==(sel)( , var__temp_h1451, other ) => 
 	 True
 
VC_END(declare-const var_h_i1295 T5185)
(declare-const var_h1294 T5185)
(declare-const v Int)
(declare-const var_h_i44 T5185)
(declare-const var_h43 T5185)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1451 T5185)
(declare-const var__temp_v1452 Int)
(declare-const |var__temp_h'1453| T5185)
(declare-const var__temp_v_err1454 T5186)
(declare-const var_h1294 T5185)
(declare-const var_h43 T5185)
(declare-const err T5199)
    (declare-const |20| Int)
  
solver 
 (declare-sort T5185)
(declare-fun sel (T5185 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5185)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h1451 () T5185)
(declare-fun |var__temp_h'1453| () T5185)
(declare-fun var__temp_v1452 () Int)
(declare-fun var_h1294 () T5185)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1451 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1451 other) (sel var_h1294 other)))
               (= (sel var__temp_h1451 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1453| res) var__temp_v1452)
                (= (sel |var__temp_h'1453| res) (+ (sel var__temp_h1451 res) 3))
                (= (sel |var__temp_h'1453| other) (sel var__temp_h1451 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1451 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************397
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1295 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1295, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1295, other ) ==(sel)( , var_h1294, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1450:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1455 --->  Ty_heap  
 var__temp_v1456 --->  Ty_int  
 var__temp_h'1457 --->  Ty_heap  
 var__temp_v_err1458 --->  error  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1455, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1455, other ) ==(sel)( , var_h1294, other ) => 
 	 Rel (sel)( , var__temp_h1455, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1455, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1457, res ) ==(var__temp_v1456) AND 
 	 Rel (sel)( , var__temp_h'1457, res ) ==((sel)( , var__temp_h1455, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1457, other ) ==(sel)( , var__temp_h1455, other ) => 
 	 True
 
VC_END(declare-const var_h_i1295 T5202)
(declare-const var_h1294 T5202)
(declare-const v Int)
(declare-const var_h_i44 T5202)
(declare-const var_h43 T5202)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1455 T5202)
(declare-const var__temp_v1456 Int)
(declare-const |var__temp_h'1457| T5202)
(declare-const var__temp_v_err1458 T5203)
(declare-const var_h1294 T5202)
(declare-const var_h43 T5202)
(declare-const err T5216)
    (declare-const |20| Int)
  
solver 
 (declare-sort T5202)
(declare-fun sel (T5202 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5202)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h1455 () T5202)
(declare-fun |var__temp_h'1457| () T5202)
(declare-fun var__temp_v1456 () Int)
(declare-fun var_h1294 () T5202)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1455 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1455 other) (sel var_h1294 other)))
               (= (sel var__temp_h1455 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1457| res) var__temp_v1456)
                (= (sel |var__temp_h'1457| res) (+ (sel var__temp_h1455 res) 5))
                (= (sel |var__temp_h'1457| other) (sel var__temp_h1455 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1455 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************398
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1295 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1295, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1295, other ) ==(sel)( , var_h1294, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1450:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1459 --->  Ty_heap  
 var__temp_v1460 --->  Ty_int  
 var__temp_h'1461 --->  Ty_heap  
 var__temp_v_err1462 --->  error  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1459, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1459, other ) ==(sel)( , var_h1294, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1461, res ) ==(var__temp_v1460) AND 
 	 Base var__temp_v1460 = 5 AND 
 	 Rel (sel)( , var__temp_h'1461, other ) ==(sel)( , var__temp_h1459, other ) => 
 	 True
 
VC_END(declare-const var_h_i1295 T5219)
(declare-const var_h1294 T5219)
(declare-const v Int)
(declare-const var_h_i44 T5219)
(declare-const var_h43 T5219)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1459 T5219)
(declare-const var__temp_v1460 Int)
(declare-const |var__temp_h'1461| T5219)
(declare-const var__temp_v_err1462 T5220)
(declare-const var_h1294 T5219)
(declare-const var_h43 T5219)
(declare-const err T5233)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T5219)
(declare-fun sel (T5219 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5219)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1459 () T5219)
(declare-fun |var__temp_h'1461| () T5219)
(declare-fun var__temp_v1460 () Int)
(declare-fun var_h1294 () T5219)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1459 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1459 other) (sel var_h1294 other)))
               true))
      (a!2 (=> (and (= (sel |var__temp_h'1461| res) var__temp_v1460)
                    (= var__temp_v1460 |5|)
                    (= (sel |var__temp_h'1461| other)
                       (sel var__temp_h1459 other)))
               true)))
  (not (and a!1 (=> true a!2)))))

***************Selection Successful************foo
PARTIAL PATH NEW
SUB 
 	 --foo
 	 --foo'
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1464 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1464 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1464, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1464, other ) ==(sel)( , var_h1463, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1465:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1464 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************399
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1464 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1464, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1464, other ) ==(sel)( , var_h1463, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1465:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1464 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1464 --->  Ty_heap  
 var_h1463 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1466 --->  Ty_heap  
 var__temp_v1467 --->  Ty_int  
 var__temp_h'1468 --->  Ty_heap  
 var__temp_v_err1469 --->  error  
 var_h1463 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1466, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1466, other ) ==(sel)( , var_h1463, other ) => 
 	 Rel (sel)( , var__temp_h1466, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1466, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1468, res ) ==(var__temp_v1467) AND 
 	 Rel (sel)( , var__temp_h'1468, res ) ==((sel)( , var__temp_h1466, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1468, other ) ==(sel)( , var__temp_h1466, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1468, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1468, other ) > (4)
 
VC_END(declare-const var_h_i1464 T5236)
(declare-const var_h1463 T5236)
(declare-const v Int)
(declare-const var_h_i1295 T5236)
(declare-const var_h1294 T5236)
(declare-const v Int)
(declare-const var_h_i44 T5236)
(declare-const var_h43 T5236)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1466 T5236)
(declare-const var__temp_v1467 Int)
(declare-const |var__temp_h'1468| T5236)
(declare-const var__temp_v_err1469 T5237)
(declare-const var_h1463 T5236)
(declare-const var_h1294 T5236)
(declare-const var_h43 T5236)
(declare-const err T5250)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5236)
(declare-fun sel (T5236 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5236)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1468| () T5236)
(declare-fun var__temp_h1466 () T5236)
(declare-fun var__temp_v1467 () Int)
(declare-fun var_h1463 () T5236)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1466 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1466 other) (sel var_h1463 other)))
               (= (sel var__temp_h1466 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1468| res) var__temp_v1467)
                (= (sel |var__temp_h'1468| res) (+ (sel var__temp_h1466 res) 3))
                (= (sel |var__temp_h'1468| other) (sel var__temp_h1466 other))))
      (a!3 (and (= (sel |var__temp_h'1468| res) 10)
                (not (> (sel |var__temp_h'1468| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1466 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************400
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1464 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1464, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1464, other ) ==(sel)( , var_h1463, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1465:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1464 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1464 --->  Ty_heap  
 var_h1463 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1470 --->  Ty_heap  
 var__temp_v1471 --->  Ty_int  
 var__temp_h'1472 --->  Ty_heap  
 var__temp_v_err1473 --->  error  
 var_h1463 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1470, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1470, other ) ==(sel)( , var_h1463, other ) => 
 	 Rel (sel)( , var__temp_h1470, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1470, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1472, res ) ==(var__temp_v1471) AND 
 	 Rel (sel)( , var__temp_h'1472, res ) ==((sel)( , var__temp_h1470, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1472, other ) ==(sel)( , var__temp_h1470, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1472, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1472, other ) > (4)
 
VC_END(declare-const var_h_i1464 T5253)
(declare-const var_h1463 T5253)
(declare-const v Int)
(declare-const var_h_i1295 T5253)
(declare-const var_h1294 T5253)
(declare-const v Int)
(declare-const var_h_i44 T5253)
(declare-const var_h43 T5253)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1470 T5253)
(declare-const var__temp_v1471 Int)
(declare-const |var__temp_h'1472| T5253)
(declare-const var__temp_v_err1473 T5254)
(declare-const var_h1463 T5253)
(declare-const var_h1294 T5253)
(declare-const var_h43 T5253)
(declare-const err T5267)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5253)
(declare-fun sel (T5253 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5253)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1472| () T5253)
(declare-fun var__temp_h1470 () T5253)
(declare-fun var__temp_v1471 () Int)
(declare-fun var_h1463 () T5253)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1470 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1470 other) (sel var_h1463 other)))
               (= (sel var__temp_h1470 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1472| res) var__temp_v1471)
                (= (sel |var__temp_h'1472| res) (+ (sel var__temp_h1470 res) 5))
                (= (sel |var__temp_h'1472| other) (sel var__temp_h1470 other))))
      (a!3 (and (= (sel |var__temp_h'1472| res) 10)
                (not (> (sel |var__temp_h'1472| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1470 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************401
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1464 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1464, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1464, other ) ==(sel)( , var_h1463, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1465:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1464 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1464 --->  Ty_heap  
 var_h1463 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1474 --->  Ty_heap  
 var__temp_v1475 --->  Ty_int  
 var__temp_h'1476 --->  Ty_heap  
 var__temp_v_err1477 --->  error  
 var_h1463 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1474, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1474, other ) ==(sel)( , var_h1463, other ) => 
 	 Rel (sel)( , var__temp_h1474, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1474, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1476, res ) ==(var__temp_v1475) AND 
 	 Rel (sel)( , var__temp_h'1476, res ) ==((sel)( , var__temp_h1474, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1476, other ) ==(sel)( , var__temp_h1474, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1476, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1476, other ) > (4)
 
VC_END(declare-const var_h_i1464 T5270)
(declare-const var_h1463 T5270)
(declare-const v Int)
(declare-const var_h_i1295 T5270)
(declare-const var_h1294 T5270)
(declare-const v Int)
(declare-const var_h_i44 T5270)
(declare-const var_h43 T5270)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1474 T5270)
(declare-const var__temp_v1475 Int)
(declare-const |var__temp_h'1476| T5270)
(declare-const var__temp_v_err1477 T5271)
(declare-const var_h1463 T5270)
(declare-const var_h1294 T5270)
(declare-const var_h43 T5270)
(declare-const err T5284)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5270)
(declare-fun sel (T5270 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5270)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1476| () T5270)
(declare-fun var__temp_h1474 () T5270)
(declare-fun var__temp_v1475 () Int)
(declare-fun var_h1463 () T5270)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1474 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1474 other) (sel var_h1463 other)))
               (= (sel var__temp_h1474 res) 5)))
      (a!2 (and (= (sel |var__temp_h'1476| res) var__temp_v1475)
                (= (sel |var__temp_h'1476| res) (+ (sel var__temp_h1474 res) 2))
                (= (sel |var__temp_h'1476| other) (sel var__temp_h1474 other))))
      (a!3 (and (= (sel |var__temp_h'1476| res) 10)
                (not (> (sel |var__temp_h'1476| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1474 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************402
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1465:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1465:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --foo
 	 --foo'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1464 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1464, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1464, other ) ==(sel)( , var_h1463, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1478:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************403
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1464 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1464, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1464, other ) ==(sel)( , var_h1463, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1478:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1464 --->  Ty_heap  
 var_h1463 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1479 --->  Ty_heap  
 var__temp_v1480 --->  Ty_int  
 var__temp_h'1481 --->  Ty_heap  
 var__temp_v_err1482 --->  error  
 var_h1463 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1479, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1479, other ) ==(sel)( , var_h1463, other ) => 
 	 Rel (sel)( , var__temp_h1479, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1479, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1481, res ) ==(var__temp_v1480) AND 
 	 Rel (sel)( , var__temp_h'1481, res ) ==((sel)( , var__temp_h1479, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1481, other ) ==(sel)( , var__temp_h1479, other ) => 
 	 True
 
VC_END(declare-const var_h_i1464 T5287)
(declare-const var_h1463 T5287)
(declare-const v Int)
(declare-const var_h_i1295 T5287)
(declare-const var_h1294 T5287)
(declare-const v Int)
(declare-const var_h_i44 T5287)
(declare-const var_h43 T5287)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1479 T5287)
(declare-const var__temp_v1480 Int)
(declare-const |var__temp_h'1481| T5287)
(declare-const var__temp_v_err1482 T5288)
(declare-const var_h1463 T5287)
(declare-const var_h1294 T5287)
(declare-const var_h43 T5287)
(declare-const err T5301)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5287)
(declare-fun sel (T5287 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5287)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1479 () T5287)
(declare-fun |var__temp_h'1481| () T5287)
(declare-fun var__temp_v1480 () Int)
(declare-fun var_h1463 () T5287)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1479 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1479 other) (sel var_h1463 other)))
               (= (sel var__temp_h1479 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1481| res) var__temp_v1480)
                (= (sel |var__temp_h'1481| res) (+ (sel var__temp_h1479 res) 3))
                (= (sel |var__temp_h'1481| other) (sel var__temp_h1479 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1479 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************404
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1464 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1464, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1464, other ) ==(sel)( , var_h1463, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1478:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1464 --->  Ty_heap  
 var_h1463 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1483 --->  Ty_heap  
 var__temp_v1484 --->  Ty_int  
 var__temp_h'1485 --->  Ty_heap  
 var__temp_v_err1486 --->  error  
 var_h1463 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1483, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1483, other ) ==(sel)( , var_h1463, other ) => 
 	 Rel (sel)( , var__temp_h1483, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1483, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1485, res ) ==(var__temp_v1484) AND 
 	 Rel (sel)( , var__temp_h'1485, res ) ==((sel)( , var__temp_h1483, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1485, other ) ==(sel)( , var__temp_h1483, other ) => 
 	 True
 
VC_END(declare-const var_h_i1464 T5304)
(declare-const var_h1463 T5304)
(declare-const v Int)
(declare-const var_h_i1295 T5304)
(declare-const var_h1294 T5304)
(declare-const v Int)
(declare-const var_h_i44 T5304)
(declare-const var_h43 T5304)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1483 T5304)
(declare-const var__temp_v1484 Int)
(declare-const |var__temp_h'1485| T5304)
(declare-const var__temp_v_err1486 T5305)
(declare-const var_h1463 T5304)
(declare-const var_h1294 T5304)
(declare-const var_h43 T5304)
(declare-const err T5318)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5304)
(declare-fun sel (T5304 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5304)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1483 () T5304)
(declare-fun |var__temp_h'1485| () T5304)
(declare-fun var__temp_v1484 () Int)
(declare-fun var_h1463 () T5304)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1483 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1483 other) (sel var_h1463 other)))
               (= (sel var__temp_h1483 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1485| res) var__temp_v1484)
                (= (sel |var__temp_h'1485| res) (+ (sel var__temp_h1483 res) 5))
                (= (sel |var__temp_h'1485| other) (sel var__temp_h1483 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1483 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************405
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1464 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1464, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1464, other ) ==(sel)( , var_h1463, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1478:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1464 --->  Ty_heap  
 var_h1463 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1487 --->  Ty_heap  
 var__temp_v1488 --->  Ty_int  
 var__temp_h'1489 --->  Ty_heap  
 var__temp_v_err1490 --->  error  
 var_h1463 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1487, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1487, other ) ==(sel)( , var_h1463, other ) => 
 	 Rel (sel)( , var__temp_h1487, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1487, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1489, res ) ==(var__temp_v1488) AND 
 	 Rel (sel)( , var__temp_h'1489, res ) ==((sel)( , var__temp_h1487, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1489, other ) ==(sel)( , var__temp_h1487, other ) => 
 	 True
 
VC_END(declare-const var_h_i1464 T5321)
(declare-const var_h1463 T5321)
(declare-const v Int)
(declare-const var_h_i1295 T5321)
(declare-const var_h1294 T5321)
(declare-const v Int)
(declare-const var_h_i44 T5321)
(declare-const var_h43 T5321)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1487 T5321)
(declare-const var__temp_v1488 Int)
(declare-const |var__temp_h'1489| T5321)
(declare-const var__temp_v_err1490 T5322)
(declare-const var_h1463 T5321)
(declare-const var_h1294 T5321)
(declare-const var_h43 T5321)
(declare-const err T5335)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5321)
(declare-fun sel (T5321 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5321)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1487 () T5321)
(declare-fun |var__temp_h'1489| () T5321)
(declare-fun var__temp_v1488 () Int)
(declare-fun var_h1463 () T5321)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1487 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1487 other) (sel var_h1463 other)))
               (= (sel var__temp_h1487 res) 5)))
      (a!2 (and (= (sel |var__temp_h'1489| res) var__temp_v1488)
                (= (sel |var__temp_h'1489| res) (+ (sel var__temp_h1487 res) 2))
                (= (sel |var__temp_h'1489| other) (sel var__temp_h1487 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1487 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************bar
PARTIAL PATH NEW
SUB 
 	 --bar
 	 --foo
 	 --foo'
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1492 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1492 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1492, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1492, res ) ==((sel)( , var_h1491, res ) + (2))
 	 , (sel)( , var_h_i1492, other ) ==(sel)( , var_h1491, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1493:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1492 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************406
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1492 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1492, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1492, res ) ==((sel)( , var_h1491, res ) + (2))
 	 , (sel)( , var_h_i1492, other ) ==(sel)( , var_h1491, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1493:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1492 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1492 --->  Ty_heap  
 var_h1491 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1464 --->  Ty_heap  
 var_h1463 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1494 --->  Ty_heap  
 var__temp_v1495 --->  Ty_int  
 var__temp_h'1496 --->  Ty_heap  
 var__temp_v_err1497 --->  error  
 var_h1491 --->  Ty_heap  
 var_h1463 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1491, res ) ==(5) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1494, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1494, res ) ==((sel)( , var_h1491, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h1494, other ) ==(sel)( , var_h1491, other ) => 
 	 Rel (sel)( , var__temp_h1494, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1494, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1496, res ) ==(var__temp_v1495) AND 
 	 Rel (sel)( , var__temp_h'1496, res ) ==((sel)( , var__temp_h1494, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1496, other ) ==(sel)( , var__temp_h1494, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1496, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1496, other ) > (4)
 
VC_END(declare-const var_h_i1492 T5338)
(declare-const var_h1491 T5338)
(declare-const v Int)
(declare-const var_h_i1464 T5338)
(declare-const var_h1463 T5338)
(declare-const v Int)
(declare-const var_h_i1295 T5338)
(declare-const var_h1294 T5338)
(declare-const v Int)
(declare-const var_h_i44 T5338)
(declare-const var_h43 T5338)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1494 T5338)
(declare-const var__temp_v1495 Int)
(declare-const |var__temp_h'1496| T5338)
(declare-const var__temp_v_err1497 T5339)
(declare-const var_h1491 T5338)
(declare-const var_h1463 T5338)
(declare-const var_h1294 T5338)
(declare-const var_h43 T5338)
(declare-const err T5352)

solver 
 (declare-sort T5338)
(declare-fun sel (T5338 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1491 () T5338)
(declare-fun var_h43 () T5338)
(declare-fun other () Int)
(declare-fun |var__temp_h'1496| () T5338)
(declare-fun var__temp_h1494 () T5338)
(declare-fun var__temp_v1495 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1491 res) 5))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1494 res) v)
                (= (sel var__temp_h1494 res) (+ (sel var_h1491 res) 2))
                (= (sel var__temp_h1494 other) (sel var_h1491 other))))
      (a!2 (and (= (sel |var__temp_h'1496| res) var__temp_v1495)
                (= (sel |var__temp_h'1496| res) (+ (sel var__temp_h1494 res) 3))
                (= (sel |var__temp_h'1496| other) (sel var__temp_h1494 other))))
      (a!3 (and (= (sel |var__temp_h'1496| res) 10)
                (not (> (sel |var__temp_h'1496| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1494 res) 7))
                (=> (= (sel var__temp_h1494 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************407
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1492 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1492, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1492, res ) ==((sel)( , var_h1491, res ) + (2))
 	 , (sel)( , var_h_i1492, other ) ==(sel)( , var_h1491, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1493:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1492 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1492 --->  Ty_heap  
 var_h1491 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1464 --->  Ty_heap  
 var_h1463 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1498 --->  Ty_heap  
 var__temp_v1499 --->  Ty_int  
 var__temp_h'1500 --->  Ty_heap  
 var__temp_v_err1501 --->  error  
 var_h1491 --->  Ty_heap  
 var_h1463 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1491, res ) ==(5) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1498, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1498, res ) ==((sel)( , var_h1491, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h1498, other ) ==(sel)( , var_h1491, other ) => 
 	 Rel (sel)( , var__temp_h1498, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1498, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1500, res ) ==(var__temp_v1499) AND 
 	 Rel (sel)( , var__temp_h'1500, res ) ==((sel)( , var__temp_h1498, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1500, other ) ==(sel)( , var__temp_h1498, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1500, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1500, other ) > (4)
 
VC_END(declare-const var_h_i1492 T5355)
(declare-const var_h1491 T5355)
(declare-const v Int)
(declare-const var_h_i1464 T5355)
(declare-const var_h1463 T5355)
(declare-const v Int)
(declare-const var_h_i1295 T5355)
(declare-const var_h1294 T5355)
(declare-const v Int)
(declare-const var_h_i44 T5355)
(declare-const var_h43 T5355)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1498 T5355)
(declare-const var__temp_v1499 Int)
(declare-const |var__temp_h'1500| T5355)
(declare-const var__temp_v_err1501 T5356)
(declare-const var_h1491 T5355)
(declare-const var_h1463 T5355)
(declare-const var_h1294 T5355)
(declare-const var_h43 T5355)
(declare-const err T5369)

solver 
 (declare-sort T5355)
(declare-fun sel (T5355 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1491 () T5355)
(declare-fun var_h43 () T5355)
(declare-fun other () Int)
(declare-fun |var__temp_h'1500| () T5355)
(declare-fun var__temp_h1498 () T5355)
(declare-fun var__temp_v1499 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1491 res) 5))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1498 res) v)
                (= (sel var__temp_h1498 res) (+ (sel var_h1491 res) 2))
                (= (sel var__temp_h1498 other) (sel var_h1491 other))))
      (a!2 (and (= (sel |var__temp_h'1500| res) var__temp_v1499)
                (= (sel |var__temp_h'1500| res) (+ (sel var__temp_h1498 res) 5))
                (= (sel |var__temp_h'1500| other) (sel var__temp_h1498 other))))
      (a!3 (and (= (sel |var__temp_h'1500| res) 10)
                (not (> (sel |var__temp_h'1500| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1498 res) 7))
                (=> (= (sel var__temp_h1498 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************408
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1493:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1493:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbarfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --foo'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1492 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1492, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1492, res ) ==((sel)( , var_h1491, res ) + (2))
 	 , (sel)( , var_h_i1492, other ) ==(sel)( , var_h1491, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1502:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************409
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1492 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1492, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1492, res ) ==((sel)( , var_h1491, res ) + (2))
 	 , (sel)( , var_h_i1492, other ) ==(sel)( , var_h1491, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1502:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1492 --->  Ty_heap  
 var_h1491 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1464 --->  Ty_heap  
 var_h1463 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1503 --->  Ty_heap  
 var__temp_v1504 --->  Ty_int  
 var__temp_h'1505 --->  Ty_heap  
 var__temp_v_err1506 --->  error  
 var_h1491 --->  Ty_heap  
 var_h1463 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1491, res ) ==(5) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1503, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1503, res ) ==((sel)( , var_h1491, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h1503, other ) ==(sel)( , var_h1491, other ) => 
 	 Rel (sel)( , var__temp_h1503, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1503, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1505, res ) ==(var__temp_v1504) AND 
 	 Rel (sel)( , var__temp_h'1505, res ) ==((sel)( , var__temp_h1503, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1505, other ) ==(sel)( , var__temp_h1503, other ) => 
 	 True
 
VC_END(declare-const var_h_i1492 T5372)
(declare-const var_h1491 T5372)
(declare-const v Int)
(declare-const var_h_i1464 T5372)
(declare-const var_h1463 T5372)
(declare-const v Int)
(declare-const var_h_i1295 T5372)
(declare-const var_h1294 T5372)
(declare-const v Int)
(declare-const var_h_i44 T5372)
(declare-const var_h43 T5372)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1503 T5372)
(declare-const var__temp_v1504 Int)
(declare-const |var__temp_h'1505| T5372)
(declare-const var__temp_v_err1506 T5373)
(declare-const var_h1491 T5372)
(declare-const var_h1463 T5372)
(declare-const var_h1294 T5372)
(declare-const var_h43 T5372)
(declare-const err T5386)

solver 
 (declare-sort T5372)
(declare-fun sel (T5372 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1491 () T5372)
(declare-fun var_h43 () T5372)
(declare-fun other () Int)
(declare-fun var__temp_h1503 () T5372)
(declare-fun |var__temp_h'1505| () T5372)
(declare-fun var__temp_v1504 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1491 res) 5))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1503 res) v)
                (= (sel var__temp_h1503 res) (+ (sel var_h1491 res) 2))
                (= (sel var__temp_h1503 other) (sel var_h1491 other))))
      (a!2 (and (= (sel |var__temp_h'1505| res) var__temp_v1504)
                (= (sel |var__temp_h'1505| res) (+ (sel var__temp_h1503 res) 3))
                (= (sel |var__temp_h'1505| other) (sel var__temp_h1503 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1503 res) 7))
                (=> (= (sel var__temp_h1503 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************baz
PARTIAL PATH NEW
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --foo'
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1508 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1508 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1508, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1508, res ) ==((sel)( , var_h1507, res ) + (3))
 	 , (sel)( , var_h_i1508, other ) ==(sel)( , var_h1507, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1509:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1508 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************410
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1508 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1508, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1508, res ) ==((sel)( , var_h1507, res ) + (3))
 	 , (sel)( , var_h_i1508, other ) ==(sel)( , var_h1507, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1509:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1508 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1508 --->  Ty_heap  
 var_h1507 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1492 --->  Ty_heap  
 var_h1491 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1464 --->  Ty_heap  
 var_h1463 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1510 --->  Ty_heap  
 var__temp_v1511 --->  Ty_int  
 var__temp_h'1512 --->  Ty_heap  
 var__temp_v_err1513 --->  error  
 var_h1507 --->  Ty_heap  
 var_h1491 --->  Ty_heap  
 var_h1463 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1507, res ) ==(7) AND 
 	 Rel (sel)( , var_h1491, res ) ==(5) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1510, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1510, res ) ==((sel)( , var_h1507, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h1510, other ) ==(sel)( , var_h1507, other ) => 
 	 Rel (sel)( , var__temp_h1510, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1510, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1512, res ) ==(var__temp_v1511) AND 
 	 Rel (sel)( , var__temp_h'1512, res ) ==((sel)( , var__temp_h1510, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1512, other ) ==(sel)( , var__temp_h1510, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1512, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1512, other ) > (4)
 
VC_END(declare-const var_h_i1508 T5389)
(declare-const var_h1507 T5389)
(declare-const v Int)
(declare-const var_h_i1492 T5389)
(declare-const var_h1491 T5389)
(declare-const v Int)
(declare-const var_h_i1464 T5389)
(declare-const var_h1463 T5389)
(declare-const v Int)
(declare-const var_h_i1295 T5389)
(declare-const var_h1294 T5389)
(declare-const v Int)
(declare-const var_h_i44 T5389)
(declare-const var_h43 T5389)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1510 T5389)
(declare-const var__temp_v1511 Int)
(declare-const |var__temp_h'1512| T5389)
(declare-const var__temp_v_err1513 T5390)
(declare-const var_h1507 T5389)
(declare-const var_h1491 T5389)
(declare-const var_h1463 T5389)
(declare-const var_h1294 T5389)
(declare-const var_h43 T5389)
(declare-const err T5403)

solver 
 (declare-sort T5389)
(declare-fun sel (T5389 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1507 () T5389)
(declare-fun var_h1491 () T5389)
(declare-fun var_h43 () T5389)
(declare-fun other () Int)
(declare-fun |var__temp_h'1512| () T5389)
(declare-fun var__temp_h1510 () T5389)
(declare-fun var__temp_v1511 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1507 res) 7))
(assert (= (sel var_h1491 res) 5))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1510 res) v)
                (= (sel var__temp_h1510 res) (+ (sel var_h1507 res) 3))
                (= (sel var__temp_h1510 other) (sel var_h1507 other))))
      (a!2 (and (= (sel |var__temp_h'1512| res) var__temp_v1511)
                (= (sel |var__temp_h'1512| res) (+ (sel var__temp_h1510 res) 5))
                (= (sel |var__temp_h'1512| other) (sel var__temp_h1510 other))))
      (a!3 (and (= (sel |var__temp_h'1512| res) 10)
                (not (> (sel |var__temp_h'1512| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1510 res) 7))
                (=> (= (sel var__temp_h1510 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************411
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1509:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1509:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbazbarfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --foo'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1508 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1508, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1508, res ) ==((sel)( , var_h1507, res ) + (3))
 	 , (sel)( , var_h_i1508, other ) ==(sel)( , var_h1507, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1514:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************412
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1508 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1508, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1508, res ) ==((sel)( , var_h1507, res ) + (3))
 	 , (sel)( , var_h_i1508, other ) ==(sel)( , var_h1507, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1514:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1508 --->  Ty_heap  
 var_h1507 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1492 --->  Ty_heap  
 var_h1491 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1464 --->  Ty_heap  
 var_h1463 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1515 --->  Ty_heap  
 var__temp_v1516 --->  Ty_int  
 var__temp_h'1517 --->  Ty_heap  
 var__temp_v_err1518 --->  error  
 var_h1507 --->  Ty_heap  
 var_h1491 --->  Ty_heap  
 var_h1463 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1507, res ) ==(7) AND 
 	 Rel (sel)( , var_h1491, res ) ==(5) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1515, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1515, res ) ==((sel)( , var_h1507, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h1515, other ) ==(sel)( , var_h1507, other ) => 
 	 Rel (sel)( , var__temp_h1515, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1515, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1517, res ) ==(var__temp_v1516) AND 
 	 Rel (sel)( , var__temp_h'1517, res ) ==((sel)( , var__temp_h1515, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1517, other ) ==(sel)( , var__temp_h1515, other ) => 
 	 True
 
VC_END(declare-const var_h_i1508 T5406)
(declare-const var_h1507 T5406)
(declare-const v Int)
(declare-const var_h_i1492 T5406)
(declare-const var_h1491 T5406)
(declare-const v Int)
(declare-const var_h_i1464 T5406)
(declare-const var_h1463 T5406)
(declare-const v Int)
(declare-const var_h_i1295 T5406)
(declare-const var_h1294 T5406)
(declare-const v Int)
(declare-const var_h_i44 T5406)
(declare-const var_h43 T5406)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1515 T5406)
(declare-const var__temp_v1516 Int)
(declare-const |var__temp_h'1517| T5406)
(declare-const var__temp_v_err1518 T5407)
(declare-const var_h1507 T5406)
(declare-const var_h1491 T5406)
(declare-const var_h1463 T5406)
(declare-const var_h1294 T5406)
(declare-const var_h43 T5406)
(declare-const err T5420)

solver 
 (declare-sort T5406)
(declare-fun sel (T5406 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1507 () T5406)
(declare-fun var_h1491 () T5406)
(declare-fun var_h43 () T5406)
(declare-fun other () Int)
(declare-fun var__temp_h1515 () T5406)
(declare-fun |var__temp_h'1517| () T5406)
(declare-fun var__temp_v1516 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1507 res) 7))
(assert (= (sel var_h1491 res) 5))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1515 res) v)
                (= (sel var__temp_h1515 res) (+ (sel var_h1507 res) 3))
                (= (sel var__temp_h1515 other) (sel var_h1507 other))))
      (a!2 (and (= (sel |var__temp_h'1517| res) var__temp_v1516)
                (= (sel |var__temp_h'1517| res) (+ (sel var__temp_h1515 res) 5))
                (= (sel |var__temp_h'1517| other) (sel var__temp_h1515 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1515 res) 7))
                (=> (= (sel var__temp_h1515 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************413
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT baz
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --foo'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1492 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1492, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1492, res ) ==((sel)( , var_h1491, res ) + (2))
 	 , (sel)( , var_h_i1492, other ) ==(sel)( , var_h1491, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1519:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************414
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1492 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1492, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1492, res ) ==((sel)( , var_h1491, res ) + (2))
 	 , (sel)( , var_h_i1492, other ) ==(sel)( , var_h1491, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1519:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1492 --->  Ty_heap  
 var_h1491 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1464 --->  Ty_heap  
 var_h1463 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1520 --->  Ty_heap  
 var__temp_v1521 --->  Ty_int  
 var__temp_h'1522 --->  Ty_heap  
 var__temp_v_err1523 --->  error  
 var_h1491 --->  Ty_heap  
 var_h1463 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1491, res ) ==(5) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1520, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1520, res ) ==((sel)( , var_h1491, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h1520, other ) ==(sel)( , var_h1491, other ) => 
 	 Rel (sel)( , var__temp_h1520, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1520, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1522, res ) ==(var__temp_v1521) AND 
 	 Rel (sel)( , var__temp_h'1522, res ) ==((sel)( , var__temp_h1520, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1522, other ) ==(sel)( , var__temp_h1520, other ) => 
 	 True
 
VC_END(declare-const var_h_i1492 T5423)
(declare-const var_h1491 T5423)
(declare-const v Int)
(declare-const var_h_i1464 T5423)
(declare-const var_h1463 T5423)
(declare-const v Int)
(declare-const var_h_i1295 T5423)
(declare-const var_h1294 T5423)
(declare-const v Int)
(declare-const var_h_i44 T5423)
(declare-const var_h43 T5423)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1520 T5423)
(declare-const var__temp_v1521 Int)
(declare-const |var__temp_h'1522| T5423)
(declare-const var__temp_v_err1523 T5424)
(declare-const var_h1491 T5423)
(declare-const var_h1463 T5423)
(declare-const var_h1294 T5423)
(declare-const var_h43 T5423)
(declare-const err T5437)

solver 
 (declare-sort T5423)
(declare-fun sel (T5423 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1491 () T5423)
(declare-fun var_h43 () T5423)
(declare-fun other () Int)
(declare-fun var__temp_h1520 () T5423)
(declare-fun |var__temp_h'1522| () T5423)
(declare-fun var__temp_v1521 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1491 res) 5))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1520 res) v)
                (= (sel var__temp_h1520 res) (+ (sel var_h1491 res) 2))
                (= (sel var__temp_h1520 other) (sel var_h1491 other))))
      (a!2 (and (= (sel |var__temp_h'1522| res) var__temp_v1521)
                (= (sel |var__temp_h'1522| res) (+ (sel var__temp_h1520 res) 5))
                (= (sel |var__temp_h'1522| other) (sel var__temp_h1520 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1520 res) 7))
                (=> (= (sel var__temp_h1520 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c5
PARTIAL PATH NEW
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --foo'
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1525 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1525 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1525, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1525, res ) ==((sel)( , var_h1524, res ) + (5))
 	 , (sel)( , var_h_i1525, other ) ==(sel)( , var_h1524, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1526:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1525 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************415
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1526:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1526:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc5bazbarfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --foo'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1525 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1525, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1525, res ) ==((sel)( , var_h1524, res ) + (5))
 	 , (sel)( , var_h_i1525, other ) ==(sel)( , var_h1524, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1527:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************416
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --foo'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1492 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1492, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1492, res ) ==((sel)( , var_h1491, res ) + (2))
 	 , (sel)( , var_h_i1492, other ) ==(sel)( , var_h1491, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1528:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************417
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --foo
 	 --foo'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1464 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1464, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1464, other ) ==(sel)( , var_h1463, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1529:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************418
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1464 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1464, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1464, other ) ==(sel)( , var_h1463, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1529:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1464 --->  Ty_heap  
 var_h1463 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1530 --->  Ty_heap  
 var__temp_v1531 --->  Ty_int  
 var__temp_h'1532 --->  Ty_heap  
 var__temp_v_err1533 --->  error  
 var_h1463 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1530, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1530, other ) ==(sel)( , var_h1463, other ) => 
 	 Rel (sel)( , var__temp_h1530, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1530, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1532, res ) ==(var__temp_v1531) AND 
 	 Rel (sel)( , var__temp_h'1532, res ) ==((sel)( , var__temp_h1530, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1532, other ) ==(sel)( , var__temp_h1530, other ) => 
 	 True
 
VC_END(declare-const var_h_i1464 T5440)
(declare-const var_h1463 T5440)
(declare-const v Int)
(declare-const var_h_i1295 T5440)
(declare-const var_h1294 T5440)
(declare-const v Int)
(declare-const var_h_i44 T5440)
(declare-const var_h43 T5440)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1530 T5440)
(declare-const var__temp_v1531 Int)
(declare-const |var__temp_h'1532| T5440)
(declare-const var__temp_v_err1533 T5441)
(declare-const var_h1463 T5440)
(declare-const var_h1294 T5440)
(declare-const var_h43 T5440)
(declare-const err T5454)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5440)
(declare-fun sel (T5440 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5440)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1530 () T5440)
(declare-fun |var__temp_h'1532| () T5440)
(declare-fun var__temp_v1531 () Int)
(declare-fun var_h1463 () T5440)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1530 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1530 other) (sel var_h1463 other)))
               (= (sel var__temp_h1530 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1532| res) var__temp_v1531)
                (= (sel |var__temp_h'1532| res) (+ (sel var__temp_h1530 res) 3))
                (= (sel |var__temp_h'1532| other) (sel var__temp_h1530 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1530 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************419
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1464 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1464, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1464, other ) ==(sel)( , var_h1463, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1529:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1464 --->  Ty_heap  
 var_h1463 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1534 --->  Ty_heap  
 var__temp_v1535 --->  Ty_int  
 var__temp_h'1536 --->  Ty_heap  
 var__temp_v_err1537 --->  error  
 var_h1463 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1534, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1534, other ) ==(sel)( , var_h1463, other ) => 
 	 Rel (sel)( , var__temp_h1534, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1534, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1536, res ) ==(var__temp_v1535) AND 
 	 Rel (sel)( , var__temp_h'1536, res ) ==((sel)( , var__temp_h1534, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1536, other ) ==(sel)( , var__temp_h1534, other ) => 
 	 True
 
VC_END(declare-const var_h_i1464 T5457)
(declare-const var_h1463 T5457)
(declare-const v Int)
(declare-const var_h_i1295 T5457)
(declare-const var_h1294 T5457)
(declare-const v Int)
(declare-const var_h_i44 T5457)
(declare-const var_h43 T5457)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1534 T5457)
(declare-const var__temp_v1535 Int)
(declare-const |var__temp_h'1536| T5457)
(declare-const var__temp_v_err1537 T5458)
(declare-const var_h1463 T5457)
(declare-const var_h1294 T5457)
(declare-const var_h43 T5457)
(declare-const err T5471)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5457)
(declare-fun sel (T5457 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5457)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1534 () T5457)
(declare-fun |var__temp_h'1536| () T5457)
(declare-fun var__temp_v1535 () Int)
(declare-fun var_h1463 () T5457)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1534 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1534 other) (sel var_h1463 other)))
               (= (sel var__temp_h1534 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1536| res) var__temp_v1535)
                (= (sel |var__temp_h'1536| res) (+ (sel var__temp_h1534 res) 5))
                (= (sel |var__temp_h'1536| other) (sel var__temp_h1534 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1534 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************420
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT bar
PARTIAL PATH
SUB 
 	 --foo'
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1295 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1295, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1295, other ) ==(sel)( , var_h1294, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1538:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************421
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1295 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1295, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1295, other ) ==(sel)( , var_h1294, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1538:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1539 --->  Ty_heap  
 var__temp_v1540 --->  Ty_int  
 var__temp_h'1541 --->  Ty_heap  
 var__temp_v_err1542 --->  error  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1539, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1539, other ) ==(sel)( , var_h1294, other ) => 
 	 Rel (sel)( , var__temp_h1539, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1539, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1541, res ) ==(var__temp_v1540) AND 
 	 Rel (sel)( , var__temp_h'1541, res ) ==((sel)( , var__temp_h1539, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1541, other ) ==(sel)( , var__temp_h1539, other ) => 
 	 True
 
VC_END(declare-const var_h_i1295 T5474)
(declare-const var_h1294 T5474)
(declare-const v Int)
(declare-const var_h_i44 T5474)
(declare-const var_h43 T5474)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1539 T5474)
(declare-const var__temp_v1540 Int)
(declare-const |var__temp_h'1541| T5474)
(declare-const var__temp_v_err1542 T5475)
(declare-const var_h1294 T5474)
(declare-const var_h43 T5474)
(declare-const err T5488)
    (declare-const |20| Int)
  
solver 
 (declare-sort T5474)
(declare-fun sel (T5474 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5474)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h1539 () T5474)
(declare-fun |var__temp_h'1541| () T5474)
(declare-fun var__temp_v1540 () Int)
(declare-fun var_h1294 () T5474)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1539 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1539 other) (sel var_h1294 other)))
               (= (sel var__temp_h1539 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1541| res) var__temp_v1540)
                (= (sel |var__temp_h'1541| res) (+ (sel var__temp_h1539 res) 3))
                (= (sel |var__temp_h'1541| other) (sel var__temp_h1539 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1539 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************422
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1295 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1295, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1295, other ) ==(sel)( , var_h1294, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1538:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1543 --->  Ty_heap  
 var__temp_v1544 --->  Ty_int  
 var__temp_h'1545 --->  Ty_heap  
 var__temp_v_err1546 --->  error  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1543, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1543, other ) ==(sel)( , var_h1294, other ) => 
 	 Rel (sel)( , var__temp_h1543, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1543, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1545, res ) ==(var__temp_v1544) AND 
 	 Rel (sel)( , var__temp_h'1545, res ) ==((sel)( , var__temp_h1543, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1545, other ) ==(sel)( , var__temp_h1543, other ) => 
 	 True
 
VC_END(declare-const var_h_i1295 T5491)
(declare-const var_h1294 T5491)
(declare-const v Int)
(declare-const var_h_i44 T5491)
(declare-const var_h43 T5491)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1543 T5491)
(declare-const var__temp_v1544 Int)
(declare-const |var__temp_h'1545| T5491)
(declare-const var__temp_v_err1546 T5492)
(declare-const var_h1294 T5491)
(declare-const var_h43 T5491)
(declare-const err T5505)
    (declare-const |20| Int)
  
solver 
 (declare-sort T5491)
(declare-fun sel (T5491 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5491)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h1543 () T5491)
(declare-fun |var__temp_h'1545| () T5491)
(declare-fun var__temp_v1544 () Int)
(declare-fun var_h1294 () T5491)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1543 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1543 other) (sel var_h1294 other)))
               (= (sel var__temp_h1543 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1545| res) var__temp_v1544)
                (= (sel |var__temp_h'1545| res) (+ (sel var__temp_h1543 res) 5))
                (= (sel |var__temp_h'1545| other) (sel var__temp_h1543 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1543 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************423
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1295 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1295, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1295, other ) ==(sel)( , var_h1294, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1538:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1295 --->  Ty_heap  
 var_h1294 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1547 --->  Ty_heap  
 var__temp_v1548 --->  Ty_int  
 var__temp_h'1549 --->  Ty_heap  
 var__temp_v_err1550 --->  error  
 var_h1294 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1547, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1547, other ) ==(sel)( , var_h1294, other ) => 
 	 Rel (sel)( , var__temp_h1547, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1547, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1549, res ) ==(var__temp_v1548) AND 
 	 Rel (sel)( , var__temp_h'1549, res ) ==((sel)( , var__temp_h1547, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1549, other ) ==(sel)( , var__temp_h1547, other ) => 
 	 True
 
VC_END(declare-const var_h_i1295 T5508)
(declare-const var_h1294 T5508)
(declare-const v Int)
(declare-const var_h_i44 T5508)
(declare-const var_h43 T5508)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1547 T5508)
(declare-const var__temp_v1548 Int)
(declare-const |var__temp_h'1549| T5508)
(declare-const var__temp_v_err1550 T5509)
(declare-const var_h1294 T5508)
(declare-const var_h43 T5508)
(declare-const err T5522)
    (declare-const |20| Int)
  
solver 
 (declare-sort T5508)
(declare-fun sel (T5508 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5508)
(declare-fun other () Int)
(declare-fun |20| () Int)
(declare-fun var__temp_h1547 () T5508)
(declare-fun |var__temp_h'1549| () T5508)
(declare-fun var__temp_v1548 () Int)
(declare-fun var_h1294 () T5508)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1547 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1547 other) (sel var_h1294 other)))
               (= (sel var__temp_h1547 res) 5)))
      (a!2 (and (= (sel |var__temp_h'1549| res) var__temp_v1548)
                (= (sel |var__temp_h'1549| res) (+ (sel var__temp_h1547 res) 2))
                (= (sel |var__temp_h'1549| other) (sel var__temp_h1547 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1547 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************424
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo
PARTIAL PATH
SUB 
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1551:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************425
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1551:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1552 --->  Ty_heap  
 var__temp_v1553 --->  Ty_int  
 var__temp_h'1554 --->  Ty_heap  
 var__temp_v_err1555 --->  error  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1552, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1552, res ) ==((sel)( , var_h43, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h1552, other ) ==((sel)( , var_h43, other ) + (5)) => 
 	 Rel (sel)( , var__temp_h1552, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1552, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1554, res ) ==(var__temp_v1553) AND 
 	 Rel (sel)( , var__temp_h'1554, res ) ==((sel)( , var__temp_h1552, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1554, other ) ==(sel)( , var__temp_h1552, other ) => 
 	 True
 
VC_END(declare-const var_h_i44 T5525)
(declare-const var_h43 T5525)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1552 T5525)
(declare-const var__temp_v1553 Int)
(declare-const |var__temp_h'1554| T5525)
(declare-const var__temp_v_err1555 T5526)
(declare-const var_h43 T5525)
(declare-const err T5539)

solver 
 (declare-sort T5525)
(declare-fun sel (T5525 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5525)
(declare-fun other () Int)
(declare-fun var__temp_h1552 () T5525)
(declare-fun |var__temp_h'1554| () T5525)
(declare-fun var__temp_v1553 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1552 res) v)
                (= (sel var__temp_h1552 res) (+ (sel var_h43 res) 3))
                (= (sel var__temp_h1552 other) (+ (sel var_h43 other) 5))))
      (a!2 (and (= (sel |var__temp_h'1554| res) var__temp_v1553)
                (= (sel |var__temp_h'1554| res) (+ (sel var__temp_h1552 res) 3))
                (= (sel |var__temp_h'1554| other) (sel var__temp_h1552 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1552 res) 7))
                (=> (= (sel var__temp_h1552 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************426
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1551:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1556 --->  Ty_heap  
 var__temp_v1557 --->  Ty_int  
 var__temp_h'1558 --->  Ty_heap  
 var__temp_v_err1559 --->  error  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1556, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1556, res ) ==((sel)( , var_h43, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h1556, other ) ==((sel)( , var_h43, other ) + (5)) => 
 	 Rel (sel)( , var__temp_h1556, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1556, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1558, res ) ==(var__temp_v1557) AND 
 	 Rel (sel)( , var__temp_h'1558, res ) ==((sel)( , var__temp_h1556, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1558, other ) ==(sel)( , var__temp_h1556, other ) => 
 	 True
 
VC_END(declare-const var_h_i44 T5542)
(declare-const var_h43 T5542)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1556 T5542)
(declare-const var__temp_v1557 Int)
(declare-const |var__temp_h'1558| T5542)
(declare-const var__temp_v_err1559 T5543)
(declare-const var_h43 T5542)
(declare-const err T5556)

solver 
 (declare-sort T5542)
(declare-fun sel (T5542 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5542)
(declare-fun other () Int)
(declare-fun var__temp_h1556 () T5542)
(declare-fun |var__temp_h'1558| () T5542)
(declare-fun var__temp_v1557 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1556 res) v)
                (= (sel var__temp_h1556 res) (+ (sel var_h43 res) 3))
                (= (sel var__temp_h1556 other) (+ (sel var_h43 other) 5))))
      (a!2 (and (= (sel |var__temp_h'1558| res) var__temp_v1557)
                (= (sel |var__temp_h'1558| res) (+ (sel var__temp_h1556 res) 5))
                (= (sel |var__temp_h'1558| other) (sel var__temp_h1556 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1556 res) 7))
                (=> (= (sel var__temp_h1556 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************427
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1551:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1560 --->  Ty_heap  
 var__temp_v1561 --->  Ty_int  
 var__temp_h'1562 --->  Ty_heap  
 var__temp_v_err1563 --->  error  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1560, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1560, res ) ==((sel)( , var_h43, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h1560, other ) ==((sel)( , var_h43, other ) + (5)) => 
 	 Rel (sel)( , var__temp_h1560, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1560, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1562, res ) ==(var__temp_v1561) AND 
 	 Rel (sel)( , var__temp_h'1562, res ) ==((sel)( , var__temp_h1560, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'1562, other ) ==(sel)( , var__temp_h1560, other ) => 
 	 True
 
VC_END(declare-const var_h_i44 T5559)
(declare-const var_h43 T5559)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1560 T5559)
(declare-const var__temp_v1561 Int)
(declare-const |var__temp_h'1562| T5559)
(declare-const var__temp_v_err1563 T5560)
(declare-const var_h43 T5559)
(declare-const err T5573)

solver 
 (declare-sort T5559)
(declare-fun sel (T5559 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5559)
(declare-fun other () Int)
(declare-fun var__temp_h1560 () T5559)
(declare-fun |var__temp_h'1562| () T5559)
(declare-fun var__temp_v1561 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1560 res) v)
                (= (sel var__temp_h1560 res) (+ (sel var_h43 res) 3))
                (= (sel var__temp_h1560 other) (+ (sel var_h43 other) 5))))
      (a!2 (and (= (sel |var__temp_h'1562| res) var__temp_v1561)
                (= (sel |var__temp_h'1562| res)
                   (+ (sel var__temp_h1560 res) 10))
                (= (sel |var__temp_h'1562| other) (sel var__temp_h1560 other)))))
(let ((a!3 (and (=> a!1 (> (sel var__temp_h1560 res) 4))
                (=> (> (sel var__temp_h1560 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************428
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1551:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1564 --->  Ty_heap  
 var__temp_v1565 --->  Ty_int  
 var__temp_h'1566 --->  Ty_heap  
 var__temp_v_err1567 --->  error  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1564, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1564, res ) ==((sel)( , var_h43, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h1564, other ) ==((sel)( , var_h43, other ) + (5)) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1566, res ) ==(var__temp_v1565) AND 
 	 Base var__temp_v1565 = 5 AND 
 	 Rel (sel)( , var__temp_h'1566, other ) ==(sel)( , var__temp_h1564, other ) => 
 	 True
 
VC_END(declare-const var_h_i44 T5576)
(declare-const var_h43 T5576)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1564 T5576)
(declare-const var__temp_v1565 Int)
(declare-const |var__temp_h'1566| T5576)
(declare-const var__temp_v_err1567 T5577)
(declare-const var_h43 T5576)
(declare-const err T5590)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5576)
(declare-fun sel (T5576 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5576)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1564 () T5576)
(declare-fun |var__temp_h'1566| () T5576)
(declare-fun var__temp_v1565 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h1564 res) v)
                (= (sel var__temp_h1564 res) (+ (sel var_h43 res) 3))
                (= (sel var__temp_h1564 other) (+ (sel var_h43 other) 5))))
      (a!2 (=> (and (= (sel |var__temp_h'1566| res) var__temp_v1565)
                    (= var__temp_v1565 |5|)
                    (= (sel |var__temp_h'1566| other)
                       (sel var__temp_h1564 other)))
               true)))
  (not (and (=> a!1 true) (=> true a!2)))))

***************Selection Successful************foo
PARTIAL PATH NEW
SUB 
 	 --foo
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1569 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1569 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1569, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1569, other ) ==(sel)( , var_h1568, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1570:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1569 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
bar
 *********************Enumeration Iteration*****************429
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1569 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1569, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1569, other ) ==(sel)( , var_h1568, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1570:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1569 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1569 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1571 --->  Ty_heap  
 var__temp_v1572 --->  Ty_int  
 var__temp_h'1573 --->  Ty_heap  
 var__temp_v_err1574 --->  error  
 var_h1568 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1571, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1571, other ) ==(sel)( , var_h1568, other ) => 
 	 Rel (sel)( , var__temp_h1571, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1571, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1573, res ) ==(var__temp_v1572) AND 
 	 Rel (sel)( , var__temp_h'1573, res ) ==((sel)( , var__temp_h1571, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1573, other ) ==(sel)( , var__temp_h1571, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1573, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1573, other ) > (4)
 
VC_END(declare-const var_h_i1569 T5593)
(declare-const var_h1568 T5593)
(declare-const v Int)
(declare-const var_h_i44 T5593)
(declare-const var_h43 T5593)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1571 T5593)
(declare-const var__temp_v1572 Int)
(declare-const |var__temp_h'1573| T5593)
(declare-const var__temp_v_err1574 T5594)
(declare-const var_h1568 T5593)
(declare-const var_h43 T5593)
(declare-const err T5607)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5593)
(declare-fun sel (T5593 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5593)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1573| () T5593)
(declare-fun var__temp_h1571 () T5593)
(declare-fun var__temp_v1572 () Int)
(declare-fun var_h1568 () T5593)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1571 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1571 other) (sel var_h1568 other)))
               (= (sel var__temp_h1571 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1573| res) var__temp_v1572)
                (= (sel |var__temp_h'1573| res) (+ (sel var__temp_h1571 res) 3))
                (= (sel |var__temp_h'1573| other) (sel var__temp_h1571 other))))
      (a!3 (and (= (sel |var__temp_h'1573| res) 10)
                (not (> (sel |var__temp_h'1573| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1571 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************430
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1569 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1569, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1569, other ) ==(sel)( , var_h1568, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1570:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1569 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1569 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1575 --->  Ty_heap  
 var__temp_v1576 --->  Ty_int  
 var__temp_h'1577 --->  Ty_heap  
 var__temp_v_err1578 --->  error  
 var_h1568 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1575, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1575, other ) ==(sel)( , var_h1568, other ) => 
 	 Rel (sel)( , var__temp_h1575, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1575, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1577, res ) ==(var__temp_v1576) AND 
 	 Rel (sel)( , var__temp_h'1577, res ) ==((sel)( , var__temp_h1575, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1577, other ) ==(sel)( , var__temp_h1575, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1577, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1577, other ) > (4)
 
VC_END(declare-const var_h_i1569 T5610)
(declare-const var_h1568 T5610)
(declare-const v Int)
(declare-const var_h_i44 T5610)
(declare-const var_h43 T5610)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1575 T5610)
(declare-const var__temp_v1576 Int)
(declare-const |var__temp_h'1577| T5610)
(declare-const var__temp_v_err1578 T5611)
(declare-const var_h1568 T5610)
(declare-const var_h43 T5610)
(declare-const err T5624)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5610)
(declare-fun sel (T5610 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5610)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1577| () T5610)
(declare-fun var__temp_h1575 () T5610)
(declare-fun var__temp_v1576 () Int)
(declare-fun var_h1568 () T5610)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1575 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1575 other) (sel var_h1568 other)))
               (= (sel var__temp_h1575 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1577| res) var__temp_v1576)
                (= (sel |var__temp_h'1577| res) (+ (sel var__temp_h1575 res) 5))
                (= (sel |var__temp_h'1577| other) (sel var__temp_h1575 other))))
      (a!3 (and (= (sel |var__temp_h'1577| res) 10)
                (not (> (sel |var__temp_h'1577| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1575 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************431
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1569 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1569, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1569, other ) ==(sel)( , var_h1568, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1570:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1569 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1569 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1579 --->  Ty_heap  
 var__temp_v1580 --->  Ty_int  
 var__temp_h'1581 --->  Ty_heap  
 var__temp_v_err1582 --->  error  
 var_h1568 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1579, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1579, other ) ==(sel)( , var_h1568, other ) => 
 	 Rel (sel)( , var__temp_h1579, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1579, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1581, res ) ==(var__temp_v1580) AND 
 	 Rel (sel)( , var__temp_h'1581, res ) ==((sel)( , var__temp_h1579, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'1581, other ) ==(sel)( , var__temp_h1579, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1581, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1581, other ) > (4)
 
VC_END(declare-const var_h_i1569 T5627)
(declare-const var_h1568 T5627)
(declare-const v Int)
(declare-const var_h_i44 T5627)
(declare-const var_h43 T5627)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1579 T5627)
(declare-const var__temp_v1580 Int)
(declare-const |var__temp_h'1581| T5627)
(declare-const var__temp_v_err1582 T5628)
(declare-const var_h1568 T5627)
(declare-const var_h43 T5627)
(declare-const err T5641)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5627)
(declare-fun sel (T5627 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5627)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1581| () T5627)
(declare-fun var__temp_h1579 () T5627)
(declare-fun var__temp_v1580 () Int)
(declare-fun var_h1568 () T5627)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1579 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1579 other) (sel var_h1568 other)))
               (> (sel var__temp_h1579 res) 4)))
      (a!2 (and (= (sel |var__temp_h'1581| res) var__temp_v1580)
                (= (sel |var__temp_h'1581| res)
                   (+ (sel var__temp_h1579 res) 10))
                (= (sel |var__temp_h'1581| other) (sel var__temp_h1579 other))))
      (a!3 (and (= (sel |var__temp_h'1581| res) 10)
                (not (> (sel |var__temp_h'1581| other) 4)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h1579 res) 4) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************432
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1569 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1569, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1569, other ) ==(sel)( , var_h1568, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1570:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1569 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1569 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1583 --->  Ty_heap  
 var__temp_v1584 --->  Ty_int  
 var__temp_h'1585 --->  Ty_heap  
 var__temp_v_err1586 --->  error  
 var_h1568 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1583, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1583, other ) ==(sel)( , var_h1568, other ) => 
 	 Rel (sel)( , var__temp_h1583, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1583, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1585, res ) ==(var__temp_v1584) AND 
 	 Rel (sel)( , var__temp_h'1585, res ) ==((sel)( , var__temp_h1583, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1585, other ) ==(sel)( , var__temp_h1583, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1585, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1585, other ) > (4)
 
VC_END(declare-const var_h_i1569 T5644)
(declare-const var_h1568 T5644)
(declare-const v Int)
(declare-const var_h_i44 T5644)
(declare-const var_h43 T5644)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1583 T5644)
(declare-const var__temp_v1584 Int)
(declare-const |var__temp_h'1585| T5644)
(declare-const var__temp_v_err1586 T5645)
(declare-const var_h1568 T5644)
(declare-const var_h43 T5644)
(declare-const err T5658)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5644)
(declare-fun sel (T5644 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5644)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1585| () T5644)
(declare-fun var__temp_h1583 () T5644)
(declare-fun var__temp_v1584 () Int)
(declare-fun var_h1568 () T5644)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1583 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1583 other) (sel var_h1568 other)))
               (= (sel var__temp_h1583 res) 5)))
      (a!2 (and (= (sel |var__temp_h'1585| res) var__temp_v1584)
                (= (sel |var__temp_h'1585| res) (+ (sel var__temp_h1583 res) 2))
                (= (sel |var__temp_h'1585| other) (sel var__temp_h1583 other))))
      (a!3 (and (= (sel |var__temp_h'1585| res) 10)
                (not (> (sel |var__temp_h'1585| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1583 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************433
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1570:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1570:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfoofoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --foo
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1569 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1569, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1569, other ) ==(sel)( , var_h1568, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1587:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
bar
 *********************Enumeration Iteration*****************434
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1569 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1569, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1569, other ) ==(sel)( , var_h1568, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1587:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1569 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1588 --->  Ty_heap  
 var__temp_v1589 --->  Ty_int  
 var__temp_h'1590 --->  Ty_heap  
 var__temp_v_err1591 --->  error  
 var_h1568 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1588, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1588, other ) ==(sel)( , var_h1568, other ) => 
 	 Rel (sel)( , var__temp_h1588, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1588, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1590, res ) ==(var__temp_v1589) AND 
 	 Rel (sel)( , var__temp_h'1590, res ) ==((sel)( , var__temp_h1588, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1590, other ) ==(sel)( , var__temp_h1588, other ) => 
 	 True
 
VC_END(declare-const var_h_i1569 T5661)
(declare-const var_h1568 T5661)
(declare-const v Int)
(declare-const var_h_i44 T5661)
(declare-const var_h43 T5661)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1588 T5661)
(declare-const var__temp_v1589 Int)
(declare-const |var__temp_h'1590| T5661)
(declare-const var__temp_v_err1591 T5662)
(declare-const var_h1568 T5661)
(declare-const var_h43 T5661)
(declare-const err T5675)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5661)
(declare-fun sel (T5661 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5661)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1588 () T5661)
(declare-fun |var__temp_h'1590| () T5661)
(declare-fun var__temp_v1589 () Int)
(declare-fun var_h1568 () T5661)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1588 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1588 other) (sel var_h1568 other)))
               (= (sel var__temp_h1588 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1590| res) var__temp_v1589)
                (= (sel |var__temp_h'1590| res) (+ (sel var__temp_h1588 res) 3))
                (= (sel |var__temp_h'1590| other) (sel var__temp_h1588 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1588 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************435
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1569 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1569, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1569, other ) ==(sel)( , var_h1568, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1587:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1569 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1592 --->  Ty_heap  
 var__temp_v1593 --->  Ty_int  
 var__temp_h'1594 --->  Ty_heap  
 var__temp_v_err1595 --->  error  
 var_h1568 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1592, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1592, other ) ==(sel)( , var_h1568, other ) => 
 	 Rel (sel)( , var__temp_h1592, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1592, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1594, res ) ==(var__temp_v1593) AND 
 	 Rel (sel)( , var__temp_h'1594, res ) ==((sel)( , var__temp_h1592, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1594, other ) ==(sel)( , var__temp_h1592, other ) => 
 	 True
 
VC_END(declare-const var_h_i1569 T5678)
(declare-const var_h1568 T5678)
(declare-const v Int)
(declare-const var_h_i44 T5678)
(declare-const var_h43 T5678)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1592 T5678)
(declare-const var__temp_v1593 Int)
(declare-const |var__temp_h'1594| T5678)
(declare-const var__temp_v_err1595 T5679)
(declare-const var_h1568 T5678)
(declare-const var_h43 T5678)
(declare-const err T5692)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5678)
(declare-fun sel (T5678 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5678)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1592 () T5678)
(declare-fun |var__temp_h'1594| () T5678)
(declare-fun var__temp_v1593 () Int)
(declare-fun var_h1568 () T5678)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1592 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1592 other) (sel var_h1568 other)))
               (= (sel var__temp_h1592 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1594| res) var__temp_v1593)
                (= (sel |var__temp_h'1594| res) (+ (sel var__temp_h1592 res) 5))
                (= (sel |var__temp_h'1594| other) (sel var__temp_h1592 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1592 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************436
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1569 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1569, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1569, other ) ==(sel)( , var_h1568, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1587:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1569 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1596 --->  Ty_heap  
 var__temp_v1597 --->  Ty_int  
 var__temp_h'1598 --->  Ty_heap  
 var__temp_v_err1599 --->  error  
 var_h1568 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1596, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1596, other ) ==(sel)( , var_h1568, other ) => 
 	 Rel (sel)( , var__temp_h1596, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1596, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1598, res ) ==(var__temp_v1597) AND 
 	 Rel (sel)( , var__temp_h'1598, res ) ==((sel)( , var__temp_h1596, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'1598, other ) ==(sel)( , var__temp_h1596, other ) => 
 	 True
 
VC_END(declare-const var_h_i1569 T5695)
(declare-const var_h1568 T5695)
(declare-const v Int)
(declare-const var_h_i44 T5695)
(declare-const var_h43 T5695)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1596 T5695)
(declare-const var__temp_v1597 Int)
(declare-const |var__temp_h'1598| T5695)
(declare-const var__temp_v_err1599 T5696)
(declare-const var_h1568 T5695)
(declare-const var_h43 T5695)
(declare-const err T5709)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5695)
(declare-fun sel (T5695 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5695)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1596 () T5695)
(declare-fun |var__temp_h'1598| () T5695)
(declare-fun var__temp_v1597 () Int)
(declare-fun var_h1568 () T5695)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1596 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1596 other) (sel var_h1568 other)))
               (> (sel var__temp_h1596 res) 4)))
      (a!2 (and (= (sel |var__temp_h'1598| res) var__temp_v1597)
                (= (sel |var__temp_h'1598| res)
                   (+ (sel var__temp_h1596 res) 10))
                (= (sel |var__temp_h'1598| other) (sel var__temp_h1596 other)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h1596 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c2
PARTIAL PATH NEW
SUB 
 	 --c2
 	 --foo
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1601 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1601 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1601, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1601, res ) ==((sel)( , var_h1600, res ) + (10))
 	 , (sel)( , var_h_i1601, other ) ==(sel)( , var_h1600, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1602:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1601 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************437
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1601 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1601, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1601, res ) ==((sel)( , var_h1600, res ) + (10))
 	 , (sel)( , var_h_i1601, other ) ==(sel)( , var_h1600, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1602:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1601 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1601 --->  Ty_heap  
 var_h1600 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1569 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1603 --->  Ty_heap  
 var__temp_v1604 --->  Ty_int  
 var__temp_h'1605 --->  Ty_heap  
 var__temp_v_err1606 --->  error  
 var_h1600 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1600, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1603, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1603, res ) ==((sel)( , var_h1600, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1603, other ) ==(sel)( , var_h1600, other ) => 
 	 Rel (sel)( , var__temp_h1603, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1603, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1605, res ) ==(var__temp_v1604) AND 
 	 Rel (sel)( , var__temp_h'1605, res ) ==((sel)( , var__temp_h1603, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1605, other ) ==(sel)( , var__temp_h1603, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1605, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1605, other ) > (4)
 
VC_END(declare-const var_h_i1601 T5712)
(declare-const var_h1600 T5712)
(declare-const v Int)
(declare-const var_h_i1569 T5712)
(declare-const var_h1568 T5712)
(declare-const v Int)
(declare-const var_h_i44 T5712)
(declare-const var_h43 T5712)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1603 T5712)
(declare-const var__temp_v1604 Int)
(declare-const |var__temp_h'1605| T5712)
(declare-const var__temp_v_err1606 T5713)
(declare-const var_h1600 T5712)
(declare-const var_h1568 T5712)
(declare-const var_h43 T5712)
(declare-const err T5726)

solver 
 (declare-sort T5712)
(declare-fun sel (T5712 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1600 () T5712)
(declare-fun var_h43 () T5712)
(declare-fun other () Int)
(declare-fun |var__temp_h'1605| () T5712)
(declare-fun var__temp_h1603 () T5712)
(declare-fun var__temp_v1604 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1600 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1603 res) v)
                (= (sel var__temp_h1603 res) (+ (sel var_h1600 res) 10))
                (= (sel var__temp_h1603 other) (sel var_h1600 other))))
      (a!2 (and (= (sel |var__temp_h'1605| res) var__temp_v1604)
                (= (sel |var__temp_h'1605| res) (+ (sel var__temp_h1603 res) 3))
                (= (sel |var__temp_h'1605| other) (sel var__temp_h1603 other))))
      (a!3 (and (= (sel |var__temp_h'1605| res) 10)
                (not (> (sel |var__temp_h'1605| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1603 res) 7))
                (=> (= (sel var__temp_h1603 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************438
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1601 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1601, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1601, res ) ==((sel)( , var_h1600, res ) + (10))
 	 , (sel)( , var_h_i1601, other ) ==(sel)( , var_h1600, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1602:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1601 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1601 --->  Ty_heap  
 var_h1600 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1569 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1607 --->  Ty_heap  
 var__temp_v1608 --->  Ty_int  
 var__temp_h'1609 --->  Ty_heap  
 var__temp_v_err1610 --->  error  
 var_h1600 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1600, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1607, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1607, res ) ==((sel)( , var_h1600, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1607, other ) ==(sel)( , var_h1600, other ) => 
 	 Rel (sel)( , var__temp_h1607, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1607, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1609, res ) ==(var__temp_v1608) AND 
 	 Rel (sel)( , var__temp_h'1609, res ) ==((sel)( , var__temp_h1607, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1609, other ) ==(sel)( , var__temp_h1607, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1609, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1609, other ) > (4)
 
VC_END(declare-const var_h_i1601 T5729)
(declare-const var_h1600 T5729)
(declare-const v Int)
(declare-const var_h_i1569 T5729)
(declare-const var_h1568 T5729)
(declare-const v Int)
(declare-const var_h_i44 T5729)
(declare-const var_h43 T5729)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1607 T5729)
(declare-const var__temp_v1608 Int)
(declare-const |var__temp_h'1609| T5729)
(declare-const var__temp_v_err1610 T5730)
(declare-const var_h1600 T5729)
(declare-const var_h1568 T5729)
(declare-const var_h43 T5729)
(declare-const err T5743)

solver 
 (declare-sort T5729)
(declare-fun sel (T5729 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1600 () T5729)
(declare-fun var_h43 () T5729)
(declare-fun other () Int)
(declare-fun |var__temp_h'1609| () T5729)
(declare-fun var__temp_h1607 () T5729)
(declare-fun var__temp_v1608 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1600 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1607 res) v)
                (= (sel var__temp_h1607 res) (+ (sel var_h1600 res) 10))
                (= (sel var__temp_h1607 other) (sel var_h1600 other))))
      (a!2 (and (= (sel |var__temp_h'1609| res) var__temp_v1608)
                (= (sel |var__temp_h'1609| res) (+ (sel var__temp_h1607 res) 5))
                (= (sel |var__temp_h'1609| other) (sel var__temp_h1607 other))))
      (a!3 (and (= (sel |var__temp_h'1609| res) 10)
                (not (> (sel |var__temp_h'1609| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1607 res) 7))
                (=> (= (sel var__temp_h1607 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************439
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1601 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1601, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1601, res ) ==((sel)( , var_h1600, res ) + (10))
 	 , (sel)( , var_h_i1601, other ) ==(sel)( , var_h1600, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1602:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1601 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1601 --->  Ty_heap  
 var_h1600 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1569 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1611 --->  Ty_heap  
 var__temp_v1612 --->  Ty_int  
 var__temp_h'1613 --->  Ty_heap  
 var__temp_v_err1614 --->  error  
 var_h1600 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1600, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1611, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1611, res ) ==((sel)( , var_h1600, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1611, other ) ==(sel)( , var_h1600, other ) => 
 	 Rel (sel)( , var__temp_h1611, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1611, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1613, res ) ==(var__temp_v1612) AND 
 	 Rel (sel)( , var__temp_h'1613, res ) ==((sel)( , var__temp_h1611, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1613, other ) ==(sel)( , var__temp_h1611, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1613, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1613, other ) > (4)
 
VC_END(declare-const var_h_i1601 T5746)
(declare-const var_h1600 T5746)
(declare-const v Int)
(declare-const var_h_i1569 T5746)
(declare-const var_h1568 T5746)
(declare-const v Int)
(declare-const var_h_i44 T5746)
(declare-const var_h43 T5746)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1611 T5746)
(declare-const var__temp_v1612 Int)
(declare-const |var__temp_h'1613| T5746)
(declare-const var__temp_v_err1614 T5747)
(declare-const var_h1600 T5746)
(declare-const var_h1568 T5746)
(declare-const var_h43 T5746)
(declare-const err T5760)

solver 
 (declare-sort T5746)
(declare-fun sel (T5746 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1600 () T5746)
(declare-fun var_h43 () T5746)
(declare-fun other () Int)
(declare-fun |var__temp_h'1613| () T5746)
(declare-fun var__temp_h1611 () T5746)
(declare-fun var__temp_v1612 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1600 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1611 res) v)
                (= (sel var__temp_h1611 res) (+ (sel var_h1600 res) 10))
                (= (sel var__temp_h1611 other) (sel var_h1600 other))))
      (a!2 (and (= (sel |var__temp_h'1613| res) var__temp_v1612)
                (= (sel |var__temp_h'1613| res) (+ (sel var__temp_h1611 res) 2))
                (= (sel |var__temp_h'1613| other) (sel var__temp_h1611 other))))
      (a!3 (and (= (sel |var__temp_h'1613| res) 10)
                (not (> (sel |var__temp_h'1613| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1611 res) 5))
                (=> (= (sel var__temp_h1611 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************440
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1602:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1602:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2foofoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c2
 	 --foo
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1601 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1601, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1601, res ) ==((sel)( , var_h1600, res ) + (10))
 	 , (sel)( , var_h_i1601, other ) ==(sel)( , var_h1600, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1615:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************441
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1601 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1601, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1601, res ) ==((sel)( , var_h1600, res ) + (10))
 	 , (sel)( , var_h_i1601, other ) ==(sel)( , var_h1600, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1615:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1601 --->  Ty_heap  
 var_h1600 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1569 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1616 --->  Ty_heap  
 var__temp_v1617 --->  Ty_int  
 var__temp_h'1618 --->  Ty_heap  
 var__temp_v_err1619 --->  error  
 var_h1600 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1600, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1616, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1616, res ) ==((sel)( , var_h1600, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1616, other ) ==(sel)( , var_h1600, other ) => 
 	 Rel (sel)( , var__temp_h1616, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1616, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1618, res ) ==(var__temp_v1617) AND 
 	 Rel (sel)( , var__temp_h'1618, res ) ==((sel)( , var__temp_h1616, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1618, other ) ==(sel)( , var__temp_h1616, other ) => 
 	 True
 
VC_END(declare-const var_h_i1601 T5763)
(declare-const var_h1600 T5763)
(declare-const v Int)
(declare-const var_h_i1569 T5763)
(declare-const var_h1568 T5763)
(declare-const v Int)
(declare-const var_h_i44 T5763)
(declare-const var_h43 T5763)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1616 T5763)
(declare-const var__temp_v1617 Int)
(declare-const |var__temp_h'1618| T5763)
(declare-const var__temp_v_err1619 T5764)
(declare-const var_h1600 T5763)
(declare-const var_h1568 T5763)
(declare-const var_h43 T5763)
(declare-const err T5777)

solver 
 (declare-sort T5763)
(declare-fun sel (T5763 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1600 () T5763)
(declare-fun var_h43 () T5763)
(declare-fun other () Int)
(declare-fun var__temp_h1616 () T5763)
(declare-fun |var__temp_h'1618| () T5763)
(declare-fun var__temp_v1617 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1600 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1616 res) v)
                (= (sel var__temp_h1616 res) (+ (sel var_h1600 res) 10))
                (= (sel var__temp_h1616 other) (sel var_h1600 other))))
      (a!2 (and (= (sel |var__temp_h'1618| res) var__temp_v1617)
                (= (sel |var__temp_h'1618| res) (+ (sel var__temp_h1616 res) 3))
                (= (sel |var__temp_h'1618| other) (sel var__temp_h1616 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1616 res) 7))
                (=> (= (sel var__temp_h1616 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************442
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1601 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1601, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1601, res ) ==((sel)( , var_h1600, res ) + (10))
 	 , (sel)( , var_h_i1601, other ) ==(sel)( , var_h1600, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1615:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1601 --->  Ty_heap  
 var_h1600 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1569 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1620 --->  Ty_heap  
 var__temp_v1621 --->  Ty_int  
 var__temp_h'1622 --->  Ty_heap  
 var__temp_v_err1623 --->  error  
 var_h1600 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1600, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1620, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1620, res ) ==((sel)( , var_h1600, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1620, other ) ==(sel)( , var_h1600, other ) => 
 	 Rel (sel)( , var__temp_h1620, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1620, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1622, res ) ==(var__temp_v1621) AND 
 	 Rel (sel)( , var__temp_h'1622, res ) ==((sel)( , var__temp_h1620, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1622, other ) ==(sel)( , var__temp_h1620, other ) => 
 	 True
 
VC_END(declare-const var_h_i1601 T5780)
(declare-const var_h1600 T5780)
(declare-const v Int)
(declare-const var_h_i1569 T5780)
(declare-const var_h1568 T5780)
(declare-const v Int)
(declare-const var_h_i44 T5780)
(declare-const var_h43 T5780)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1620 T5780)
(declare-const var__temp_v1621 Int)
(declare-const |var__temp_h'1622| T5780)
(declare-const var__temp_v_err1623 T5781)
(declare-const var_h1600 T5780)
(declare-const var_h1568 T5780)
(declare-const var_h43 T5780)
(declare-const err T5794)

solver 
 (declare-sort T5780)
(declare-fun sel (T5780 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1600 () T5780)
(declare-fun var_h43 () T5780)
(declare-fun other () Int)
(declare-fun var__temp_h1620 () T5780)
(declare-fun |var__temp_h'1622| () T5780)
(declare-fun var__temp_v1621 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1600 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1620 res) v)
                (= (sel var__temp_h1620 res) (+ (sel var_h1600 res) 10))
                (= (sel var__temp_h1620 other) (sel var_h1600 other))))
      (a!2 (and (= (sel |var__temp_h'1622| res) var__temp_v1621)
                (= (sel |var__temp_h'1622| res) (+ (sel var__temp_h1620 res) 5))
                (= (sel |var__temp_h'1622| other) (sel var__temp_h1620 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1620 res) 7))
                (=> (= (sel var__temp_h1620 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************443
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1601 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1601, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1601, res ) ==((sel)( , var_h1600, res ) + (10))
 	 , (sel)( , var_h_i1601, other ) ==(sel)( , var_h1600, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1615:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1601 --->  Ty_heap  
 var_h1600 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1569 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1624 --->  Ty_heap  
 var__temp_v1625 --->  Ty_int  
 var__temp_h'1626 --->  Ty_heap  
 var__temp_v_err1627 --->  error  
 var_h1600 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1600, res ) > (4) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1624, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1624, res ) ==((sel)( , var_h1600, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1624, other ) ==(sel)( , var_h1600, other ) => 
 	 Rel (sel)( , var__temp_h1624, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1624, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1626, res ) ==(var__temp_v1625) AND 
 	 Rel (sel)( , var__temp_h'1626, res ) ==((sel)( , var__temp_h1624, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1626, other ) ==(sel)( , var__temp_h1624, other ) => 
 	 True
 
VC_END(declare-const var_h_i1601 T5797)
(declare-const var_h1600 T5797)
(declare-const v Int)
(declare-const var_h_i1569 T5797)
(declare-const var_h1568 T5797)
(declare-const v Int)
(declare-const var_h_i44 T5797)
(declare-const var_h43 T5797)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1624 T5797)
(declare-const var__temp_v1625 Int)
(declare-const |var__temp_h'1626| T5797)
(declare-const var__temp_v_err1627 T5798)
(declare-const var_h1600 T5797)
(declare-const var_h1568 T5797)
(declare-const var_h43 T5797)
(declare-const err T5811)

solver 
 (declare-sort T5797)
(declare-fun sel (T5797 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1600 () T5797)
(declare-fun var_h43 () T5797)
(declare-fun other () Int)
(declare-fun var__temp_h1624 () T5797)
(declare-fun |var__temp_h'1626| () T5797)
(declare-fun var__temp_v1625 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1600 res) 4))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1624 res) v)
                (= (sel var__temp_h1624 res) (+ (sel var_h1600 res) 10))
                (= (sel var__temp_h1624 other) (sel var_h1600 other))))
      (a!2 (and (= (sel |var__temp_h'1626| res) var__temp_v1625)
                (= (sel |var__temp_h'1626| res) (+ (sel var__temp_h1624 res) 2))
                (= (sel |var__temp_h'1626| other) (sel var__temp_h1624 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1624 res) 5))
                (=> (= (sel var__temp_h1624 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************444
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 
 	 --foo
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1569 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1569, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1569, other ) ==(sel)( , var_h1568, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1628:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************445
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1569 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1569, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1569, other ) ==(sel)( , var_h1568, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1628:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1569 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1629 --->  Ty_heap  
 var__temp_v1630 --->  Ty_int  
 var__temp_h'1631 --->  Ty_heap  
 var__temp_v_err1632 --->  error  
 var_h1568 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1629, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1629, other ) ==(sel)( , var_h1568, other ) => 
 	 Rel (sel)( , var__temp_h1629, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1629, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1631, res ) ==(var__temp_v1630) AND 
 	 Rel (sel)( , var__temp_h'1631, res ) ==((sel)( , var__temp_h1629, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1631, other ) ==(sel)( , var__temp_h1629, other ) => 
 	 True
 
VC_END(declare-const var_h_i1569 T5814)
(declare-const var_h1568 T5814)
(declare-const v Int)
(declare-const var_h_i44 T5814)
(declare-const var_h43 T5814)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1629 T5814)
(declare-const var__temp_v1630 Int)
(declare-const |var__temp_h'1631| T5814)
(declare-const var__temp_v_err1632 T5815)
(declare-const var_h1568 T5814)
(declare-const var_h43 T5814)
(declare-const err T5828)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5814)
(declare-fun sel (T5814 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5814)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1629 () T5814)
(declare-fun |var__temp_h'1631| () T5814)
(declare-fun var__temp_v1630 () Int)
(declare-fun var_h1568 () T5814)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1629 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1629 other) (sel var_h1568 other)))
               (= (sel var__temp_h1629 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1631| res) var__temp_v1630)
                (= (sel |var__temp_h'1631| res) (+ (sel var__temp_h1629 res) 3))
                (= (sel |var__temp_h'1631| other) (sel var__temp_h1629 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1629 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************446
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1569 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1569, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1569, other ) ==(sel)( , var_h1568, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1628:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1569 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1633 --->  Ty_heap  
 var__temp_v1634 --->  Ty_int  
 var__temp_h'1635 --->  Ty_heap  
 var__temp_v_err1636 --->  error  
 var_h1568 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1633, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1633, other ) ==(sel)( , var_h1568, other ) => 
 	 Rel (sel)( , var__temp_h1633, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1633, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1635, res ) ==(var__temp_v1634) AND 
 	 Rel (sel)( , var__temp_h'1635, res ) ==((sel)( , var__temp_h1633, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1635, other ) ==(sel)( , var__temp_h1633, other ) => 
 	 True
 
VC_END(declare-const var_h_i1569 T5831)
(declare-const var_h1568 T5831)
(declare-const v Int)
(declare-const var_h_i44 T5831)
(declare-const var_h43 T5831)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1633 T5831)
(declare-const var__temp_v1634 Int)
(declare-const |var__temp_h'1635| T5831)
(declare-const var__temp_v_err1636 T5832)
(declare-const var_h1568 T5831)
(declare-const var_h43 T5831)
(declare-const err T5845)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5831)
(declare-fun sel (T5831 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5831)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1633 () T5831)
(declare-fun |var__temp_h'1635| () T5831)
(declare-fun var__temp_v1634 () Int)
(declare-fun var_h1568 () T5831)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1633 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1633 other) (sel var_h1568 other)))
               (= (sel var__temp_h1633 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1635| res) var__temp_v1634)
                (= (sel |var__temp_h'1635| res) (+ (sel var__temp_h1633 res) 5))
                (= (sel |var__temp_h'1635| other) (sel var__temp_h1633 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1633 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************447
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1569 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1569, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1569, other ) ==(sel)( , var_h1568, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1628:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1569 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1637 --->  Ty_heap  
 var__temp_v1638 --->  Ty_int  
 var__temp_h'1639 --->  Ty_heap  
 var__temp_v_err1640 --->  error  
 var_h1568 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1637, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1637, other ) ==(sel)( , var_h1568, other ) => 
 	 Rel (sel)( , var__temp_h1637, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1637, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1639, res ) ==(var__temp_v1638) AND 
 	 Rel (sel)( , var__temp_h'1639, res ) ==((sel)( , var__temp_h1637, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1639, other ) ==(sel)( , var__temp_h1637, other ) => 
 	 True
 
VC_END(declare-const var_h_i1569 T5848)
(declare-const var_h1568 T5848)
(declare-const v Int)
(declare-const var_h_i44 T5848)
(declare-const var_h43 T5848)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1637 T5848)
(declare-const var__temp_v1638 Int)
(declare-const |var__temp_h'1639| T5848)
(declare-const var__temp_v_err1640 T5849)
(declare-const var_h1568 T5848)
(declare-const var_h43 T5848)
(declare-const err T5862)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5848)
(declare-fun sel (T5848 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5848)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1637 () T5848)
(declare-fun |var__temp_h'1639| () T5848)
(declare-fun var__temp_v1638 () Int)
(declare-fun var_h1568 () T5848)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1637 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1637 other) (sel var_h1568 other)))
               (= (sel var__temp_h1637 res) 5)))
      (a!2 (and (= (sel |var__temp_h'1639| res) var__temp_v1638)
                (= (sel |var__temp_h'1639| res) (+ (sel var__temp_h1637 res) 2))
                (= (sel |var__temp_h'1639| other) (sel var__temp_h1637 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1637 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************bar
PARTIAL PATH NEW
SUB 
 	 --bar
 	 --foo
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1642 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1642 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1642, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1642, res ) ==((sel)( , var_h1641, res ) + (2))
 	 , (sel)( , var_h_i1642, other ) ==(sel)( , var_h1641, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1643:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1642 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************448
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1642 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1642, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1642, res ) ==((sel)( , var_h1641, res ) + (2))
 	 , (sel)( , var_h_i1642, other ) ==(sel)( , var_h1641, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1643:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1642 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1642 --->  Ty_heap  
 var_h1641 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1569 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1644 --->  Ty_heap  
 var__temp_v1645 --->  Ty_int  
 var__temp_h'1646 --->  Ty_heap  
 var__temp_v_err1647 --->  error  
 var_h1641 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1641, res ) ==(5) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1644, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1644, res ) ==((sel)( , var_h1641, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h1644, other ) ==(sel)( , var_h1641, other ) => 
 	 Rel (sel)( , var__temp_h1644, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1644, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1646, res ) ==(var__temp_v1645) AND 
 	 Rel (sel)( , var__temp_h'1646, res ) ==((sel)( , var__temp_h1644, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1646, other ) ==(sel)( , var__temp_h1644, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1646, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1646, other ) > (4)
 
VC_END(declare-const var_h_i1642 T5865)
(declare-const var_h1641 T5865)
(declare-const v Int)
(declare-const var_h_i1569 T5865)
(declare-const var_h1568 T5865)
(declare-const v Int)
(declare-const var_h_i44 T5865)
(declare-const var_h43 T5865)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1644 T5865)
(declare-const var__temp_v1645 Int)
(declare-const |var__temp_h'1646| T5865)
(declare-const var__temp_v_err1647 T5866)
(declare-const var_h1641 T5865)
(declare-const var_h1568 T5865)
(declare-const var_h43 T5865)
(declare-const err T5879)

solver 
 (declare-sort T5865)
(declare-fun sel (T5865 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1641 () T5865)
(declare-fun var_h43 () T5865)
(declare-fun other () Int)
(declare-fun |var__temp_h'1646| () T5865)
(declare-fun var__temp_h1644 () T5865)
(declare-fun var__temp_v1645 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1641 res) 5))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1644 res) v)
                (= (sel var__temp_h1644 res) (+ (sel var_h1641 res) 2))
                (= (sel var__temp_h1644 other) (sel var_h1641 other))))
      (a!2 (and (= (sel |var__temp_h'1646| res) var__temp_v1645)
                (= (sel |var__temp_h'1646| res) (+ (sel var__temp_h1644 res) 3))
                (= (sel |var__temp_h'1646| other) (sel var__temp_h1644 other))))
      (a!3 (and (= (sel |var__temp_h'1646| res) 10)
                (not (> (sel |var__temp_h'1646| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1644 res) 7))
                (=> (= (sel var__temp_h1644 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************449
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1642 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1642, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1642, res ) ==((sel)( , var_h1641, res ) + (2))
 	 , (sel)( , var_h_i1642, other ) ==(sel)( , var_h1641, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1643:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1642 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1642 --->  Ty_heap  
 var_h1641 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1569 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1648 --->  Ty_heap  
 var__temp_v1649 --->  Ty_int  
 var__temp_h'1650 --->  Ty_heap  
 var__temp_v_err1651 --->  error  
 var_h1641 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1641, res ) ==(5) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1648, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1648, res ) ==((sel)( , var_h1641, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h1648, other ) ==(sel)( , var_h1641, other ) => 
 	 Rel (sel)( , var__temp_h1648, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1648, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1650, res ) ==(var__temp_v1649) AND 
 	 Rel (sel)( , var__temp_h'1650, res ) ==((sel)( , var__temp_h1648, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1650, other ) ==(sel)( , var__temp_h1648, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1650, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1650, other ) > (4)
 
VC_END(declare-const var_h_i1642 T5882)
(declare-const var_h1641 T5882)
(declare-const v Int)
(declare-const var_h_i1569 T5882)
(declare-const var_h1568 T5882)
(declare-const v Int)
(declare-const var_h_i44 T5882)
(declare-const var_h43 T5882)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1648 T5882)
(declare-const var__temp_v1649 Int)
(declare-const |var__temp_h'1650| T5882)
(declare-const var__temp_v_err1651 T5883)
(declare-const var_h1641 T5882)
(declare-const var_h1568 T5882)
(declare-const var_h43 T5882)
(declare-const err T5896)

solver 
 (declare-sort T5882)
(declare-fun sel (T5882 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1641 () T5882)
(declare-fun var_h43 () T5882)
(declare-fun other () Int)
(declare-fun |var__temp_h'1650| () T5882)
(declare-fun var__temp_h1648 () T5882)
(declare-fun var__temp_v1649 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1641 res) 5))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1648 res) v)
                (= (sel var__temp_h1648 res) (+ (sel var_h1641 res) 2))
                (= (sel var__temp_h1648 other) (sel var_h1641 other))))
      (a!2 (and (= (sel |var__temp_h'1650| res) var__temp_v1649)
                (= (sel |var__temp_h'1650| res) (+ (sel var__temp_h1648 res) 5))
                (= (sel |var__temp_h'1650| other) (sel var__temp_h1648 other))))
      (a!3 (and (= (sel |var__temp_h'1650| res) 10)
                (not (> (sel |var__temp_h'1650| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1648 res) 7))
                (=> (= (sel var__temp_h1648 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************450
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1643:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1643:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbarc2foofoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1642 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1642, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1642, res ) ==((sel)( , var_h1641, res ) + (2))
 	 , (sel)( , var_h_i1642, other ) ==(sel)( , var_h1641, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1652:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************451
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1642 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1642, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1642, res ) ==((sel)( , var_h1641, res ) + (2))
 	 , (sel)( , var_h_i1642, other ) ==(sel)( , var_h1641, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1652:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1642 --->  Ty_heap  
 var_h1641 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1569 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1653 --->  Ty_heap  
 var__temp_v1654 --->  Ty_int  
 var__temp_h'1655 --->  Ty_heap  
 var__temp_v_err1656 --->  error  
 var_h1641 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1641, res ) ==(5) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1653, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1653, res ) ==((sel)( , var_h1641, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h1653, other ) ==(sel)( , var_h1641, other ) => 
 	 Rel (sel)( , var__temp_h1653, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1653, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1655, res ) ==(var__temp_v1654) AND 
 	 Rel (sel)( , var__temp_h'1655, res ) ==((sel)( , var__temp_h1653, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1655, other ) ==(sel)( , var__temp_h1653, other ) => 
 	 True
 
VC_END(declare-const var_h_i1642 T5899)
(declare-const var_h1641 T5899)
(declare-const v Int)
(declare-const var_h_i1569 T5899)
(declare-const var_h1568 T5899)
(declare-const v Int)
(declare-const var_h_i44 T5899)
(declare-const var_h43 T5899)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1653 T5899)
(declare-const var__temp_v1654 Int)
(declare-const |var__temp_h'1655| T5899)
(declare-const var__temp_v_err1656 T5900)
(declare-const var_h1641 T5899)
(declare-const var_h1568 T5899)
(declare-const var_h43 T5899)
(declare-const err T5913)

solver 
 (declare-sort T5899)
(declare-fun sel (T5899 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1641 () T5899)
(declare-fun var_h43 () T5899)
(declare-fun other () Int)
(declare-fun var__temp_h1653 () T5899)
(declare-fun |var__temp_h'1655| () T5899)
(declare-fun var__temp_v1654 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1641 res) 5))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1653 res) v)
                (= (sel var__temp_h1653 res) (+ (sel var_h1641 res) 2))
                (= (sel var__temp_h1653 other) (sel var_h1641 other))))
      (a!2 (and (= (sel |var__temp_h'1655| res) var__temp_v1654)
                (= (sel |var__temp_h'1655| res) (+ (sel var__temp_h1653 res) 3))
                (= (sel |var__temp_h'1655| other) (sel var__temp_h1653 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1653 res) 7))
                (=> (= (sel var__temp_h1653 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************baz
PARTIAL PATH NEW
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1658 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1658 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1658, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1658, res ) ==((sel)( , var_h1657, res ) + (3))
 	 , (sel)( , var_h_i1658, other ) ==(sel)( , var_h1657, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1659:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1658 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************452
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1658 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1658, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1658, res ) ==((sel)( , var_h1657, res ) + (3))
 	 , (sel)( , var_h_i1658, other ) ==(sel)( , var_h1657, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1659:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1658 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1658 --->  Ty_heap  
 var_h1657 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1642 --->  Ty_heap  
 var_h1641 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1569 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1660 --->  Ty_heap  
 var__temp_v1661 --->  Ty_int  
 var__temp_h'1662 --->  Ty_heap  
 var__temp_v_err1663 --->  error  
 var_h1657 --->  Ty_heap  
 var_h1641 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1657, res ) ==(7) AND 
 	 Rel (sel)( , var_h1641, res ) ==(5) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1660, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1660, res ) ==((sel)( , var_h1657, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h1660, other ) ==(sel)( , var_h1657, other ) => 
 	 Rel (sel)( , var__temp_h1660, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1660, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1662, res ) ==(var__temp_v1661) AND 
 	 Rel (sel)( , var__temp_h'1662, res ) ==((sel)( , var__temp_h1660, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1662, other ) ==(sel)( , var__temp_h1660, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1662, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1662, other ) > (4)
 
VC_END(declare-const var_h_i1658 T5916)
(declare-const var_h1657 T5916)
(declare-const v Int)
(declare-const var_h_i1642 T5916)
(declare-const var_h1641 T5916)
(declare-const v Int)
(declare-const var_h_i1569 T5916)
(declare-const var_h1568 T5916)
(declare-const v Int)
(declare-const var_h_i44 T5916)
(declare-const var_h43 T5916)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1660 T5916)
(declare-const var__temp_v1661 Int)
(declare-const |var__temp_h'1662| T5916)
(declare-const var__temp_v_err1663 T5917)
(declare-const var_h1657 T5916)
(declare-const var_h1641 T5916)
(declare-const var_h1568 T5916)
(declare-const var_h43 T5916)
(declare-const err T5930)

solver 
 (declare-sort T5916)
(declare-fun sel (T5916 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1657 () T5916)
(declare-fun var_h1641 () T5916)
(declare-fun var_h43 () T5916)
(declare-fun other () Int)
(declare-fun |var__temp_h'1662| () T5916)
(declare-fun var__temp_h1660 () T5916)
(declare-fun var__temp_v1661 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1657 res) 7))
(assert (= (sel var_h1641 res) 5))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1660 res) v)
                (= (sel var__temp_h1660 res) (+ (sel var_h1657 res) 3))
                (= (sel var__temp_h1660 other) (sel var_h1657 other))))
      (a!2 (and (= (sel |var__temp_h'1662| res) var__temp_v1661)
                (= (sel |var__temp_h'1662| res) (+ (sel var__temp_h1660 res) 5))
                (= (sel |var__temp_h'1662| other) (sel var__temp_h1660 other))))
      (a!3 (and (= (sel |var__temp_h'1662| res) 10)
                (not (> (sel |var__temp_h'1662| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1660 res) 7))
                (=> (= (sel var__temp_h1660 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************453
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1659:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1659:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbazbarc2foofoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1658 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1658, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1658, res ) ==((sel)( , var_h1657, res ) + (3))
 	 , (sel)( , var_h_i1658, other ) ==(sel)( , var_h1657, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1664:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************454
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1658 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1658, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1658, res ) ==((sel)( , var_h1657, res ) + (3))
 	 , (sel)( , var_h_i1658, other ) ==(sel)( , var_h1657, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1664:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1658 --->  Ty_heap  
 var_h1657 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1642 --->  Ty_heap  
 var_h1641 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1569 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1665 --->  Ty_heap  
 var__temp_v1666 --->  Ty_int  
 var__temp_h'1667 --->  Ty_heap  
 var__temp_v_err1668 --->  error  
 var_h1657 --->  Ty_heap  
 var_h1641 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1657, res ) ==(7) AND 
 	 Rel (sel)( , var_h1641, res ) ==(5) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1665, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1665, res ) ==((sel)( , var_h1657, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h1665, other ) ==(sel)( , var_h1657, other ) => 
 	 Rel (sel)( , var__temp_h1665, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1665, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1667, res ) ==(var__temp_v1666) AND 
 	 Rel (sel)( , var__temp_h'1667, res ) ==((sel)( , var__temp_h1665, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1667, other ) ==(sel)( , var__temp_h1665, other ) => 
 	 True
 
VC_END(declare-const var_h_i1658 T5933)
(declare-const var_h1657 T5933)
(declare-const v Int)
(declare-const var_h_i1642 T5933)
(declare-const var_h1641 T5933)
(declare-const v Int)
(declare-const var_h_i1569 T5933)
(declare-const var_h1568 T5933)
(declare-const v Int)
(declare-const var_h_i44 T5933)
(declare-const var_h43 T5933)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1665 T5933)
(declare-const var__temp_v1666 Int)
(declare-const |var__temp_h'1667| T5933)
(declare-const var__temp_v_err1668 T5934)
(declare-const var_h1657 T5933)
(declare-const var_h1641 T5933)
(declare-const var_h1568 T5933)
(declare-const var_h43 T5933)
(declare-const err T5947)

solver 
 (declare-sort T5933)
(declare-fun sel (T5933 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1657 () T5933)
(declare-fun var_h1641 () T5933)
(declare-fun var_h43 () T5933)
(declare-fun other () Int)
(declare-fun var__temp_h1665 () T5933)
(declare-fun |var__temp_h'1667| () T5933)
(declare-fun var__temp_v1666 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1657 res) 7))
(assert (= (sel var_h1641 res) 5))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1665 res) v)
                (= (sel var__temp_h1665 res) (+ (sel var_h1657 res) 3))
                (= (sel var__temp_h1665 other) (sel var_h1657 other))))
      (a!2 (and (= (sel |var__temp_h'1667| res) var__temp_v1666)
                (= (sel |var__temp_h'1667| res) (+ (sel var__temp_h1665 res) 5))
                (= (sel |var__temp_h'1667| other) (sel var__temp_h1665 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1665 res) 7))
                (=> (= (sel var__temp_h1665 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************455
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT baz
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1642 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1642, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1642, res ) ==((sel)( , var_h1641, res ) + (2))
 	 , (sel)( , var_h_i1642, other ) ==(sel)( , var_h1641, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1669:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************456
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1642 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1642, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1642, res ) ==((sel)( , var_h1641, res ) + (2))
 	 , (sel)( , var_h_i1642, other ) ==(sel)( , var_h1641, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1669:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1642 --->  Ty_heap  
 var_h1641 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1569 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1670 --->  Ty_heap  
 var__temp_v1671 --->  Ty_int  
 var__temp_h'1672 --->  Ty_heap  
 var__temp_v_err1673 --->  error  
 var_h1641 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1641, res ) ==(5) AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1670, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1670, res ) ==((sel)( , var_h1641, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h1670, other ) ==(sel)( , var_h1641, other ) => 
 	 Rel (sel)( , var__temp_h1670, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1670, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1672, res ) ==(var__temp_v1671) AND 
 	 Rel (sel)( , var__temp_h'1672, res ) ==((sel)( , var__temp_h1670, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1672, other ) ==(sel)( , var__temp_h1670, other ) => 
 	 True
 
VC_END(declare-const var_h_i1642 T5950)
(declare-const var_h1641 T5950)
(declare-const v Int)
(declare-const var_h_i1569 T5950)
(declare-const var_h1568 T5950)
(declare-const v Int)
(declare-const var_h_i44 T5950)
(declare-const var_h43 T5950)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1670 T5950)
(declare-const var__temp_v1671 Int)
(declare-const |var__temp_h'1672| T5950)
(declare-const var__temp_v_err1673 T5951)
(declare-const var_h1641 T5950)
(declare-const var_h1568 T5950)
(declare-const var_h43 T5950)
(declare-const err T5964)

solver 
 (declare-sort T5950)
(declare-fun sel (T5950 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1641 () T5950)
(declare-fun var_h43 () T5950)
(declare-fun other () Int)
(declare-fun var__temp_h1670 () T5950)
(declare-fun |var__temp_h'1672| () T5950)
(declare-fun var__temp_v1671 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1641 res) 5))
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1670 res) v)
                (= (sel var__temp_h1670 res) (+ (sel var_h1641 res) 2))
                (= (sel var__temp_h1670 other) (sel var_h1641 other))))
      (a!2 (and (= (sel |var__temp_h'1672| res) var__temp_v1671)
                (= (sel |var__temp_h'1672| res) (+ (sel var__temp_h1670 res) 5))
                (= (sel |var__temp_h'1672| other) (sel var__temp_h1670 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1670 res) 7))
                (=> (= (sel var__temp_h1670 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c5
PARTIAL PATH NEW
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --c3'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1675 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1675 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1675, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1675, res ) ==((sel)( , var_h1674, res ) + (5))
 	 , (sel)( , var_h_i1675, other ) ==(sel)( , var_h1674, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1676:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1675 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************457
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1676:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1676:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc5bazbarc2foofoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1675 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1675, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1675, res ) ==((sel)( , var_h1674, res ) + (5))
 	 , (sel)( , var_h_i1675, other ) ==(sel)( , var_h1674, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1677:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************458
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1642 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1642, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1642, res ) ==((sel)( , var_h1641, res ) + (2))
 	 , (sel)( , var_h_i1642, other ) ==(sel)( , var_h1641, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1678:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************459
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --foo
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1569 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1569, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1569, other ) ==(sel)( , var_h1568, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1679:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************460
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1569 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1569, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1569, other ) ==(sel)( , var_h1568, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1679:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1569 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1680 --->  Ty_heap  
 var__temp_v1681 --->  Ty_int  
 var__temp_h'1682 --->  Ty_heap  
 var__temp_v_err1683 --->  error  
 var_h1568 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1680, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1680, other ) ==(sel)( , var_h1568, other ) => 
 	 Rel (sel)( , var__temp_h1680, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1680, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1682, res ) ==(var__temp_v1681) AND 
 	 Rel (sel)( , var__temp_h'1682, res ) ==((sel)( , var__temp_h1680, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1682, other ) ==(sel)( , var__temp_h1680, other ) => 
 	 True
 
VC_END(declare-const var_h_i1569 T5967)
(declare-const var_h1568 T5967)
(declare-const v Int)
(declare-const var_h_i44 T5967)
(declare-const var_h43 T5967)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1680 T5967)
(declare-const var__temp_v1681 Int)
(declare-const |var__temp_h'1682| T5967)
(declare-const var__temp_v_err1683 T5968)
(declare-const var_h1568 T5967)
(declare-const var_h43 T5967)
(declare-const err T5981)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5967)
(declare-fun sel (T5967 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5967)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1680 () T5967)
(declare-fun |var__temp_h'1682| () T5967)
(declare-fun var__temp_v1681 () Int)
(declare-fun var_h1568 () T5967)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1680 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1680 other) (sel var_h1568 other)))
               (= (sel var__temp_h1680 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1682| res) var__temp_v1681)
                (= (sel |var__temp_h'1682| res) (+ (sel var__temp_h1680 res) 3))
                (= (sel |var__temp_h'1682| other) (sel var__temp_h1680 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1680 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************461
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1569 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1569, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1569, other ) ==(sel)( , var_h1568, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1679:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1569 --->  Ty_heap  
 var_h1568 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1684 --->  Ty_heap  
 var__temp_v1685 --->  Ty_int  
 var__temp_h'1686 --->  Ty_heap  
 var__temp_v_err1687 --->  error  
 var_h1568 --->  Ty_heap  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1684, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1684, other ) ==(sel)( , var_h1568, other ) => 
 	 Rel (sel)( , var__temp_h1684, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1684, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1686, res ) ==(var__temp_v1685) AND 
 	 Rel (sel)( , var__temp_h'1686, res ) ==((sel)( , var__temp_h1684, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1686, other ) ==(sel)( , var__temp_h1684, other ) => 
 	 True
 
VC_END(declare-const var_h_i1569 T5984)
(declare-const var_h1568 T5984)
(declare-const v Int)
(declare-const var_h_i44 T5984)
(declare-const var_h43 T5984)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1684 T5984)
(declare-const var__temp_v1685 Int)
(declare-const |var__temp_h'1686| T5984)
(declare-const var__temp_v_err1687 T5985)
(declare-const var_h1568 T5984)
(declare-const var_h43 T5984)
(declare-const err T5998)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5984)
(declare-fun sel (T5984 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T5984)
(declare-fun other () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_h1684 () T5984)
(declare-fun |var__temp_h'1686| () T5984)
(declare-fun var__temp_v1685 () Int)
(declare-fun var_h1568 () T5984)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1684 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1684 other) (sel var_h1568 other)))
               (= (sel var__temp_h1684 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1686| res) var__temp_v1685)
                (= (sel |var__temp_h'1686| res) (+ (sel var__temp_h1684 res) 5))
                (= (sel |var__temp_h'1686| other) (sel var__temp_h1684 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1684 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************462
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT bar
PARTIAL PATH
SUB 
 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1688:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
bar
 *********************Enumeration Iteration*****************463
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1688:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1689 --->  Ty_heap  
 var__temp_v1690 --->  Ty_int  
 var__temp_h'1691 --->  Ty_heap  
 var__temp_v_err1692 --->  error  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1689, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1689, res ) ==((sel)( , var_h43, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h1689, other ) ==((sel)( , var_h43, other ) + (5)) => 
 	 Rel (sel)( , var__temp_h1689, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1689, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1691, res ) ==(var__temp_v1690) AND 
 	 Rel (sel)( , var__temp_h'1691, res ) ==((sel)( , var__temp_h1689, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1691, other ) ==(sel)( , var__temp_h1689, other ) => 
 	 True
 
VC_END(declare-const var_h_i44 T6001)
(declare-const var_h43 T6001)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1689 T6001)
(declare-const var__temp_v1690 Int)
(declare-const |var__temp_h'1691| T6001)
(declare-const var__temp_v_err1692 T6002)
(declare-const var_h43 T6001)
(declare-const err T6015)

solver 
 (declare-sort T6001)
(declare-fun sel (T6001 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T6001)
(declare-fun other () Int)
(declare-fun var__temp_h1689 () T6001)
(declare-fun |var__temp_h'1691| () T6001)
(declare-fun var__temp_v1690 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1689 res) v)
                (= (sel var__temp_h1689 res) (+ (sel var_h43 res) 3))
                (= (sel var__temp_h1689 other) (+ (sel var_h43 other) 5))))
      (a!2 (and (= (sel |var__temp_h'1691| res) var__temp_v1690)
                (= (sel |var__temp_h'1691| res) (+ (sel var__temp_h1689 res) 3))
                (= (sel |var__temp_h'1691| other) (sel var__temp_h1689 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1689 res) 7))
                (=> (= (sel var__temp_h1689 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************464
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1688:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1693 --->  Ty_heap  
 var__temp_v1694 --->  Ty_int  
 var__temp_h'1695 --->  Ty_heap  
 var__temp_v_err1696 --->  error  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1693, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1693, res ) ==((sel)( , var_h43, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h1693, other ) ==((sel)( , var_h43, other ) + (5)) => 
 	 Rel (sel)( , var__temp_h1693, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1693, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1695, res ) ==(var__temp_v1694) AND 
 	 Rel (sel)( , var__temp_h'1695, res ) ==((sel)( , var__temp_h1693, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1695, other ) ==(sel)( , var__temp_h1693, other ) => 
 	 True
 
VC_END(declare-const var_h_i44 T6018)
(declare-const var_h43 T6018)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1693 T6018)
(declare-const var__temp_v1694 Int)
(declare-const |var__temp_h'1695| T6018)
(declare-const var__temp_v_err1696 T6019)
(declare-const var_h43 T6018)
(declare-const err T6032)

solver 
 (declare-sort T6018)
(declare-fun sel (T6018 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T6018)
(declare-fun other () Int)
(declare-fun var__temp_h1693 () T6018)
(declare-fun |var__temp_h'1695| () T6018)
(declare-fun var__temp_v1694 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1693 res) v)
                (= (sel var__temp_h1693 res) (+ (sel var_h43 res) 3))
                (= (sel var__temp_h1693 other) (+ (sel var_h43 other) 5))))
      (a!2 (and (= (sel |var__temp_h'1695| res) var__temp_v1694)
                (= (sel |var__temp_h'1695| res) (+ (sel var__temp_h1693 res) 5))
                (= (sel |var__temp_h'1695| other) (sel var__temp_h1693 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1693 res) 7))
                (=> (= (sel var__temp_h1693 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************465
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1688:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1697 --->  Ty_heap  
 var__temp_v1698 --->  Ty_int  
 var__temp_h'1699 --->  Ty_heap  
 var__temp_v_err1700 --->  error  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1697, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1697, res ) ==((sel)( , var_h43, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h1697, other ) ==((sel)( , var_h43, other ) + (5)) => 
 	 Rel (sel)( , var__temp_h1697, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1697, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1699, res ) ==(var__temp_v1698) AND 
 	 Rel (sel)( , var__temp_h'1699, res ) ==((sel)( , var__temp_h1697, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'1699, other ) ==(sel)( , var__temp_h1697, other ) => 
 	 True
 
VC_END(declare-const var_h_i44 T6035)
(declare-const var_h43 T6035)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1697 T6035)
(declare-const var__temp_v1698 Int)
(declare-const |var__temp_h'1699| T6035)
(declare-const var__temp_v_err1700 T6036)
(declare-const var_h43 T6035)
(declare-const err T6049)

solver 
 (declare-sort T6035)
(declare-fun sel (T6035 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T6035)
(declare-fun other () Int)
(declare-fun var__temp_h1697 () T6035)
(declare-fun |var__temp_h'1699| () T6035)
(declare-fun var__temp_v1698 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1697 res) v)
                (= (sel var__temp_h1697 res) (+ (sel var_h43 res) 3))
                (= (sel var__temp_h1697 other) (+ (sel var_h43 other) 5))))
      (a!2 (and (= (sel |var__temp_h'1699| res) var__temp_v1698)
                (= (sel |var__temp_h'1699| res)
                   (+ (sel var__temp_h1697 res) 10))
                (= (sel |var__temp_h'1699| other) (sel var__temp_h1697 other)))))
(let ((a!3 (and (=> a!1 (> (sel var__temp_h1697 res) 4))
                (=> (> (sel var__temp_h1697 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************466
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i44 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i44, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i44, res ) ==((sel)( , var_h43, res ) + (3))
 	 , (sel)( , var_h_i44, other ) ==((sel)( , var_h43, other ) + (5)) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1688:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i44 --->  Ty_heap  
 var_h43 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1701 --->  Ty_heap  
 var__temp_v1702 --->  Ty_int  
 var__temp_h'1703 --->  Ty_heap  
 var__temp_v_err1704 --->  error  
 var_h43 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h43, res ) > (8) AND 
 	 Rel (sel)( , var_h43, other ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1701, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1701, res ) ==((sel)( , var_h43, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h1701, other ) ==((sel)( , var_h43, other ) + (5)) => 
 	 Rel (sel)( , var__temp_h1701, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1701, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1703, res ) ==(var__temp_v1702) AND 
 	 Rel (sel)( , var__temp_h'1703, res ) ==((sel)( , var__temp_h1701, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1703, other ) ==(sel)( , var__temp_h1701, other ) => 
 	 True
 
VC_END(declare-const var_h_i44 T6052)
(declare-const var_h43 T6052)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1701 T6052)
(declare-const var__temp_v1702 Int)
(declare-const |var__temp_h'1703| T6052)
(declare-const var__temp_v_err1704 T6053)
(declare-const var_h43 T6052)
(declare-const err T6066)

solver 
 (declare-sort T6052)
(declare-fun sel (T6052 Int) Int)
(declare-fun res () Int)
(declare-fun var_h43 () T6052)
(declare-fun other () Int)
(declare-fun var__temp_h1701 () T6052)
(declare-fun |var__temp_h'1703| () T6052)
(declare-fun var__temp_v1702 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h43 res) 8)))
(assert (= (sel var_h43 other) 0))
(assert (let ((a!1 (and (= (sel var__temp_h1701 res) v)
                (= (sel var__temp_h1701 res) (+ (sel var_h43 res) 3))
                (= (sel var__temp_h1701 other) (+ (sel var_h43 other) 5))))
      (a!2 (and (= (sel |var__temp_h'1703| res) var__temp_v1702)
                (= (sel |var__temp_h'1703| res) (+ (sel var__temp_h1701 res) 2))
                (= (sel |var__temp_h'1703| other) (sel var__temp_h1701 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1701 res) 5))
                (=> (= (sel var__temp_h1701 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************467
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo
PARTIAL PATH
SUB 
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {var_v1705:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c4
c2'
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************468
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {var_v1705:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1706 --->  Ty_heap  
 var__temp_v1707 --->  Ty_int  
 var__temp_h'1708 --->  Ty_heap  
 var__temp_v_err1709 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1706, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h1706, other ) ==(0) => 
 	 Rel (sel)( , var__temp_h1706, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1706, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1708, res ) ==(var__temp_v1707) AND 
 	 Rel (sel)( , var__temp_h'1708, res ) ==((sel)( , var__temp_h1706, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1708, other ) ==(sel)( , var__temp_h1706, other ) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1706 T6069)
(declare-const var__temp_v1707 Int)
(declare-const |var__temp_h'1708| T6069)
(declare-const var__temp_v_err1709 T6070)
(declare-const err T6083)

solver 
 (declare-sort T6069)
(declare-fun sel (T6069 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h1706 () T6069)
(declare-fun |var__temp_h'1708| () T6069)
(declare-fun res () Int)
(declare-fun var__temp_v1707 () Int)
(assert true)
(assert (let ((a!1 (=> (and (= (sel var__temp_h1706 res) 0)
                    (= (sel var__temp_h1706 other) 0))
               (= (sel var__temp_h1706 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1708| res) var__temp_v1707)
                (= (sel |var__temp_h'1708| res) (+ (sel var__temp_h1706 res) 3))
                (= (sel |var__temp_h'1708| other) (sel var__temp_h1706 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1706 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************469
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {var_v1705:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1710 --->  Ty_heap  
 var__temp_v1711 --->  Ty_int  
 var__temp_h'1712 --->  Ty_heap  
 var__temp_v_err1713 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1710, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h1710, other ) ==(0) => 
 	 Rel (sel)( , var__temp_h1710, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1710, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1712, res ) ==(var__temp_v1711) AND 
 	 Rel (sel)( , var__temp_h'1712, res ) ==((sel)( , var__temp_h1710, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1712, other ) ==(sel)( , var__temp_h1710, other ) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1710 T6086)
(declare-const var__temp_v1711 Int)
(declare-const |var__temp_h'1712| T6086)
(declare-const var__temp_v_err1713 T6087)
(declare-const err T6100)

solver 
 (declare-sort T6086)
(declare-fun sel (T6086 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h1710 () T6086)
(declare-fun |var__temp_h'1712| () T6086)
(declare-fun res () Int)
(declare-fun var__temp_v1711 () Int)
(assert true)
(assert (let ((a!1 (=> (and (= (sel var__temp_h1710 res) 0)
                    (= (sel var__temp_h1710 other) 0))
               (= (sel var__temp_h1710 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1712| res) var__temp_v1711)
                (= (sel |var__temp_h'1712| res) (+ (sel var__temp_h1710 res) 5))
                (= (sel |var__temp_h'1712| other) (sel var__temp_h1710 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1710 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************470
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (30) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {var_v1705:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1714 --->  Ty_heap  
 var__temp_v1715 --->  Ty_int  
 var__temp_h'1716 --->  Ty_heap  
 var__temp_v_err1717 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1714, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h1714, other ) ==(0) => 
 	 Rel (sel)( , var__temp_h1714, res ) > (30) AND 
 	 Rel (sel)( , var__temp_h1714, res ) > (30) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1716, res ) ==(var__temp_v1715) AND 
 	 Rel (sel)( , var__temp_h'1716, res ) ==((sel)( , var__temp_h1714, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1716, other ) ==(sel)( , var__temp_h1714, other ) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1714 T6103)
(declare-const var__temp_v1715 Int)
(declare-const |var__temp_h'1716| T6103)
(declare-const var__temp_v_err1717 T6104)
(declare-const err T6117)

solver 
 (declare-sort T6103)
(declare-fun sel (T6103 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h1714 () T6103)
(declare-fun |var__temp_h'1716| () T6103)
(declare-fun res () Int)
(declare-fun var__temp_v1715 () Int)
(assert true)
(assert (let ((a!1 (=> (and (= (sel var__temp_h1714 res) 0)
                    (= (sel var__temp_h1714 other) 0))
               (not (> (sel var__temp_h1714 res) 30))))
      (a!2 (and (= (sel |var__temp_h'1716| res) var__temp_v1715)
                (= (sel |var__temp_h'1716| res) (+ (sel var__temp_h1714 res) 5))
                (= (sel |var__temp_h'1716| other) (sel var__temp_h1714 other)))))
(let ((a!3 (=> (not (> (sel var__temp_h1714 res) 30)) (=> a!2 true))))
  (not (and a!1 a!3)))))

***************Selection Successful************c4
PARTIAL PATH NEW
SUB 
 	 --c4
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1719, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1719, res ) ==((sel)( , var_h1718, res ) + (5))
 	 , (sel)( , var_h_i1719, other ) ==(sel)( , var_h1718, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1720:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************471
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1719, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1719, res ) ==((sel)( , var_h1718, res ) + (5))
 	 , (sel)( , var_h_i1719, other ) ==(sel)( , var_h1718, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1720:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1721 --->  Ty_heap  
 var__temp_v1722 --->  Ty_int  
 var__temp_h'1723 --->  Ty_heap  
 var__temp_v_err1724 --->  error  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1721, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1721, res ) ==((sel)( , var_h1718, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h1721, other ) ==(sel)( , var_h1718, other ) => 
 	 Rel (sel)( , var__temp_h1721, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1721, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1723, res ) ==(var__temp_v1722) AND 
 	 Rel (sel)( , var__temp_h'1723, res ) ==((sel)( , var__temp_h1721, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1723, other ) ==(sel)( , var__temp_h1721, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1723, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1723, other ) > (4)
 
VC_END(declare-const var_h_i1719 T6120)
(declare-const var_h1718 T6120)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1721 T6120)
(declare-const var__temp_v1722 Int)
(declare-const |var__temp_h'1723| T6120)
(declare-const var__temp_v_err1724 T6121)
(declare-const var_h1718 T6120)
(declare-const err T6134)

solver 
 (declare-sort T6120)
(declare-fun sel (T6120 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T6120)
(declare-fun other () Int)
(declare-fun |var__temp_h'1723| () T6120)
(declare-fun var__temp_h1721 () T6120)
(declare-fun var__temp_v1722 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h1721 res) v)
                (= (sel var__temp_h1721 res) (+ (sel var_h1718 res) 5))
                (= (sel var__temp_h1721 other) (sel var_h1718 other))))
      (a!2 (and (= (sel |var__temp_h'1723| res) var__temp_v1722)
                (= (sel |var__temp_h'1723| res) (+ (sel var__temp_h1721 res) 3))
                (= (sel |var__temp_h'1723| other) (sel var__temp_h1721 other))))
      (a!3 (and (= (sel |var__temp_h'1723| res) 10)
                (not (> (sel |var__temp_h'1723| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1721 res) 7))
                (=> (= (sel var__temp_h1721 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************472
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1719, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1719, res ) ==((sel)( , var_h1718, res ) + (5))
 	 , (sel)( , var_h_i1719, other ) ==(sel)( , var_h1718, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1720:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1725 --->  Ty_heap  
 var__temp_v1726 --->  Ty_int  
 var__temp_h'1727 --->  Ty_heap  
 var__temp_v_err1728 --->  error  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1725, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1725, res ) ==((sel)( , var_h1718, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h1725, other ) ==(sel)( , var_h1718, other ) => 
 	 Rel (sel)( , var__temp_h1725, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1725, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1727, res ) ==(var__temp_v1726) AND 
 	 Rel (sel)( , var__temp_h'1727, res ) ==((sel)( , var__temp_h1725, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1727, other ) ==(sel)( , var__temp_h1725, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1727, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1727, other ) > (4)
 
VC_END(declare-const var_h_i1719 T6137)
(declare-const var_h1718 T6137)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1725 T6137)
(declare-const var__temp_v1726 Int)
(declare-const |var__temp_h'1727| T6137)
(declare-const var__temp_v_err1728 T6138)
(declare-const var_h1718 T6137)
(declare-const err T6151)

solver 
 (declare-sort T6137)
(declare-fun sel (T6137 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T6137)
(declare-fun other () Int)
(declare-fun |var__temp_h'1727| () T6137)
(declare-fun var__temp_h1725 () T6137)
(declare-fun var__temp_v1726 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h1725 res) v)
                (= (sel var__temp_h1725 res) (+ (sel var_h1718 res) 5))
                (= (sel var__temp_h1725 other) (sel var_h1718 other))))
      (a!2 (and (= (sel |var__temp_h'1727| res) var__temp_v1726)
                (= (sel |var__temp_h'1727| res) (+ (sel var__temp_h1725 res) 5))
                (= (sel |var__temp_h'1727| other) (sel var__temp_h1725 other))))
      (a!3 (and (= (sel |var__temp_h'1727| res) 10)
                (not (> (sel |var__temp_h'1727| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1725 res) 7))
                (=> (= (sel var__temp_h1725 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************473
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1719, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1719, res ) ==((sel)( , var_h1718, res ) + (5))
 	 , (sel)( , var_h_i1719, other ) ==(sel)( , var_h1718, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1720:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1729 --->  Ty_heap  
 var__temp_v1730 --->  Ty_int  
 var__temp_h'1731 --->  Ty_heap  
 var__temp_v_err1732 --->  error  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1729, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1729, res ) ==((sel)( , var_h1718, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h1729, other ) ==(sel)( , var_h1718, other ) => 
 	 Rel (sel)( , var__temp_h1729, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h1729, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1731, res ) ==(var__temp_v1730) AND 
 	 Rel (sel)( , var__temp_h1729, res ) ==(sel)( , var__temp_h1729, res ) AND 
 	 Rel (sel)( , var__temp_h'1731, other ) ==(sel)( , var__temp_h1729, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1731, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1731, other ) > (4)
 
VC_END(declare-const var_h_i1719 T6154)
(declare-const var_h1718 T6154)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1729 T6154)
(declare-const var__temp_v1730 Int)
(declare-const |var__temp_h'1731| T6154)
(declare-const var__temp_v_err1732 T6155)
(declare-const var_h1718 T6154)
(declare-const err T6168)

solver 
 (declare-sort T6154)
(declare-fun sel (T6154 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T6154)
(declare-fun other () Int)
(declare-fun |var__temp_h'1731| () T6154)
(declare-fun var__temp_h1729 () T6154)
(declare-fun var__temp_v1730 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h1729 res) v)
                (= (sel var__temp_h1729 res) (+ (sel var_h1718 res) 5))
                (= (sel var__temp_h1729 other) (sel var_h1718 other))))
      (a!3 (and (= (sel |var__temp_h'1731| res) 10)
                (not (> (sel |var__temp_h'1731| other) 4)))))
(let ((a!2 (=> a!1 (not (> (sel var__temp_h1729 res) 20))))
      (a!4 (=> (and (= (sel |var__temp_h'1731| res) var__temp_v1730)
                    (= (sel var__temp_h1729 res) (sel var__temp_h1729 res))
                    (= (sel |var__temp_h'1731| other)
                       (sel var__temp_h1729 other)))
               a!3)))
(let ((a!5 (=> (not (> (sel var__temp_h1729 res) 20)) a!4)))
  (not (and a!2 a!5))))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************474
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1719, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1719, res ) ==((sel)( , var_h1718, res ) + (5))
 	 , (sel)( , var_h_i1719, other ) ==(sel)( , var_h1718, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1720:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1733 --->  Ty_heap  
 var__temp_v1734 --->  Ty_int  
 var__temp_h'1735 --->  Ty_heap  
 var__temp_v_err1736 --->  error  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1733, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1733, res ) ==((sel)( , var_h1718, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h1733, other ) ==(sel)( , var_h1718, other ) => 
 	 Rel (sel)( , var__temp_h1733, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1733, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1735, res ) ==(var__temp_v1734) AND 
 	 Rel (sel)( , var__temp_h'1735, res ) ==((sel)( , var__temp_h1733, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'1735, other ) ==(sel)( , var__temp_h1733, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1735, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1735, other ) > (4)
 
VC_END(declare-const var_h_i1719 T6171)
(declare-const var_h1718 T6171)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1733 T6171)
(declare-const var__temp_v1734 Int)
(declare-const |var__temp_h'1735| T6171)
(declare-const var__temp_v_err1736 T6172)
(declare-const var_h1718 T6171)
(declare-const err T6185)

solver 
 (declare-sort T6171)
(declare-fun sel (T6171 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T6171)
(declare-fun other () Int)
(declare-fun |var__temp_h'1735| () T6171)
(declare-fun var__temp_h1733 () T6171)
(declare-fun var__temp_v1734 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h1733 res) v)
                (= (sel var__temp_h1733 res) (+ (sel var_h1718 res) 5))
                (= (sel var__temp_h1733 other) (sel var_h1718 other))))
      (a!2 (and (= (sel |var__temp_h'1735| res) var__temp_v1734)
                (= (sel |var__temp_h'1735| res)
                   (+ (sel var__temp_h1733 res) 10))
                (= (sel |var__temp_h'1735| other) (sel var__temp_h1733 other))))
      (a!3 (and (= (sel |var__temp_h'1735| res) 10)
                (not (> (sel |var__temp_h'1735| other) 4)))))
(let ((a!4 (and (=> a!1 (> (sel var__temp_h1733 res) 4))
                (=> (> (sel var__temp_h1733 res) 4) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************475
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1719, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1719, res ) ==((sel)( , var_h1718, res ) + (5))
 	 , (sel)( , var_h_i1719, other ) ==(sel)( , var_h1718, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1720:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1737 --->  Ty_heap  
 var__temp_v1738 --->  Ty_int  
 var__temp_h'1739 --->  Ty_heap  
 var__temp_v_err1740 --->  error  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1737, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1737, res ) ==((sel)( , var_h1718, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h1737, other ) ==(sel)( , var_h1718, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1739, res ) ==(var__temp_v1738) AND 
 	 Base var__temp_v1738 = 20 AND 
 	 Rel (sel)( , var__temp_h'1739, other ) ==(sel)( , var__temp_h1737, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1739, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1739, other ) > (4)
 
VC_END(declare-const var_h_i1719 T6188)
(declare-const var_h1718 T6188)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1737 T6188)
(declare-const var__temp_v1738 Int)
(declare-const |var__temp_h'1739| T6188)
(declare-const var__temp_v_err1740 T6189)
(declare-const var_h1718 T6188)
(declare-const err T6202)
    (declare-const |20| Int)
  
solver 
 (declare-sort T6188)
(declare-fun sel (T6188 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T6188)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'1739| () T6188)
(declare-fun var__temp_h1737 () T6188)
(declare-fun var__temp_v1738 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (and (= (sel var__temp_h1737 res) v)
                (= (sel var__temp_h1737 res) (+ (sel var_h1718 res) 5))
                (= (sel var__temp_h1737 other) (sel var_h1718 other))))
      (a!2 (and (= (sel |var__temp_h'1739| res) 10)
                (not (> (sel |var__temp_h'1739| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'1739| res) var__temp_v1738)
                    (= var__temp_v1738 |20|)
                    (= (sel |var__temp_h'1739| other)
                       (sel var__temp_h1737 other)))
               a!2)))
  (not (and (=> a!1 true) (=> true a!3))))))

***************Selection Failed************foo'
 *********************Enumeration Iteration*****************476
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1719, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1719, res ) ==((sel)( , var_h1718, res ) + (5))
 	 , (sel)( , var_h_i1719, other ) ==(sel)( , var_h1718, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1720:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1741 --->  Ty_heap  
 var__temp_v1742 --->  Ty_int  
 var__temp_h'1743 --->  Ty_heap  
 var__temp_v_err1744 --->  error  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1741, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1741, res ) ==((sel)( , var_h1718, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h1741, other ) ==(sel)( , var_h1718, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1743, res ) ==(var__temp_v1742) AND 
 	 Base var__temp_v1742 = 5 AND 
 	 Rel (sel)( , var__temp_h'1743, other ) ==(sel)( , var__temp_h1741, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1743, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1743, other ) > (4)
 
VC_END(declare-const var_h_i1719 T6205)
(declare-const var_h1718 T6205)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1741 T6205)
(declare-const var__temp_v1742 Int)
(declare-const |var__temp_h'1743| T6205)
(declare-const var__temp_v_err1744 T6206)
(declare-const var_h1718 T6205)
(declare-const err T6219)
    (declare-const |5| Int)
  
solver 
 (declare-sort T6205)
(declare-fun sel (T6205 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T6205)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'1743| () T6205)
(declare-fun var__temp_h1741 () T6205)
(declare-fun var__temp_v1742 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h1741 res) v)
                (= (sel var__temp_h1741 res) (+ (sel var_h1718 res) 5))
                (= (sel var__temp_h1741 other) (sel var_h1718 other))))
      (a!2 (and (= (sel |var__temp_h'1743| res) 10)
                (not (> (sel |var__temp_h'1743| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'1743| res) var__temp_v1742)
                    (= var__temp_v1742 |5|)
                    (= (sel |var__temp_h'1743| other)
                       (sel var__temp_h1741 other)))
               a!2)))
  (not (and (=> a!1 true) (=> true a!3))))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************477
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1719, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1719, res ) ==((sel)( , var_h1718, res ) + (5))
 	 , (sel)( , var_h_i1719, other ) ==(sel)( , var_h1718, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1720:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1745 --->  Ty_heap  
 var__temp_v1746 --->  Ty_int  
 var__temp_h'1747 --->  Ty_heap  
 var__temp_v_err1748 --->  error  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1745, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1745, res ) ==((sel)( , var_h1718, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h1745, other ) ==(sel)( , var_h1718, other ) => 
 	 Rel (sel)( , var__temp_h1745, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1745, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1747, res ) ==(var__temp_v1746) AND 
 	 Rel (sel)( , var__temp_h'1747, res ) ==((sel)( , var__temp_h1745, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1747, other ) ==(sel)( , var__temp_h1745, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1747, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1747, other ) > (4)
 
VC_END(declare-const var_h_i1719 T6222)
(declare-const var_h1718 T6222)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1745 T6222)
(declare-const var__temp_v1746 Int)
(declare-const |var__temp_h'1747| T6222)
(declare-const var__temp_v_err1748 T6223)
(declare-const var_h1718 T6222)
(declare-const err T6236)

solver 
 (declare-sort T6222)
(declare-fun sel (T6222 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T6222)
(declare-fun other () Int)
(declare-fun |var__temp_h'1747| () T6222)
(declare-fun var__temp_h1745 () T6222)
(declare-fun var__temp_v1746 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h1745 res) v)
                (= (sel var__temp_h1745 res) (+ (sel var_h1718 res) 5))
                (= (sel var__temp_h1745 other) (sel var_h1718 other))))
      (a!2 (and (= (sel |var__temp_h'1747| res) var__temp_v1746)
                (= (sel |var__temp_h'1747| res) (+ (sel var__temp_h1745 res) 2))
                (= (sel |var__temp_h'1747| other) (sel var__temp_h1745 other))))
      (a!3 (and (= (sel |var__temp_h'1747| res) 10)
                (not (> (sel |var__temp_h'1747| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1745 res) 5))
                (=> (= (sel var__temp_h1745 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************478
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1720:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1720:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1719, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1719, res ) ==((sel)( , var_h1718, res ) + (5))
 	 , (sel)( , var_h_i1719, other ) ==(sel)( , var_h1718, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1749:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************479
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1719, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1719, res ) ==((sel)( , var_h1718, res ) + (5))
 	 , (sel)( , var_h_i1719, other ) ==(sel)( , var_h1718, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1749:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1750 --->  Ty_heap  
 var__temp_v1751 --->  Ty_int  
 var__temp_h'1752 --->  Ty_heap  
 var__temp_v_err1753 --->  error  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1750, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1750, res ) ==((sel)( , var_h1718, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h1750, other ) ==(sel)( , var_h1718, other ) => 
 	 Rel (sel)( , var__temp_h1750, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1750, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1752, res ) ==(var__temp_v1751) AND 
 	 Rel (sel)( , var__temp_h'1752, res ) ==((sel)( , var__temp_h1750, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1752, other ) ==(sel)( , var__temp_h1750, other ) => 
 	 True
 
VC_END(declare-const var_h_i1719 T6239)
(declare-const var_h1718 T6239)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1750 T6239)
(declare-const var__temp_v1751 Int)
(declare-const |var__temp_h'1752| T6239)
(declare-const var__temp_v_err1753 T6240)
(declare-const var_h1718 T6239)
(declare-const err T6253)

solver 
 (declare-sort T6239)
(declare-fun sel (T6239 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T6239)
(declare-fun other () Int)
(declare-fun var__temp_h1750 () T6239)
(declare-fun |var__temp_h'1752| () T6239)
(declare-fun var__temp_v1751 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h1750 res) v)
                (= (sel var__temp_h1750 res) (+ (sel var_h1718 res) 5))
                (= (sel var__temp_h1750 other) (sel var_h1718 other))))
      (a!2 (and (= (sel |var__temp_h'1752| res) var__temp_v1751)
                (= (sel |var__temp_h'1752| res) (+ (sel var__temp_h1750 res) 3))
                (= (sel |var__temp_h'1752| other) (sel var__temp_h1750 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1750 res) 7))
                (=> (= (sel var__temp_h1750 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************480
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1719, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1719, res ) ==((sel)( , var_h1718, res ) + (5))
 	 , (sel)( , var_h_i1719, other ) ==(sel)( , var_h1718, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1749:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1754 --->  Ty_heap  
 var__temp_v1755 --->  Ty_int  
 var__temp_h'1756 --->  Ty_heap  
 var__temp_v_err1757 --->  error  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1754, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1754, res ) ==((sel)( , var_h1718, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h1754, other ) ==(sel)( , var_h1718, other ) => 
 	 Rel (sel)( , var__temp_h1754, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1754, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1756, res ) ==(var__temp_v1755) AND 
 	 Rel (sel)( , var__temp_h'1756, res ) ==((sel)( , var__temp_h1754, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1756, other ) ==(sel)( , var__temp_h1754, other ) => 
 	 True
 
VC_END(declare-const var_h_i1719 T6256)
(declare-const var_h1718 T6256)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1754 T6256)
(declare-const var__temp_v1755 Int)
(declare-const |var__temp_h'1756| T6256)
(declare-const var__temp_v_err1757 T6257)
(declare-const var_h1718 T6256)
(declare-const err T6270)

solver 
 (declare-sort T6256)
(declare-fun sel (T6256 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T6256)
(declare-fun other () Int)
(declare-fun var__temp_h1754 () T6256)
(declare-fun |var__temp_h'1756| () T6256)
(declare-fun var__temp_v1755 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h1754 res) v)
                (= (sel var__temp_h1754 res) (+ (sel var_h1718 res) 5))
                (= (sel var__temp_h1754 other) (sel var_h1718 other))))
      (a!2 (and (= (sel |var__temp_h'1756| res) var__temp_v1755)
                (= (sel |var__temp_h'1756| res) (+ (sel var__temp_h1754 res) 5))
                (= (sel |var__temp_h'1756| other) (sel var__temp_h1754 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1754 res) 7))
                (=> (= (sel var__temp_h1754 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************481
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1719, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1719, res ) ==((sel)( , var_h1718, res ) + (5))
 	 , (sel)( , var_h_i1719, other ) ==(sel)( , var_h1718, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1749:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1758 --->  Ty_heap  
 var__temp_v1759 --->  Ty_int  
 var__temp_h'1760 --->  Ty_heap  
 var__temp_v_err1761 --->  error  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1758, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1758, res ) ==((sel)( , var_h1718, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h1758, other ) ==(sel)( , var_h1718, other ) => 
 	 Rel (sel)( , var__temp_h1758, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h1758, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1760, res ) ==(var__temp_v1759) AND 
 	 Rel (sel)( , var__temp_h1758, res ) ==(sel)( , var__temp_h1758, res ) AND 
 	 Rel (sel)( , var__temp_h'1760, other ) ==(sel)( , var__temp_h1758, other ) => 
 	 True
 
VC_END(declare-const var_h_i1719 T6273)
(declare-const var_h1718 T6273)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1758 T6273)
(declare-const var__temp_v1759 Int)
(declare-const |var__temp_h'1760| T6273)
(declare-const var__temp_v_err1761 T6274)
(declare-const var_h1718 T6273)
(declare-const err T6287)

solver 
 (declare-sort T6273)
(declare-fun sel (T6273 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T6273)
(declare-fun other () Int)
(declare-fun var__temp_h1758 () T6273)
(declare-fun |var__temp_h'1760| () T6273)
(declare-fun var__temp_v1759 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h1758 res) v)
                (= (sel var__temp_h1758 res) (+ (sel var_h1718 res) 5))
                (= (sel var__temp_h1758 other) (sel var_h1718 other))))
      (a!3 (=> (and (= (sel |var__temp_h'1760| res) var__temp_v1759)
                    (= (sel var__temp_h1758 res) (sel var__temp_h1758 res))
                    (= (sel |var__temp_h'1760| other)
                       (sel var__temp_h1758 other)))
               true)))
(let ((a!2 (=> a!1 (not (> (sel var__temp_h1758 res) 20))))
      (a!4 (=> (not (> (sel var__temp_h1758 res) 20)) a!3)))
  (not (and a!2 a!4)))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************482
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1719, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1719, res ) ==((sel)( , var_h1718, res ) + (5))
 	 , (sel)( , var_h_i1719, other ) ==(sel)( , var_h1718, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1749:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1762 --->  Ty_heap  
 var__temp_v1763 --->  Ty_int  
 var__temp_h'1764 --->  Ty_heap  
 var__temp_v_err1765 --->  error  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1762, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1762, res ) ==((sel)( , var_h1718, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h1762, other ) ==(sel)( , var_h1718, other ) => 
 	 Rel (sel)( , var__temp_h1762, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1762, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1764, res ) ==(var__temp_v1763) AND 
 	 Rel (sel)( , var__temp_h'1764, res ) ==((sel)( , var__temp_h1762, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'1764, other ) ==(sel)( , var__temp_h1762, other ) => 
 	 True
 
VC_END(declare-const var_h_i1719 T6290)
(declare-const var_h1718 T6290)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1762 T6290)
(declare-const var__temp_v1763 Int)
(declare-const |var__temp_h'1764| T6290)
(declare-const var__temp_v_err1765 T6291)
(declare-const var_h1718 T6290)
(declare-const err T6304)

solver 
 (declare-sort T6290)
(declare-fun sel (T6290 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T6290)
(declare-fun other () Int)
(declare-fun var__temp_h1762 () T6290)
(declare-fun |var__temp_h'1764| () T6290)
(declare-fun var__temp_v1763 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h1762 res) v)
                (= (sel var__temp_h1762 res) (+ (sel var_h1718 res) 5))
                (= (sel var__temp_h1762 other) (sel var_h1718 other))))
      (a!2 (and (= (sel |var__temp_h'1764| res) var__temp_v1763)
                (= (sel |var__temp_h'1764| res)
                   (+ (sel var__temp_h1762 res) 10))
                (= (sel |var__temp_h'1764| other) (sel var__temp_h1762 other)))))
(let ((a!3 (and (=> a!1 (> (sel var__temp_h1762 res) 4))
                (=> (> (sel var__temp_h1762 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************483
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1719, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1719, res ) ==((sel)( , var_h1718, res ) + (5))
 	 , (sel)( , var_h_i1719, other ) ==(sel)( , var_h1718, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1749:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1766 --->  Ty_heap  
 var__temp_v1767 --->  Ty_int  
 var__temp_h'1768 --->  Ty_heap  
 var__temp_v_err1769 --->  error  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1766, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1766, res ) ==((sel)( , var_h1718, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h1766, other ) ==(sel)( , var_h1718, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1768, res ) ==(var__temp_v1767) AND 
 	 Base var__temp_v1767 = 20 AND 
 	 Rel (sel)( , var__temp_h'1768, other ) ==(sel)( , var__temp_h1766, other ) => 
 	 True
 
VC_END(declare-const var_h_i1719 T6307)
(declare-const var_h1718 T6307)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1766 T6307)
(declare-const var__temp_v1767 Int)
(declare-const |var__temp_h'1768| T6307)
(declare-const var__temp_v_err1769 T6308)
(declare-const var_h1718 T6307)
(declare-const err T6321)
    (declare-const |20| Int)
  
solver 
 (declare-sort T6307)
(declare-fun sel (T6307 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T6307)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h1766 () T6307)
(declare-fun |var__temp_h'1768| () T6307)
(declare-fun var__temp_v1767 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (and (= (sel var__temp_h1766 res) v)
                (= (sel var__temp_h1766 res) (+ (sel var_h1718 res) 5))
                (= (sel var__temp_h1766 other) (sel var_h1718 other))))
      (a!2 (=> (and (= (sel |var__temp_h'1768| res) var__temp_v1767)
                    (= var__temp_v1767 |20|)
                    (= (sel |var__temp_h'1768| other)
                       (sel var__temp_h1766 other)))
               true)))
  (not (and (=> a!1 true) (=> true a!2)))))

***************Selection Successful************foo'
PARTIAL PATH NEW
SUB 
 	 --foo'
 	 --c4
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1771, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1771, other ) ==(sel)( , var_h1770, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1772:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
foo
bar
 *********************Enumeration Iteration*****************484
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1771, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1771, other ) ==(sel)( , var_h1770, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1772:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1773 --->  Ty_heap  
 var__temp_v1774 --->  Ty_int  
 var__temp_h'1775 --->  Ty_heap  
 var__temp_v_err1776 --->  error  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1773, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1773, other ) ==(sel)( , var_h1770, other ) => 
 	 Rel (sel)( , var__temp_h1773, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1773, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1775, res ) ==(var__temp_v1774) AND 
 	 Rel (sel)( , var__temp_h'1775, res ) ==((sel)( , var__temp_h1773, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1775, other ) ==(sel)( , var__temp_h1773, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1775, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1775, other ) > (4)
 
VC_END(declare-const var_h_i1771 T6324)
(declare-const var_h1770 T6324)
(declare-const v Int)
(declare-const var_h_i1719 T6324)
(declare-const var_h1718 T6324)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1773 T6324)
(declare-const var__temp_v1774 Int)
(declare-const |var__temp_h'1775| T6324)
(declare-const var__temp_v_err1776 T6325)
(declare-const var_h1770 T6324)
(declare-const var_h1718 T6324)
(declare-const err T6338)
    (declare-const |20| Int)
  
solver 
 (declare-sort T6324)
(declare-fun sel (T6324 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T6324)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'1775| () T6324)
(declare-fun var__temp_h1773 () T6324)
(declare-fun var__temp_v1774 () Int)
(declare-fun var_h1770 () T6324)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1773 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1773 other) (sel var_h1770 other)))
               (= (sel var__temp_h1773 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1775| res) var__temp_v1774)
                (= (sel |var__temp_h'1775| res) (+ (sel var__temp_h1773 res) 3))
                (= (sel |var__temp_h'1775| other) (sel var__temp_h1773 other))))
      (a!3 (and (= (sel |var__temp_h'1775| res) 10)
                (not (> (sel |var__temp_h'1775| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1773 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************485
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1771, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1771, other ) ==(sel)( , var_h1770, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1772:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1777 --->  Ty_heap  
 var__temp_v1778 --->  Ty_int  
 var__temp_h'1779 --->  Ty_heap  
 var__temp_v_err1780 --->  error  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1777, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1777, other ) ==(sel)( , var_h1770, other ) => 
 	 Rel (sel)( , var__temp_h1777, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1777, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1779, res ) ==(var__temp_v1778) AND 
 	 Rel (sel)( , var__temp_h'1779, res ) ==((sel)( , var__temp_h1777, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1779, other ) ==(sel)( , var__temp_h1777, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1779, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1779, other ) > (4)
 
VC_END(declare-const var_h_i1771 T6341)
(declare-const var_h1770 T6341)
(declare-const v Int)
(declare-const var_h_i1719 T6341)
(declare-const var_h1718 T6341)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1777 T6341)
(declare-const var__temp_v1778 Int)
(declare-const |var__temp_h'1779| T6341)
(declare-const var__temp_v_err1780 T6342)
(declare-const var_h1770 T6341)
(declare-const var_h1718 T6341)
(declare-const err T6355)
    (declare-const |20| Int)
  
solver 
 (declare-sort T6341)
(declare-fun sel (T6341 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T6341)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'1779| () T6341)
(declare-fun var__temp_h1777 () T6341)
(declare-fun var__temp_v1778 () Int)
(declare-fun var_h1770 () T6341)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1777 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1777 other) (sel var_h1770 other)))
               (= (sel var__temp_h1777 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1779| res) var__temp_v1778)
                (= (sel |var__temp_h'1779| res) (+ (sel var__temp_h1777 res) 5))
                (= (sel |var__temp_h'1779| other) (sel var__temp_h1777 other))))
      (a!3 (and (= (sel |var__temp_h'1779| res) 10)
                (not (> (sel |var__temp_h'1779| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1777 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************486
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1771, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1771, other ) ==(sel)( , var_h1770, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1772:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1781 --->  Ty_heap  
 var__temp_v1782 --->  Ty_int  
 var__temp_h'1783 --->  Ty_heap  
 var__temp_v_err1784 --->  error  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1781, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1781, other ) ==(sel)( , var_h1770, other ) => 
 	 Rel (sel)( , var__temp_h1781, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h1781, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1783, res ) ==(var__temp_v1782) AND 
 	 Rel (sel)( , var__temp_h1781, res ) ==(sel)( , var__temp_h1781, res ) AND 
 	 Rel (sel)( , var__temp_h'1783, other ) ==(sel)( , var__temp_h1781, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1783, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1783, other ) > (4)
 
VC_END(declare-const var_h_i1771 T6358)
(declare-const var_h1770 T6358)
(declare-const v Int)
(declare-const var_h_i1719 T6358)
(declare-const var_h1718 T6358)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1781 T6358)
(declare-const var__temp_v1782 Int)
(declare-const |var__temp_h'1783| T6358)
(declare-const var__temp_v_err1784 T6359)
(declare-const var_h1770 T6358)
(declare-const var_h1718 T6358)
(declare-const err T6372)
    (declare-const |20| Int)
  
solver 
 (declare-sort T6358)
(declare-fun sel (T6358 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T6358)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'1783| () T6358)
(declare-fun var__temp_h1781 () T6358)
(declare-fun var__temp_v1782 () Int)
(declare-fun var_h1770 () T6358)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1781 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1781 other) (sel var_h1770 other)))
               (not (> (sel var__temp_h1781 res) 20))))
      (a!2 (and (= (sel |var__temp_h'1783| res) 10)
                (not (> (sel |var__temp_h'1783| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'1783| res) var__temp_v1782)
                    (= (sel var__temp_h1781 res) (sel var__temp_h1781 res))
                    (= (sel |var__temp_h'1783| other)
                       (sel var__temp_h1781 other)))
               a!2)))
(let ((a!4 (=> (not (> (sel var__temp_h1781 res) 20)) a!3)))
  (not (and a!1 a!4))))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************487
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1771, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1771, other ) ==(sel)( , var_h1770, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1772:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1785 --->  Ty_heap  
 var__temp_v1786 --->  Ty_int  
 var__temp_h'1787 --->  Ty_heap  
 var__temp_v_err1788 --->  error  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1785, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1785, other ) ==(sel)( , var_h1770, other ) => 
 	 Rel (sel)( , var__temp_h1785, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1785, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1787, res ) ==(var__temp_v1786) AND 
 	 Rel (sel)( , var__temp_h'1787, res ) ==((sel)( , var__temp_h1785, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'1787, other ) ==(sel)( , var__temp_h1785, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1787, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1787, other ) > (4)
 
VC_END(declare-const var_h_i1771 T6375)
(declare-const var_h1770 T6375)
(declare-const v Int)
(declare-const var_h_i1719 T6375)
(declare-const var_h1718 T6375)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1785 T6375)
(declare-const var__temp_v1786 Int)
(declare-const |var__temp_h'1787| T6375)
(declare-const var__temp_v_err1788 T6376)
(declare-const var_h1770 T6375)
(declare-const var_h1718 T6375)
(declare-const err T6389)
    (declare-const |20| Int)
  
solver 
 (declare-sort T6375)
(declare-fun sel (T6375 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T6375)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'1787| () T6375)
(declare-fun var__temp_h1785 () T6375)
(declare-fun var__temp_v1786 () Int)
(declare-fun var_h1770 () T6375)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1785 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1785 other) (sel var_h1770 other)))
               (> (sel var__temp_h1785 res) 4)))
      (a!2 (and (= (sel |var__temp_h'1787| res) var__temp_v1786)
                (= (sel |var__temp_h'1787| res)
                   (+ (sel var__temp_h1785 res) 10))
                (= (sel |var__temp_h'1787| other) (sel var__temp_h1785 other))))
      (a!3 (and (= (sel |var__temp_h'1787| res) 10)
                (not (> (sel |var__temp_h'1787| other) 4)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h1785 res) 4) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************488
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1771, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1771, other ) ==(sel)( , var_h1770, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1772:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1789 --->  Ty_heap  
 var__temp_v1790 --->  Ty_int  
 var__temp_h'1791 --->  Ty_heap  
 var__temp_v_err1792 --->  error  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1789, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1789, other ) ==(sel)( , var_h1770, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1791, res ) ==(var__temp_v1790) AND 
 	 Base var__temp_v1790 = 5 AND 
 	 Rel (sel)( , var__temp_h'1791, other ) ==(sel)( , var__temp_h1789, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1791, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1791, other ) > (4)
 
VC_END(declare-const var_h_i1771 T6392)
(declare-const var_h1770 T6392)
(declare-const v Int)
(declare-const var_h_i1719 T6392)
(declare-const var_h1718 T6392)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1789 T6392)
(declare-const var__temp_v1790 Int)
(declare-const |var__temp_h'1791| T6392)
(declare-const var__temp_v_err1792 T6393)
(declare-const var_h1770 T6392)
(declare-const var_h1718 T6392)
(declare-const err T6406)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T6392)
(declare-fun sel (T6392 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T6392)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'1791| () T6392)
(declare-fun var__temp_h1789 () T6392)
(declare-fun var__temp_v1790 () Int)
(declare-fun var_h1770 () T6392)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1789 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1789 other) (sel var_h1770 other)))
               true))
      (a!2 (and (= (sel |var__temp_h'1791| res) 10)
                (not (> (sel |var__temp_h'1791| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'1791| res) var__temp_v1790)
                    (= var__temp_v1790 |5|)
                    (= (sel |var__temp_h'1791| other)
                       (sel var__temp_h1789 other)))
               a!2)))
  (not (and a!1 (=> true a!3))))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************489
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1771, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1771, other ) ==(sel)( , var_h1770, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1772:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1793 --->  Ty_heap  
 var__temp_v1794 --->  Ty_int  
 var__temp_h'1795 --->  Ty_heap  
 var__temp_v_err1796 --->  error  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1793, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1793, other ) ==(sel)( , var_h1770, other ) => 
 	 Rel (sel)( , var__temp_h1793, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1793, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1795, res ) ==(var__temp_v1794) AND 
 	 Rel (sel)( , var__temp_h'1795, res ) ==((sel)( , var__temp_h1793, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1795, other ) ==(sel)( , var__temp_h1793, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1795, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1795, other ) > (4)
 
VC_END(declare-const var_h_i1771 T6409)
(declare-const var_h1770 T6409)
(declare-const v Int)
(declare-const var_h_i1719 T6409)
(declare-const var_h1718 T6409)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1793 T6409)
(declare-const var__temp_v1794 Int)
(declare-const |var__temp_h'1795| T6409)
(declare-const var__temp_v_err1796 T6410)
(declare-const var_h1770 T6409)
(declare-const var_h1718 T6409)
(declare-const err T6423)
    (declare-const |20| Int)
  
solver 
 (declare-sort T6409)
(declare-fun sel (T6409 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T6409)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'1795| () T6409)
(declare-fun var__temp_h1793 () T6409)
(declare-fun var__temp_v1794 () Int)
(declare-fun var_h1770 () T6409)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1793 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1793 other) (sel var_h1770 other)))
               (= (sel var__temp_h1793 res) 5)))
      (a!2 (and (= (sel |var__temp_h'1795| res) var__temp_v1794)
                (= (sel |var__temp_h'1795| res) (+ (sel var__temp_h1793 res) 2))
                (= (sel |var__temp_h'1795| other) (sel var__temp_h1793 other))))
      (a!3 (and (= (sel |var__temp_h'1795| res) 10)
                (not (> (sel |var__temp_h'1795| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1793 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************490
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1772:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1772:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfoo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1771, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1771, other ) ==(sel)( , var_h1770, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1797:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
foo
bar
 *********************Enumeration Iteration*****************491
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1771, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1771, other ) ==(sel)( , var_h1770, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1797:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1798 --->  Ty_heap  
 var__temp_v1799 --->  Ty_int  
 var__temp_h'1800 --->  Ty_heap  
 var__temp_v_err1801 --->  error  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1798, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1798, other ) ==(sel)( , var_h1770, other ) => 
 	 Rel (sel)( , var__temp_h1798, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1798, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1800, res ) ==(var__temp_v1799) AND 
 	 Rel (sel)( , var__temp_h'1800, res ) ==((sel)( , var__temp_h1798, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1800, other ) ==(sel)( , var__temp_h1798, other ) => 
 	 True
 
VC_END(declare-const var_h_i1771 T6426)
(declare-const var_h1770 T6426)
(declare-const v Int)
(declare-const var_h_i1719 T6426)
(declare-const var_h1718 T6426)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1798 T6426)
(declare-const var__temp_v1799 Int)
(declare-const |var__temp_h'1800| T6426)
(declare-const var__temp_v_err1801 T6427)
(declare-const var_h1770 T6426)
(declare-const var_h1718 T6426)
(declare-const err T6440)
    (declare-const |20| Int)
  
solver 
 (declare-sort T6426)
(declare-fun sel (T6426 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T6426)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h1798 () T6426)
(declare-fun |var__temp_h'1800| () T6426)
(declare-fun var__temp_v1799 () Int)
(declare-fun var_h1770 () T6426)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1798 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1798 other) (sel var_h1770 other)))
               (= (sel var__temp_h1798 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1800| res) var__temp_v1799)
                (= (sel |var__temp_h'1800| res) (+ (sel var__temp_h1798 res) 3))
                (= (sel |var__temp_h'1800| other) (sel var__temp_h1798 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1798 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************492
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1771, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1771, other ) ==(sel)( , var_h1770, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1797:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1802 --->  Ty_heap  
 var__temp_v1803 --->  Ty_int  
 var__temp_h'1804 --->  Ty_heap  
 var__temp_v_err1805 --->  error  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1802, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1802, other ) ==(sel)( , var_h1770, other ) => 
 	 Rel (sel)( , var__temp_h1802, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1802, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1804, res ) ==(var__temp_v1803) AND 
 	 Rel (sel)( , var__temp_h'1804, res ) ==((sel)( , var__temp_h1802, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1804, other ) ==(sel)( , var__temp_h1802, other ) => 
 	 True
 
VC_END(declare-const var_h_i1771 T6443)
(declare-const var_h1770 T6443)
(declare-const v Int)
(declare-const var_h_i1719 T6443)
(declare-const var_h1718 T6443)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1802 T6443)
(declare-const var__temp_v1803 Int)
(declare-const |var__temp_h'1804| T6443)
(declare-const var__temp_v_err1805 T6444)
(declare-const var_h1770 T6443)
(declare-const var_h1718 T6443)
(declare-const err T6457)
    (declare-const |20| Int)
  
solver 
 (declare-sort T6443)
(declare-fun sel (T6443 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T6443)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h1802 () T6443)
(declare-fun |var__temp_h'1804| () T6443)
(declare-fun var__temp_v1803 () Int)
(declare-fun var_h1770 () T6443)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1802 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1802 other) (sel var_h1770 other)))
               (= (sel var__temp_h1802 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1804| res) var__temp_v1803)
                (= (sel |var__temp_h'1804| res) (+ (sel var__temp_h1802 res) 5))
                (= (sel |var__temp_h'1804| other) (sel var__temp_h1802 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1802 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************493
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1771, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1771, other ) ==(sel)( , var_h1770, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1797:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1806 --->  Ty_heap  
 var__temp_v1807 --->  Ty_int  
 var__temp_h'1808 --->  Ty_heap  
 var__temp_v_err1809 --->  error  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1806, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1806, other ) ==(sel)( , var_h1770, other ) => 
 	 Rel (sel)( , var__temp_h1806, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h1806, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1808, res ) ==(var__temp_v1807) AND 
 	 Rel (sel)( , var__temp_h1806, res ) ==(sel)( , var__temp_h1806, res ) AND 
 	 Rel (sel)( , var__temp_h'1808, other ) ==(sel)( , var__temp_h1806, other ) => 
 	 True
 
VC_END(declare-const var_h_i1771 T6460)
(declare-const var_h1770 T6460)
(declare-const v Int)
(declare-const var_h_i1719 T6460)
(declare-const var_h1718 T6460)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1806 T6460)
(declare-const var__temp_v1807 Int)
(declare-const |var__temp_h'1808| T6460)
(declare-const var__temp_v_err1809 T6461)
(declare-const var_h1770 T6460)
(declare-const var_h1718 T6460)
(declare-const err T6474)
    (declare-const |20| Int)
  
solver 
 (declare-sort T6460)
(declare-fun sel (T6460 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T6460)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h1806 () T6460)
(declare-fun |var__temp_h'1808| () T6460)
(declare-fun var__temp_v1807 () Int)
(declare-fun var_h1770 () T6460)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1806 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1806 other) (sel var_h1770 other)))
               (not (> (sel var__temp_h1806 res) 20))))
      (a!2 (=> (and (= (sel |var__temp_h'1808| res) var__temp_v1807)
                    (= (sel var__temp_h1806 res) (sel var__temp_h1806 res))
                    (= (sel |var__temp_h'1808| other)
                       (sel var__temp_h1806 other)))
               true)))
(let ((a!3 (=> (not (> (sel var__temp_h1806 res) 20)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Successful************c2'
PARTIAL PATH NEW
SUB 
 	 --c2'
 	 --foo'
 	 --c4
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1811 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1811 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1811, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h1810, res ) ==(sel)( , var_h1810, res )
 	 , (sel)( , var_h_i1811, other ) ==(sel)( , var_h1810, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1812:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1811 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************494
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1811 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1811, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h1810, res ) ==(sel)( , var_h1810, res )
 	 , (sel)( , var_h_i1811, other ) ==(sel)( , var_h1810, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1812:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1811 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1813 --->  Ty_heap  
 var__temp_v1814 --->  Ty_int  
 var__temp_h'1815 --->  Ty_heap  
 var__temp_v_err1816 --->  error  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1813, res ) ==(v) AND 
 	 Rel (sel)( , var_h1810, res ) ==(sel)( , var_h1810, res ) AND 
 	 Rel (sel)( , var__temp_h1813, other ) ==(sel)( , var_h1810, other ) => 
 	 Rel (sel)( , var__temp_h1813, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1813, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1815, res ) ==(var__temp_v1814) AND 
 	 Rel (sel)( , var__temp_h'1815, res ) ==((sel)( , var__temp_h1813, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1815, other ) ==(sel)( , var__temp_h1813, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1815, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1815, other ) > (4)
 
VC_END(declare-const var_h_i1811 T6477)
(declare-const var_h1810 T6477)
(declare-const v Int)
(declare-const var_h_i1771 T6477)
(declare-const var_h1770 T6477)
(declare-const v Int)
(declare-const var_h_i1719 T6477)
(declare-const var_h1718 T6477)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1813 T6477)
(declare-const var__temp_v1814 Int)
(declare-const |var__temp_h'1815| T6477)
(declare-const var__temp_v_err1816 T6478)
(declare-const var_h1810 T6477)
(declare-const var_h1770 T6477)
(declare-const var_h1718 T6477)
(declare-const err T6491)

solver 
 (declare-sort T6477)
(declare-fun sel (T6477 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1810 () T6477)
(declare-fun var_h1718 () T6477)
(declare-fun other () Int)
(declare-fun |var__temp_h'1815| () T6477)
(declare-fun var__temp_h1813 () T6477)
(declare-fun var__temp_v1814 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1813 res) v)
                    (= (sel var_h1810 res) (sel var_h1810 res))
                    (= (sel var__temp_h1813 other) (sel var_h1810 other)))
               (= (sel var__temp_h1813 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1815| res) var__temp_v1814)
                (= (sel |var__temp_h'1815| res) (+ (sel var__temp_h1813 res) 3))
                (= (sel |var__temp_h'1815| other) (sel var__temp_h1813 other))))
      (a!3 (and (= (sel |var__temp_h'1815| res) 10)
                (not (> (sel |var__temp_h'1815| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1813 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************495
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1811 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1811, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h1810, res ) ==(sel)( , var_h1810, res )
 	 , (sel)( , var_h_i1811, other ) ==(sel)( , var_h1810, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1812:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1811 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1817 --->  Ty_heap  
 var__temp_v1818 --->  Ty_int  
 var__temp_h'1819 --->  Ty_heap  
 var__temp_v_err1820 --->  error  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1817, res ) ==(v) AND 
 	 Rel (sel)( , var_h1810, res ) ==(sel)( , var_h1810, res ) AND 
 	 Rel (sel)( , var__temp_h1817, other ) ==(sel)( , var_h1810, other ) => 
 	 Rel (sel)( , var__temp_h1817, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1817, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1819, res ) ==(var__temp_v1818) AND 
 	 Rel (sel)( , var__temp_h'1819, res ) ==((sel)( , var__temp_h1817, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1819, other ) ==(sel)( , var__temp_h1817, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1819, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1819, other ) > (4)
 
VC_END(declare-const var_h_i1811 T6494)
(declare-const var_h1810 T6494)
(declare-const v Int)
(declare-const var_h_i1771 T6494)
(declare-const var_h1770 T6494)
(declare-const v Int)
(declare-const var_h_i1719 T6494)
(declare-const var_h1718 T6494)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1817 T6494)
(declare-const var__temp_v1818 Int)
(declare-const |var__temp_h'1819| T6494)
(declare-const var__temp_v_err1820 T6495)
(declare-const var_h1810 T6494)
(declare-const var_h1770 T6494)
(declare-const var_h1718 T6494)
(declare-const err T6508)

solver 
 (declare-sort T6494)
(declare-fun sel (T6494 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1810 () T6494)
(declare-fun var_h1718 () T6494)
(declare-fun other () Int)
(declare-fun |var__temp_h'1819| () T6494)
(declare-fun var__temp_h1817 () T6494)
(declare-fun var__temp_v1818 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1817 res) v)
                    (= (sel var_h1810 res) (sel var_h1810 res))
                    (= (sel var__temp_h1817 other) (sel var_h1810 other)))
               (= (sel var__temp_h1817 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1819| res) var__temp_v1818)
                (= (sel |var__temp_h'1819| res) (+ (sel var__temp_h1817 res) 5))
                (= (sel |var__temp_h'1819| other) (sel var__temp_h1817 other))))
      (a!3 (and (= (sel |var__temp_h'1819| res) 10)
                (not (> (sel |var__temp_h'1819| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1817 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************496
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1811 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1811, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h1810, res ) ==(sel)( , var_h1810, res )
 	 , (sel)( , var_h_i1811, other ) ==(sel)( , var_h1810, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1812:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1811 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1821 --->  Ty_heap  
 var__temp_v1822 --->  Ty_int  
 var__temp_h'1823 --->  Ty_heap  
 var__temp_v_err1824 --->  error  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1821, res ) ==(v) AND 
 	 Rel (sel)( , var_h1810, res ) ==(sel)( , var_h1810, res ) AND 
 	 Rel (sel)( , var__temp_h1821, other ) ==(sel)( , var_h1810, other ) => 
 	 Rel (sel)( , var__temp_h1821, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1821, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1823, res ) ==(var__temp_v1822) AND 
 	 Rel (sel)( , var__temp_h'1823, res ) ==((sel)( , var__temp_h1821, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'1823, other ) ==(sel)( , var__temp_h1821, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1823, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1823, other ) > (4)
 
VC_END(declare-const var_h_i1811 T6511)
(declare-const var_h1810 T6511)
(declare-const v Int)
(declare-const var_h_i1771 T6511)
(declare-const var_h1770 T6511)
(declare-const v Int)
(declare-const var_h_i1719 T6511)
(declare-const var_h1718 T6511)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1821 T6511)
(declare-const var__temp_v1822 Int)
(declare-const |var__temp_h'1823| T6511)
(declare-const var__temp_v_err1824 T6512)
(declare-const var_h1810 T6511)
(declare-const var_h1770 T6511)
(declare-const var_h1718 T6511)
(declare-const err T6525)

solver 
 (declare-sort T6511)
(declare-fun sel (T6511 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1810 () T6511)
(declare-fun var_h1718 () T6511)
(declare-fun other () Int)
(declare-fun |var__temp_h'1823| () T6511)
(declare-fun var__temp_h1821 () T6511)
(declare-fun var__temp_v1822 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1821 res) v)
                    (= (sel var_h1810 res) (sel var_h1810 res))
                    (= (sel var__temp_h1821 other) (sel var_h1810 other)))
               (> (sel var__temp_h1821 res) 4)))
      (a!2 (and (= (sel |var__temp_h'1823| res) var__temp_v1822)
                (= (sel |var__temp_h'1823| res)
                   (+ (sel var__temp_h1821 res) 10))
                (= (sel |var__temp_h'1823| other) (sel var__temp_h1821 other))))
      (a!3 (and (= (sel |var__temp_h'1823| res) 10)
                (not (> (sel |var__temp_h'1823| other) 4)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h1821 res) 4) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************497
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1811 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1811, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h1810, res ) ==(sel)( , var_h1810, res )
 	 , (sel)( , var_h_i1811, other ) ==(sel)( , var_h1810, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1812:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1811 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1825 --->  Ty_heap  
 var__temp_v1826 --->  Ty_int  
 var__temp_h'1827 --->  Ty_heap  
 var__temp_v_err1828 --->  error  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1825, res ) ==(v) AND 
 	 Rel (sel)( , var_h1810, res ) ==(sel)( , var_h1810, res ) AND 
 	 Rel (sel)( , var__temp_h1825, other ) ==(sel)( , var_h1810, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1827, res ) ==(var__temp_v1826) AND 
 	 Base var__temp_v1826 = 5 AND 
 	 Rel (sel)( , var__temp_h'1827, other ) ==(sel)( , var__temp_h1825, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1827, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1827, other ) > (4)
 
VC_END(declare-const var_h_i1811 T6528)
(declare-const var_h1810 T6528)
(declare-const v Int)
(declare-const var_h_i1771 T6528)
(declare-const var_h1770 T6528)
(declare-const v Int)
(declare-const var_h_i1719 T6528)
(declare-const var_h1718 T6528)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1825 T6528)
(declare-const var__temp_v1826 Int)
(declare-const |var__temp_h'1827| T6528)
(declare-const var__temp_v_err1828 T6529)
(declare-const var_h1810 T6528)
(declare-const var_h1770 T6528)
(declare-const var_h1718 T6528)
(declare-const err T6542)
    (declare-const |5| Int)
  
solver 
 (declare-sort T6528)
(declare-fun sel (T6528 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1810 () T6528)
(declare-fun var_h1718 () T6528)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'1827| () T6528)
(declare-fun var__temp_h1825 () T6528)
(declare-fun var__temp_v1826 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1825 res) v)
                    (= (sel var_h1810 res) (sel var_h1810 res))
                    (= (sel var__temp_h1825 other) (sel var_h1810 other)))
               true))
      (a!2 (and (= (sel |var__temp_h'1827| res) 10)
                (not (> (sel |var__temp_h'1827| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'1827| res) var__temp_v1826)
                    (= var__temp_v1826 |5|)
                    (= (sel |var__temp_h'1827| other)
                       (sel var__temp_h1825 other)))
               a!2)))
  (not (and a!1 (=> true a!3))))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************498
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1811 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1811, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h1810, res ) ==(sel)( , var_h1810, res )
 	 , (sel)( , var_h_i1811, other ) ==(sel)( , var_h1810, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1812:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1811 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1829 --->  Ty_heap  
 var__temp_v1830 --->  Ty_int  
 var__temp_h'1831 --->  Ty_heap  
 var__temp_v_err1832 --->  error  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1829, res ) ==(v) AND 
 	 Rel (sel)( , var_h1810, res ) ==(sel)( , var_h1810, res ) AND 
 	 Rel (sel)( , var__temp_h1829, other ) ==(sel)( , var_h1810, other ) => 
 	 Rel (sel)( , var__temp_h1829, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1829, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1831, res ) ==(var__temp_v1830) AND 
 	 Rel (sel)( , var__temp_h'1831, res ) ==((sel)( , var__temp_h1829, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1831, other ) ==(sel)( , var__temp_h1829, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1831, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1831, other ) > (4)
 
VC_END(declare-const var_h_i1811 T6545)
(declare-const var_h1810 T6545)
(declare-const v Int)
(declare-const var_h_i1771 T6545)
(declare-const var_h1770 T6545)
(declare-const v Int)
(declare-const var_h_i1719 T6545)
(declare-const var_h1718 T6545)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1829 T6545)
(declare-const var__temp_v1830 Int)
(declare-const |var__temp_h'1831| T6545)
(declare-const var__temp_v_err1832 T6546)
(declare-const var_h1810 T6545)
(declare-const var_h1770 T6545)
(declare-const var_h1718 T6545)
(declare-const err T6559)

solver 
 (declare-sort T6545)
(declare-fun sel (T6545 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1810 () T6545)
(declare-fun var_h1718 () T6545)
(declare-fun other () Int)
(declare-fun |var__temp_h'1831| () T6545)
(declare-fun var__temp_h1829 () T6545)
(declare-fun var__temp_v1830 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1829 res) v)
                    (= (sel var_h1810 res) (sel var_h1810 res))
                    (= (sel var__temp_h1829 other) (sel var_h1810 other)))
               (= (sel var__temp_h1829 res) 5)))
      (a!2 (and (= (sel |var__temp_h'1831| res) var__temp_v1830)
                (= (sel |var__temp_h'1831| res) (+ (sel var__temp_h1829 res) 2))
                (= (sel |var__temp_h'1831| other) (sel var__temp_h1829 other))))
      (a!3 (and (= (sel |var__temp_h'1831| res) 10)
                (not (> (sel |var__temp_h'1831| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1829 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************499
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1812:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1812:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c2'
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1811 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1811, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h1810, res ) ==(sel)( , var_h1810, res )
 	 , (sel)( , var_h_i1811, other ) ==(sel)( , var_h1810, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1833:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************500
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1811 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1811, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h1810, res ) ==(sel)( , var_h1810, res )
 	 , (sel)( , var_h_i1811, other ) ==(sel)( , var_h1810, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1833:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1834 --->  Ty_heap  
 var__temp_v1835 --->  Ty_int  
 var__temp_h'1836 --->  Ty_heap  
 var__temp_v_err1837 --->  error  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1834, res ) ==(v) AND 
 	 Rel (sel)( , var_h1810, res ) ==(sel)( , var_h1810, res ) AND 
 	 Rel (sel)( , var__temp_h1834, other ) ==(sel)( , var_h1810, other ) => 
 	 Rel (sel)( , var__temp_h1834, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1834, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1836, res ) ==(var__temp_v1835) AND 
 	 Rel (sel)( , var__temp_h'1836, res ) ==((sel)( , var__temp_h1834, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1836, other ) ==(sel)( , var__temp_h1834, other ) => 
 	 True
 
VC_END(declare-const var_h_i1811 T6562)
(declare-const var_h1810 T6562)
(declare-const v Int)
(declare-const var_h_i1771 T6562)
(declare-const var_h1770 T6562)
(declare-const v Int)
(declare-const var_h_i1719 T6562)
(declare-const var_h1718 T6562)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1834 T6562)
(declare-const var__temp_v1835 Int)
(declare-const |var__temp_h'1836| T6562)
(declare-const var__temp_v_err1837 T6563)
(declare-const var_h1810 T6562)
(declare-const var_h1770 T6562)
(declare-const var_h1718 T6562)
(declare-const err T6576)

solver 
 (declare-sort T6562)
(declare-fun sel (T6562 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1810 () T6562)
(declare-fun var_h1718 () T6562)
(declare-fun other () Int)
(declare-fun var__temp_h1834 () T6562)
(declare-fun |var__temp_h'1836| () T6562)
(declare-fun var__temp_v1835 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1834 res) v)
                    (= (sel var_h1810 res) (sel var_h1810 res))
                    (= (sel var__temp_h1834 other) (sel var_h1810 other)))
               (= (sel var__temp_h1834 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1836| res) var__temp_v1835)
                (= (sel |var__temp_h'1836| res) (+ (sel var__temp_h1834 res) 3))
                (= (sel |var__temp_h'1836| other) (sel var__temp_h1834 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1834 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************501
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1811 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1811, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h1810, res ) ==(sel)( , var_h1810, res )
 	 , (sel)( , var_h_i1811, other ) ==(sel)( , var_h1810, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1833:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1838 --->  Ty_heap  
 var__temp_v1839 --->  Ty_int  
 var__temp_h'1840 --->  Ty_heap  
 var__temp_v_err1841 --->  error  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1838, res ) ==(v) AND 
 	 Rel (sel)( , var_h1810, res ) ==(sel)( , var_h1810, res ) AND 
 	 Rel (sel)( , var__temp_h1838, other ) ==(sel)( , var_h1810, other ) => 
 	 Rel (sel)( , var__temp_h1838, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1838, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1840, res ) ==(var__temp_v1839) AND 
 	 Rel (sel)( , var__temp_h'1840, res ) ==((sel)( , var__temp_h1838, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1840, other ) ==(sel)( , var__temp_h1838, other ) => 
 	 True
 
VC_END(declare-const var_h_i1811 T6579)
(declare-const var_h1810 T6579)
(declare-const v Int)
(declare-const var_h_i1771 T6579)
(declare-const var_h1770 T6579)
(declare-const v Int)
(declare-const var_h_i1719 T6579)
(declare-const var_h1718 T6579)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1838 T6579)
(declare-const var__temp_v1839 Int)
(declare-const |var__temp_h'1840| T6579)
(declare-const var__temp_v_err1841 T6580)
(declare-const var_h1810 T6579)
(declare-const var_h1770 T6579)
(declare-const var_h1718 T6579)
(declare-const err T6593)

solver 
 (declare-sort T6579)
(declare-fun sel (T6579 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1810 () T6579)
(declare-fun var_h1718 () T6579)
(declare-fun other () Int)
(declare-fun var__temp_h1838 () T6579)
(declare-fun |var__temp_h'1840| () T6579)
(declare-fun var__temp_v1839 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1838 res) v)
                    (= (sel var_h1810 res) (sel var_h1810 res))
                    (= (sel var__temp_h1838 other) (sel var_h1810 other)))
               (= (sel var__temp_h1838 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1840| res) var__temp_v1839)
                (= (sel |var__temp_h'1840| res) (+ (sel var__temp_h1838 res) 5))
                (= (sel |var__temp_h'1840| other) (sel var__temp_h1838 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1838 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************502
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1811 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1811, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h1810, res ) ==(sel)( , var_h1810, res )
 	 , (sel)( , var_h_i1811, other ) ==(sel)( , var_h1810, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1833:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1842 --->  Ty_heap  
 var__temp_v1843 --->  Ty_int  
 var__temp_h'1844 --->  Ty_heap  
 var__temp_v_err1845 --->  error  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1842, res ) ==(v) AND 
 	 Rel (sel)( , var_h1810, res ) ==(sel)( , var_h1810, res ) AND 
 	 Rel (sel)( , var__temp_h1842, other ) ==(sel)( , var_h1810, other ) => 
 	 Rel (sel)( , var__temp_h1842, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1842, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1844, res ) ==(var__temp_v1843) AND 
 	 Rel (sel)( , var__temp_h'1844, res ) ==((sel)( , var__temp_h1842, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'1844, other ) ==(sel)( , var__temp_h1842, other ) => 
 	 True
 
VC_END(declare-const var_h_i1811 T6596)
(declare-const var_h1810 T6596)
(declare-const v Int)
(declare-const var_h_i1771 T6596)
(declare-const var_h1770 T6596)
(declare-const v Int)
(declare-const var_h_i1719 T6596)
(declare-const var_h1718 T6596)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1842 T6596)
(declare-const var__temp_v1843 Int)
(declare-const |var__temp_h'1844| T6596)
(declare-const var__temp_v_err1845 T6597)
(declare-const var_h1810 T6596)
(declare-const var_h1770 T6596)
(declare-const var_h1718 T6596)
(declare-const err T6610)

solver 
 (declare-sort T6596)
(declare-fun sel (T6596 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1810 () T6596)
(declare-fun var_h1718 () T6596)
(declare-fun other () Int)
(declare-fun var__temp_h1842 () T6596)
(declare-fun |var__temp_h'1844| () T6596)
(declare-fun var__temp_v1843 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1842 res) v)
                    (= (sel var_h1810 res) (sel var_h1810 res))
                    (= (sel var__temp_h1842 other) (sel var_h1810 other)))
               (> (sel var__temp_h1842 res) 4)))
      (a!2 (and (= (sel |var__temp_h'1844| res) var__temp_v1843)
                (= (sel |var__temp_h'1844| res)
                   (+ (sel var__temp_h1842 res) 10))
                (= (sel |var__temp_h'1844| other) (sel var__temp_h1842 other)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h1842 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************503
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1811 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1811, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h1810, res ) ==(sel)( , var_h1810, res )
 	 , (sel)( , var_h_i1811, other ) ==(sel)( , var_h1810, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1833:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1846 --->  Ty_heap  
 var__temp_v1847 --->  Ty_int  
 var__temp_h'1848 --->  Ty_heap  
 var__temp_v_err1849 --->  error  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1846, res ) ==(v) AND 
 	 Rel (sel)( , var_h1810, res ) ==(sel)( , var_h1810, res ) AND 
 	 Rel (sel)( , var__temp_h1846, other ) ==(sel)( , var_h1810, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1848, res ) ==(var__temp_v1847) AND 
 	 Base var__temp_v1847 = 5 AND 
 	 Rel (sel)( , var__temp_h'1848, other ) ==(sel)( , var__temp_h1846, other ) => 
 	 True
 
VC_END(declare-const var_h_i1811 T6613)
(declare-const var_h1810 T6613)
(declare-const v Int)
(declare-const var_h_i1771 T6613)
(declare-const var_h1770 T6613)
(declare-const v Int)
(declare-const var_h_i1719 T6613)
(declare-const var_h1718 T6613)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1846 T6613)
(declare-const var__temp_v1847 Int)
(declare-const |var__temp_h'1848| T6613)
(declare-const var__temp_v_err1849 T6614)
(declare-const var_h1810 T6613)
(declare-const var_h1770 T6613)
(declare-const var_h1718 T6613)
(declare-const err T6627)
    (declare-const |5| Int)
  
solver 
 (declare-sort T6613)
(declare-fun sel (T6613 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1810 () T6613)
(declare-fun var_h1718 () T6613)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h1846 () T6613)
(declare-fun |var__temp_h'1848| () T6613)
(declare-fun var__temp_v1847 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1846 res) v)
                    (= (sel var_h1810 res) (sel var_h1810 res))
                    (= (sel var__temp_h1846 other) (sel var_h1810 other)))
               true))
      (a!2 (=> (and (= (sel |var__temp_h'1848| res) var__temp_v1847)
                    (= var__temp_v1847 |5|)
                    (= (sel |var__temp_h'1848| other)
                       (sel var__temp_h1846 other)))
               true)))
  (not (and a!1 (=> true a!2)))))

***************Selection Successful************foo
PARTIAL PATH NEW
SUB 
 	 --foo
 	 --c2'
 	 --foo'
 	 --c4
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1851 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1851 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1851, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1851, other ) ==(sel)( , var_h1850, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1852:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1851 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
bar
 *********************Enumeration Iteration*****************504
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1851 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1851, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1851, other ) ==(sel)( , var_h1850, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1852:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1851 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1851 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1853 --->  Ty_heap  
 var__temp_v1854 --->  Ty_int  
 var__temp_h'1855 --->  Ty_heap  
 var__temp_v_err1856 --->  error  
 var_h1850 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1853, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1853, other ) ==(sel)( , var_h1850, other ) => 
 	 Rel (sel)( , var__temp_h1853, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1853, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1855, res ) ==(var__temp_v1854) AND 
 	 Rel (sel)( , var__temp_h'1855, res ) ==((sel)( , var__temp_h1853, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1855, other ) ==(sel)( , var__temp_h1853, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1855, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1855, other ) > (4)
 
VC_END(declare-const var_h_i1851 T6630)
(declare-const var_h1850 T6630)
(declare-const v Int)
(declare-const var_h_i1811 T6630)
(declare-const var_h1810 T6630)
(declare-const v Int)
(declare-const var_h_i1771 T6630)
(declare-const var_h1770 T6630)
(declare-const v Int)
(declare-const var_h_i1719 T6630)
(declare-const var_h1718 T6630)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1853 T6630)
(declare-const var__temp_v1854 Int)
(declare-const |var__temp_h'1855| T6630)
(declare-const var__temp_v_err1856 T6631)
(declare-const var_h1850 T6630)
(declare-const var_h1810 T6630)
(declare-const var_h1770 T6630)
(declare-const var_h1718 T6630)
(declare-const err T6644)
    (declare-const |5| Int)
  
solver 
 (declare-sort T6630)
(declare-fun sel (T6630 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1810 () T6630)
(declare-fun var_h1718 () T6630)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'1855| () T6630)
(declare-fun var__temp_h1853 () T6630)
(declare-fun var__temp_v1854 () Int)
(declare-fun var_h1850 () T6630)
(declare-fun v () Int)
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1853 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1853 other) (sel var_h1850 other)))
               (= (sel var__temp_h1853 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1855| res) var__temp_v1854)
                (= (sel |var__temp_h'1855| res) (+ (sel var__temp_h1853 res) 3))
                (= (sel |var__temp_h'1855| other) (sel var__temp_h1853 other))))
      (a!3 (and (= (sel |var__temp_h'1855| res) 10)
                (not (> (sel |var__temp_h'1855| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1853 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************505
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1851 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1851, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1851, other ) ==(sel)( , var_h1850, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1852:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1851 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1851 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1857 --->  Ty_heap  
 var__temp_v1858 --->  Ty_int  
 var__temp_h'1859 --->  Ty_heap  
 var__temp_v_err1860 --->  error  
 var_h1850 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1857, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1857, other ) ==(sel)( , var_h1850, other ) => 
 	 Rel (sel)( , var__temp_h1857, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1857, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1859, res ) ==(var__temp_v1858) AND 
 	 Rel (sel)( , var__temp_h'1859, res ) ==((sel)( , var__temp_h1857, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1859, other ) ==(sel)( , var__temp_h1857, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1859, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1859, other ) > (4)
 
VC_END(declare-const var_h_i1851 T6647)
(declare-const var_h1850 T6647)
(declare-const v Int)
(declare-const var_h_i1811 T6647)
(declare-const var_h1810 T6647)
(declare-const v Int)
(declare-const var_h_i1771 T6647)
(declare-const var_h1770 T6647)
(declare-const v Int)
(declare-const var_h_i1719 T6647)
(declare-const var_h1718 T6647)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1857 T6647)
(declare-const var__temp_v1858 Int)
(declare-const |var__temp_h'1859| T6647)
(declare-const var__temp_v_err1860 T6648)
(declare-const var_h1850 T6647)
(declare-const var_h1810 T6647)
(declare-const var_h1770 T6647)
(declare-const var_h1718 T6647)
(declare-const err T6661)
    (declare-const |5| Int)
  
solver 
 (declare-sort T6647)
(declare-fun sel (T6647 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1810 () T6647)
(declare-fun var_h1718 () T6647)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'1859| () T6647)
(declare-fun var__temp_h1857 () T6647)
(declare-fun var__temp_v1858 () Int)
(declare-fun var_h1850 () T6647)
(declare-fun v () Int)
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1857 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1857 other) (sel var_h1850 other)))
               (= (sel var__temp_h1857 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1859| res) var__temp_v1858)
                (= (sel |var__temp_h'1859| res) (+ (sel var__temp_h1857 res) 5))
                (= (sel |var__temp_h'1859| other) (sel var__temp_h1857 other))))
      (a!3 (and (= (sel |var__temp_h'1859| res) 10)
                (not (> (sel |var__temp_h'1859| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1857 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************506
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1851 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1851, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1851, other ) ==(sel)( , var_h1850, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1852:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1851 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1851 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1861 --->  Ty_heap  
 var__temp_v1862 --->  Ty_int  
 var__temp_h'1863 --->  Ty_heap  
 var__temp_v_err1864 --->  error  
 var_h1850 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1861, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1861, other ) ==(sel)( , var_h1850, other ) => 
 	 Rel (sel)( , var__temp_h1861, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1861, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1863, res ) ==(var__temp_v1862) AND 
 	 Rel (sel)( , var__temp_h'1863, res ) ==((sel)( , var__temp_h1861, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'1863, other ) ==(sel)( , var__temp_h1861, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1863, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1863, other ) > (4)
 
VC_END(declare-const var_h_i1851 T6664)
(declare-const var_h1850 T6664)
(declare-const v Int)
(declare-const var_h_i1811 T6664)
(declare-const var_h1810 T6664)
(declare-const v Int)
(declare-const var_h_i1771 T6664)
(declare-const var_h1770 T6664)
(declare-const v Int)
(declare-const var_h_i1719 T6664)
(declare-const var_h1718 T6664)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1861 T6664)
(declare-const var__temp_v1862 Int)
(declare-const |var__temp_h'1863| T6664)
(declare-const var__temp_v_err1864 T6665)
(declare-const var_h1850 T6664)
(declare-const var_h1810 T6664)
(declare-const var_h1770 T6664)
(declare-const var_h1718 T6664)
(declare-const err T6678)
    (declare-const |5| Int)
  
solver 
 (declare-sort T6664)
(declare-fun sel (T6664 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1810 () T6664)
(declare-fun var_h1718 () T6664)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'1863| () T6664)
(declare-fun var__temp_h1861 () T6664)
(declare-fun var__temp_v1862 () Int)
(declare-fun var_h1850 () T6664)
(declare-fun v () Int)
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1861 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1861 other) (sel var_h1850 other)))
               (> (sel var__temp_h1861 res) 4)))
      (a!2 (and (= (sel |var__temp_h'1863| res) var__temp_v1862)
                (= (sel |var__temp_h'1863| res)
                   (+ (sel var__temp_h1861 res) 10))
                (= (sel |var__temp_h'1863| other) (sel var__temp_h1861 other))))
      (a!3 (and (= (sel |var__temp_h'1863| res) 10)
                (not (> (sel |var__temp_h'1863| other) 4)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h1861 res) 4) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************507
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1851 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1851, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1851, other ) ==(sel)( , var_h1850, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1852:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1851 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1851 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1865 --->  Ty_heap  
 var__temp_v1866 --->  Ty_int  
 var__temp_h'1867 --->  Ty_heap  
 var__temp_v_err1868 --->  error  
 var_h1850 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1865, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1865, other ) ==(sel)( , var_h1850, other ) => 
 	 Rel (sel)( , var__temp_h1865, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1865, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1867, res ) ==(var__temp_v1866) AND 
 	 Rel (sel)( , var__temp_h'1867, res ) ==((sel)( , var__temp_h1865, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1867, other ) ==(sel)( , var__temp_h1865, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1867, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1867, other ) > (4)
 
VC_END(declare-const var_h_i1851 T6681)
(declare-const var_h1850 T6681)
(declare-const v Int)
(declare-const var_h_i1811 T6681)
(declare-const var_h1810 T6681)
(declare-const v Int)
(declare-const var_h_i1771 T6681)
(declare-const var_h1770 T6681)
(declare-const v Int)
(declare-const var_h_i1719 T6681)
(declare-const var_h1718 T6681)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1865 T6681)
(declare-const var__temp_v1866 Int)
(declare-const |var__temp_h'1867| T6681)
(declare-const var__temp_v_err1868 T6682)
(declare-const var_h1850 T6681)
(declare-const var_h1810 T6681)
(declare-const var_h1770 T6681)
(declare-const var_h1718 T6681)
(declare-const err T6695)
    (declare-const |5| Int)
  
solver 
 (declare-sort T6681)
(declare-fun sel (T6681 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1810 () T6681)
(declare-fun var_h1718 () T6681)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'1867| () T6681)
(declare-fun var__temp_h1865 () T6681)
(declare-fun var__temp_v1866 () Int)
(declare-fun var_h1850 () T6681)
(declare-fun v () Int)
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1865 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1865 other) (sel var_h1850 other)))
               (= (sel var__temp_h1865 res) 5)))
      (a!2 (and (= (sel |var__temp_h'1867| res) var__temp_v1866)
                (= (sel |var__temp_h'1867| res) (+ (sel var__temp_h1865 res) 2))
                (= (sel |var__temp_h'1867| other) (sel var__temp_h1865 other))))
      (a!3 (and (= (sel |var__temp_h'1867| res) 10)
                (not (> (sel |var__temp_h'1867| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h1865 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************508
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1852:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1852:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfooc2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --foo
 	 --c2'
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1851 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1851, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1851, other ) ==(sel)( , var_h1850, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1869:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
bar
 *********************Enumeration Iteration*****************509
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1851 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1851, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1851, other ) ==(sel)( , var_h1850, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1869:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1851 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1870 --->  Ty_heap  
 var__temp_v1871 --->  Ty_int  
 var__temp_h'1872 --->  Ty_heap  
 var__temp_v_err1873 --->  error  
 var_h1850 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1870, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1870, other ) ==(sel)( , var_h1850, other ) => 
 	 Rel (sel)( , var__temp_h1870, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1870, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1872, res ) ==(var__temp_v1871) AND 
 	 Rel (sel)( , var__temp_h'1872, res ) ==((sel)( , var__temp_h1870, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1872, other ) ==(sel)( , var__temp_h1870, other ) => 
 	 True
 
VC_END(declare-const var_h_i1851 T6698)
(declare-const var_h1850 T6698)
(declare-const v Int)
(declare-const var_h_i1811 T6698)
(declare-const var_h1810 T6698)
(declare-const v Int)
(declare-const var_h_i1771 T6698)
(declare-const var_h1770 T6698)
(declare-const v Int)
(declare-const var_h_i1719 T6698)
(declare-const var_h1718 T6698)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1870 T6698)
(declare-const var__temp_v1871 Int)
(declare-const |var__temp_h'1872| T6698)
(declare-const var__temp_v_err1873 T6699)
(declare-const var_h1850 T6698)
(declare-const var_h1810 T6698)
(declare-const var_h1770 T6698)
(declare-const var_h1718 T6698)
(declare-const err T6712)
    (declare-const |5| Int)
  
solver 
 (declare-sort T6698)
(declare-fun sel (T6698 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1810 () T6698)
(declare-fun var_h1718 () T6698)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h1870 () T6698)
(declare-fun |var__temp_h'1872| () T6698)
(declare-fun var__temp_v1871 () Int)
(declare-fun var_h1850 () T6698)
(declare-fun v () Int)
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1870 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1870 other) (sel var_h1850 other)))
               (= (sel var__temp_h1870 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1872| res) var__temp_v1871)
                (= (sel |var__temp_h'1872| res) (+ (sel var__temp_h1870 res) 3))
                (= (sel |var__temp_h'1872| other) (sel var__temp_h1870 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1870 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************510
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1851 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1851, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1851, other ) ==(sel)( , var_h1850, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1869:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1851 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1874 --->  Ty_heap  
 var__temp_v1875 --->  Ty_int  
 var__temp_h'1876 --->  Ty_heap  
 var__temp_v_err1877 --->  error  
 var_h1850 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1874, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1874, other ) ==(sel)( , var_h1850, other ) => 
 	 Rel (sel)( , var__temp_h1874, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1874, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1876, res ) ==(var__temp_v1875) AND 
 	 Rel (sel)( , var__temp_h'1876, res ) ==((sel)( , var__temp_h1874, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1876, other ) ==(sel)( , var__temp_h1874, other ) => 
 	 True
 
VC_END(declare-const var_h_i1851 T6715)
(declare-const var_h1850 T6715)
(declare-const v Int)
(declare-const var_h_i1811 T6715)
(declare-const var_h1810 T6715)
(declare-const v Int)
(declare-const var_h_i1771 T6715)
(declare-const var_h1770 T6715)
(declare-const v Int)
(declare-const var_h_i1719 T6715)
(declare-const var_h1718 T6715)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1874 T6715)
(declare-const var__temp_v1875 Int)
(declare-const |var__temp_h'1876| T6715)
(declare-const var__temp_v_err1877 T6716)
(declare-const var_h1850 T6715)
(declare-const var_h1810 T6715)
(declare-const var_h1770 T6715)
(declare-const var_h1718 T6715)
(declare-const err T6729)
    (declare-const |5| Int)
  
solver 
 (declare-sort T6715)
(declare-fun sel (T6715 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1810 () T6715)
(declare-fun var_h1718 () T6715)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h1874 () T6715)
(declare-fun |var__temp_h'1876| () T6715)
(declare-fun var__temp_v1875 () Int)
(declare-fun var_h1850 () T6715)
(declare-fun v () Int)
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1874 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1874 other) (sel var_h1850 other)))
               (= (sel var__temp_h1874 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1876| res) var__temp_v1875)
                (= (sel |var__temp_h'1876| res) (+ (sel var__temp_h1874 res) 5))
                (= (sel |var__temp_h'1876| other) (sel var__temp_h1874 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1874 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************511
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1851 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1851, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1851, other ) ==(sel)( , var_h1850, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1869:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1851 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1878 --->  Ty_heap  
 var__temp_v1879 --->  Ty_int  
 var__temp_h'1880 --->  Ty_heap  
 var__temp_v_err1881 --->  error  
 var_h1850 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1878, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1878, other ) ==(sel)( , var_h1850, other ) => 
 	 Rel (sel)( , var__temp_h1878, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1878, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1880, res ) ==(var__temp_v1879) AND 
 	 Rel (sel)( , var__temp_h'1880, res ) ==((sel)( , var__temp_h1878, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'1880, other ) ==(sel)( , var__temp_h1878, other ) => 
 	 True
 
VC_END(declare-const var_h_i1851 T6732)
(declare-const var_h1850 T6732)
(declare-const v Int)
(declare-const var_h_i1811 T6732)
(declare-const var_h1810 T6732)
(declare-const v Int)
(declare-const var_h_i1771 T6732)
(declare-const var_h1770 T6732)
(declare-const v Int)
(declare-const var_h_i1719 T6732)
(declare-const var_h1718 T6732)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1878 T6732)
(declare-const var__temp_v1879 Int)
(declare-const |var__temp_h'1880| T6732)
(declare-const var__temp_v_err1881 T6733)
(declare-const var_h1850 T6732)
(declare-const var_h1810 T6732)
(declare-const var_h1770 T6732)
(declare-const var_h1718 T6732)
(declare-const err T6746)
    (declare-const |5| Int)
  
solver 
 (declare-sort T6732)
(declare-fun sel (T6732 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1810 () T6732)
(declare-fun var_h1718 () T6732)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h1878 () T6732)
(declare-fun |var__temp_h'1880| () T6732)
(declare-fun var__temp_v1879 () Int)
(declare-fun var_h1850 () T6732)
(declare-fun v () Int)
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1878 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1878 other) (sel var_h1850 other)))
               (> (sel var__temp_h1878 res) 4)))
      (a!2 (and (= (sel |var__temp_h'1880| res) var__temp_v1879)
                (= (sel |var__temp_h'1880| res)
                   (+ (sel var__temp_h1878 res) 10))
                (= (sel |var__temp_h'1880| other) (sel var__temp_h1878 other)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h1878 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c2
PARTIAL PATH NEW
SUB 
 	 --c2
 	 --foo
 	 --c2'
 	 --foo'
 	 --c4
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1883 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1883 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1883, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1883, res ) ==((sel)( , var_h1882, res ) + (10))
 	 , (sel)( , var_h_i1883, other ) ==(sel)( , var_h1882, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1884:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1883 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************512
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1883 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1883, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1883, res ) ==((sel)( , var_h1882, res ) + (10))
 	 , (sel)( , var_h_i1883, other ) ==(sel)( , var_h1882, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1884:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1883 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1883 --->  Ty_heap  
 var_h1882 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1851 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1885 --->  Ty_heap  
 var__temp_v1886 --->  Ty_int  
 var__temp_h'1887 --->  Ty_heap  
 var__temp_v_err1888 --->  error  
 var_h1882 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h1882, res ) > (4) AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1885, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1885, res ) ==((sel)( , var_h1882, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1885, other ) ==(sel)( , var_h1882, other ) => 
 	 Rel (sel)( , var__temp_h1885, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1885, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1887, res ) ==(var__temp_v1886) AND 
 	 Rel (sel)( , var__temp_h'1887, res ) ==((sel)( , var__temp_h1885, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1887, other ) ==(sel)( , var__temp_h1885, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1887, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1887, other ) > (4)
 
VC_END(declare-const var_h_i1883 T6749)
(declare-const var_h1882 T6749)
(declare-const v Int)
(declare-const var_h_i1851 T6749)
(declare-const var_h1850 T6749)
(declare-const v Int)
(declare-const var_h_i1811 T6749)
(declare-const var_h1810 T6749)
(declare-const v Int)
(declare-const var_h_i1771 T6749)
(declare-const var_h1770 T6749)
(declare-const v Int)
(declare-const var_h_i1719 T6749)
(declare-const var_h1718 T6749)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1885 T6749)
(declare-const var__temp_v1886 Int)
(declare-const |var__temp_h'1887| T6749)
(declare-const var__temp_v_err1888 T6750)
(declare-const var_h1882 T6749)
(declare-const var_h1850 T6749)
(declare-const var_h1810 T6749)
(declare-const var_h1770 T6749)
(declare-const var_h1718 T6749)
(declare-const err T6763)

solver 
 (declare-sort T6749)
(declare-fun sel (T6749 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1882 () T6749)
(declare-fun var_h1810 () T6749)
(declare-fun var_h1718 () T6749)
(declare-fun other () Int)
(declare-fun |var__temp_h'1887| () T6749)
(declare-fun var__temp_h1885 () T6749)
(declare-fun var__temp_v1886 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1882 res) 4))
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h1885 res) v)
                (= (sel var__temp_h1885 res) (+ (sel var_h1882 res) 10))
                (= (sel var__temp_h1885 other) (sel var_h1882 other))))
      (a!2 (and (= (sel |var__temp_h'1887| res) var__temp_v1886)
                (= (sel |var__temp_h'1887| res) (+ (sel var__temp_h1885 res) 3))
                (= (sel |var__temp_h'1887| other) (sel var__temp_h1885 other))))
      (a!3 (and (= (sel |var__temp_h'1887| res) 10)
                (not (> (sel |var__temp_h'1887| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1885 res) 7))
                (=> (= (sel var__temp_h1885 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************513
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1883 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1883, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1883, res ) ==((sel)( , var_h1882, res ) + (10))
 	 , (sel)( , var_h_i1883, other ) ==(sel)( , var_h1882, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1884:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1883 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1883 --->  Ty_heap  
 var_h1882 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1851 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1889 --->  Ty_heap  
 var__temp_v1890 --->  Ty_int  
 var__temp_h'1891 --->  Ty_heap  
 var__temp_v_err1892 --->  error  
 var_h1882 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h1882, res ) > (4) AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1889, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1889, res ) ==((sel)( , var_h1882, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1889, other ) ==(sel)( , var_h1882, other ) => 
 	 Rel (sel)( , var__temp_h1889, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1889, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1891, res ) ==(var__temp_v1890) AND 
 	 Rel (sel)( , var__temp_h'1891, res ) ==((sel)( , var__temp_h1889, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1891, other ) ==(sel)( , var__temp_h1889, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1891, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1891, other ) > (4)
 
VC_END(declare-const var_h_i1883 T6766)
(declare-const var_h1882 T6766)
(declare-const v Int)
(declare-const var_h_i1851 T6766)
(declare-const var_h1850 T6766)
(declare-const v Int)
(declare-const var_h_i1811 T6766)
(declare-const var_h1810 T6766)
(declare-const v Int)
(declare-const var_h_i1771 T6766)
(declare-const var_h1770 T6766)
(declare-const v Int)
(declare-const var_h_i1719 T6766)
(declare-const var_h1718 T6766)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1889 T6766)
(declare-const var__temp_v1890 Int)
(declare-const |var__temp_h'1891| T6766)
(declare-const var__temp_v_err1892 T6767)
(declare-const var_h1882 T6766)
(declare-const var_h1850 T6766)
(declare-const var_h1810 T6766)
(declare-const var_h1770 T6766)
(declare-const var_h1718 T6766)
(declare-const err T6780)

solver 
 (declare-sort T6766)
(declare-fun sel (T6766 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1882 () T6766)
(declare-fun var_h1810 () T6766)
(declare-fun var_h1718 () T6766)
(declare-fun other () Int)
(declare-fun |var__temp_h'1891| () T6766)
(declare-fun var__temp_h1889 () T6766)
(declare-fun var__temp_v1890 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1882 res) 4))
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h1889 res) v)
                (= (sel var__temp_h1889 res) (+ (sel var_h1882 res) 10))
                (= (sel var__temp_h1889 other) (sel var_h1882 other))))
      (a!2 (and (= (sel |var__temp_h'1891| res) var__temp_v1890)
                (= (sel |var__temp_h'1891| res) (+ (sel var__temp_h1889 res) 5))
                (= (sel |var__temp_h'1891| other) (sel var__temp_h1889 other))))
      (a!3 (and (= (sel |var__temp_h'1891| res) 10)
                (not (> (sel |var__temp_h'1891| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1889 res) 7))
                (=> (= (sel var__temp_h1889 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************514
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1883 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1883, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1883, res ) ==((sel)( , var_h1882, res ) + (10))
 	 , (sel)( , var_h_i1883, other ) ==(sel)( , var_h1882, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1884:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1883 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1883 --->  Ty_heap  
 var_h1882 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1851 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1893 --->  Ty_heap  
 var__temp_v1894 --->  Ty_int  
 var__temp_h'1895 --->  Ty_heap  
 var__temp_v_err1896 --->  error  
 var_h1882 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h1882, res ) > (4) AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1893, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1893, res ) ==((sel)( , var_h1882, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1893, other ) ==(sel)( , var_h1882, other ) => 
 	 Rel (sel)( , var__temp_h1893, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1893, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1895, res ) ==(var__temp_v1894) AND 
 	 Rel (sel)( , var__temp_h'1895, res ) ==((sel)( , var__temp_h1893, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1895, other ) ==(sel)( , var__temp_h1893, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1895, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1895, other ) > (4)
 
VC_END(declare-const var_h_i1883 T6783)
(declare-const var_h1882 T6783)
(declare-const v Int)
(declare-const var_h_i1851 T6783)
(declare-const var_h1850 T6783)
(declare-const v Int)
(declare-const var_h_i1811 T6783)
(declare-const var_h1810 T6783)
(declare-const v Int)
(declare-const var_h_i1771 T6783)
(declare-const var_h1770 T6783)
(declare-const v Int)
(declare-const var_h_i1719 T6783)
(declare-const var_h1718 T6783)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1893 T6783)
(declare-const var__temp_v1894 Int)
(declare-const |var__temp_h'1895| T6783)
(declare-const var__temp_v_err1896 T6784)
(declare-const var_h1882 T6783)
(declare-const var_h1850 T6783)
(declare-const var_h1810 T6783)
(declare-const var_h1770 T6783)
(declare-const var_h1718 T6783)
(declare-const err T6797)

solver 
 (declare-sort T6783)
(declare-fun sel (T6783 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1882 () T6783)
(declare-fun var_h1810 () T6783)
(declare-fun var_h1718 () T6783)
(declare-fun other () Int)
(declare-fun |var__temp_h'1895| () T6783)
(declare-fun var__temp_h1893 () T6783)
(declare-fun var__temp_v1894 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1882 res) 4))
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h1893 res) v)
                (= (sel var__temp_h1893 res) (+ (sel var_h1882 res) 10))
                (= (sel var__temp_h1893 other) (sel var_h1882 other))))
      (a!2 (and (= (sel |var__temp_h'1895| res) var__temp_v1894)
                (= (sel |var__temp_h'1895| res) (+ (sel var__temp_h1893 res) 2))
                (= (sel |var__temp_h'1895| other) (sel var__temp_h1893 other))))
      (a!3 (and (= (sel |var__temp_h'1895| res) 10)
                (not (> (sel |var__temp_h'1895| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1893 res) 5))
                (=> (= (sel var__temp_h1893 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************515
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1884:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1884:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2fooc2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c2
 	 --foo
 	 --c2'
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1883 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1883, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1883, res ) ==((sel)( , var_h1882, res ) + (10))
 	 , (sel)( , var_h_i1883, other ) ==(sel)( , var_h1882, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1897:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************516
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1883 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1883, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1883, res ) ==((sel)( , var_h1882, res ) + (10))
 	 , (sel)( , var_h_i1883, other ) ==(sel)( , var_h1882, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1897:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1883 --->  Ty_heap  
 var_h1882 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1851 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1898 --->  Ty_heap  
 var__temp_v1899 --->  Ty_int  
 var__temp_h'1900 --->  Ty_heap  
 var__temp_v_err1901 --->  error  
 var_h1882 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h1882, res ) > (4) AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1898, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1898, res ) ==((sel)( , var_h1882, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1898, other ) ==(sel)( , var_h1882, other ) => 
 	 Rel (sel)( , var__temp_h1898, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1898, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1900, res ) ==(var__temp_v1899) AND 
 	 Rel (sel)( , var__temp_h'1900, res ) ==((sel)( , var__temp_h1898, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1900, other ) ==(sel)( , var__temp_h1898, other ) => 
 	 True
 
VC_END(declare-const var_h_i1883 T6800)
(declare-const var_h1882 T6800)
(declare-const v Int)
(declare-const var_h_i1851 T6800)
(declare-const var_h1850 T6800)
(declare-const v Int)
(declare-const var_h_i1811 T6800)
(declare-const var_h1810 T6800)
(declare-const v Int)
(declare-const var_h_i1771 T6800)
(declare-const var_h1770 T6800)
(declare-const v Int)
(declare-const var_h_i1719 T6800)
(declare-const var_h1718 T6800)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1898 T6800)
(declare-const var__temp_v1899 Int)
(declare-const |var__temp_h'1900| T6800)
(declare-const var__temp_v_err1901 T6801)
(declare-const var_h1882 T6800)
(declare-const var_h1850 T6800)
(declare-const var_h1810 T6800)
(declare-const var_h1770 T6800)
(declare-const var_h1718 T6800)
(declare-const err T6814)

solver 
 (declare-sort T6800)
(declare-fun sel (T6800 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1882 () T6800)
(declare-fun var_h1810 () T6800)
(declare-fun var_h1718 () T6800)
(declare-fun other () Int)
(declare-fun var__temp_h1898 () T6800)
(declare-fun |var__temp_h'1900| () T6800)
(declare-fun var__temp_v1899 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1882 res) 4))
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h1898 res) v)
                (= (sel var__temp_h1898 res) (+ (sel var_h1882 res) 10))
                (= (sel var__temp_h1898 other) (sel var_h1882 other))))
      (a!2 (and (= (sel |var__temp_h'1900| res) var__temp_v1899)
                (= (sel |var__temp_h'1900| res) (+ (sel var__temp_h1898 res) 3))
                (= (sel |var__temp_h'1900| other) (sel var__temp_h1898 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1898 res) 7))
                (=> (= (sel var__temp_h1898 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************517
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1883 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1883, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1883, res ) ==((sel)( , var_h1882, res ) + (10))
 	 , (sel)( , var_h_i1883, other ) ==(sel)( , var_h1882, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1897:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1883 --->  Ty_heap  
 var_h1882 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1851 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1902 --->  Ty_heap  
 var__temp_v1903 --->  Ty_int  
 var__temp_h'1904 --->  Ty_heap  
 var__temp_v_err1905 --->  error  
 var_h1882 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h1882, res ) > (4) AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1902, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1902, res ) ==((sel)( , var_h1882, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1902, other ) ==(sel)( , var_h1882, other ) => 
 	 Rel (sel)( , var__temp_h1902, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1902, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1904, res ) ==(var__temp_v1903) AND 
 	 Rel (sel)( , var__temp_h'1904, res ) ==((sel)( , var__temp_h1902, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1904, other ) ==(sel)( , var__temp_h1902, other ) => 
 	 True
 
VC_END(declare-const var_h_i1883 T6817)
(declare-const var_h1882 T6817)
(declare-const v Int)
(declare-const var_h_i1851 T6817)
(declare-const var_h1850 T6817)
(declare-const v Int)
(declare-const var_h_i1811 T6817)
(declare-const var_h1810 T6817)
(declare-const v Int)
(declare-const var_h_i1771 T6817)
(declare-const var_h1770 T6817)
(declare-const v Int)
(declare-const var_h_i1719 T6817)
(declare-const var_h1718 T6817)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1902 T6817)
(declare-const var__temp_v1903 Int)
(declare-const |var__temp_h'1904| T6817)
(declare-const var__temp_v_err1905 T6818)
(declare-const var_h1882 T6817)
(declare-const var_h1850 T6817)
(declare-const var_h1810 T6817)
(declare-const var_h1770 T6817)
(declare-const var_h1718 T6817)
(declare-const err T6831)

solver 
 (declare-sort T6817)
(declare-fun sel (T6817 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1882 () T6817)
(declare-fun var_h1810 () T6817)
(declare-fun var_h1718 () T6817)
(declare-fun other () Int)
(declare-fun var__temp_h1902 () T6817)
(declare-fun |var__temp_h'1904| () T6817)
(declare-fun var__temp_v1903 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1882 res) 4))
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h1902 res) v)
                (= (sel var__temp_h1902 res) (+ (sel var_h1882 res) 10))
                (= (sel var__temp_h1902 other) (sel var_h1882 other))))
      (a!2 (and (= (sel |var__temp_h'1904| res) var__temp_v1903)
                (= (sel |var__temp_h'1904| res) (+ (sel var__temp_h1902 res) 5))
                (= (sel |var__temp_h'1904| other) (sel var__temp_h1902 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1902 res) 7))
                (=> (= (sel var__temp_h1902 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************518
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1883 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1883, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1883, res ) ==((sel)( , var_h1882, res ) + (10))
 	 , (sel)( , var_h_i1883, other ) ==(sel)( , var_h1882, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1897:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1883 --->  Ty_heap  
 var_h1882 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1851 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1906 --->  Ty_heap  
 var__temp_v1907 --->  Ty_int  
 var__temp_h'1908 --->  Ty_heap  
 var__temp_v_err1909 --->  error  
 var_h1882 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h1882, res ) > (4) AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1906, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1906, res ) ==((sel)( , var_h1882, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h1906, other ) ==(sel)( , var_h1882, other ) => 
 	 Rel (sel)( , var__temp_h1906, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1906, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1908, res ) ==(var__temp_v1907) AND 
 	 Rel (sel)( , var__temp_h'1908, res ) ==((sel)( , var__temp_h1906, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1908, other ) ==(sel)( , var__temp_h1906, other ) => 
 	 True
 
VC_END(declare-const var_h_i1883 T6834)
(declare-const var_h1882 T6834)
(declare-const v Int)
(declare-const var_h_i1851 T6834)
(declare-const var_h1850 T6834)
(declare-const v Int)
(declare-const var_h_i1811 T6834)
(declare-const var_h1810 T6834)
(declare-const v Int)
(declare-const var_h_i1771 T6834)
(declare-const var_h1770 T6834)
(declare-const v Int)
(declare-const var_h_i1719 T6834)
(declare-const var_h1718 T6834)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1906 T6834)
(declare-const var__temp_v1907 Int)
(declare-const |var__temp_h'1908| T6834)
(declare-const var__temp_v_err1909 T6835)
(declare-const var_h1882 T6834)
(declare-const var_h1850 T6834)
(declare-const var_h1810 T6834)
(declare-const var_h1770 T6834)
(declare-const var_h1718 T6834)
(declare-const err T6848)

solver 
 (declare-sort T6834)
(declare-fun sel (T6834 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1882 () T6834)
(declare-fun var_h1810 () T6834)
(declare-fun var_h1718 () T6834)
(declare-fun other () Int)
(declare-fun var__temp_h1906 () T6834)
(declare-fun |var__temp_h'1908| () T6834)
(declare-fun var__temp_v1907 () Int)
(declare-fun v () Int)
(assert (> (sel var_h1882 res) 4))
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h1906 res) v)
                (= (sel var__temp_h1906 res) (+ (sel var_h1882 res) 10))
                (= (sel var__temp_h1906 other) (sel var_h1882 other))))
      (a!2 (and (= (sel |var__temp_h'1908| res) var__temp_v1907)
                (= (sel |var__temp_h'1908| res) (+ (sel var__temp_h1906 res) 2))
                (= (sel |var__temp_h'1908| other) (sel var__temp_h1906 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1906 res) 5))
                (=> (= (sel var__temp_h1906 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************519
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 
 	 --foo
 	 --c2'
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1851 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1851, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1851, other ) ==(sel)( , var_h1850, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1910:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************520
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1851 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1851, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1851, other ) ==(sel)( , var_h1850, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1910:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1851 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1911 --->  Ty_heap  
 var__temp_v1912 --->  Ty_int  
 var__temp_h'1913 --->  Ty_heap  
 var__temp_v_err1914 --->  error  
 var_h1850 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1911, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1911, other ) ==(sel)( , var_h1850, other ) => 
 	 Rel (sel)( , var__temp_h1911, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1911, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1913, res ) ==(var__temp_v1912) AND 
 	 Rel (sel)( , var__temp_h'1913, res ) ==((sel)( , var__temp_h1911, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1913, other ) ==(sel)( , var__temp_h1911, other ) => 
 	 True
 
VC_END(declare-const var_h_i1851 T6851)
(declare-const var_h1850 T6851)
(declare-const v Int)
(declare-const var_h_i1811 T6851)
(declare-const var_h1810 T6851)
(declare-const v Int)
(declare-const var_h_i1771 T6851)
(declare-const var_h1770 T6851)
(declare-const v Int)
(declare-const var_h_i1719 T6851)
(declare-const var_h1718 T6851)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1911 T6851)
(declare-const var__temp_v1912 Int)
(declare-const |var__temp_h'1913| T6851)
(declare-const var__temp_v_err1914 T6852)
(declare-const var_h1850 T6851)
(declare-const var_h1810 T6851)
(declare-const var_h1770 T6851)
(declare-const var_h1718 T6851)
(declare-const err T6865)
    (declare-const |5| Int)
  
solver 
 (declare-sort T6851)
(declare-fun sel (T6851 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1810 () T6851)
(declare-fun var_h1718 () T6851)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h1911 () T6851)
(declare-fun |var__temp_h'1913| () T6851)
(declare-fun var__temp_v1912 () Int)
(declare-fun var_h1850 () T6851)
(declare-fun v () Int)
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1911 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1911 other) (sel var_h1850 other)))
               (= (sel var__temp_h1911 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1913| res) var__temp_v1912)
                (= (sel |var__temp_h'1913| res) (+ (sel var__temp_h1911 res) 3))
                (= (sel |var__temp_h'1913| other) (sel var__temp_h1911 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1911 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************521
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1851 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1851, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1851, other ) ==(sel)( , var_h1850, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1910:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1851 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1915 --->  Ty_heap  
 var__temp_v1916 --->  Ty_int  
 var__temp_h'1917 --->  Ty_heap  
 var__temp_v_err1918 --->  error  
 var_h1850 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1915, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1915, other ) ==(sel)( , var_h1850, other ) => 
 	 Rel (sel)( , var__temp_h1915, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1915, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1917, res ) ==(var__temp_v1916) AND 
 	 Rel (sel)( , var__temp_h'1917, res ) ==((sel)( , var__temp_h1915, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1917, other ) ==(sel)( , var__temp_h1915, other ) => 
 	 True
 
VC_END(declare-const var_h_i1851 T6868)
(declare-const var_h1850 T6868)
(declare-const v Int)
(declare-const var_h_i1811 T6868)
(declare-const var_h1810 T6868)
(declare-const v Int)
(declare-const var_h_i1771 T6868)
(declare-const var_h1770 T6868)
(declare-const v Int)
(declare-const var_h_i1719 T6868)
(declare-const var_h1718 T6868)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1915 T6868)
(declare-const var__temp_v1916 Int)
(declare-const |var__temp_h'1917| T6868)
(declare-const var__temp_v_err1918 T6869)
(declare-const var_h1850 T6868)
(declare-const var_h1810 T6868)
(declare-const var_h1770 T6868)
(declare-const var_h1718 T6868)
(declare-const err T6882)
    (declare-const |5| Int)
  
solver 
 (declare-sort T6868)
(declare-fun sel (T6868 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1810 () T6868)
(declare-fun var_h1718 () T6868)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h1915 () T6868)
(declare-fun |var__temp_h'1917| () T6868)
(declare-fun var__temp_v1916 () Int)
(declare-fun var_h1850 () T6868)
(declare-fun v () Int)
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1915 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1915 other) (sel var_h1850 other)))
               (= (sel var__temp_h1915 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1917| res) var__temp_v1916)
                (= (sel |var__temp_h'1917| res) (+ (sel var__temp_h1915 res) 5))
                (= (sel |var__temp_h'1917| other) (sel var__temp_h1915 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1915 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************522
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1851 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1851, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1851, other ) ==(sel)( , var_h1850, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1910:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1851 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1919 --->  Ty_heap  
 var__temp_v1920 --->  Ty_int  
 var__temp_h'1921 --->  Ty_heap  
 var__temp_v_err1922 --->  error  
 var_h1850 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1919, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1919, other ) ==(sel)( , var_h1850, other ) => 
 	 Rel (sel)( , var__temp_h1919, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1919, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1921, res ) ==(var__temp_v1920) AND 
 	 Rel (sel)( , var__temp_h'1921, res ) ==((sel)( , var__temp_h1919, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1921, other ) ==(sel)( , var__temp_h1919, other ) => 
 	 True
 
VC_END(declare-const var_h_i1851 T6885)
(declare-const var_h1850 T6885)
(declare-const v Int)
(declare-const var_h_i1811 T6885)
(declare-const var_h1810 T6885)
(declare-const v Int)
(declare-const var_h_i1771 T6885)
(declare-const var_h1770 T6885)
(declare-const v Int)
(declare-const var_h_i1719 T6885)
(declare-const var_h1718 T6885)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1919 T6885)
(declare-const var__temp_v1920 Int)
(declare-const |var__temp_h'1921| T6885)
(declare-const var__temp_v_err1922 T6886)
(declare-const var_h1850 T6885)
(declare-const var_h1810 T6885)
(declare-const var_h1770 T6885)
(declare-const var_h1718 T6885)
(declare-const err T6899)
    (declare-const |5| Int)
  
solver 
 (declare-sort T6885)
(declare-fun sel (T6885 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1810 () T6885)
(declare-fun var_h1718 () T6885)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h1919 () T6885)
(declare-fun |var__temp_h'1921| () T6885)
(declare-fun var__temp_v1920 () Int)
(declare-fun var_h1850 () T6885)
(declare-fun v () Int)
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1919 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1919 other) (sel var_h1850 other)))
               (= (sel var__temp_h1919 res) 5)))
      (a!2 (and (= (sel |var__temp_h'1921| res) var__temp_v1920)
                (= (sel |var__temp_h'1921| res) (+ (sel var__temp_h1919 res) 2))
                (= (sel |var__temp_h'1921| other) (sel var__temp_h1919 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1919 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************bar
PARTIAL PATH NEW
SUB 
 	 --bar
 	 --foo
 	 --c2'
 	 --foo'
 	 --c4
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1924 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1924 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1924, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1924, res ) ==((sel)( , var_h1923, res ) + (2))
 	 , (sel)( , var_h_i1924, other ) ==(sel)( , var_h1923, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1925:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1924 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************523
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1924 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1924, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1924, res ) ==((sel)( , var_h1923, res ) + (2))
 	 , (sel)( , var_h_i1924, other ) ==(sel)( , var_h1923, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1925:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1924 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1924 --->  Ty_heap  
 var_h1923 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1851 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1926 --->  Ty_heap  
 var__temp_v1927 --->  Ty_int  
 var__temp_h'1928 --->  Ty_heap  
 var__temp_v_err1929 --->  error  
 var_h1923 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h1923, res ) ==(5) AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1926, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1926, res ) ==((sel)( , var_h1923, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h1926, other ) ==(sel)( , var_h1923, other ) => 
 	 Rel (sel)( , var__temp_h1926, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1926, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1928, res ) ==(var__temp_v1927) AND 
 	 Rel (sel)( , var__temp_h'1928, res ) ==((sel)( , var__temp_h1926, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1928, other ) ==(sel)( , var__temp_h1926, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1928, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1928, other ) > (4)
 
VC_END(declare-const var_h_i1924 T6902)
(declare-const var_h1923 T6902)
(declare-const v Int)
(declare-const var_h_i1851 T6902)
(declare-const var_h1850 T6902)
(declare-const v Int)
(declare-const var_h_i1811 T6902)
(declare-const var_h1810 T6902)
(declare-const v Int)
(declare-const var_h_i1771 T6902)
(declare-const var_h1770 T6902)
(declare-const v Int)
(declare-const var_h_i1719 T6902)
(declare-const var_h1718 T6902)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1926 T6902)
(declare-const var__temp_v1927 Int)
(declare-const |var__temp_h'1928| T6902)
(declare-const var__temp_v_err1929 T6903)
(declare-const var_h1923 T6902)
(declare-const var_h1850 T6902)
(declare-const var_h1810 T6902)
(declare-const var_h1770 T6902)
(declare-const var_h1718 T6902)
(declare-const err T6916)

solver 
 (declare-sort T6902)
(declare-fun sel (T6902 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1923 () T6902)
(declare-fun var_h1810 () T6902)
(declare-fun var_h1718 () T6902)
(declare-fun other () Int)
(declare-fun |var__temp_h'1928| () T6902)
(declare-fun var__temp_h1926 () T6902)
(declare-fun var__temp_v1927 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1923 res) 5))
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h1926 res) v)
                (= (sel var__temp_h1926 res) (+ (sel var_h1923 res) 2))
                (= (sel var__temp_h1926 other) (sel var_h1923 other))))
      (a!2 (and (= (sel |var__temp_h'1928| res) var__temp_v1927)
                (= (sel |var__temp_h'1928| res) (+ (sel var__temp_h1926 res) 3))
                (= (sel |var__temp_h'1928| other) (sel var__temp_h1926 other))))
      (a!3 (and (= (sel |var__temp_h'1928| res) 10)
                (not (> (sel |var__temp_h'1928| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1926 res) 7))
                (=> (= (sel var__temp_h1926 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************524
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1924 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1924, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1924, res ) ==((sel)( , var_h1923, res ) + (2))
 	 , (sel)( , var_h_i1924, other ) ==(sel)( , var_h1923, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1925:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1924 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1924 --->  Ty_heap  
 var_h1923 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1851 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1930 --->  Ty_heap  
 var__temp_v1931 --->  Ty_int  
 var__temp_h'1932 --->  Ty_heap  
 var__temp_v_err1933 --->  error  
 var_h1923 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h1923, res ) ==(5) AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1930, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1930, res ) ==((sel)( , var_h1923, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h1930, other ) ==(sel)( , var_h1923, other ) => 
 	 Rel (sel)( , var__temp_h1930, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1930, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1932, res ) ==(var__temp_v1931) AND 
 	 Rel (sel)( , var__temp_h'1932, res ) ==((sel)( , var__temp_h1930, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1932, other ) ==(sel)( , var__temp_h1930, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1932, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1932, other ) > (4)
 
VC_END(declare-const var_h_i1924 T6919)
(declare-const var_h1923 T6919)
(declare-const v Int)
(declare-const var_h_i1851 T6919)
(declare-const var_h1850 T6919)
(declare-const v Int)
(declare-const var_h_i1811 T6919)
(declare-const var_h1810 T6919)
(declare-const v Int)
(declare-const var_h_i1771 T6919)
(declare-const var_h1770 T6919)
(declare-const v Int)
(declare-const var_h_i1719 T6919)
(declare-const var_h1718 T6919)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1930 T6919)
(declare-const var__temp_v1931 Int)
(declare-const |var__temp_h'1932| T6919)
(declare-const var__temp_v_err1933 T6920)
(declare-const var_h1923 T6919)
(declare-const var_h1850 T6919)
(declare-const var_h1810 T6919)
(declare-const var_h1770 T6919)
(declare-const var_h1718 T6919)
(declare-const err T6933)

solver 
 (declare-sort T6919)
(declare-fun sel (T6919 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1923 () T6919)
(declare-fun var_h1810 () T6919)
(declare-fun var_h1718 () T6919)
(declare-fun other () Int)
(declare-fun |var__temp_h'1932| () T6919)
(declare-fun var__temp_h1930 () T6919)
(declare-fun var__temp_v1931 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1923 res) 5))
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h1930 res) v)
                (= (sel var__temp_h1930 res) (+ (sel var_h1923 res) 2))
                (= (sel var__temp_h1930 other) (sel var_h1923 other))))
      (a!2 (and (= (sel |var__temp_h'1932| res) var__temp_v1931)
                (= (sel |var__temp_h'1932| res) (+ (sel var__temp_h1930 res) 5))
                (= (sel |var__temp_h'1932| other) (sel var__temp_h1930 other))))
      (a!3 (and (= (sel |var__temp_h'1932| res) 10)
                (not (> (sel |var__temp_h'1932| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1930 res) 7))
                (=> (= (sel var__temp_h1930 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************525
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1925:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1925:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbarc2fooc2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2'
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1924 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1924, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1924, res ) ==((sel)( , var_h1923, res ) + (2))
 	 , (sel)( , var_h_i1924, other ) ==(sel)( , var_h1923, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1934:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************526
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1924 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1924, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1924, res ) ==((sel)( , var_h1923, res ) + (2))
 	 , (sel)( , var_h_i1924, other ) ==(sel)( , var_h1923, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1934:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1924 --->  Ty_heap  
 var_h1923 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1851 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1935 --->  Ty_heap  
 var__temp_v1936 --->  Ty_int  
 var__temp_h'1937 --->  Ty_heap  
 var__temp_v_err1938 --->  error  
 var_h1923 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h1923, res ) ==(5) AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1935, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1935, res ) ==((sel)( , var_h1923, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h1935, other ) ==(sel)( , var_h1923, other ) => 
 	 Rel (sel)( , var__temp_h1935, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1935, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1937, res ) ==(var__temp_v1936) AND 
 	 Rel (sel)( , var__temp_h'1937, res ) ==((sel)( , var__temp_h1935, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1937, other ) ==(sel)( , var__temp_h1935, other ) => 
 	 True
 
VC_END(declare-const var_h_i1924 T6936)
(declare-const var_h1923 T6936)
(declare-const v Int)
(declare-const var_h_i1851 T6936)
(declare-const var_h1850 T6936)
(declare-const v Int)
(declare-const var_h_i1811 T6936)
(declare-const var_h1810 T6936)
(declare-const v Int)
(declare-const var_h_i1771 T6936)
(declare-const var_h1770 T6936)
(declare-const v Int)
(declare-const var_h_i1719 T6936)
(declare-const var_h1718 T6936)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1935 T6936)
(declare-const var__temp_v1936 Int)
(declare-const |var__temp_h'1937| T6936)
(declare-const var__temp_v_err1938 T6937)
(declare-const var_h1923 T6936)
(declare-const var_h1850 T6936)
(declare-const var_h1810 T6936)
(declare-const var_h1770 T6936)
(declare-const var_h1718 T6936)
(declare-const err T6950)

solver 
 (declare-sort T6936)
(declare-fun sel (T6936 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1923 () T6936)
(declare-fun var_h1810 () T6936)
(declare-fun var_h1718 () T6936)
(declare-fun other () Int)
(declare-fun var__temp_h1935 () T6936)
(declare-fun |var__temp_h'1937| () T6936)
(declare-fun var__temp_v1936 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1923 res) 5))
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h1935 res) v)
                (= (sel var__temp_h1935 res) (+ (sel var_h1923 res) 2))
                (= (sel var__temp_h1935 other) (sel var_h1923 other))))
      (a!2 (and (= (sel |var__temp_h'1937| res) var__temp_v1936)
                (= (sel |var__temp_h'1937| res) (+ (sel var__temp_h1935 res) 3))
                (= (sel |var__temp_h'1937| other) (sel var__temp_h1935 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1935 res) 7))
                (=> (= (sel var__temp_h1935 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************baz
PARTIAL PATH NEW
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --c2'
 	 --foo'
 	 --c4
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1940 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1940 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1940, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1940, res ) ==((sel)( , var_h1939, res ) + (3))
 	 , (sel)( , var_h_i1940, other ) ==(sel)( , var_h1939, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1941:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1940 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************527
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1940 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1940, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1940, res ) ==((sel)( , var_h1939, res ) + (3))
 	 , (sel)( , var_h_i1940, other ) ==(sel)( , var_h1939, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1941:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1940 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1940 --->  Ty_heap  
 var_h1939 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1924 --->  Ty_heap  
 var_h1923 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1851 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1942 --->  Ty_heap  
 var__temp_v1943 --->  Ty_int  
 var__temp_h'1944 --->  Ty_heap  
 var__temp_v_err1945 --->  error  
 var_h1939 --->  Ty_heap  
 var_h1923 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h1939, res ) ==(7) AND 
 	 Rel (sel)( , var_h1923, res ) ==(5) AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1942, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1942, res ) ==((sel)( , var_h1939, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h1942, other ) ==(sel)( , var_h1939, other ) => 
 	 Rel (sel)( , var__temp_h1942, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1942, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1944, res ) ==(var__temp_v1943) AND 
 	 Rel (sel)( , var__temp_h'1944, res ) ==((sel)( , var__temp_h1942, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1944, other ) ==(sel)( , var__temp_h1942, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1944, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'1944, other ) > (4)
 
VC_END(declare-const var_h_i1940 T6953)
(declare-const var_h1939 T6953)
(declare-const v Int)
(declare-const var_h_i1924 T6953)
(declare-const var_h1923 T6953)
(declare-const v Int)
(declare-const var_h_i1851 T6953)
(declare-const var_h1850 T6953)
(declare-const v Int)
(declare-const var_h_i1811 T6953)
(declare-const var_h1810 T6953)
(declare-const v Int)
(declare-const var_h_i1771 T6953)
(declare-const var_h1770 T6953)
(declare-const v Int)
(declare-const var_h_i1719 T6953)
(declare-const var_h1718 T6953)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1942 T6953)
(declare-const var__temp_v1943 Int)
(declare-const |var__temp_h'1944| T6953)
(declare-const var__temp_v_err1945 T6954)
(declare-const var_h1939 T6953)
(declare-const var_h1923 T6953)
(declare-const var_h1850 T6953)
(declare-const var_h1810 T6953)
(declare-const var_h1770 T6953)
(declare-const var_h1718 T6953)
(declare-const err T6967)

solver 
 (declare-sort T6953)
(declare-fun sel (T6953 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1939 () T6953)
(declare-fun var_h1923 () T6953)
(declare-fun var_h1810 () T6953)
(declare-fun var_h1718 () T6953)
(declare-fun other () Int)
(declare-fun |var__temp_h'1944| () T6953)
(declare-fun var__temp_h1942 () T6953)
(declare-fun var__temp_v1943 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1939 res) 7))
(assert (= (sel var_h1923 res) 5))
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h1942 res) v)
                (= (sel var__temp_h1942 res) (+ (sel var_h1939 res) 3))
                (= (sel var__temp_h1942 other) (sel var_h1939 other))))
      (a!2 (and (= (sel |var__temp_h'1944| res) var__temp_v1943)
                (= (sel |var__temp_h'1944| res) (+ (sel var__temp_h1942 res) 5))
                (= (sel |var__temp_h'1944| other) (sel var__temp_h1942 other))))
      (a!3 (and (= (sel |var__temp_h'1944| res) 10)
                (not (> (sel |var__temp_h'1944| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h1942 res) 7))
                (=> (= (sel var__temp_h1942 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************528
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1941:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1941:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbazbarc2fooc2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --c2'
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1940 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1940, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1940, res ) ==((sel)( , var_h1939, res ) + (3))
 	 , (sel)( , var_h_i1940, other ) ==(sel)( , var_h1939, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1946:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************529
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1940 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1940, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1940, res ) ==((sel)( , var_h1939, res ) + (3))
 	 , (sel)( , var_h_i1940, other ) ==(sel)( , var_h1939, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1946:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1940 --->  Ty_heap  
 var_h1939 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1924 --->  Ty_heap  
 var_h1923 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1851 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1947 --->  Ty_heap  
 var__temp_v1948 --->  Ty_int  
 var__temp_h'1949 --->  Ty_heap  
 var__temp_v_err1950 --->  error  
 var_h1939 --->  Ty_heap  
 var_h1923 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h1939, res ) ==(7) AND 
 	 Rel (sel)( , var_h1923, res ) ==(5) AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1947, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1947, res ) ==((sel)( , var_h1939, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h1947, other ) ==(sel)( , var_h1939, other ) => 
 	 Rel (sel)( , var__temp_h1947, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1947, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1949, res ) ==(var__temp_v1948) AND 
 	 Rel (sel)( , var__temp_h'1949, res ) ==((sel)( , var__temp_h1947, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1949, other ) ==(sel)( , var__temp_h1947, other ) => 
 	 True
 
VC_END(declare-const var_h_i1940 T6970)
(declare-const var_h1939 T6970)
(declare-const v Int)
(declare-const var_h_i1924 T6970)
(declare-const var_h1923 T6970)
(declare-const v Int)
(declare-const var_h_i1851 T6970)
(declare-const var_h1850 T6970)
(declare-const v Int)
(declare-const var_h_i1811 T6970)
(declare-const var_h1810 T6970)
(declare-const v Int)
(declare-const var_h_i1771 T6970)
(declare-const var_h1770 T6970)
(declare-const v Int)
(declare-const var_h_i1719 T6970)
(declare-const var_h1718 T6970)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1947 T6970)
(declare-const var__temp_v1948 Int)
(declare-const |var__temp_h'1949| T6970)
(declare-const var__temp_v_err1950 T6971)
(declare-const var_h1939 T6970)
(declare-const var_h1923 T6970)
(declare-const var_h1850 T6970)
(declare-const var_h1810 T6970)
(declare-const var_h1770 T6970)
(declare-const var_h1718 T6970)
(declare-const err T6984)

solver 
 (declare-sort T6970)
(declare-fun sel (T6970 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1939 () T6970)
(declare-fun var_h1923 () T6970)
(declare-fun var_h1810 () T6970)
(declare-fun var_h1718 () T6970)
(declare-fun other () Int)
(declare-fun var__temp_h1947 () T6970)
(declare-fun |var__temp_h'1949| () T6970)
(declare-fun var__temp_v1948 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1939 res) 7))
(assert (= (sel var_h1923 res) 5))
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h1947 res) v)
                (= (sel var__temp_h1947 res) (+ (sel var_h1939 res) 3))
                (= (sel var__temp_h1947 other) (sel var_h1939 other))))
      (a!2 (and (= (sel |var__temp_h'1949| res) var__temp_v1948)
                (= (sel |var__temp_h'1949| res) (+ (sel var__temp_h1947 res) 5))
                (= (sel |var__temp_h'1949| other) (sel var__temp_h1947 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1947 res) 7))
                (=> (= (sel var__temp_h1947 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************530
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT baz
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2'
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1924 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1924, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1924, res ) ==((sel)( , var_h1923, res ) + (2))
 	 , (sel)( , var_h_i1924, other ) ==(sel)( , var_h1923, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1951:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************531
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1924 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1924, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1924, res ) ==((sel)( , var_h1923, res ) + (2))
 	 , (sel)( , var_h_i1924, other ) ==(sel)( , var_h1923, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1951:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1924 --->  Ty_heap  
 var_h1923 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1851 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1952 --->  Ty_heap  
 var__temp_v1953 --->  Ty_int  
 var__temp_h'1954 --->  Ty_heap  
 var__temp_v_err1955 --->  error  
 var_h1923 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h1923, res ) ==(5) AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1952, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h1952, res ) ==((sel)( , var_h1923, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h1952, other ) ==(sel)( , var_h1923, other ) => 
 	 Rel (sel)( , var__temp_h1952, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1952, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1954, res ) ==(var__temp_v1953) AND 
 	 Rel (sel)( , var__temp_h'1954, res ) ==((sel)( , var__temp_h1952, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1954, other ) ==(sel)( , var__temp_h1952, other ) => 
 	 True
 
VC_END(declare-const var_h_i1924 T6987)
(declare-const var_h1923 T6987)
(declare-const v Int)
(declare-const var_h_i1851 T6987)
(declare-const var_h1850 T6987)
(declare-const v Int)
(declare-const var_h_i1811 T6987)
(declare-const var_h1810 T6987)
(declare-const v Int)
(declare-const var_h_i1771 T6987)
(declare-const var_h1770 T6987)
(declare-const v Int)
(declare-const var_h_i1719 T6987)
(declare-const var_h1718 T6987)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1952 T6987)
(declare-const var__temp_v1953 Int)
(declare-const |var__temp_h'1954| T6987)
(declare-const var__temp_v_err1955 T6988)
(declare-const var_h1923 T6987)
(declare-const var_h1850 T6987)
(declare-const var_h1810 T6987)
(declare-const var_h1770 T6987)
(declare-const var_h1718 T6987)
(declare-const err T7001)

solver 
 (declare-sort T6987)
(declare-fun sel (T6987 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1923 () T6987)
(declare-fun var_h1810 () T6987)
(declare-fun var_h1718 () T6987)
(declare-fun other () Int)
(declare-fun var__temp_h1952 () T6987)
(declare-fun |var__temp_h'1954| () T6987)
(declare-fun var__temp_v1953 () Int)
(declare-fun v () Int)
(assert (= (sel var_h1923 res) 5))
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h1952 res) v)
                (= (sel var__temp_h1952 res) (+ (sel var_h1923 res) 2))
                (= (sel var__temp_h1952 other) (sel var_h1923 other))))
      (a!2 (and (= (sel |var__temp_h'1954| res) var__temp_v1953)
                (= (sel |var__temp_h'1954| res) (+ (sel var__temp_h1952 res) 5))
                (= (sel |var__temp_h'1954| other) (sel var__temp_h1952 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h1952 res) 7))
                (=> (= (sel var__temp_h1952 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c5
PARTIAL PATH NEW
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --c2'
 	 --foo'
 	 --c4
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i1957 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1957 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1957, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1957, res ) ==((sel)( , var_h1956, res ) + (5))
 	 , (sel)( , var_h_i1957, other ) ==(sel)( , var_h1956, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1958:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1957 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************532
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1958:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1958:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc5bazbarc2fooc2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --c2'
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1957 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1957, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1957, res ) ==((sel)( , var_h1956, res ) + (5))
 	 , (sel)( , var_h_i1957, other ) ==(sel)( , var_h1956, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1959:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************533
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2'
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1924 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1924, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1924, res ) ==((sel)( , var_h1923, res ) + (2))
 	 , (sel)( , var_h_i1924, other ) ==(sel)( , var_h1923, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1960:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************534
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --foo
 	 --c2'
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1851 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1851, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1851, other ) ==(sel)( , var_h1850, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1961:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************535
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1851 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1851, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1851, other ) ==(sel)( , var_h1850, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1961:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1851 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1962 --->  Ty_heap  
 var__temp_v1963 --->  Ty_int  
 var__temp_h'1964 --->  Ty_heap  
 var__temp_v_err1965 --->  error  
 var_h1850 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1962, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1962, other ) ==(sel)( , var_h1850, other ) => 
 	 Rel (sel)( , var__temp_h1962, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1962, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1964, res ) ==(var__temp_v1963) AND 
 	 Rel (sel)( , var__temp_h'1964, res ) ==((sel)( , var__temp_h1962, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1964, other ) ==(sel)( , var__temp_h1962, other ) => 
 	 True
 
VC_END(declare-const var_h_i1851 T7004)
(declare-const var_h1850 T7004)
(declare-const v Int)
(declare-const var_h_i1811 T7004)
(declare-const var_h1810 T7004)
(declare-const v Int)
(declare-const var_h_i1771 T7004)
(declare-const var_h1770 T7004)
(declare-const v Int)
(declare-const var_h_i1719 T7004)
(declare-const var_h1718 T7004)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1962 T7004)
(declare-const var__temp_v1963 Int)
(declare-const |var__temp_h'1964| T7004)
(declare-const var__temp_v_err1965 T7005)
(declare-const var_h1850 T7004)
(declare-const var_h1810 T7004)
(declare-const var_h1770 T7004)
(declare-const var_h1718 T7004)
(declare-const err T7018)
    (declare-const |5| Int)
  
solver 
 (declare-sort T7004)
(declare-fun sel (T7004 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1810 () T7004)
(declare-fun var_h1718 () T7004)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h1962 () T7004)
(declare-fun |var__temp_h'1964| () T7004)
(declare-fun var__temp_v1963 () Int)
(declare-fun var_h1850 () T7004)
(declare-fun v () Int)
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1962 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1962 other) (sel var_h1850 other)))
               (= (sel var__temp_h1962 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1964| res) var__temp_v1963)
                (= (sel |var__temp_h'1964| res) (+ (sel var__temp_h1962 res) 3))
                (= (sel |var__temp_h'1964| other) (sel var__temp_h1962 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1962 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************536
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1851 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1851, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i1851, other ) ==(sel)( , var_h1850, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1961:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1851 --->  Ty_heap  
 var_h1850 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1966 --->  Ty_heap  
 var__temp_v1967 --->  Ty_int  
 var__temp_h'1968 --->  Ty_heap  
 var__temp_v_err1969 --->  error  
 var_h1850 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1966, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h1966, other ) ==(sel)( , var_h1850, other ) => 
 	 Rel (sel)( , var__temp_h1966, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1966, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1968, res ) ==(var__temp_v1967) AND 
 	 Rel (sel)( , var__temp_h'1968, res ) ==((sel)( , var__temp_h1966, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1968, other ) ==(sel)( , var__temp_h1966, other ) => 
 	 True
 
VC_END(declare-const var_h_i1851 T7021)
(declare-const var_h1850 T7021)
(declare-const v Int)
(declare-const var_h_i1811 T7021)
(declare-const var_h1810 T7021)
(declare-const v Int)
(declare-const var_h_i1771 T7021)
(declare-const var_h1770 T7021)
(declare-const v Int)
(declare-const var_h_i1719 T7021)
(declare-const var_h1718 T7021)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1966 T7021)
(declare-const var__temp_v1967 Int)
(declare-const |var__temp_h'1968| T7021)
(declare-const var__temp_v_err1969 T7022)
(declare-const var_h1850 T7021)
(declare-const var_h1810 T7021)
(declare-const var_h1770 T7021)
(declare-const var_h1718 T7021)
(declare-const err T7035)
    (declare-const |5| Int)
  
solver 
 (declare-sort T7021)
(declare-fun sel (T7021 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1810 () T7021)
(declare-fun var_h1718 () T7021)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h1966 () T7021)
(declare-fun |var__temp_h'1968| () T7021)
(declare-fun var__temp_v1967 () Int)
(declare-fun var_h1850 () T7021)
(declare-fun v () Int)
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1966 res) v)
                    (= v |5|)
                    (= (sel var__temp_h1966 other) (sel var_h1850 other)))
               (= (sel var__temp_h1966 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1968| res) var__temp_v1967)
                (= (sel |var__temp_h'1968| res) (+ (sel var__temp_h1966 res) 5))
                (= (sel |var__temp_h'1968| other) (sel var__temp_h1966 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1966 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************537
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT bar
PARTIAL PATH
SUB 
 	 --c2'
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1811 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1811, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h1810, res ) ==(sel)( , var_h1810, res )
 	 , (sel)( , var_h_i1811, other ) ==(sel)( , var_h1810, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1970:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
bar
 *********************Enumeration Iteration*****************538
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1811 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1811, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h1810, res ) ==(sel)( , var_h1810, res )
 	 , (sel)( , var_h_i1811, other ) ==(sel)( , var_h1810, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1970:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1971 --->  Ty_heap  
 var__temp_v1972 --->  Ty_int  
 var__temp_h'1973 --->  Ty_heap  
 var__temp_v_err1974 --->  error  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1971, res ) ==(v) AND 
 	 Rel (sel)( , var_h1810, res ) ==(sel)( , var_h1810, res ) AND 
 	 Rel (sel)( , var__temp_h1971, other ) ==(sel)( , var_h1810, other ) => 
 	 Rel (sel)( , var__temp_h1971, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1971, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1973, res ) ==(var__temp_v1972) AND 
 	 Rel (sel)( , var__temp_h'1973, res ) ==((sel)( , var__temp_h1971, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1973, other ) ==(sel)( , var__temp_h1971, other ) => 
 	 True
 
VC_END(declare-const var_h_i1811 T7038)
(declare-const var_h1810 T7038)
(declare-const v Int)
(declare-const var_h_i1771 T7038)
(declare-const var_h1770 T7038)
(declare-const v Int)
(declare-const var_h_i1719 T7038)
(declare-const var_h1718 T7038)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1971 T7038)
(declare-const var__temp_v1972 Int)
(declare-const |var__temp_h'1973| T7038)
(declare-const var__temp_v_err1974 T7039)
(declare-const var_h1810 T7038)
(declare-const var_h1770 T7038)
(declare-const var_h1718 T7038)
(declare-const err T7052)

solver 
 (declare-sort T7038)
(declare-fun sel (T7038 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1810 () T7038)
(declare-fun var_h1718 () T7038)
(declare-fun other () Int)
(declare-fun var__temp_h1971 () T7038)
(declare-fun |var__temp_h'1973| () T7038)
(declare-fun var__temp_v1972 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1971 res) v)
                    (= (sel var_h1810 res) (sel var_h1810 res))
                    (= (sel var__temp_h1971 other) (sel var_h1810 other)))
               (= (sel var__temp_h1971 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1973| res) var__temp_v1972)
                (= (sel |var__temp_h'1973| res) (+ (sel var__temp_h1971 res) 3))
                (= (sel |var__temp_h'1973| other) (sel var__temp_h1971 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1971 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************539
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1811 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1811, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h1810, res ) ==(sel)( , var_h1810, res )
 	 , (sel)( , var_h_i1811, other ) ==(sel)( , var_h1810, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1970:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1975 --->  Ty_heap  
 var__temp_v1976 --->  Ty_int  
 var__temp_h'1977 --->  Ty_heap  
 var__temp_v_err1978 --->  error  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1975, res ) ==(v) AND 
 	 Rel (sel)( , var_h1810, res ) ==(sel)( , var_h1810, res ) AND 
 	 Rel (sel)( , var__temp_h1975, other ) ==(sel)( , var_h1810, other ) => 
 	 Rel (sel)( , var__temp_h1975, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1975, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1977, res ) ==(var__temp_v1976) AND 
 	 Rel (sel)( , var__temp_h'1977, res ) ==((sel)( , var__temp_h1975, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1977, other ) ==(sel)( , var__temp_h1975, other ) => 
 	 True
 
VC_END(declare-const var_h_i1811 T7055)
(declare-const var_h1810 T7055)
(declare-const v Int)
(declare-const var_h_i1771 T7055)
(declare-const var_h1770 T7055)
(declare-const v Int)
(declare-const var_h_i1719 T7055)
(declare-const var_h1718 T7055)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1975 T7055)
(declare-const var__temp_v1976 Int)
(declare-const |var__temp_h'1977| T7055)
(declare-const var__temp_v_err1978 T7056)
(declare-const var_h1810 T7055)
(declare-const var_h1770 T7055)
(declare-const var_h1718 T7055)
(declare-const err T7069)

solver 
 (declare-sort T7055)
(declare-fun sel (T7055 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1810 () T7055)
(declare-fun var_h1718 () T7055)
(declare-fun other () Int)
(declare-fun var__temp_h1975 () T7055)
(declare-fun |var__temp_h'1977| () T7055)
(declare-fun var__temp_v1976 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1975 res) v)
                    (= (sel var_h1810 res) (sel var_h1810 res))
                    (= (sel var__temp_h1975 other) (sel var_h1810 other)))
               (= (sel var__temp_h1975 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1977| res) var__temp_v1976)
                (= (sel |var__temp_h'1977| res) (+ (sel var__temp_h1975 res) 5))
                (= (sel |var__temp_h'1977| other) (sel var__temp_h1975 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1975 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************540
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1811 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1811, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h1810, res ) ==(sel)( , var_h1810, res )
 	 , (sel)( , var_h_i1811, other ) ==(sel)( , var_h1810, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1970:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1979 --->  Ty_heap  
 var__temp_v1980 --->  Ty_int  
 var__temp_h'1981 --->  Ty_heap  
 var__temp_v_err1982 --->  error  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1979, res ) ==(v) AND 
 	 Rel (sel)( , var_h1810, res ) ==(sel)( , var_h1810, res ) AND 
 	 Rel (sel)( , var__temp_h1979, other ) ==(sel)( , var_h1810, other ) => 
 	 Rel (sel)( , var__temp_h1979, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1979, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1981, res ) ==(var__temp_v1980) AND 
 	 Rel (sel)( , var__temp_h'1981, res ) ==((sel)( , var__temp_h1979, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'1981, other ) ==(sel)( , var__temp_h1979, other ) => 
 	 True
 
VC_END(declare-const var_h_i1811 T7072)
(declare-const var_h1810 T7072)
(declare-const v Int)
(declare-const var_h_i1771 T7072)
(declare-const var_h1770 T7072)
(declare-const v Int)
(declare-const var_h_i1719 T7072)
(declare-const var_h1718 T7072)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1979 T7072)
(declare-const var__temp_v1980 Int)
(declare-const |var__temp_h'1981| T7072)
(declare-const var__temp_v_err1982 T7073)
(declare-const var_h1810 T7072)
(declare-const var_h1770 T7072)
(declare-const var_h1718 T7072)
(declare-const err T7086)

solver 
 (declare-sort T7072)
(declare-fun sel (T7072 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1810 () T7072)
(declare-fun var_h1718 () T7072)
(declare-fun other () Int)
(declare-fun var__temp_h1979 () T7072)
(declare-fun |var__temp_h'1981| () T7072)
(declare-fun var__temp_v1980 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1979 res) v)
                    (= (sel var_h1810 res) (sel var_h1810 res))
                    (= (sel var__temp_h1979 other) (sel var_h1810 other)))
               (> (sel var__temp_h1979 res) 4)))
      (a!2 (and (= (sel |var__temp_h'1981| res) var__temp_v1980)
                (= (sel |var__temp_h'1981| res)
                   (+ (sel var__temp_h1979 res) 10))
                (= (sel |var__temp_h'1981| other) (sel var__temp_h1979 other)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h1979 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************541
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1811 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1811, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h1810, res ) ==(sel)( , var_h1810, res )
 	 , (sel)( , var_h_i1811, other ) ==(sel)( , var_h1810, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1970:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1811 --->  Ty_heap  
 var_h1810 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1983 --->  Ty_heap  
 var__temp_v1984 --->  Ty_int  
 var__temp_h'1985 --->  Ty_heap  
 var__temp_v_err1986 --->  error  
 var_h1810 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1810, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1983, res ) ==(v) AND 
 	 Rel (sel)( , var_h1810, res ) ==(sel)( , var_h1810, res ) AND 
 	 Rel (sel)( , var__temp_h1983, other ) ==(sel)( , var_h1810, other ) => 
 	 Rel (sel)( , var__temp_h1983, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1983, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1985, res ) ==(var__temp_v1984) AND 
 	 Rel (sel)( , var__temp_h'1985, res ) ==((sel)( , var__temp_h1983, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'1985, other ) ==(sel)( , var__temp_h1983, other ) => 
 	 True
 
VC_END(declare-const var_h_i1811 T7089)
(declare-const var_h1810 T7089)
(declare-const v Int)
(declare-const var_h_i1771 T7089)
(declare-const var_h1770 T7089)
(declare-const v Int)
(declare-const var_h_i1719 T7089)
(declare-const var_h1718 T7089)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1983 T7089)
(declare-const var__temp_v1984 Int)
(declare-const |var__temp_h'1985| T7089)
(declare-const var__temp_v_err1986 T7090)
(declare-const var_h1810 T7089)
(declare-const var_h1770 T7089)
(declare-const var_h1718 T7089)
(declare-const err T7103)

solver 
 (declare-sort T7089)
(declare-fun sel (T7089 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1810 () T7089)
(declare-fun var_h1718 () T7089)
(declare-fun other () Int)
(declare-fun var__temp_h1983 () T7089)
(declare-fun |var__temp_h'1985| () T7089)
(declare-fun var__temp_v1984 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1810 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1983 res) v)
                    (= (sel var_h1810 res) (sel var_h1810 res))
                    (= (sel var__temp_h1983 other) (sel var_h1810 other)))
               (= (sel var__temp_h1983 res) 5)))
      (a!2 (and (= (sel |var__temp_h'1985| res) var__temp_v1984)
                (= (sel |var__temp_h'1985| res) (+ (sel var__temp_h1983 res) 2))
                (= (sel |var__temp_h'1985| other) (sel var__temp_h1983 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1983 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************542
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo
PARTIAL PATH
SUB 
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1771, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1771, other ) ==(sel)( , var_h1770, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1987:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************543
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1771, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1771, other ) ==(sel)( , var_h1770, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1987:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1988 --->  Ty_heap  
 var__temp_v1989 --->  Ty_int  
 var__temp_h'1990 --->  Ty_heap  
 var__temp_v_err1991 --->  error  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1988, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1988, other ) ==(sel)( , var_h1770, other ) => 
 	 Rel (sel)( , var__temp_h1988, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1988, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1990, res ) ==(var__temp_v1989) AND 
 	 Rel (sel)( , var__temp_h'1990, res ) ==((sel)( , var__temp_h1988, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'1990, other ) ==(sel)( , var__temp_h1988, other ) => 
 	 True
 
VC_END(declare-const var_h_i1771 T7106)
(declare-const var_h1770 T7106)
(declare-const v Int)
(declare-const var_h_i1719 T7106)
(declare-const var_h1718 T7106)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1988 T7106)
(declare-const var__temp_v1989 Int)
(declare-const |var__temp_h'1990| T7106)
(declare-const var__temp_v_err1991 T7107)
(declare-const var_h1770 T7106)
(declare-const var_h1718 T7106)
(declare-const err T7120)
    (declare-const |20| Int)
  
solver 
 (declare-sort T7106)
(declare-fun sel (T7106 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T7106)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h1988 () T7106)
(declare-fun |var__temp_h'1990| () T7106)
(declare-fun var__temp_v1989 () Int)
(declare-fun var_h1770 () T7106)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1988 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1988 other) (sel var_h1770 other)))
               (= (sel var__temp_h1988 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1990| res) var__temp_v1989)
                (= (sel |var__temp_h'1990| res) (+ (sel var__temp_h1988 res) 3))
                (= (sel |var__temp_h'1990| other) (sel var__temp_h1988 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1988 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************544
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1771, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1771, other ) ==(sel)( , var_h1770, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1987:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1992 --->  Ty_heap  
 var__temp_v1993 --->  Ty_int  
 var__temp_h'1994 --->  Ty_heap  
 var__temp_v_err1995 --->  error  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1992, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1992, other ) ==(sel)( , var_h1770, other ) => 
 	 Rel (sel)( , var__temp_h1992, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1992, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1994, res ) ==(var__temp_v1993) AND 
 	 Rel (sel)( , var__temp_h'1994, res ) ==((sel)( , var__temp_h1992, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'1994, other ) ==(sel)( , var__temp_h1992, other ) => 
 	 True
 
VC_END(declare-const var_h_i1771 T7123)
(declare-const var_h1770 T7123)
(declare-const v Int)
(declare-const var_h_i1719 T7123)
(declare-const var_h1718 T7123)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1992 T7123)
(declare-const var__temp_v1993 Int)
(declare-const |var__temp_h'1994| T7123)
(declare-const var__temp_v_err1995 T7124)
(declare-const var_h1770 T7123)
(declare-const var_h1718 T7123)
(declare-const err T7137)
    (declare-const |20| Int)
  
solver 
 (declare-sort T7123)
(declare-fun sel (T7123 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T7123)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h1992 () T7123)
(declare-fun |var__temp_h'1994| () T7123)
(declare-fun var__temp_v1993 () Int)
(declare-fun var_h1770 () T7123)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1992 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1992 other) (sel var_h1770 other)))
               (= (sel var__temp_h1992 res) 7)))
      (a!2 (and (= (sel |var__temp_h'1994| res) var__temp_v1993)
                (= (sel |var__temp_h'1994| res) (+ (sel var__temp_h1992 res) 5))
                (= (sel |var__temp_h'1994| other) (sel var__temp_h1992 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1992 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************545
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1771, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1771, other ) ==(sel)( , var_h1770, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v1987:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1996 --->  Ty_heap  
 var__temp_v1997 --->  Ty_int  
 var__temp_h'1998 --->  Ty_heap  
 var__temp_v_err1999 --->  error  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1996, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h1996, other ) ==(sel)( , var_h1770, other ) => 
 	 Rel (sel)( , var__temp_h1996, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1996, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1998, res ) ==(var__temp_v1997) AND 
 	 Rel (sel)( , var__temp_h'1998, res ) ==((sel)( , var__temp_h1996, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'1998, other ) ==(sel)( , var__temp_h1996, other ) => 
 	 True
 
VC_END(declare-const var_h_i1771 T7140)
(declare-const var_h1770 T7140)
(declare-const v Int)
(declare-const var_h_i1719 T7140)
(declare-const var_h1718 T7140)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h1996 T7140)
(declare-const var__temp_v1997 Int)
(declare-const |var__temp_h'1998| T7140)
(declare-const var__temp_v_err1999 T7141)
(declare-const var_h1770 T7140)
(declare-const var_h1718 T7140)
(declare-const err T7154)
    (declare-const |20| Int)
  
solver 
 (declare-sort T7140)
(declare-fun sel (T7140 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T7140)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h1996 () T7140)
(declare-fun |var__temp_h'1998| () T7140)
(declare-fun var__temp_v1997 () Int)
(declare-fun var_h1770 () T7140)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1996 res) v)
                    (= v |20|)
                    (= (sel var__temp_h1996 other) (sel var_h1770 other)))
               (> (sel var__temp_h1996 res) 4)))
      (a!2 (and (= (sel |var__temp_h'1998| res) var__temp_v1997)
                (= (sel |var__temp_h'1998| res)
                   (+ (sel var__temp_h1996 res) 10))
                (= (sel |var__temp_h'1998| other) (sel var__temp_h1996 other)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h1996 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c2
PARTIAL PATH NEW
SUB 
 	 --c2
 	 --foo'
 	 --c4
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2001 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2001 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2001, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2001, res ) ==((sel)( , var_h2000, res ) + (10))
 	 , (sel)( , var_h_i2001, other ) ==(sel)( , var_h2000, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2002:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2001 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************546
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2001 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2001, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2001, res ) ==((sel)( , var_h2000, res ) + (10))
 	 , (sel)( , var_h_i2001, other ) ==(sel)( , var_h2000, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2002:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2001 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2001 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2003 --->  Ty_heap  
 var__temp_v2004 --->  Ty_int  
 var__temp_h'2005 --->  Ty_heap  
 var__temp_v_err2006 --->  error  
 var_h2000 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2000, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2003, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2003, res ) ==((sel)( , var_h2000, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2003, other ) ==(sel)( , var_h2000, other ) => 
 	 Rel (sel)( , var__temp_h2003, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2003, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2005, res ) ==(var__temp_v2004) AND 
 	 Rel (sel)( , var__temp_h'2005, res ) ==((sel)( , var__temp_h2003, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2005, other ) ==(sel)( , var__temp_h2003, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2005, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2005, other ) > (4)
 
VC_END(declare-const var_h_i2001 T7157)
(declare-const var_h2000 T7157)
(declare-const v Int)
(declare-const var_h_i1771 T7157)
(declare-const var_h1770 T7157)
(declare-const v Int)
(declare-const var_h_i1719 T7157)
(declare-const var_h1718 T7157)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2003 T7157)
(declare-const var__temp_v2004 Int)
(declare-const |var__temp_h'2005| T7157)
(declare-const var__temp_v_err2006 T7158)
(declare-const var_h2000 T7157)
(declare-const var_h1770 T7157)
(declare-const var_h1718 T7157)
(declare-const err T7171)

solver 
 (declare-sort T7157)
(declare-fun sel (T7157 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2000 () T7157)
(declare-fun var_h1718 () T7157)
(declare-fun other () Int)
(declare-fun |var__temp_h'2005| () T7157)
(declare-fun var__temp_h2003 () T7157)
(declare-fun var__temp_v2004 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2000 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2003 res) v)
                (= (sel var__temp_h2003 res) (+ (sel var_h2000 res) 10))
                (= (sel var__temp_h2003 other) (sel var_h2000 other))))
      (a!2 (and (= (sel |var__temp_h'2005| res) var__temp_v2004)
                (= (sel |var__temp_h'2005| res) (+ (sel var__temp_h2003 res) 3))
                (= (sel |var__temp_h'2005| other) (sel var__temp_h2003 other))))
      (a!3 (and (= (sel |var__temp_h'2005| res) 10)
                (not (> (sel |var__temp_h'2005| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2003 res) 7))
                (=> (= (sel var__temp_h2003 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************547
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2001 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2001, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2001, res ) ==((sel)( , var_h2000, res ) + (10))
 	 , (sel)( , var_h_i2001, other ) ==(sel)( , var_h2000, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2002:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2001 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2001 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2007 --->  Ty_heap  
 var__temp_v2008 --->  Ty_int  
 var__temp_h'2009 --->  Ty_heap  
 var__temp_v_err2010 --->  error  
 var_h2000 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2000, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2007, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2007, res ) ==((sel)( , var_h2000, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2007, other ) ==(sel)( , var_h2000, other ) => 
 	 Rel (sel)( , var__temp_h2007, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2007, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2009, res ) ==(var__temp_v2008) AND 
 	 Rel (sel)( , var__temp_h'2009, res ) ==((sel)( , var__temp_h2007, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2009, other ) ==(sel)( , var__temp_h2007, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2009, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2009, other ) > (4)
 
VC_END(declare-const var_h_i2001 T7174)
(declare-const var_h2000 T7174)
(declare-const v Int)
(declare-const var_h_i1771 T7174)
(declare-const var_h1770 T7174)
(declare-const v Int)
(declare-const var_h_i1719 T7174)
(declare-const var_h1718 T7174)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2007 T7174)
(declare-const var__temp_v2008 Int)
(declare-const |var__temp_h'2009| T7174)
(declare-const var__temp_v_err2010 T7175)
(declare-const var_h2000 T7174)
(declare-const var_h1770 T7174)
(declare-const var_h1718 T7174)
(declare-const err T7188)

solver 
 (declare-sort T7174)
(declare-fun sel (T7174 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2000 () T7174)
(declare-fun var_h1718 () T7174)
(declare-fun other () Int)
(declare-fun |var__temp_h'2009| () T7174)
(declare-fun var__temp_h2007 () T7174)
(declare-fun var__temp_v2008 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2000 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2007 res) v)
                (= (sel var__temp_h2007 res) (+ (sel var_h2000 res) 10))
                (= (sel var__temp_h2007 other) (sel var_h2000 other))))
      (a!2 (and (= (sel |var__temp_h'2009| res) var__temp_v2008)
                (= (sel |var__temp_h'2009| res) (+ (sel var__temp_h2007 res) 5))
                (= (sel |var__temp_h'2009| other) (sel var__temp_h2007 other))))
      (a!3 (and (= (sel |var__temp_h'2009| res) 10)
                (not (> (sel |var__temp_h'2009| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2007 res) 7))
                (=> (= (sel var__temp_h2007 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************548
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2001 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2001, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2001, res ) ==((sel)( , var_h2000, res ) + (10))
 	 , (sel)( , var_h_i2001, other ) ==(sel)( , var_h2000, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2002:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2001 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2001 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2011 --->  Ty_heap  
 var__temp_v2012 --->  Ty_int  
 var__temp_h'2013 --->  Ty_heap  
 var__temp_v_err2014 --->  error  
 var_h2000 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2000, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2011, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2011, res ) ==((sel)( , var_h2000, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2011, other ) ==(sel)( , var_h2000, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2013, res ) ==(var__temp_v2012) AND 
 	 Base var__temp_v2012 = 5 AND 
 	 Rel (sel)( , var__temp_h'2013, other ) ==(sel)( , var__temp_h2011, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2013, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2013, other ) > (4)
 
VC_END(declare-const var_h_i2001 T7191)
(declare-const var_h2000 T7191)
(declare-const v Int)
(declare-const var_h_i1771 T7191)
(declare-const var_h1770 T7191)
(declare-const v Int)
(declare-const var_h_i1719 T7191)
(declare-const var_h1718 T7191)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2011 T7191)
(declare-const var__temp_v2012 Int)
(declare-const |var__temp_h'2013| T7191)
(declare-const var__temp_v_err2014 T7192)
(declare-const var_h2000 T7191)
(declare-const var_h1770 T7191)
(declare-const var_h1718 T7191)
(declare-const err T7205)
    (declare-const |5| Int)
  
solver 
 (declare-sort T7191)
(declare-fun sel (T7191 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2000 () T7191)
(declare-fun var_h1718 () T7191)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2013| () T7191)
(declare-fun var__temp_h2011 () T7191)
(declare-fun var__temp_v2012 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2000 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h2011 res) v)
                (= (sel var__temp_h2011 res) (+ (sel var_h2000 res) 10))
                (= (sel var__temp_h2011 other) (sel var_h2000 other))))
      (a!2 (and (= (sel |var__temp_h'2013| res) 10)
                (not (> (sel |var__temp_h'2013| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'2013| res) var__temp_v2012)
                    (= var__temp_v2012 |5|)
                    (= (sel |var__temp_h'2013| other)
                       (sel var__temp_h2011 other)))
               a!2)))
  (not (and (=> a!1 true) (=> true a!3))))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************549
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2001 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2001, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2001, res ) ==((sel)( , var_h2000, res ) + (10))
 	 , (sel)( , var_h_i2001, other ) ==(sel)( , var_h2000, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2002:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2001 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2001 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2015 --->  Ty_heap  
 var__temp_v2016 --->  Ty_int  
 var__temp_h'2017 --->  Ty_heap  
 var__temp_v_err2018 --->  error  
 var_h2000 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2000, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2015, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2015, res ) ==((sel)( , var_h2000, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2015, other ) ==(sel)( , var_h2000, other ) => 
 	 Rel (sel)( , var__temp_h2015, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2015, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2017, res ) ==(var__temp_v2016) AND 
 	 Rel (sel)( , var__temp_h'2017, res ) ==((sel)( , var__temp_h2015, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2017, other ) ==(sel)( , var__temp_h2015, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2017, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2017, other ) > (4)
 
VC_END(declare-const var_h_i2001 T7208)
(declare-const var_h2000 T7208)
(declare-const v Int)
(declare-const var_h_i1771 T7208)
(declare-const var_h1770 T7208)
(declare-const v Int)
(declare-const var_h_i1719 T7208)
(declare-const var_h1718 T7208)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2015 T7208)
(declare-const var__temp_v2016 Int)
(declare-const |var__temp_h'2017| T7208)
(declare-const var__temp_v_err2018 T7209)
(declare-const var_h2000 T7208)
(declare-const var_h1770 T7208)
(declare-const var_h1718 T7208)
(declare-const err T7222)

solver 
 (declare-sort T7208)
(declare-fun sel (T7208 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2000 () T7208)
(declare-fun var_h1718 () T7208)
(declare-fun other () Int)
(declare-fun |var__temp_h'2017| () T7208)
(declare-fun var__temp_h2015 () T7208)
(declare-fun var__temp_v2016 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2000 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2015 res) v)
                (= (sel var__temp_h2015 res) (+ (sel var_h2000 res) 10))
                (= (sel var__temp_h2015 other) (sel var_h2000 other))))
      (a!2 (and (= (sel |var__temp_h'2017| res) var__temp_v2016)
                (= (sel |var__temp_h'2017| res) (+ (sel var__temp_h2015 res) 2))
                (= (sel |var__temp_h'2017| other) (sel var__temp_h2015 other))))
      (a!3 (and (= (sel |var__temp_h'2017| res) 10)
                (not (> (sel |var__temp_h'2017| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2015 res) 5))
                (=> (= (sel var__temp_h2015 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************550
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2002:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2002:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2c2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c2
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2001 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2001, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2001, res ) ==((sel)( , var_h2000, res ) + (10))
 	 , (sel)( , var_h_i2001, other ) ==(sel)( , var_h2000, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2019:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************551
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2001 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2001, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2001, res ) ==((sel)( , var_h2000, res ) + (10))
 	 , (sel)( , var_h_i2001, other ) ==(sel)( , var_h2000, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2019:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2001 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2020 --->  Ty_heap  
 var__temp_v2021 --->  Ty_int  
 var__temp_h'2022 --->  Ty_heap  
 var__temp_v_err2023 --->  error  
 var_h2000 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2000, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2020, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2020, res ) ==((sel)( , var_h2000, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2020, other ) ==(sel)( , var_h2000, other ) => 
 	 Rel (sel)( , var__temp_h2020, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2020, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2022, res ) ==(var__temp_v2021) AND 
 	 Rel (sel)( , var__temp_h'2022, res ) ==((sel)( , var__temp_h2020, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2022, other ) ==(sel)( , var__temp_h2020, other ) => 
 	 True
 
VC_END(declare-const var_h_i2001 T7225)
(declare-const var_h2000 T7225)
(declare-const v Int)
(declare-const var_h_i1771 T7225)
(declare-const var_h1770 T7225)
(declare-const v Int)
(declare-const var_h_i1719 T7225)
(declare-const var_h1718 T7225)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2020 T7225)
(declare-const var__temp_v2021 Int)
(declare-const |var__temp_h'2022| T7225)
(declare-const var__temp_v_err2023 T7226)
(declare-const var_h2000 T7225)
(declare-const var_h1770 T7225)
(declare-const var_h1718 T7225)
(declare-const err T7239)

solver 
 (declare-sort T7225)
(declare-fun sel (T7225 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2000 () T7225)
(declare-fun var_h1718 () T7225)
(declare-fun other () Int)
(declare-fun var__temp_h2020 () T7225)
(declare-fun |var__temp_h'2022| () T7225)
(declare-fun var__temp_v2021 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2000 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2020 res) v)
                (= (sel var__temp_h2020 res) (+ (sel var_h2000 res) 10))
                (= (sel var__temp_h2020 other) (sel var_h2000 other))))
      (a!2 (and (= (sel |var__temp_h'2022| res) var__temp_v2021)
                (= (sel |var__temp_h'2022| res) (+ (sel var__temp_h2020 res) 3))
                (= (sel |var__temp_h'2022| other) (sel var__temp_h2020 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2020 res) 7))
                (=> (= (sel var__temp_h2020 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************552
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2001 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2001, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2001, res ) ==((sel)( , var_h2000, res ) + (10))
 	 , (sel)( , var_h_i2001, other ) ==(sel)( , var_h2000, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2019:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2001 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2024 --->  Ty_heap  
 var__temp_v2025 --->  Ty_int  
 var__temp_h'2026 --->  Ty_heap  
 var__temp_v_err2027 --->  error  
 var_h2000 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2000, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2024, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2024, res ) ==((sel)( , var_h2000, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2024, other ) ==(sel)( , var_h2000, other ) => 
 	 Rel (sel)( , var__temp_h2024, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2024, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2026, res ) ==(var__temp_v2025) AND 
 	 Rel (sel)( , var__temp_h'2026, res ) ==((sel)( , var__temp_h2024, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2026, other ) ==(sel)( , var__temp_h2024, other ) => 
 	 True
 
VC_END(declare-const var_h_i2001 T7242)
(declare-const var_h2000 T7242)
(declare-const v Int)
(declare-const var_h_i1771 T7242)
(declare-const var_h1770 T7242)
(declare-const v Int)
(declare-const var_h_i1719 T7242)
(declare-const var_h1718 T7242)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2024 T7242)
(declare-const var__temp_v2025 Int)
(declare-const |var__temp_h'2026| T7242)
(declare-const var__temp_v_err2027 T7243)
(declare-const var_h2000 T7242)
(declare-const var_h1770 T7242)
(declare-const var_h1718 T7242)
(declare-const err T7256)

solver 
 (declare-sort T7242)
(declare-fun sel (T7242 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2000 () T7242)
(declare-fun var_h1718 () T7242)
(declare-fun other () Int)
(declare-fun var__temp_h2024 () T7242)
(declare-fun |var__temp_h'2026| () T7242)
(declare-fun var__temp_v2025 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2000 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2024 res) v)
                (= (sel var__temp_h2024 res) (+ (sel var_h2000 res) 10))
                (= (sel var__temp_h2024 other) (sel var_h2000 other))))
      (a!2 (and (= (sel |var__temp_h'2026| res) var__temp_v2025)
                (= (sel |var__temp_h'2026| res) (+ (sel var__temp_h2024 res) 5))
                (= (sel |var__temp_h'2026| other) (sel var__temp_h2024 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2024 res) 7))
                (=> (= (sel var__temp_h2024 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************553
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2001 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2001, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2001, res ) ==((sel)( , var_h2000, res ) + (10))
 	 , (sel)( , var_h_i2001, other ) ==(sel)( , var_h2000, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2019:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2001 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2028 --->  Ty_heap  
 var__temp_v2029 --->  Ty_int  
 var__temp_h'2030 --->  Ty_heap  
 var__temp_v_err2031 --->  error  
 var_h2000 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2000, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2028, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2028, res ) ==((sel)( , var_h2000, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2028, other ) ==(sel)( , var_h2000, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2030, res ) ==(var__temp_v2029) AND 
 	 Base var__temp_v2029 = 5 AND 
 	 Rel (sel)( , var__temp_h'2030, other ) ==(sel)( , var__temp_h2028, other ) => 
 	 True
 
VC_END(declare-const var_h_i2001 T7259)
(declare-const var_h2000 T7259)
(declare-const v Int)
(declare-const var_h_i1771 T7259)
(declare-const var_h1770 T7259)
(declare-const v Int)
(declare-const var_h_i1719 T7259)
(declare-const var_h1718 T7259)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2028 T7259)
(declare-const var__temp_v2029 Int)
(declare-const |var__temp_h'2030| T7259)
(declare-const var__temp_v_err2031 T7260)
(declare-const var_h2000 T7259)
(declare-const var_h1770 T7259)
(declare-const var_h1718 T7259)
(declare-const err T7273)
    (declare-const |5| Int)
  
solver 
 (declare-sort T7259)
(declare-fun sel (T7259 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2000 () T7259)
(declare-fun var_h1718 () T7259)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2028 () T7259)
(declare-fun |var__temp_h'2030| () T7259)
(declare-fun var__temp_v2029 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2000 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h2028 res) v)
                (= (sel var__temp_h2028 res) (+ (sel var_h2000 res) 10))
                (= (sel var__temp_h2028 other) (sel var_h2000 other))))
      (a!2 (=> (and (= (sel |var__temp_h'2030| res) var__temp_v2029)
                    (= var__temp_v2029 |5|)
                    (= (sel |var__temp_h'2030| other)
                       (sel var__temp_h2028 other)))
               true)))
  (not (and (=> a!1 true) (=> true a!2)))))

***************Selection Successful************foo
PARTIAL PATH NEW
SUB 
 	 --foo
 	 --c2
 	 --foo'
 	 --c4
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2033 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2033 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2033, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2033, other ) ==(sel)( , var_h2032, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2034:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2033 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************554
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2033 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2033, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2033, other ) ==(sel)( , var_h2032, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2034:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2033 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2033 --->  Ty_heap  
 var_h2032 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2001 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2035 --->  Ty_heap  
 var__temp_v2036 --->  Ty_int  
 var__temp_h'2037 --->  Ty_heap  
 var__temp_v_err2038 --->  error  
 var_h2032 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2000, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2035, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2035, other ) ==(sel)( , var_h2032, other ) => 
 	 Rel (sel)( , var__temp_h2035, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2035, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2037, res ) ==(var__temp_v2036) AND 
 	 Rel (sel)( , var__temp_h'2037, res ) ==((sel)( , var__temp_h2035, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2037, other ) ==(sel)( , var__temp_h2035, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2037, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2037, other ) > (4)
 
VC_END(declare-const var_h_i2033 T7276)
(declare-const var_h2032 T7276)
(declare-const v Int)
(declare-const var_h_i2001 T7276)
(declare-const var_h2000 T7276)
(declare-const v Int)
(declare-const var_h_i1771 T7276)
(declare-const var_h1770 T7276)
(declare-const v Int)
(declare-const var_h_i1719 T7276)
(declare-const var_h1718 T7276)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2035 T7276)
(declare-const var__temp_v2036 Int)
(declare-const |var__temp_h'2037| T7276)
(declare-const var__temp_v_err2038 T7277)
(declare-const var_h2032 T7276)
(declare-const var_h2000 T7276)
(declare-const var_h1770 T7276)
(declare-const var_h1718 T7276)
(declare-const err T7290)
    (declare-const |5| Int)
  
solver 
 (declare-sort T7276)
(declare-fun sel (T7276 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2000 () T7276)
(declare-fun var_h1718 () T7276)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2037| () T7276)
(declare-fun var__temp_h2035 () T7276)
(declare-fun var__temp_v2036 () Int)
(declare-fun var_h2032 () T7276)
(declare-fun v () Int)
(assert (> (sel var_h2000 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2035 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2035 other) (sel var_h2032 other)))
               (= (sel var__temp_h2035 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2037| res) var__temp_v2036)
                (= (sel |var__temp_h'2037| res) (+ (sel var__temp_h2035 res) 3))
                (= (sel |var__temp_h'2037| other) (sel var__temp_h2035 other))))
      (a!3 (and (= (sel |var__temp_h'2037| res) 10)
                (not (> (sel |var__temp_h'2037| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2035 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************555
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2033 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2033, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2033, other ) ==(sel)( , var_h2032, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2034:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2033 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2033 --->  Ty_heap  
 var_h2032 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2001 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2039 --->  Ty_heap  
 var__temp_v2040 --->  Ty_int  
 var__temp_h'2041 --->  Ty_heap  
 var__temp_v_err2042 --->  error  
 var_h2032 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2000, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2039, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2039, other ) ==(sel)( , var_h2032, other ) => 
 	 Rel (sel)( , var__temp_h2039, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2039, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2041, res ) ==(var__temp_v2040) AND 
 	 Rel (sel)( , var__temp_h'2041, res ) ==((sel)( , var__temp_h2039, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2041, other ) ==(sel)( , var__temp_h2039, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2041, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2041, other ) > (4)
 
VC_END(declare-const var_h_i2033 T7293)
(declare-const var_h2032 T7293)
(declare-const v Int)
(declare-const var_h_i2001 T7293)
(declare-const var_h2000 T7293)
(declare-const v Int)
(declare-const var_h_i1771 T7293)
(declare-const var_h1770 T7293)
(declare-const v Int)
(declare-const var_h_i1719 T7293)
(declare-const var_h1718 T7293)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2039 T7293)
(declare-const var__temp_v2040 Int)
(declare-const |var__temp_h'2041| T7293)
(declare-const var__temp_v_err2042 T7294)
(declare-const var_h2032 T7293)
(declare-const var_h2000 T7293)
(declare-const var_h1770 T7293)
(declare-const var_h1718 T7293)
(declare-const err T7307)
    (declare-const |5| Int)
  
solver 
 (declare-sort T7293)
(declare-fun sel (T7293 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2000 () T7293)
(declare-fun var_h1718 () T7293)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2041| () T7293)
(declare-fun var__temp_h2039 () T7293)
(declare-fun var__temp_v2040 () Int)
(declare-fun var_h2032 () T7293)
(declare-fun v () Int)
(assert (> (sel var_h2000 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2039 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2039 other) (sel var_h2032 other)))
               (= (sel var__temp_h2039 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2041| res) var__temp_v2040)
                (= (sel |var__temp_h'2041| res) (+ (sel var__temp_h2039 res) 5))
                (= (sel |var__temp_h'2041| other) (sel var__temp_h2039 other))))
      (a!3 (and (= (sel |var__temp_h'2041| res) 10)
                (not (> (sel |var__temp_h'2041| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2039 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************556
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2033 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2033, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2033, other ) ==(sel)( , var_h2032, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2034:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2033 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2033 --->  Ty_heap  
 var_h2032 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2001 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2043 --->  Ty_heap  
 var__temp_v2044 --->  Ty_int  
 var__temp_h'2045 --->  Ty_heap  
 var__temp_v_err2046 --->  error  
 var_h2032 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2000, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2043, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2043, other ) ==(sel)( , var_h2032, other ) => 
 	 Rel (sel)( , var__temp_h2043, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2043, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2045, res ) ==(var__temp_v2044) AND 
 	 Rel (sel)( , var__temp_h'2045, res ) ==((sel)( , var__temp_h2043, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2045, other ) ==(sel)( , var__temp_h2043, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2045, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2045, other ) > (4)
 
VC_END(declare-const var_h_i2033 T7310)
(declare-const var_h2032 T7310)
(declare-const v Int)
(declare-const var_h_i2001 T7310)
(declare-const var_h2000 T7310)
(declare-const v Int)
(declare-const var_h_i1771 T7310)
(declare-const var_h1770 T7310)
(declare-const v Int)
(declare-const var_h_i1719 T7310)
(declare-const var_h1718 T7310)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2043 T7310)
(declare-const var__temp_v2044 Int)
(declare-const |var__temp_h'2045| T7310)
(declare-const var__temp_v_err2046 T7311)
(declare-const var_h2032 T7310)
(declare-const var_h2000 T7310)
(declare-const var_h1770 T7310)
(declare-const var_h1718 T7310)
(declare-const err T7324)
    (declare-const |5| Int)
  
solver 
 (declare-sort T7310)
(declare-fun sel (T7310 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2000 () T7310)
(declare-fun var_h1718 () T7310)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2045| () T7310)
(declare-fun var__temp_h2043 () T7310)
(declare-fun var__temp_v2044 () Int)
(declare-fun var_h2032 () T7310)
(declare-fun v () Int)
(assert (> (sel var_h2000 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2043 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2043 other) (sel var_h2032 other)))
               (= (sel var__temp_h2043 res) 5)))
      (a!2 (and (= (sel |var__temp_h'2045| res) var__temp_v2044)
                (= (sel |var__temp_h'2045| res) (+ (sel var__temp_h2043 res) 2))
                (= (sel |var__temp_h'2045| other) (sel var__temp_h2043 other))))
      (a!3 (and (= (sel |var__temp_h'2045| res) 10)
                (not (> (sel |var__temp_h'2045| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2043 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************557
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2034:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2034:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfooc2c2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --foo
 	 --c2
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2033 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2033, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2033, other ) ==(sel)( , var_h2032, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2047:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************558
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2033 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2033, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2033, other ) ==(sel)( , var_h2032, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2047:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2033 --->  Ty_heap  
 var_h2032 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2001 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2048 --->  Ty_heap  
 var__temp_v2049 --->  Ty_int  
 var__temp_h'2050 --->  Ty_heap  
 var__temp_v_err2051 --->  error  
 var_h2032 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2000, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2048, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2048, other ) ==(sel)( , var_h2032, other ) => 
 	 Rel (sel)( , var__temp_h2048, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2048, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2050, res ) ==(var__temp_v2049) AND 
 	 Rel (sel)( , var__temp_h'2050, res ) ==((sel)( , var__temp_h2048, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2050, other ) ==(sel)( , var__temp_h2048, other ) => 
 	 True
 
VC_END(declare-const var_h_i2033 T7327)
(declare-const var_h2032 T7327)
(declare-const v Int)
(declare-const var_h_i2001 T7327)
(declare-const var_h2000 T7327)
(declare-const v Int)
(declare-const var_h_i1771 T7327)
(declare-const var_h1770 T7327)
(declare-const v Int)
(declare-const var_h_i1719 T7327)
(declare-const var_h1718 T7327)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2048 T7327)
(declare-const var__temp_v2049 Int)
(declare-const |var__temp_h'2050| T7327)
(declare-const var__temp_v_err2051 T7328)
(declare-const var_h2032 T7327)
(declare-const var_h2000 T7327)
(declare-const var_h1770 T7327)
(declare-const var_h1718 T7327)
(declare-const err T7341)
    (declare-const |5| Int)
  
solver 
 (declare-sort T7327)
(declare-fun sel (T7327 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2000 () T7327)
(declare-fun var_h1718 () T7327)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2048 () T7327)
(declare-fun |var__temp_h'2050| () T7327)
(declare-fun var__temp_v2049 () Int)
(declare-fun var_h2032 () T7327)
(declare-fun v () Int)
(assert (> (sel var_h2000 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2048 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2048 other) (sel var_h2032 other)))
               (= (sel var__temp_h2048 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2050| res) var__temp_v2049)
                (= (sel |var__temp_h'2050| res) (+ (sel var__temp_h2048 res) 3))
                (= (sel |var__temp_h'2050| other) (sel var__temp_h2048 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2048 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************559
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2033 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2033, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2033, other ) ==(sel)( , var_h2032, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2047:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2033 --->  Ty_heap  
 var_h2032 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2001 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2052 --->  Ty_heap  
 var__temp_v2053 --->  Ty_int  
 var__temp_h'2054 --->  Ty_heap  
 var__temp_v_err2055 --->  error  
 var_h2032 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2000, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2052, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2052, other ) ==(sel)( , var_h2032, other ) => 
 	 Rel (sel)( , var__temp_h2052, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2052, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2054, res ) ==(var__temp_v2053) AND 
 	 Rel (sel)( , var__temp_h'2054, res ) ==((sel)( , var__temp_h2052, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2054, other ) ==(sel)( , var__temp_h2052, other ) => 
 	 True
 
VC_END(declare-const var_h_i2033 T7344)
(declare-const var_h2032 T7344)
(declare-const v Int)
(declare-const var_h_i2001 T7344)
(declare-const var_h2000 T7344)
(declare-const v Int)
(declare-const var_h_i1771 T7344)
(declare-const var_h1770 T7344)
(declare-const v Int)
(declare-const var_h_i1719 T7344)
(declare-const var_h1718 T7344)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2052 T7344)
(declare-const var__temp_v2053 Int)
(declare-const |var__temp_h'2054| T7344)
(declare-const var__temp_v_err2055 T7345)
(declare-const var_h2032 T7344)
(declare-const var_h2000 T7344)
(declare-const var_h1770 T7344)
(declare-const var_h1718 T7344)
(declare-const err T7358)
    (declare-const |5| Int)
  
solver 
 (declare-sort T7344)
(declare-fun sel (T7344 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2000 () T7344)
(declare-fun var_h1718 () T7344)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2052 () T7344)
(declare-fun |var__temp_h'2054| () T7344)
(declare-fun var__temp_v2053 () Int)
(declare-fun var_h2032 () T7344)
(declare-fun v () Int)
(assert (> (sel var_h2000 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2052 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2052 other) (sel var_h2032 other)))
               (= (sel var__temp_h2052 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2054| res) var__temp_v2053)
                (= (sel |var__temp_h'2054| res) (+ (sel var__temp_h2052 res) 5))
                (= (sel |var__temp_h'2054| other) (sel var__temp_h2052 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2052 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************560
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2033 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2033, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2033, other ) ==(sel)( , var_h2032, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2047:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2033 --->  Ty_heap  
 var_h2032 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2001 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2056 --->  Ty_heap  
 var__temp_v2057 --->  Ty_int  
 var__temp_h'2058 --->  Ty_heap  
 var__temp_v_err2059 --->  error  
 var_h2032 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2000, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2056, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2056, other ) ==(sel)( , var_h2032, other ) => 
 	 Rel (sel)( , var__temp_h2056, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2056, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2058, res ) ==(var__temp_v2057) AND 
 	 Rel (sel)( , var__temp_h'2058, res ) ==((sel)( , var__temp_h2056, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2058, other ) ==(sel)( , var__temp_h2056, other ) => 
 	 True
 
VC_END(declare-const var_h_i2033 T7361)
(declare-const var_h2032 T7361)
(declare-const v Int)
(declare-const var_h_i2001 T7361)
(declare-const var_h2000 T7361)
(declare-const v Int)
(declare-const var_h_i1771 T7361)
(declare-const var_h1770 T7361)
(declare-const v Int)
(declare-const var_h_i1719 T7361)
(declare-const var_h1718 T7361)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2056 T7361)
(declare-const var__temp_v2057 Int)
(declare-const |var__temp_h'2058| T7361)
(declare-const var__temp_v_err2059 T7362)
(declare-const var_h2032 T7361)
(declare-const var_h2000 T7361)
(declare-const var_h1770 T7361)
(declare-const var_h1718 T7361)
(declare-const err T7375)
    (declare-const |5| Int)
  
solver 
 (declare-sort T7361)
(declare-fun sel (T7361 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2000 () T7361)
(declare-fun var_h1718 () T7361)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2056 () T7361)
(declare-fun |var__temp_h'2058| () T7361)
(declare-fun var__temp_v2057 () Int)
(declare-fun var_h2032 () T7361)
(declare-fun v () Int)
(assert (> (sel var_h2000 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2056 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2056 other) (sel var_h2032 other)))
               (= (sel var__temp_h2056 res) 5)))
      (a!2 (and (= (sel |var__temp_h'2058| res) var__temp_v2057)
                (= (sel |var__temp_h'2058| res) (+ (sel var__temp_h2056 res) 2))
                (= (sel |var__temp_h'2058| other) (sel var__temp_h2056 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2056 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************bar
PARTIAL PATH NEW
SUB 
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c4
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2061 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2061 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2061, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2061, res ) ==((sel)( , var_h2060, res ) + (2))
 	 , (sel)( , var_h_i2061, other ) ==(sel)( , var_h2060, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2062:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2061 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************561
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2061 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2061, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2061, res ) ==((sel)( , var_h2060, res ) + (2))
 	 , (sel)( , var_h_i2061, other ) ==(sel)( , var_h2060, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2062:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2061 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2061 --->  Ty_heap  
 var_h2060 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2033 --->  Ty_heap  
 var_h2032 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2001 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2063 --->  Ty_heap  
 var__temp_v2064 --->  Ty_int  
 var__temp_h'2065 --->  Ty_heap  
 var__temp_v_err2066 --->  error  
 var_h2060 --->  Ty_heap  
 var_h2032 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h2060, res ) ==(5) AND 
 	 Rel (sel)( , var_h2000, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2063, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2063, res ) ==((sel)( , var_h2060, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h2063, other ) ==(sel)( , var_h2060, other ) => 
 	 Rel (sel)( , var__temp_h2063, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2063, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2065, res ) ==(var__temp_v2064) AND 
 	 Rel (sel)( , var__temp_h'2065, res ) ==((sel)( , var__temp_h2063, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2065, other ) ==(sel)( , var__temp_h2063, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2065, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2065, other ) > (4)
 
VC_END(declare-const var_h_i2061 T7378)
(declare-const var_h2060 T7378)
(declare-const v Int)
(declare-const var_h_i2033 T7378)
(declare-const var_h2032 T7378)
(declare-const v Int)
(declare-const var_h_i2001 T7378)
(declare-const var_h2000 T7378)
(declare-const v Int)
(declare-const var_h_i1771 T7378)
(declare-const var_h1770 T7378)
(declare-const v Int)
(declare-const var_h_i1719 T7378)
(declare-const var_h1718 T7378)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2063 T7378)
(declare-const var__temp_v2064 Int)
(declare-const |var__temp_h'2065| T7378)
(declare-const var__temp_v_err2066 T7379)
(declare-const var_h2060 T7378)
(declare-const var_h2032 T7378)
(declare-const var_h2000 T7378)
(declare-const var_h1770 T7378)
(declare-const var_h1718 T7378)
(declare-const err T7392)

solver 
 (declare-sort T7378)
(declare-fun sel (T7378 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2060 () T7378)
(declare-fun var_h2000 () T7378)
(declare-fun var_h1718 () T7378)
(declare-fun other () Int)
(declare-fun |var__temp_h'2065| () T7378)
(declare-fun var__temp_h2063 () T7378)
(declare-fun var__temp_v2064 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2060 res) 5))
(assert (> (sel var_h2000 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2063 res) v)
                (= (sel var__temp_h2063 res) (+ (sel var_h2060 res) 2))
                (= (sel var__temp_h2063 other) (sel var_h2060 other))))
      (a!2 (and (= (sel |var__temp_h'2065| res) var__temp_v2064)
                (= (sel |var__temp_h'2065| res) (+ (sel var__temp_h2063 res) 3))
                (= (sel |var__temp_h'2065| other) (sel var__temp_h2063 other))))
      (a!3 (and (= (sel |var__temp_h'2065| res) 10)
                (not (> (sel |var__temp_h'2065| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2063 res) 7))
                (=> (= (sel var__temp_h2063 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************562
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2061 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2061, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2061, res ) ==((sel)( , var_h2060, res ) + (2))
 	 , (sel)( , var_h_i2061, other ) ==(sel)( , var_h2060, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2062:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2061 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2061 --->  Ty_heap  
 var_h2060 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2033 --->  Ty_heap  
 var_h2032 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2001 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2067 --->  Ty_heap  
 var__temp_v2068 --->  Ty_int  
 var__temp_h'2069 --->  Ty_heap  
 var__temp_v_err2070 --->  error  
 var_h2060 --->  Ty_heap  
 var_h2032 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h2060, res ) ==(5) AND 
 	 Rel (sel)( , var_h2000, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2067, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2067, res ) ==((sel)( , var_h2060, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h2067, other ) ==(sel)( , var_h2060, other ) => 
 	 Rel (sel)( , var__temp_h2067, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2067, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2069, res ) ==(var__temp_v2068) AND 
 	 Rel (sel)( , var__temp_h'2069, res ) ==((sel)( , var__temp_h2067, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2069, other ) ==(sel)( , var__temp_h2067, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2069, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2069, other ) > (4)
 
VC_END(declare-const var_h_i2061 T7395)
(declare-const var_h2060 T7395)
(declare-const v Int)
(declare-const var_h_i2033 T7395)
(declare-const var_h2032 T7395)
(declare-const v Int)
(declare-const var_h_i2001 T7395)
(declare-const var_h2000 T7395)
(declare-const v Int)
(declare-const var_h_i1771 T7395)
(declare-const var_h1770 T7395)
(declare-const v Int)
(declare-const var_h_i1719 T7395)
(declare-const var_h1718 T7395)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2067 T7395)
(declare-const var__temp_v2068 Int)
(declare-const |var__temp_h'2069| T7395)
(declare-const var__temp_v_err2070 T7396)
(declare-const var_h2060 T7395)
(declare-const var_h2032 T7395)
(declare-const var_h2000 T7395)
(declare-const var_h1770 T7395)
(declare-const var_h1718 T7395)
(declare-const err T7409)

solver 
 (declare-sort T7395)
(declare-fun sel (T7395 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2060 () T7395)
(declare-fun var_h2000 () T7395)
(declare-fun var_h1718 () T7395)
(declare-fun other () Int)
(declare-fun |var__temp_h'2069| () T7395)
(declare-fun var__temp_h2067 () T7395)
(declare-fun var__temp_v2068 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2060 res) 5))
(assert (> (sel var_h2000 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2067 res) v)
                (= (sel var__temp_h2067 res) (+ (sel var_h2060 res) 2))
                (= (sel var__temp_h2067 other) (sel var_h2060 other))))
      (a!2 (and (= (sel |var__temp_h'2069| res) var__temp_v2068)
                (= (sel |var__temp_h'2069| res) (+ (sel var__temp_h2067 res) 5))
                (= (sel |var__temp_h'2069| other) (sel var__temp_h2067 other))))
      (a!3 (and (= (sel |var__temp_h'2069| res) 10)
                (not (> (sel |var__temp_h'2069| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2067 res) 7))
                (=> (= (sel var__temp_h2067 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************563
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2062:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2062:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbarfooc2c2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2061 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2061, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2061, res ) ==((sel)( , var_h2060, res ) + (2))
 	 , (sel)( , var_h_i2061, other ) ==(sel)( , var_h2060, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2071:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************564
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2061 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2061, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2061, res ) ==((sel)( , var_h2060, res ) + (2))
 	 , (sel)( , var_h_i2061, other ) ==(sel)( , var_h2060, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2071:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2061 --->  Ty_heap  
 var_h2060 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2033 --->  Ty_heap  
 var_h2032 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2001 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2072 --->  Ty_heap  
 var__temp_v2073 --->  Ty_int  
 var__temp_h'2074 --->  Ty_heap  
 var__temp_v_err2075 --->  error  
 var_h2060 --->  Ty_heap  
 var_h2032 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h2060, res ) ==(5) AND 
 	 Rel (sel)( , var_h2000, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2072, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2072, res ) ==((sel)( , var_h2060, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h2072, other ) ==(sel)( , var_h2060, other ) => 
 	 Rel (sel)( , var__temp_h2072, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2072, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2074, res ) ==(var__temp_v2073) AND 
 	 Rel (sel)( , var__temp_h'2074, res ) ==((sel)( , var__temp_h2072, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2074, other ) ==(sel)( , var__temp_h2072, other ) => 
 	 True
 
VC_END(declare-const var_h_i2061 T7412)
(declare-const var_h2060 T7412)
(declare-const v Int)
(declare-const var_h_i2033 T7412)
(declare-const var_h2032 T7412)
(declare-const v Int)
(declare-const var_h_i2001 T7412)
(declare-const var_h2000 T7412)
(declare-const v Int)
(declare-const var_h_i1771 T7412)
(declare-const var_h1770 T7412)
(declare-const v Int)
(declare-const var_h_i1719 T7412)
(declare-const var_h1718 T7412)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2072 T7412)
(declare-const var__temp_v2073 Int)
(declare-const |var__temp_h'2074| T7412)
(declare-const var__temp_v_err2075 T7413)
(declare-const var_h2060 T7412)
(declare-const var_h2032 T7412)
(declare-const var_h2000 T7412)
(declare-const var_h1770 T7412)
(declare-const var_h1718 T7412)
(declare-const err T7426)

solver 
 (declare-sort T7412)
(declare-fun sel (T7412 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2060 () T7412)
(declare-fun var_h2000 () T7412)
(declare-fun var_h1718 () T7412)
(declare-fun other () Int)
(declare-fun var__temp_h2072 () T7412)
(declare-fun |var__temp_h'2074| () T7412)
(declare-fun var__temp_v2073 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2060 res) 5))
(assert (> (sel var_h2000 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2072 res) v)
                (= (sel var__temp_h2072 res) (+ (sel var_h2060 res) 2))
                (= (sel var__temp_h2072 other) (sel var_h2060 other))))
      (a!2 (and (= (sel |var__temp_h'2074| res) var__temp_v2073)
                (= (sel |var__temp_h'2074| res) (+ (sel var__temp_h2072 res) 3))
                (= (sel |var__temp_h'2074| other) (sel var__temp_h2072 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2072 res) 7))
                (=> (= (sel var__temp_h2072 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************baz
PARTIAL PATH NEW
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c4
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2077 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2077 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2077, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2077, res ) ==((sel)( , var_h2076, res ) + (3))
 	 , (sel)( , var_h_i2077, other ) ==(sel)( , var_h2076, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2078:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2077 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************565
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2077 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2077, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2077, res ) ==((sel)( , var_h2076, res ) + (3))
 	 , (sel)( , var_h_i2077, other ) ==(sel)( , var_h2076, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2078:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2077 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2077 --->  Ty_heap  
 var_h2076 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2061 --->  Ty_heap  
 var_h2060 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2033 --->  Ty_heap  
 var_h2032 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2001 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2079 --->  Ty_heap  
 var__temp_v2080 --->  Ty_int  
 var__temp_h'2081 --->  Ty_heap  
 var__temp_v_err2082 --->  error  
 var_h2076 --->  Ty_heap  
 var_h2060 --->  Ty_heap  
 var_h2032 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h2076, res ) ==(7) AND 
 	 Rel (sel)( , var_h2060, res ) ==(5) AND 
 	 Rel (sel)( , var_h2000, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2079, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2079, res ) ==((sel)( , var_h2076, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h2079, other ) ==(sel)( , var_h2076, other ) => 
 	 Rel (sel)( , var__temp_h2079, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2079, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2081, res ) ==(var__temp_v2080) AND 
 	 Rel (sel)( , var__temp_h'2081, res ) ==((sel)( , var__temp_h2079, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2081, other ) ==(sel)( , var__temp_h2079, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2081, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2081, other ) > (4)
 
VC_END(declare-const var_h_i2077 T7429)
(declare-const var_h2076 T7429)
(declare-const v Int)
(declare-const var_h_i2061 T7429)
(declare-const var_h2060 T7429)
(declare-const v Int)
(declare-const var_h_i2033 T7429)
(declare-const var_h2032 T7429)
(declare-const v Int)
(declare-const var_h_i2001 T7429)
(declare-const var_h2000 T7429)
(declare-const v Int)
(declare-const var_h_i1771 T7429)
(declare-const var_h1770 T7429)
(declare-const v Int)
(declare-const var_h_i1719 T7429)
(declare-const var_h1718 T7429)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2079 T7429)
(declare-const var__temp_v2080 Int)
(declare-const |var__temp_h'2081| T7429)
(declare-const var__temp_v_err2082 T7430)
(declare-const var_h2076 T7429)
(declare-const var_h2060 T7429)
(declare-const var_h2032 T7429)
(declare-const var_h2000 T7429)
(declare-const var_h1770 T7429)
(declare-const var_h1718 T7429)
(declare-const err T7443)

solver 
 (declare-sort T7429)
(declare-fun sel (T7429 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2076 () T7429)
(declare-fun var_h2060 () T7429)
(declare-fun var_h2000 () T7429)
(declare-fun var_h1718 () T7429)
(declare-fun other () Int)
(declare-fun |var__temp_h'2081| () T7429)
(declare-fun var__temp_h2079 () T7429)
(declare-fun var__temp_v2080 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2076 res) 7))
(assert (= (sel var_h2060 res) 5))
(assert (> (sel var_h2000 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2079 res) v)
                (= (sel var__temp_h2079 res) (+ (sel var_h2076 res) 3))
                (= (sel var__temp_h2079 other) (sel var_h2076 other))))
      (a!2 (and (= (sel |var__temp_h'2081| res) var__temp_v2080)
                (= (sel |var__temp_h'2081| res) (+ (sel var__temp_h2079 res) 5))
                (= (sel |var__temp_h'2081| other) (sel var__temp_h2079 other))))
      (a!3 (and (= (sel |var__temp_h'2081| res) 10)
                (not (> (sel |var__temp_h'2081| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2079 res) 7))
                (=> (= (sel var__temp_h2079 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************566
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2078:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2078:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbazbarfooc2c2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2077 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2077, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2077, res ) ==((sel)( , var_h2076, res ) + (3))
 	 , (sel)( , var_h_i2077, other ) ==(sel)( , var_h2076, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2083:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************567
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2077 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2077, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2077, res ) ==((sel)( , var_h2076, res ) + (3))
 	 , (sel)( , var_h_i2077, other ) ==(sel)( , var_h2076, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2083:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2077 --->  Ty_heap  
 var_h2076 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2061 --->  Ty_heap  
 var_h2060 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2033 --->  Ty_heap  
 var_h2032 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2001 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2084 --->  Ty_heap  
 var__temp_v2085 --->  Ty_int  
 var__temp_h'2086 --->  Ty_heap  
 var__temp_v_err2087 --->  error  
 var_h2076 --->  Ty_heap  
 var_h2060 --->  Ty_heap  
 var_h2032 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h2076, res ) ==(7) AND 
 	 Rel (sel)( , var_h2060, res ) ==(5) AND 
 	 Rel (sel)( , var_h2000, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2084, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2084, res ) ==((sel)( , var_h2076, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h2084, other ) ==(sel)( , var_h2076, other ) => 
 	 Rel (sel)( , var__temp_h2084, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2084, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2086, res ) ==(var__temp_v2085) AND 
 	 Rel (sel)( , var__temp_h'2086, res ) ==((sel)( , var__temp_h2084, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2086, other ) ==(sel)( , var__temp_h2084, other ) => 
 	 True
 
VC_END(declare-const var_h_i2077 T7446)
(declare-const var_h2076 T7446)
(declare-const v Int)
(declare-const var_h_i2061 T7446)
(declare-const var_h2060 T7446)
(declare-const v Int)
(declare-const var_h_i2033 T7446)
(declare-const var_h2032 T7446)
(declare-const v Int)
(declare-const var_h_i2001 T7446)
(declare-const var_h2000 T7446)
(declare-const v Int)
(declare-const var_h_i1771 T7446)
(declare-const var_h1770 T7446)
(declare-const v Int)
(declare-const var_h_i1719 T7446)
(declare-const var_h1718 T7446)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2084 T7446)
(declare-const var__temp_v2085 Int)
(declare-const |var__temp_h'2086| T7446)
(declare-const var__temp_v_err2087 T7447)
(declare-const var_h2076 T7446)
(declare-const var_h2060 T7446)
(declare-const var_h2032 T7446)
(declare-const var_h2000 T7446)
(declare-const var_h1770 T7446)
(declare-const var_h1718 T7446)
(declare-const err T7460)

solver 
 (declare-sort T7446)
(declare-fun sel (T7446 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2076 () T7446)
(declare-fun var_h2060 () T7446)
(declare-fun var_h2000 () T7446)
(declare-fun var_h1718 () T7446)
(declare-fun other () Int)
(declare-fun var__temp_h2084 () T7446)
(declare-fun |var__temp_h'2086| () T7446)
(declare-fun var__temp_v2085 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2076 res) 7))
(assert (= (sel var_h2060 res) 5))
(assert (> (sel var_h2000 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2084 res) v)
                (= (sel var__temp_h2084 res) (+ (sel var_h2076 res) 3))
                (= (sel var__temp_h2084 other) (sel var_h2076 other))))
      (a!2 (and (= (sel |var__temp_h'2086| res) var__temp_v2085)
                (= (sel |var__temp_h'2086| res) (+ (sel var__temp_h2084 res) 5))
                (= (sel |var__temp_h'2086| other) (sel var__temp_h2084 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2084 res) 7))
                (=> (= (sel var__temp_h2084 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************568
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT baz
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2061 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2061, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2061, res ) ==((sel)( , var_h2060, res ) + (2))
 	 , (sel)( , var_h_i2061, other ) ==(sel)( , var_h2060, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2088:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************569
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2061 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2061, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2061, res ) ==((sel)( , var_h2060, res ) + (2))
 	 , (sel)( , var_h_i2061, other ) ==(sel)( , var_h2060, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2088:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2061 --->  Ty_heap  
 var_h2060 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2033 --->  Ty_heap  
 var_h2032 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2001 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2089 --->  Ty_heap  
 var__temp_v2090 --->  Ty_int  
 var__temp_h'2091 --->  Ty_heap  
 var__temp_v_err2092 --->  error  
 var_h2060 --->  Ty_heap  
 var_h2032 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h2060, res ) ==(5) AND 
 	 Rel (sel)( , var_h2000, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2089, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2089, res ) ==((sel)( , var_h2060, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h2089, other ) ==(sel)( , var_h2060, other ) => 
 	 Rel (sel)( , var__temp_h2089, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2089, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2091, res ) ==(var__temp_v2090) AND 
 	 Rel (sel)( , var__temp_h'2091, res ) ==((sel)( , var__temp_h2089, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2091, other ) ==(sel)( , var__temp_h2089, other ) => 
 	 True
 
VC_END(declare-const var_h_i2061 T7463)
(declare-const var_h2060 T7463)
(declare-const v Int)
(declare-const var_h_i2033 T7463)
(declare-const var_h2032 T7463)
(declare-const v Int)
(declare-const var_h_i2001 T7463)
(declare-const var_h2000 T7463)
(declare-const v Int)
(declare-const var_h_i1771 T7463)
(declare-const var_h1770 T7463)
(declare-const v Int)
(declare-const var_h_i1719 T7463)
(declare-const var_h1718 T7463)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2089 T7463)
(declare-const var__temp_v2090 Int)
(declare-const |var__temp_h'2091| T7463)
(declare-const var__temp_v_err2092 T7464)
(declare-const var_h2060 T7463)
(declare-const var_h2032 T7463)
(declare-const var_h2000 T7463)
(declare-const var_h1770 T7463)
(declare-const var_h1718 T7463)
(declare-const err T7477)

solver 
 (declare-sort T7463)
(declare-fun sel (T7463 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2060 () T7463)
(declare-fun var_h2000 () T7463)
(declare-fun var_h1718 () T7463)
(declare-fun other () Int)
(declare-fun var__temp_h2089 () T7463)
(declare-fun |var__temp_h'2091| () T7463)
(declare-fun var__temp_v2090 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2060 res) 5))
(assert (> (sel var_h2000 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2089 res) v)
                (= (sel var__temp_h2089 res) (+ (sel var_h2060 res) 2))
                (= (sel var__temp_h2089 other) (sel var_h2060 other))))
      (a!2 (and (= (sel |var__temp_h'2091| res) var__temp_v2090)
                (= (sel |var__temp_h'2091| res) (+ (sel var__temp_h2089 res) 5))
                (= (sel |var__temp_h'2091| other) (sel var__temp_h2089 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2089 res) 7))
                (=> (= (sel var__temp_h2089 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c5
PARTIAL PATH NEW
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c4
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2094 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2094 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2094, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2094, res ) ==((sel)( , var_h2093, res ) + (5))
 	 , (sel)( , var_h_i2094, other ) ==(sel)( , var_h2093, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2095:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2094 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************570
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2095:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2095:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc5bazbarfooc2c2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2094 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2094, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2094, res ) ==((sel)( , var_h2093, res ) + (5))
 	 , (sel)( , var_h_i2094, other ) ==(sel)( , var_h2093, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2096:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************571
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2061 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2061, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2061, res ) ==((sel)( , var_h2060, res ) + (2))
 	 , (sel)( , var_h_i2061, other ) ==(sel)( , var_h2060, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2097:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************572
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --foo
 	 --c2
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2033 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2033, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2033, other ) ==(sel)( , var_h2032, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2098:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************573
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2033 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2033, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2033, other ) ==(sel)( , var_h2032, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2098:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2033 --->  Ty_heap  
 var_h2032 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2001 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2099 --->  Ty_heap  
 var__temp_v2100 --->  Ty_int  
 var__temp_h'2101 --->  Ty_heap  
 var__temp_v_err2102 --->  error  
 var_h2032 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2000, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2099, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2099, other ) ==(sel)( , var_h2032, other ) => 
 	 Rel (sel)( , var__temp_h2099, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2099, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2101, res ) ==(var__temp_v2100) AND 
 	 Rel (sel)( , var__temp_h'2101, res ) ==((sel)( , var__temp_h2099, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2101, other ) ==(sel)( , var__temp_h2099, other ) => 
 	 True
 
VC_END(declare-const var_h_i2033 T7480)
(declare-const var_h2032 T7480)
(declare-const v Int)
(declare-const var_h_i2001 T7480)
(declare-const var_h2000 T7480)
(declare-const v Int)
(declare-const var_h_i1771 T7480)
(declare-const var_h1770 T7480)
(declare-const v Int)
(declare-const var_h_i1719 T7480)
(declare-const var_h1718 T7480)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2099 T7480)
(declare-const var__temp_v2100 Int)
(declare-const |var__temp_h'2101| T7480)
(declare-const var__temp_v_err2102 T7481)
(declare-const var_h2032 T7480)
(declare-const var_h2000 T7480)
(declare-const var_h1770 T7480)
(declare-const var_h1718 T7480)
(declare-const err T7494)
    (declare-const |5| Int)
  
solver 
 (declare-sort T7480)
(declare-fun sel (T7480 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2000 () T7480)
(declare-fun var_h1718 () T7480)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2099 () T7480)
(declare-fun |var__temp_h'2101| () T7480)
(declare-fun var__temp_v2100 () Int)
(declare-fun var_h2032 () T7480)
(declare-fun v () Int)
(assert (> (sel var_h2000 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2099 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2099 other) (sel var_h2032 other)))
               (= (sel var__temp_h2099 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2101| res) var__temp_v2100)
                (= (sel |var__temp_h'2101| res) (+ (sel var__temp_h2099 res) 3))
                (= (sel |var__temp_h'2101| other) (sel var__temp_h2099 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2099 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************574
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2033 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2033, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2033, other ) ==(sel)( , var_h2032, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2098:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2033 --->  Ty_heap  
 var_h2032 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2001 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2103 --->  Ty_heap  
 var__temp_v2104 --->  Ty_int  
 var__temp_h'2105 --->  Ty_heap  
 var__temp_v_err2106 --->  error  
 var_h2032 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2000, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2103, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2103, other ) ==(sel)( , var_h2032, other ) => 
 	 Rel (sel)( , var__temp_h2103, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2103, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2105, res ) ==(var__temp_v2104) AND 
 	 Rel (sel)( , var__temp_h'2105, res ) ==((sel)( , var__temp_h2103, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2105, other ) ==(sel)( , var__temp_h2103, other ) => 
 	 True
 
VC_END(declare-const var_h_i2033 T7497)
(declare-const var_h2032 T7497)
(declare-const v Int)
(declare-const var_h_i2001 T7497)
(declare-const var_h2000 T7497)
(declare-const v Int)
(declare-const var_h_i1771 T7497)
(declare-const var_h1770 T7497)
(declare-const v Int)
(declare-const var_h_i1719 T7497)
(declare-const var_h1718 T7497)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2103 T7497)
(declare-const var__temp_v2104 Int)
(declare-const |var__temp_h'2105| T7497)
(declare-const var__temp_v_err2106 T7498)
(declare-const var_h2032 T7497)
(declare-const var_h2000 T7497)
(declare-const var_h1770 T7497)
(declare-const var_h1718 T7497)
(declare-const err T7511)
    (declare-const |5| Int)
  
solver 
 (declare-sort T7497)
(declare-fun sel (T7497 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2000 () T7497)
(declare-fun var_h1718 () T7497)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2103 () T7497)
(declare-fun |var__temp_h'2105| () T7497)
(declare-fun var__temp_v2104 () Int)
(declare-fun var_h2032 () T7497)
(declare-fun v () Int)
(assert (> (sel var_h2000 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2103 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2103 other) (sel var_h2032 other)))
               (= (sel var__temp_h2103 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2105| res) var__temp_v2104)
                (= (sel |var__temp_h'2105| res) (+ (sel var__temp_h2103 res) 5))
                (= (sel |var__temp_h'2105| other) (sel var__temp_h2103 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2103 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************575
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT bar
PARTIAL PATH
SUB 
 	 --c2
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2001 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2001, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2001, res ) ==((sel)( , var_h2000, res ) + (10))
 	 , (sel)( , var_h_i2001, other ) ==(sel)( , var_h2000, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2107:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************576
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2001 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2001, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2001, res ) ==((sel)( , var_h2000, res ) + (10))
 	 , (sel)( , var_h_i2001, other ) ==(sel)( , var_h2000, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2107:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2001 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2108 --->  Ty_heap  
 var__temp_v2109 --->  Ty_int  
 var__temp_h'2110 --->  Ty_heap  
 var__temp_v_err2111 --->  error  
 var_h2000 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2000, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2108, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2108, res ) ==((sel)( , var_h2000, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2108, other ) ==(sel)( , var_h2000, other ) => 
 	 Rel (sel)( , var__temp_h2108, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2108, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2110, res ) ==(var__temp_v2109) AND 
 	 Rel (sel)( , var__temp_h'2110, res ) ==((sel)( , var__temp_h2108, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2110, other ) ==(sel)( , var__temp_h2108, other ) => 
 	 True
 
VC_END(declare-const var_h_i2001 T7514)
(declare-const var_h2000 T7514)
(declare-const v Int)
(declare-const var_h_i1771 T7514)
(declare-const var_h1770 T7514)
(declare-const v Int)
(declare-const var_h_i1719 T7514)
(declare-const var_h1718 T7514)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2108 T7514)
(declare-const var__temp_v2109 Int)
(declare-const |var__temp_h'2110| T7514)
(declare-const var__temp_v_err2111 T7515)
(declare-const var_h2000 T7514)
(declare-const var_h1770 T7514)
(declare-const var_h1718 T7514)
(declare-const err T7528)

solver 
 (declare-sort T7514)
(declare-fun sel (T7514 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2000 () T7514)
(declare-fun var_h1718 () T7514)
(declare-fun other () Int)
(declare-fun var__temp_h2108 () T7514)
(declare-fun |var__temp_h'2110| () T7514)
(declare-fun var__temp_v2109 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2000 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2108 res) v)
                (= (sel var__temp_h2108 res) (+ (sel var_h2000 res) 10))
                (= (sel var__temp_h2108 other) (sel var_h2000 other))))
      (a!2 (and (= (sel |var__temp_h'2110| res) var__temp_v2109)
                (= (sel |var__temp_h'2110| res) (+ (sel var__temp_h2108 res) 3))
                (= (sel |var__temp_h'2110| other) (sel var__temp_h2108 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2108 res) 7))
                (=> (= (sel var__temp_h2108 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************577
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2001 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2001, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2001, res ) ==((sel)( , var_h2000, res ) + (10))
 	 , (sel)( , var_h_i2001, other ) ==(sel)( , var_h2000, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2107:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2001 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2112 --->  Ty_heap  
 var__temp_v2113 --->  Ty_int  
 var__temp_h'2114 --->  Ty_heap  
 var__temp_v_err2115 --->  error  
 var_h2000 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2000, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2112, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2112, res ) ==((sel)( , var_h2000, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2112, other ) ==(sel)( , var_h2000, other ) => 
 	 Rel (sel)( , var__temp_h2112, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2112, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2114, res ) ==(var__temp_v2113) AND 
 	 Rel (sel)( , var__temp_h'2114, res ) ==((sel)( , var__temp_h2112, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2114, other ) ==(sel)( , var__temp_h2112, other ) => 
 	 True
 
VC_END(declare-const var_h_i2001 T7531)
(declare-const var_h2000 T7531)
(declare-const v Int)
(declare-const var_h_i1771 T7531)
(declare-const var_h1770 T7531)
(declare-const v Int)
(declare-const var_h_i1719 T7531)
(declare-const var_h1718 T7531)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2112 T7531)
(declare-const var__temp_v2113 Int)
(declare-const |var__temp_h'2114| T7531)
(declare-const var__temp_v_err2115 T7532)
(declare-const var_h2000 T7531)
(declare-const var_h1770 T7531)
(declare-const var_h1718 T7531)
(declare-const err T7545)

solver 
 (declare-sort T7531)
(declare-fun sel (T7531 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2000 () T7531)
(declare-fun var_h1718 () T7531)
(declare-fun other () Int)
(declare-fun var__temp_h2112 () T7531)
(declare-fun |var__temp_h'2114| () T7531)
(declare-fun var__temp_v2113 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2000 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2112 res) v)
                (= (sel var__temp_h2112 res) (+ (sel var_h2000 res) 10))
                (= (sel var__temp_h2112 other) (sel var_h2000 other))))
      (a!2 (and (= (sel |var__temp_h'2114| res) var__temp_v2113)
                (= (sel |var__temp_h'2114| res) (+ (sel var__temp_h2112 res) 5))
                (= (sel |var__temp_h'2114| other) (sel var__temp_h2112 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2112 res) 7))
                (=> (= (sel var__temp_h2112 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************578
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2001 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2001, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2001, res ) ==((sel)( , var_h2000, res ) + (10))
 	 , (sel)( , var_h_i2001, other ) ==(sel)( , var_h2000, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2107:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2001 --->  Ty_heap  
 var_h2000 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2116 --->  Ty_heap  
 var__temp_v2117 --->  Ty_int  
 var__temp_h'2118 --->  Ty_heap  
 var__temp_v_err2119 --->  error  
 var_h2000 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2000, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2116, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2116, res ) ==((sel)( , var_h2000, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2116, other ) ==(sel)( , var_h2000, other ) => 
 	 Rel (sel)( , var__temp_h2116, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2116, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2118, res ) ==(var__temp_v2117) AND 
 	 Rel (sel)( , var__temp_h'2118, res ) ==((sel)( , var__temp_h2116, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2118, other ) ==(sel)( , var__temp_h2116, other ) => 
 	 True
 
VC_END(declare-const var_h_i2001 T7548)
(declare-const var_h2000 T7548)
(declare-const v Int)
(declare-const var_h_i1771 T7548)
(declare-const var_h1770 T7548)
(declare-const v Int)
(declare-const var_h_i1719 T7548)
(declare-const var_h1718 T7548)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2116 T7548)
(declare-const var__temp_v2117 Int)
(declare-const |var__temp_h'2118| T7548)
(declare-const var__temp_v_err2119 T7549)
(declare-const var_h2000 T7548)
(declare-const var_h1770 T7548)
(declare-const var_h1718 T7548)
(declare-const err T7562)

solver 
 (declare-sort T7548)
(declare-fun sel (T7548 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2000 () T7548)
(declare-fun var_h1718 () T7548)
(declare-fun other () Int)
(declare-fun var__temp_h2116 () T7548)
(declare-fun |var__temp_h'2118| () T7548)
(declare-fun var__temp_v2117 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2000 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2116 res) v)
                (= (sel var__temp_h2116 res) (+ (sel var_h2000 res) 10))
                (= (sel var__temp_h2116 other) (sel var_h2000 other))))
      (a!2 (and (= (sel |var__temp_h'2118| res) var__temp_v2117)
                (= (sel |var__temp_h'2118| res) (+ (sel var__temp_h2116 res) 2))
                (= (sel |var__temp_h'2118| other) (sel var__temp_h2116 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2116 res) 5))
                (=> (= (sel var__temp_h2116 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************579
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo
PARTIAL PATH
SUB 
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1771, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1771, other ) ==(sel)( , var_h1770, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2120:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************580
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1771, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1771, other ) ==(sel)( , var_h1770, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2120:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2121 --->  Ty_heap  
 var__temp_v2122 --->  Ty_int  
 var__temp_h'2123 --->  Ty_heap  
 var__temp_v_err2124 --->  error  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2121, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h2121, other ) ==(sel)( , var_h1770, other ) => 
 	 Rel (sel)( , var__temp_h2121, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2121, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2123, res ) ==(var__temp_v2122) AND 
 	 Rel (sel)( , var__temp_h'2123, res ) ==((sel)( , var__temp_h2121, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2123, other ) ==(sel)( , var__temp_h2121, other ) => 
 	 True
 
VC_END(declare-const var_h_i1771 T7565)
(declare-const var_h1770 T7565)
(declare-const v Int)
(declare-const var_h_i1719 T7565)
(declare-const var_h1718 T7565)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2121 T7565)
(declare-const var__temp_v2122 Int)
(declare-const |var__temp_h'2123| T7565)
(declare-const var__temp_v_err2124 T7566)
(declare-const var_h1770 T7565)
(declare-const var_h1718 T7565)
(declare-const err T7579)
    (declare-const |20| Int)
  
solver 
 (declare-sort T7565)
(declare-fun sel (T7565 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T7565)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2121 () T7565)
(declare-fun |var__temp_h'2123| () T7565)
(declare-fun var__temp_v2122 () Int)
(declare-fun var_h1770 () T7565)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2121 res) v)
                    (= v |20|)
                    (= (sel var__temp_h2121 other) (sel var_h1770 other)))
               (= (sel var__temp_h2121 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2123| res) var__temp_v2122)
                (= (sel |var__temp_h'2123| res) (+ (sel var__temp_h2121 res) 3))
                (= (sel |var__temp_h'2123| other) (sel var__temp_h2121 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2121 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************581
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1771, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1771, other ) ==(sel)( , var_h1770, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2120:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2125 --->  Ty_heap  
 var__temp_v2126 --->  Ty_int  
 var__temp_h'2127 --->  Ty_heap  
 var__temp_v_err2128 --->  error  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2125, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h2125, other ) ==(sel)( , var_h1770, other ) => 
 	 Rel (sel)( , var__temp_h2125, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2125, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2127, res ) ==(var__temp_v2126) AND 
 	 Rel (sel)( , var__temp_h'2127, res ) ==((sel)( , var__temp_h2125, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2127, other ) ==(sel)( , var__temp_h2125, other ) => 
 	 True
 
VC_END(declare-const var_h_i1771 T7582)
(declare-const var_h1770 T7582)
(declare-const v Int)
(declare-const var_h_i1719 T7582)
(declare-const var_h1718 T7582)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2125 T7582)
(declare-const var__temp_v2126 Int)
(declare-const |var__temp_h'2127| T7582)
(declare-const var__temp_v_err2128 T7583)
(declare-const var_h1770 T7582)
(declare-const var_h1718 T7582)
(declare-const err T7596)
    (declare-const |20| Int)
  
solver 
 (declare-sort T7582)
(declare-fun sel (T7582 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T7582)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2125 () T7582)
(declare-fun |var__temp_h'2127| () T7582)
(declare-fun var__temp_v2126 () Int)
(declare-fun var_h1770 () T7582)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2125 res) v)
                    (= v |20|)
                    (= (sel var__temp_h2125 other) (sel var_h1770 other)))
               (= (sel var__temp_h2125 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2127| res) var__temp_v2126)
                (= (sel |var__temp_h'2127| res) (+ (sel var__temp_h2125 res) 5))
                (= (sel |var__temp_h'2127| other) (sel var__temp_h2125 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2125 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************582
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1771, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1771, other ) ==(sel)( , var_h1770, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2120:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2129 --->  Ty_heap  
 var__temp_v2130 --->  Ty_int  
 var__temp_h'2131 --->  Ty_heap  
 var__temp_v_err2132 --->  error  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2129, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h2129, other ) ==(sel)( , var_h1770, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2131, res ) ==(var__temp_v2130) AND 
 	 Base var__temp_v2130 = 5 AND 
 	 Rel (sel)( , var__temp_h'2131, other ) ==(sel)( , var__temp_h2129, other ) => 
 	 True
 
VC_END(declare-const var_h_i1771 T7599)
(declare-const var_h1770 T7599)
(declare-const v Int)
(declare-const var_h_i1719 T7599)
(declare-const var_h1718 T7599)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2129 T7599)
(declare-const var__temp_v2130 Int)
(declare-const |var__temp_h'2131| T7599)
(declare-const var__temp_v_err2132 T7600)
(declare-const var_h1770 T7599)
(declare-const var_h1718 T7599)
(declare-const err T7613)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T7599)
(declare-fun sel (T7599 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T7599)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2129 () T7599)
(declare-fun |var__temp_h'2131| () T7599)
(declare-fun var__temp_v2130 () Int)
(declare-fun var_h1770 () T7599)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2129 res) v)
                    (= v |20|)
                    (= (sel var__temp_h2129 other) (sel var_h1770 other)))
               true))
      (a!2 (=> (and (= (sel |var__temp_h'2131| res) var__temp_v2130)
                    (= var__temp_v2130 |5|)
                    (= (sel |var__temp_h'2131| other)
                       (sel var__temp_h2129 other)))
               true)))
  (not (and a!1 (=> true a!2)))))

***************Selection Successful************foo
PARTIAL PATH NEW
SUB 
 	 --foo
 	 --foo'
 	 --c4
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2134 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2134 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2134, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2134, other ) ==(sel)( , var_h2133, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2135:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2134 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************583
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2134 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2134, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2134, other ) ==(sel)( , var_h2133, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2135:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2134 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2134 --->  Ty_heap  
 var_h2133 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2136 --->  Ty_heap  
 var__temp_v2137 --->  Ty_int  
 var__temp_h'2138 --->  Ty_heap  
 var__temp_v_err2139 --->  error  
 var_h2133 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2136, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2136, other ) ==(sel)( , var_h2133, other ) => 
 	 Rel (sel)( , var__temp_h2136, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2136, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2138, res ) ==(var__temp_v2137) AND 
 	 Rel (sel)( , var__temp_h'2138, res ) ==((sel)( , var__temp_h2136, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2138, other ) ==(sel)( , var__temp_h2136, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2138, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2138, other ) > (4)
 
VC_END(declare-const var_h_i2134 T7616)
(declare-const var_h2133 T7616)
(declare-const v Int)
(declare-const var_h_i1771 T7616)
(declare-const var_h1770 T7616)
(declare-const v Int)
(declare-const var_h_i1719 T7616)
(declare-const var_h1718 T7616)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2136 T7616)
(declare-const var__temp_v2137 Int)
(declare-const |var__temp_h'2138| T7616)
(declare-const var__temp_v_err2139 T7617)
(declare-const var_h2133 T7616)
(declare-const var_h1770 T7616)
(declare-const var_h1718 T7616)
(declare-const err T7630)
    (declare-const |5| Int)
  
solver 
 (declare-sort T7616)
(declare-fun sel (T7616 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T7616)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2138| () T7616)
(declare-fun var__temp_h2136 () T7616)
(declare-fun var__temp_v2137 () Int)
(declare-fun var_h2133 () T7616)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2136 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2136 other) (sel var_h2133 other)))
               (= (sel var__temp_h2136 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2138| res) var__temp_v2137)
                (= (sel |var__temp_h'2138| res) (+ (sel var__temp_h2136 res) 3))
                (= (sel |var__temp_h'2138| other) (sel var__temp_h2136 other))))
      (a!3 (and (= (sel |var__temp_h'2138| res) 10)
                (not (> (sel |var__temp_h'2138| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2136 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************584
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2134 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2134, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2134, other ) ==(sel)( , var_h2133, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2135:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2134 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2134 --->  Ty_heap  
 var_h2133 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2140 --->  Ty_heap  
 var__temp_v2141 --->  Ty_int  
 var__temp_h'2142 --->  Ty_heap  
 var__temp_v_err2143 --->  error  
 var_h2133 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2140, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2140, other ) ==(sel)( , var_h2133, other ) => 
 	 Rel (sel)( , var__temp_h2140, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2140, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2142, res ) ==(var__temp_v2141) AND 
 	 Rel (sel)( , var__temp_h'2142, res ) ==((sel)( , var__temp_h2140, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2142, other ) ==(sel)( , var__temp_h2140, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2142, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2142, other ) > (4)
 
VC_END(declare-const var_h_i2134 T7633)
(declare-const var_h2133 T7633)
(declare-const v Int)
(declare-const var_h_i1771 T7633)
(declare-const var_h1770 T7633)
(declare-const v Int)
(declare-const var_h_i1719 T7633)
(declare-const var_h1718 T7633)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2140 T7633)
(declare-const var__temp_v2141 Int)
(declare-const |var__temp_h'2142| T7633)
(declare-const var__temp_v_err2143 T7634)
(declare-const var_h2133 T7633)
(declare-const var_h1770 T7633)
(declare-const var_h1718 T7633)
(declare-const err T7647)
    (declare-const |5| Int)
  
solver 
 (declare-sort T7633)
(declare-fun sel (T7633 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T7633)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2142| () T7633)
(declare-fun var__temp_h2140 () T7633)
(declare-fun var__temp_v2141 () Int)
(declare-fun var_h2133 () T7633)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2140 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2140 other) (sel var_h2133 other)))
               (= (sel var__temp_h2140 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2142| res) var__temp_v2141)
                (= (sel |var__temp_h'2142| res) (+ (sel var__temp_h2140 res) 5))
                (= (sel |var__temp_h'2142| other) (sel var__temp_h2140 other))))
      (a!3 (and (= (sel |var__temp_h'2142| res) 10)
                (not (> (sel |var__temp_h'2142| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2140 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************585
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2134 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2134, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2134, other ) ==(sel)( , var_h2133, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2135:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2134 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2134 --->  Ty_heap  
 var_h2133 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2144 --->  Ty_heap  
 var__temp_v2145 --->  Ty_int  
 var__temp_h'2146 --->  Ty_heap  
 var__temp_v_err2147 --->  error  
 var_h2133 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2144, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2144, other ) ==(sel)( , var_h2133, other ) => 
 	 Rel (sel)( , var__temp_h2144, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2144, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2146, res ) ==(var__temp_v2145) AND 
 	 Rel (sel)( , var__temp_h'2146, res ) ==((sel)( , var__temp_h2144, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2146, other ) ==(sel)( , var__temp_h2144, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2146, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2146, other ) > (4)
 
VC_END(declare-const var_h_i2134 T7650)
(declare-const var_h2133 T7650)
(declare-const v Int)
(declare-const var_h_i1771 T7650)
(declare-const var_h1770 T7650)
(declare-const v Int)
(declare-const var_h_i1719 T7650)
(declare-const var_h1718 T7650)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2144 T7650)
(declare-const var__temp_v2145 Int)
(declare-const |var__temp_h'2146| T7650)
(declare-const var__temp_v_err2147 T7651)
(declare-const var_h2133 T7650)
(declare-const var_h1770 T7650)
(declare-const var_h1718 T7650)
(declare-const err T7664)
    (declare-const |5| Int)
  
solver 
 (declare-sort T7650)
(declare-fun sel (T7650 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T7650)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2146| () T7650)
(declare-fun var__temp_h2144 () T7650)
(declare-fun var__temp_v2145 () Int)
(declare-fun var_h2133 () T7650)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2144 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2144 other) (sel var_h2133 other)))
               (= (sel var__temp_h2144 res) 5)))
      (a!2 (and (= (sel |var__temp_h'2146| res) var__temp_v2145)
                (= (sel |var__temp_h'2146| res) (+ (sel var__temp_h2144 res) 2))
                (= (sel |var__temp_h'2146| other) (sel var__temp_h2144 other))))
      (a!3 (and (= (sel |var__temp_h'2146| res) 10)
                (not (> (sel |var__temp_h'2146| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2144 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************586
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2135:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2135:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfooc2c2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --foo
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2134 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2134, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2134, other ) ==(sel)( , var_h2133, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2148:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************587
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2134 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2134, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2134, other ) ==(sel)( , var_h2133, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2148:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2134 --->  Ty_heap  
 var_h2133 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2149 --->  Ty_heap  
 var__temp_v2150 --->  Ty_int  
 var__temp_h'2151 --->  Ty_heap  
 var__temp_v_err2152 --->  error  
 var_h2133 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2149, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2149, other ) ==(sel)( , var_h2133, other ) => 
 	 Rel (sel)( , var__temp_h2149, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2149, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2151, res ) ==(var__temp_v2150) AND 
 	 Rel (sel)( , var__temp_h'2151, res ) ==((sel)( , var__temp_h2149, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2151, other ) ==(sel)( , var__temp_h2149, other ) => 
 	 True
 
VC_END(declare-const var_h_i2134 T7667)
(declare-const var_h2133 T7667)
(declare-const v Int)
(declare-const var_h_i1771 T7667)
(declare-const var_h1770 T7667)
(declare-const v Int)
(declare-const var_h_i1719 T7667)
(declare-const var_h1718 T7667)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2149 T7667)
(declare-const var__temp_v2150 Int)
(declare-const |var__temp_h'2151| T7667)
(declare-const var__temp_v_err2152 T7668)
(declare-const var_h2133 T7667)
(declare-const var_h1770 T7667)
(declare-const var_h1718 T7667)
(declare-const err T7681)
    (declare-const |5| Int)
  
solver 
 (declare-sort T7667)
(declare-fun sel (T7667 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T7667)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2149 () T7667)
(declare-fun |var__temp_h'2151| () T7667)
(declare-fun var__temp_v2150 () Int)
(declare-fun var_h2133 () T7667)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2149 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2149 other) (sel var_h2133 other)))
               (= (sel var__temp_h2149 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2151| res) var__temp_v2150)
                (= (sel |var__temp_h'2151| res) (+ (sel var__temp_h2149 res) 3))
                (= (sel |var__temp_h'2151| other) (sel var__temp_h2149 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2149 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************588
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2134 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2134, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2134, other ) ==(sel)( , var_h2133, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2148:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2134 --->  Ty_heap  
 var_h2133 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2153 --->  Ty_heap  
 var__temp_v2154 --->  Ty_int  
 var__temp_h'2155 --->  Ty_heap  
 var__temp_v_err2156 --->  error  
 var_h2133 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2153, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2153, other ) ==(sel)( , var_h2133, other ) => 
 	 Rel (sel)( , var__temp_h2153, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2153, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2155, res ) ==(var__temp_v2154) AND 
 	 Rel (sel)( , var__temp_h'2155, res ) ==((sel)( , var__temp_h2153, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2155, other ) ==(sel)( , var__temp_h2153, other ) => 
 	 True
 
VC_END(declare-const var_h_i2134 T7684)
(declare-const var_h2133 T7684)
(declare-const v Int)
(declare-const var_h_i1771 T7684)
(declare-const var_h1770 T7684)
(declare-const v Int)
(declare-const var_h_i1719 T7684)
(declare-const var_h1718 T7684)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2153 T7684)
(declare-const var__temp_v2154 Int)
(declare-const |var__temp_h'2155| T7684)
(declare-const var__temp_v_err2156 T7685)
(declare-const var_h2133 T7684)
(declare-const var_h1770 T7684)
(declare-const var_h1718 T7684)
(declare-const err T7698)
    (declare-const |5| Int)
  
solver 
 (declare-sort T7684)
(declare-fun sel (T7684 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T7684)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2153 () T7684)
(declare-fun |var__temp_h'2155| () T7684)
(declare-fun var__temp_v2154 () Int)
(declare-fun var_h2133 () T7684)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2153 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2153 other) (sel var_h2133 other)))
               (= (sel var__temp_h2153 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2155| res) var__temp_v2154)
                (= (sel |var__temp_h'2155| res) (+ (sel var__temp_h2153 res) 5))
                (= (sel |var__temp_h'2155| other) (sel var__temp_h2153 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2153 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************589
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2134 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2134, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2134, other ) ==(sel)( , var_h2133, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2148:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2134 --->  Ty_heap  
 var_h2133 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2157 --->  Ty_heap  
 var__temp_v2158 --->  Ty_int  
 var__temp_h'2159 --->  Ty_heap  
 var__temp_v_err2160 --->  error  
 var_h2133 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2157, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2157, other ) ==(sel)( , var_h2133, other ) => 
 	 Rel (sel)( , var__temp_h2157, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2157, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2159, res ) ==(var__temp_v2158) AND 
 	 Rel (sel)( , var__temp_h'2159, res ) ==((sel)( , var__temp_h2157, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2159, other ) ==(sel)( , var__temp_h2157, other ) => 
 	 True
 
VC_END(declare-const var_h_i2134 T7701)
(declare-const var_h2133 T7701)
(declare-const v Int)
(declare-const var_h_i1771 T7701)
(declare-const var_h1770 T7701)
(declare-const v Int)
(declare-const var_h_i1719 T7701)
(declare-const var_h1718 T7701)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2157 T7701)
(declare-const var__temp_v2158 Int)
(declare-const |var__temp_h'2159| T7701)
(declare-const var__temp_v_err2160 T7702)
(declare-const var_h2133 T7701)
(declare-const var_h1770 T7701)
(declare-const var_h1718 T7701)
(declare-const err T7715)
    (declare-const |5| Int)
  
solver 
 (declare-sort T7701)
(declare-fun sel (T7701 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T7701)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2157 () T7701)
(declare-fun |var__temp_h'2159| () T7701)
(declare-fun var__temp_v2158 () Int)
(declare-fun var_h2133 () T7701)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2157 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2157 other) (sel var_h2133 other)))
               (= (sel var__temp_h2157 res) 5)))
      (a!2 (and (= (sel |var__temp_h'2159| res) var__temp_v2158)
                (= (sel |var__temp_h'2159| res) (+ (sel var__temp_h2157 res) 2))
                (= (sel |var__temp_h'2159| other) (sel var__temp_h2157 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2157 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************bar
PARTIAL PATH NEW
SUB 
 	 --bar
 	 --foo
 	 --foo'
 	 --c4
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2162 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2162 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2162, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2162, res ) ==((sel)( , var_h2161, res ) + (2))
 	 , (sel)( , var_h_i2162, other ) ==(sel)( , var_h2161, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2163:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2162 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************590
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2162 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2162, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2162, res ) ==((sel)( , var_h2161, res ) + (2))
 	 , (sel)( , var_h_i2162, other ) ==(sel)( , var_h2161, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2163:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2162 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2162 --->  Ty_heap  
 var_h2161 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2134 --->  Ty_heap  
 var_h2133 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2164 --->  Ty_heap  
 var__temp_v2165 --->  Ty_int  
 var__temp_h'2166 --->  Ty_heap  
 var__temp_v_err2167 --->  error  
 var_h2161 --->  Ty_heap  
 var_h2133 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2161, res ) ==(5) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2164, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2164, res ) ==((sel)( , var_h2161, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h2164, other ) ==(sel)( , var_h2161, other ) => 
 	 Rel (sel)( , var__temp_h2164, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2164, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2166, res ) ==(var__temp_v2165) AND 
 	 Rel (sel)( , var__temp_h'2166, res ) ==((sel)( , var__temp_h2164, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2166, other ) ==(sel)( , var__temp_h2164, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2166, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2166, other ) > (4)
 
VC_END(declare-const var_h_i2162 T7718)
(declare-const var_h2161 T7718)
(declare-const v Int)
(declare-const var_h_i2134 T7718)
(declare-const var_h2133 T7718)
(declare-const v Int)
(declare-const var_h_i1771 T7718)
(declare-const var_h1770 T7718)
(declare-const v Int)
(declare-const var_h_i1719 T7718)
(declare-const var_h1718 T7718)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2164 T7718)
(declare-const var__temp_v2165 Int)
(declare-const |var__temp_h'2166| T7718)
(declare-const var__temp_v_err2167 T7719)
(declare-const var_h2161 T7718)
(declare-const var_h2133 T7718)
(declare-const var_h1770 T7718)
(declare-const var_h1718 T7718)
(declare-const err T7732)

solver 
 (declare-sort T7718)
(declare-fun sel (T7718 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2161 () T7718)
(declare-fun var_h1718 () T7718)
(declare-fun other () Int)
(declare-fun |var__temp_h'2166| () T7718)
(declare-fun var__temp_h2164 () T7718)
(declare-fun var__temp_v2165 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2161 res) 5))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2164 res) v)
                (= (sel var__temp_h2164 res) (+ (sel var_h2161 res) 2))
                (= (sel var__temp_h2164 other) (sel var_h2161 other))))
      (a!2 (and (= (sel |var__temp_h'2166| res) var__temp_v2165)
                (= (sel |var__temp_h'2166| res) (+ (sel var__temp_h2164 res) 3))
                (= (sel |var__temp_h'2166| other) (sel var__temp_h2164 other))))
      (a!3 (and (= (sel |var__temp_h'2166| res) 10)
                (not (> (sel |var__temp_h'2166| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2164 res) 7))
                (=> (= (sel var__temp_h2164 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************591
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2162 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2162, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2162, res ) ==((sel)( , var_h2161, res ) + (2))
 	 , (sel)( , var_h_i2162, other ) ==(sel)( , var_h2161, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2163:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2162 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2162 --->  Ty_heap  
 var_h2161 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2134 --->  Ty_heap  
 var_h2133 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2168 --->  Ty_heap  
 var__temp_v2169 --->  Ty_int  
 var__temp_h'2170 --->  Ty_heap  
 var__temp_v_err2171 --->  error  
 var_h2161 --->  Ty_heap  
 var_h2133 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2161, res ) ==(5) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2168, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2168, res ) ==((sel)( , var_h2161, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h2168, other ) ==(sel)( , var_h2161, other ) => 
 	 Rel (sel)( , var__temp_h2168, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2168, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2170, res ) ==(var__temp_v2169) AND 
 	 Rel (sel)( , var__temp_h'2170, res ) ==((sel)( , var__temp_h2168, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2170, other ) ==(sel)( , var__temp_h2168, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2170, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2170, other ) > (4)
 
VC_END(declare-const var_h_i2162 T7735)
(declare-const var_h2161 T7735)
(declare-const v Int)
(declare-const var_h_i2134 T7735)
(declare-const var_h2133 T7735)
(declare-const v Int)
(declare-const var_h_i1771 T7735)
(declare-const var_h1770 T7735)
(declare-const v Int)
(declare-const var_h_i1719 T7735)
(declare-const var_h1718 T7735)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2168 T7735)
(declare-const var__temp_v2169 Int)
(declare-const |var__temp_h'2170| T7735)
(declare-const var__temp_v_err2171 T7736)
(declare-const var_h2161 T7735)
(declare-const var_h2133 T7735)
(declare-const var_h1770 T7735)
(declare-const var_h1718 T7735)
(declare-const err T7749)

solver 
 (declare-sort T7735)
(declare-fun sel (T7735 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2161 () T7735)
(declare-fun var_h1718 () T7735)
(declare-fun other () Int)
(declare-fun |var__temp_h'2170| () T7735)
(declare-fun var__temp_h2168 () T7735)
(declare-fun var__temp_v2169 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2161 res) 5))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2168 res) v)
                (= (sel var__temp_h2168 res) (+ (sel var_h2161 res) 2))
                (= (sel var__temp_h2168 other) (sel var_h2161 other))))
      (a!2 (and (= (sel |var__temp_h'2170| res) var__temp_v2169)
                (= (sel |var__temp_h'2170| res) (+ (sel var__temp_h2168 res) 5))
                (= (sel |var__temp_h'2170| other) (sel var__temp_h2168 other))))
      (a!3 (and (= (sel |var__temp_h'2170| res) 10)
                (not (> (sel |var__temp_h'2170| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2168 res) 7))
                (=> (= (sel var__temp_h2168 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************592
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2163:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2163:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbarfooc2c2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2162 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2162, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2162, res ) ==((sel)( , var_h2161, res ) + (2))
 	 , (sel)( , var_h_i2162, other ) ==(sel)( , var_h2161, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2172:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************593
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2162 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2162, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2162, res ) ==((sel)( , var_h2161, res ) + (2))
 	 , (sel)( , var_h_i2162, other ) ==(sel)( , var_h2161, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2172:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2162 --->  Ty_heap  
 var_h2161 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2134 --->  Ty_heap  
 var_h2133 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2173 --->  Ty_heap  
 var__temp_v2174 --->  Ty_int  
 var__temp_h'2175 --->  Ty_heap  
 var__temp_v_err2176 --->  error  
 var_h2161 --->  Ty_heap  
 var_h2133 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2161, res ) ==(5) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2173, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2173, res ) ==((sel)( , var_h2161, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h2173, other ) ==(sel)( , var_h2161, other ) => 
 	 Rel (sel)( , var__temp_h2173, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2173, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2175, res ) ==(var__temp_v2174) AND 
 	 Rel (sel)( , var__temp_h'2175, res ) ==((sel)( , var__temp_h2173, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2175, other ) ==(sel)( , var__temp_h2173, other ) => 
 	 True
 
VC_END(declare-const var_h_i2162 T7752)
(declare-const var_h2161 T7752)
(declare-const v Int)
(declare-const var_h_i2134 T7752)
(declare-const var_h2133 T7752)
(declare-const v Int)
(declare-const var_h_i1771 T7752)
(declare-const var_h1770 T7752)
(declare-const v Int)
(declare-const var_h_i1719 T7752)
(declare-const var_h1718 T7752)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2173 T7752)
(declare-const var__temp_v2174 Int)
(declare-const |var__temp_h'2175| T7752)
(declare-const var__temp_v_err2176 T7753)
(declare-const var_h2161 T7752)
(declare-const var_h2133 T7752)
(declare-const var_h1770 T7752)
(declare-const var_h1718 T7752)
(declare-const err T7766)

solver 
 (declare-sort T7752)
(declare-fun sel (T7752 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2161 () T7752)
(declare-fun var_h1718 () T7752)
(declare-fun other () Int)
(declare-fun var__temp_h2173 () T7752)
(declare-fun |var__temp_h'2175| () T7752)
(declare-fun var__temp_v2174 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2161 res) 5))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2173 res) v)
                (= (sel var__temp_h2173 res) (+ (sel var_h2161 res) 2))
                (= (sel var__temp_h2173 other) (sel var_h2161 other))))
      (a!2 (and (= (sel |var__temp_h'2175| res) var__temp_v2174)
                (= (sel |var__temp_h'2175| res) (+ (sel var__temp_h2173 res) 3))
                (= (sel |var__temp_h'2175| other) (sel var__temp_h2173 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2173 res) 7))
                (=> (= (sel var__temp_h2173 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************baz
PARTIAL PATH NEW
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --foo'
 	 --c4
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2178 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2178 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2178, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2178, res ) ==((sel)( , var_h2177, res ) + (3))
 	 , (sel)( , var_h_i2178, other ) ==(sel)( , var_h2177, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2179:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2178 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************594
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2178 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2178, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2178, res ) ==((sel)( , var_h2177, res ) + (3))
 	 , (sel)( , var_h_i2178, other ) ==(sel)( , var_h2177, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2179:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2178 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2178 --->  Ty_heap  
 var_h2177 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2162 --->  Ty_heap  
 var_h2161 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2134 --->  Ty_heap  
 var_h2133 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2180 --->  Ty_heap  
 var__temp_v2181 --->  Ty_int  
 var__temp_h'2182 --->  Ty_heap  
 var__temp_v_err2183 --->  error  
 var_h2177 --->  Ty_heap  
 var_h2161 --->  Ty_heap  
 var_h2133 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h2177, res ) ==(7) AND 
 	 Rel (sel)( , var_h2161, res ) ==(5) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2180, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2180, res ) ==((sel)( , var_h2177, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h2180, other ) ==(sel)( , var_h2177, other ) => 
 	 Rel (sel)( , var__temp_h2180, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2180, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2182, res ) ==(var__temp_v2181) AND 
 	 Rel (sel)( , var__temp_h'2182, res ) ==((sel)( , var__temp_h2180, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2182, other ) ==(sel)( , var__temp_h2180, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2182, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2182, other ) > (4)
 
VC_END(declare-const var_h_i2178 T7769)
(declare-const var_h2177 T7769)
(declare-const v Int)
(declare-const var_h_i2162 T7769)
(declare-const var_h2161 T7769)
(declare-const v Int)
(declare-const var_h_i2134 T7769)
(declare-const var_h2133 T7769)
(declare-const v Int)
(declare-const var_h_i1771 T7769)
(declare-const var_h1770 T7769)
(declare-const v Int)
(declare-const var_h_i1719 T7769)
(declare-const var_h1718 T7769)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2180 T7769)
(declare-const var__temp_v2181 Int)
(declare-const |var__temp_h'2182| T7769)
(declare-const var__temp_v_err2183 T7770)
(declare-const var_h2177 T7769)
(declare-const var_h2161 T7769)
(declare-const var_h2133 T7769)
(declare-const var_h1770 T7769)
(declare-const var_h1718 T7769)
(declare-const err T7783)

solver 
 (declare-sort T7769)
(declare-fun sel (T7769 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2177 () T7769)
(declare-fun var_h2161 () T7769)
(declare-fun var_h1718 () T7769)
(declare-fun other () Int)
(declare-fun |var__temp_h'2182| () T7769)
(declare-fun var__temp_h2180 () T7769)
(declare-fun var__temp_v2181 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2177 res) 7))
(assert (= (sel var_h2161 res) 5))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2180 res) v)
                (= (sel var__temp_h2180 res) (+ (sel var_h2177 res) 3))
                (= (sel var__temp_h2180 other) (sel var_h2177 other))))
      (a!2 (and (= (sel |var__temp_h'2182| res) var__temp_v2181)
                (= (sel |var__temp_h'2182| res) (+ (sel var__temp_h2180 res) 5))
                (= (sel |var__temp_h'2182| other) (sel var__temp_h2180 other))))
      (a!3 (and (= (sel |var__temp_h'2182| res) 10)
                (not (> (sel |var__temp_h'2182| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2180 res) 7))
                (=> (= (sel var__temp_h2180 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************595
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2179:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2179:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbazbarfooc2c2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2178 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2178, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2178, res ) ==((sel)( , var_h2177, res ) + (3))
 	 , (sel)( , var_h_i2178, other ) ==(sel)( , var_h2177, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2184:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************596
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2178 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2178, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2178, res ) ==((sel)( , var_h2177, res ) + (3))
 	 , (sel)( , var_h_i2178, other ) ==(sel)( , var_h2177, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2184:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2178 --->  Ty_heap  
 var_h2177 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2162 --->  Ty_heap  
 var_h2161 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2134 --->  Ty_heap  
 var_h2133 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2185 --->  Ty_heap  
 var__temp_v2186 --->  Ty_int  
 var__temp_h'2187 --->  Ty_heap  
 var__temp_v_err2188 --->  error  
 var_h2177 --->  Ty_heap  
 var_h2161 --->  Ty_heap  
 var_h2133 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h2177, res ) ==(7) AND 
 	 Rel (sel)( , var_h2161, res ) ==(5) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2185, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2185, res ) ==((sel)( , var_h2177, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h2185, other ) ==(sel)( , var_h2177, other ) => 
 	 Rel (sel)( , var__temp_h2185, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2185, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2187, res ) ==(var__temp_v2186) AND 
 	 Rel (sel)( , var__temp_h'2187, res ) ==((sel)( , var__temp_h2185, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2187, other ) ==(sel)( , var__temp_h2185, other ) => 
 	 True
 
VC_END(declare-const var_h_i2178 T7786)
(declare-const var_h2177 T7786)
(declare-const v Int)
(declare-const var_h_i2162 T7786)
(declare-const var_h2161 T7786)
(declare-const v Int)
(declare-const var_h_i2134 T7786)
(declare-const var_h2133 T7786)
(declare-const v Int)
(declare-const var_h_i1771 T7786)
(declare-const var_h1770 T7786)
(declare-const v Int)
(declare-const var_h_i1719 T7786)
(declare-const var_h1718 T7786)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2185 T7786)
(declare-const var__temp_v2186 Int)
(declare-const |var__temp_h'2187| T7786)
(declare-const var__temp_v_err2188 T7787)
(declare-const var_h2177 T7786)
(declare-const var_h2161 T7786)
(declare-const var_h2133 T7786)
(declare-const var_h1770 T7786)
(declare-const var_h1718 T7786)
(declare-const err T7800)

solver 
 (declare-sort T7786)
(declare-fun sel (T7786 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2177 () T7786)
(declare-fun var_h2161 () T7786)
(declare-fun var_h1718 () T7786)
(declare-fun other () Int)
(declare-fun var__temp_h2185 () T7786)
(declare-fun |var__temp_h'2187| () T7786)
(declare-fun var__temp_v2186 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2177 res) 7))
(assert (= (sel var_h2161 res) 5))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2185 res) v)
                (= (sel var__temp_h2185 res) (+ (sel var_h2177 res) 3))
                (= (sel var__temp_h2185 other) (sel var_h2177 other))))
      (a!2 (and (= (sel |var__temp_h'2187| res) var__temp_v2186)
                (= (sel |var__temp_h'2187| res) (+ (sel var__temp_h2185 res) 5))
                (= (sel |var__temp_h'2187| other) (sel var__temp_h2185 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2185 res) 7))
                (=> (= (sel var__temp_h2185 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************597
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT baz
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2162 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2162, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2162, res ) ==((sel)( , var_h2161, res ) + (2))
 	 , (sel)( , var_h_i2162, other ) ==(sel)( , var_h2161, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2189:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************598
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2162 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2162, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2162, res ) ==((sel)( , var_h2161, res ) + (2))
 	 , (sel)( , var_h_i2162, other ) ==(sel)( , var_h2161, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2189:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2162 --->  Ty_heap  
 var_h2161 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2134 --->  Ty_heap  
 var_h2133 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2190 --->  Ty_heap  
 var__temp_v2191 --->  Ty_int  
 var__temp_h'2192 --->  Ty_heap  
 var__temp_v_err2193 --->  error  
 var_h2161 --->  Ty_heap  
 var_h2133 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2161, res ) ==(5) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2190, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2190, res ) ==((sel)( , var_h2161, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h2190, other ) ==(sel)( , var_h2161, other ) => 
 	 Rel (sel)( , var__temp_h2190, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2190, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2192, res ) ==(var__temp_v2191) AND 
 	 Rel (sel)( , var__temp_h'2192, res ) ==((sel)( , var__temp_h2190, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2192, other ) ==(sel)( , var__temp_h2190, other ) => 
 	 True
 
VC_END(declare-const var_h_i2162 T7803)
(declare-const var_h2161 T7803)
(declare-const v Int)
(declare-const var_h_i2134 T7803)
(declare-const var_h2133 T7803)
(declare-const v Int)
(declare-const var_h_i1771 T7803)
(declare-const var_h1770 T7803)
(declare-const v Int)
(declare-const var_h_i1719 T7803)
(declare-const var_h1718 T7803)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2190 T7803)
(declare-const var__temp_v2191 Int)
(declare-const |var__temp_h'2192| T7803)
(declare-const var__temp_v_err2193 T7804)
(declare-const var_h2161 T7803)
(declare-const var_h2133 T7803)
(declare-const var_h1770 T7803)
(declare-const var_h1718 T7803)
(declare-const err T7817)

solver 
 (declare-sort T7803)
(declare-fun sel (T7803 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2161 () T7803)
(declare-fun var_h1718 () T7803)
(declare-fun other () Int)
(declare-fun var__temp_h2190 () T7803)
(declare-fun |var__temp_h'2192| () T7803)
(declare-fun var__temp_v2191 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2161 res) 5))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2190 res) v)
                (= (sel var__temp_h2190 res) (+ (sel var_h2161 res) 2))
                (= (sel var__temp_h2190 other) (sel var_h2161 other))))
      (a!2 (and (= (sel |var__temp_h'2192| res) var__temp_v2191)
                (= (sel |var__temp_h'2192| res) (+ (sel var__temp_h2190 res) 5))
                (= (sel |var__temp_h'2192| other) (sel var__temp_h2190 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2190 res) 7))
                (=> (= (sel var__temp_h2190 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c5
PARTIAL PATH NEW
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --foo'
 	 --c4
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2195 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2195 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2195, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2195, res ) ==((sel)( , var_h2194, res ) + (5))
 	 , (sel)( , var_h_i2195, other ) ==(sel)( , var_h2194, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2196:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2195 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************599
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2196:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2196:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc5bazbarfooc2c2'foo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2195 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2195, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2195, res ) ==((sel)( , var_h2194, res ) + (5))
 	 , (sel)( , var_h_i2195, other ) ==(sel)( , var_h2194, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2197:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************600
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2162 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2162, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2162, res ) ==((sel)( , var_h2161, res ) + (2))
 	 , (sel)( , var_h_i2162, other ) ==(sel)( , var_h2161, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2198:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************601
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --foo
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2134 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2134, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2134, other ) ==(sel)( , var_h2133, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2199:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************602
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2134 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2134, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2134, other ) ==(sel)( , var_h2133, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2199:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2134 --->  Ty_heap  
 var_h2133 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2200 --->  Ty_heap  
 var__temp_v2201 --->  Ty_int  
 var__temp_h'2202 --->  Ty_heap  
 var__temp_v_err2203 --->  error  
 var_h2133 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2200, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2200, other ) ==(sel)( , var_h2133, other ) => 
 	 Rel (sel)( , var__temp_h2200, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2200, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2202, res ) ==(var__temp_v2201) AND 
 	 Rel (sel)( , var__temp_h'2202, res ) ==((sel)( , var__temp_h2200, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2202, other ) ==(sel)( , var__temp_h2200, other ) => 
 	 True
 
VC_END(declare-const var_h_i2134 T7820)
(declare-const var_h2133 T7820)
(declare-const v Int)
(declare-const var_h_i1771 T7820)
(declare-const var_h1770 T7820)
(declare-const v Int)
(declare-const var_h_i1719 T7820)
(declare-const var_h1718 T7820)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2200 T7820)
(declare-const var__temp_v2201 Int)
(declare-const |var__temp_h'2202| T7820)
(declare-const var__temp_v_err2203 T7821)
(declare-const var_h2133 T7820)
(declare-const var_h1770 T7820)
(declare-const var_h1718 T7820)
(declare-const err T7834)
    (declare-const |5| Int)
  
solver 
 (declare-sort T7820)
(declare-fun sel (T7820 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T7820)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2200 () T7820)
(declare-fun |var__temp_h'2202| () T7820)
(declare-fun var__temp_v2201 () Int)
(declare-fun var_h2133 () T7820)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2200 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2200 other) (sel var_h2133 other)))
               (= (sel var__temp_h2200 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2202| res) var__temp_v2201)
                (= (sel |var__temp_h'2202| res) (+ (sel var__temp_h2200 res) 3))
                (= (sel |var__temp_h'2202| other) (sel var__temp_h2200 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2200 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************603
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2134 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2134, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2134, other ) ==(sel)( , var_h2133, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2199:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2134 --->  Ty_heap  
 var_h2133 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2204 --->  Ty_heap  
 var__temp_v2205 --->  Ty_int  
 var__temp_h'2206 --->  Ty_heap  
 var__temp_v_err2207 --->  error  
 var_h2133 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2204, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2204, other ) ==(sel)( , var_h2133, other ) => 
 	 Rel (sel)( , var__temp_h2204, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2204, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2206, res ) ==(var__temp_v2205) AND 
 	 Rel (sel)( , var__temp_h'2206, res ) ==((sel)( , var__temp_h2204, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2206, other ) ==(sel)( , var__temp_h2204, other ) => 
 	 True
 
VC_END(declare-const var_h_i2134 T7837)
(declare-const var_h2133 T7837)
(declare-const v Int)
(declare-const var_h_i1771 T7837)
(declare-const var_h1770 T7837)
(declare-const v Int)
(declare-const var_h_i1719 T7837)
(declare-const var_h1718 T7837)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2204 T7837)
(declare-const var__temp_v2205 Int)
(declare-const |var__temp_h'2206| T7837)
(declare-const var__temp_v_err2207 T7838)
(declare-const var_h2133 T7837)
(declare-const var_h1770 T7837)
(declare-const var_h1718 T7837)
(declare-const err T7851)
    (declare-const |5| Int)
  
solver 
 (declare-sort T7837)
(declare-fun sel (T7837 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T7837)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2204 () T7837)
(declare-fun |var__temp_h'2206| () T7837)
(declare-fun var__temp_v2205 () Int)
(declare-fun var_h2133 () T7837)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2204 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2204 other) (sel var_h2133 other)))
               (= (sel var__temp_h2204 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2206| res) var__temp_v2205)
                (= (sel |var__temp_h'2206| res) (+ (sel var__temp_h2204 res) 5))
                (= (sel |var__temp_h'2206| other) (sel var__temp_h2204 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2204 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************604
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT bar
PARTIAL PATH
SUB 
 	 --foo'
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1771, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1771, other ) ==(sel)( , var_h1770, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2208:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************605
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1771, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1771, other ) ==(sel)( , var_h1770, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2208:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2209 --->  Ty_heap  
 var__temp_v2210 --->  Ty_int  
 var__temp_h'2211 --->  Ty_heap  
 var__temp_v_err2212 --->  error  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2209, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h2209, other ) ==(sel)( , var_h1770, other ) => 
 	 Rel (sel)( , var__temp_h2209, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2209, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2211, res ) ==(var__temp_v2210) AND 
 	 Rel (sel)( , var__temp_h'2211, res ) ==((sel)( , var__temp_h2209, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2211, other ) ==(sel)( , var__temp_h2209, other ) => 
 	 True
 
VC_END(declare-const var_h_i1771 T7854)
(declare-const var_h1770 T7854)
(declare-const v Int)
(declare-const var_h_i1719 T7854)
(declare-const var_h1718 T7854)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2209 T7854)
(declare-const var__temp_v2210 Int)
(declare-const |var__temp_h'2211| T7854)
(declare-const var__temp_v_err2212 T7855)
(declare-const var_h1770 T7854)
(declare-const var_h1718 T7854)
(declare-const err T7868)
    (declare-const |20| Int)
  
solver 
 (declare-sort T7854)
(declare-fun sel (T7854 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T7854)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2209 () T7854)
(declare-fun |var__temp_h'2211| () T7854)
(declare-fun var__temp_v2210 () Int)
(declare-fun var_h1770 () T7854)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2209 res) v)
                    (= v |20|)
                    (= (sel var__temp_h2209 other) (sel var_h1770 other)))
               (= (sel var__temp_h2209 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2211| res) var__temp_v2210)
                (= (sel |var__temp_h'2211| res) (+ (sel var__temp_h2209 res) 3))
                (= (sel |var__temp_h'2211| other) (sel var__temp_h2209 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2209 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************606
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1771, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1771, other ) ==(sel)( , var_h1770, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2208:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2213 --->  Ty_heap  
 var__temp_v2214 --->  Ty_int  
 var__temp_h'2215 --->  Ty_heap  
 var__temp_v_err2216 --->  error  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2213, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h2213, other ) ==(sel)( , var_h1770, other ) => 
 	 Rel (sel)( , var__temp_h2213, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2213, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2215, res ) ==(var__temp_v2214) AND 
 	 Rel (sel)( , var__temp_h'2215, res ) ==((sel)( , var__temp_h2213, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2215, other ) ==(sel)( , var__temp_h2213, other ) => 
 	 True
 
VC_END(declare-const var_h_i1771 T7871)
(declare-const var_h1770 T7871)
(declare-const v Int)
(declare-const var_h_i1719 T7871)
(declare-const var_h1718 T7871)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2213 T7871)
(declare-const var__temp_v2214 Int)
(declare-const |var__temp_h'2215| T7871)
(declare-const var__temp_v_err2216 T7872)
(declare-const var_h1770 T7871)
(declare-const var_h1718 T7871)
(declare-const err T7885)
    (declare-const |20| Int)
  
solver 
 (declare-sort T7871)
(declare-fun sel (T7871 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T7871)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2213 () T7871)
(declare-fun |var__temp_h'2215| () T7871)
(declare-fun var__temp_v2214 () Int)
(declare-fun var_h1770 () T7871)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2213 res) v)
                    (= v |20|)
                    (= (sel var__temp_h2213 other) (sel var_h1770 other)))
               (= (sel var__temp_h2213 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2215| res) var__temp_v2214)
                (= (sel |var__temp_h'2215| res) (+ (sel var__temp_h2213 res) 5))
                (= (sel |var__temp_h'2215| other) (sel var__temp_h2213 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2213 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************607
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1771 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1771, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i1771, other ) ==(sel)( , var_h1770, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2208:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1771 --->  Ty_heap  
 var_h1770 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2217 --->  Ty_heap  
 var__temp_v2218 --->  Ty_int  
 var__temp_h'2219 --->  Ty_heap  
 var__temp_v_err2220 --->  error  
 var_h1770 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2217, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h2217, other ) ==(sel)( , var_h1770, other ) => 
 	 Rel (sel)( , var__temp_h2217, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2217, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2219, res ) ==(var__temp_v2218) AND 
 	 Rel (sel)( , var__temp_h'2219, res ) ==((sel)( , var__temp_h2217, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2219, other ) ==(sel)( , var__temp_h2217, other ) => 
 	 True
 
VC_END(declare-const var_h_i1771 T7888)
(declare-const var_h1770 T7888)
(declare-const v Int)
(declare-const var_h_i1719 T7888)
(declare-const var_h1718 T7888)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2217 T7888)
(declare-const var__temp_v2218 Int)
(declare-const |var__temp_h'2219| T7888)
(declare-const var__temp_v_err2220 T7889)
(declare-const var_h1770 T7888)
(declare-const var_h1718 T7888)
(declare-const err T7902)
    (declare-const |20| Int)
  
solver 
 (declare-sort T7888)
(declare-fun sel (T7888 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T7888)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2217 () T7888)
(declare-fun |var__temp_h'2219| () T7888)
(declare-fun var__temp_v2218 () Int)
(declare-fun var_h1770 () T7888)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2217 res) v)
                    (= v |20|)
                    (= (sel var__temp_h2217 other) (sel var_h1770 other)))
               (= (sel var__temp_h2217 res) 5)))
      (a!2 (and (= (sel |var__temp_h'2219| res) var__temp_v2218)
                (= (sel |var__temp_h'2219| res) (+ (sel var__temp_h2217 res) 2))
                (= (sel |var__temp_h'2219| other) (sel var__temp_h2217 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2217 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************608
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo
PARTIAL PATH
SUB 
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1719, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1719, res ) ==((sel)( , var_h1718, res ) + (5))
 	 , (sel)( , var_h_i1719, other ) ==(sel)( , var_h1718, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2221:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
foo
bar
 *********************Enumeration Iteration*****************609
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1719, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1719, res ) ==((sel)( , var_h1718, res ) + (5))
 	 , (sel)( , var_h_i1719, other ) ==(sel)( , var_h1718, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2221:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2222 --->  Ty_heap  
 var__temp_v2223 --->  Ty_int  
 var__temp_h'2224 --->  Ty_heap  
 var__temp_v_err2225 --->  error  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2222, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2222, res ) ==((sel)( , var_h1718, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h2222, other ) ==(sel)( , var_h1718, other ) => 
 	 Rel (sel)( , var__temp_h2222, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2222, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2224, res ) ==(var__temp_v2223) AND 
 	 Rel (sel)( , var__temp_h'2224, res ) ==((sel)( , var__temp_h2222, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2224, other ) ==(sel)( , var__temp_h2222, other ) => 
 	 True
 
VC_END(declare-const var_h_i1719 T7905)
(declare-const var_h1718 T7905)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2222 T7905)
(declare-const var__temp_v2223 Int)
(declare-const |var__temp_h'2224| T7905)
(declare-const var__temp_v_err2225 T7906)
(declare-const var_h1718 T7905)
(declare-const err T7919)

solver 
 (declare-sort T7905)
(declare-fun sel (T7905 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T7905)
(declare-fun other () Int)
(declare-fun var__temp_h2222 () T7905)
(declare-fun |var__temp_h'2224| () T7905)
(declare-fun var__temp_v2223 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2222 res) v)
                (= (sel var__temp_h2222 res) (+ (sel var_h1718 res) 5))
                (= (sel var__temp_h2222 other) (sel var_h1718 other))))
      (a!2 (and (= (sel |var__temp_h'2224| res) var__temp_v2223)
                (= (sel |var__temp_h'2224| res) (+ (sel var__temp_h2222 res) 3))
                (= (sel |var__temp_h'2224| other) (sel var__temp_h2222 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2222 res) 7))
                (=> (= (sel var__temp_h2222 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************610
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1719, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1719, res ) ==((sel)( , var_h1718, res ) + (5))
 	 , (sel)( , var_h_i1719, other ) ==(sel)( , var_h1718, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2221:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2226 --->  Ty_heap  
 var__temp_v2227 --->  Ty_int  
 var__temp_h'2228 --->  Ty_heap  
 var__temp_v_err2229 --->  error  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2226, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2226, res ) ==((sel)( , var_h1718, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h2226, other ) ==(sel)( , var_h1718, other ) => 
 	 Rel (sel)( , var__temp_h2226, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2226, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2228, res ) ==(var__temp_v2227) AND 
 	 Rel (sel)( , var__temp_h'2228, res ) ==((sel)( , var__temp_h2226, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2228, other ) ==(sel)( , var__temp_h2226, other ) => 
 	 True
 
VC_END(declare-const var_h_i1719 T7922)
(declare-const var_h1718 T7922)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2226 T7922)
(declare-const var__temp_v2227 Int)
(declare-const |var__temp_h'2228| T7922)
(declare-const var__temp_v_err2229 T7923)
(declare-const var_h1718 T7922)
(declare-const err T7936)

solver 
 (declare-sort T7922)
(declare-fun sel (T7922 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T7922)
(declare-fun other () Int)
(declare-fun var__temp_h2226 () T7922)
(declare-fun |var__temp_h'2228| () T7922)
(declare-fun var__temp_v2227 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2226 res) v)
                (= (sel var__temp_h2226 res) (+ (sel var_h1718 res) 5))
                (= (sel var__temp_h2226 other) (sel var_h1718 other))))
      (a!2 (and (= (sel |var__temp_h'2228| res) var__temp_v2227)
                (= (sel |var__temp_h'2228| res) (+ (sel var__temp_h2226 res) 5))
                (= (sel |var__temp_h'2228| other) (sel var__temp_h2226 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2226 res) 7))
                (=> (= (sel var__temp_h2226 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************611
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1719, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1719, res ) ==((sel)( , var_h1718, res ) + (5))
 	 , (sel)( , var_h_i1719, other ) ==(sel)( , var_h1718, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2221:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2230 --->  Ty_heap  
 var__temp_v2231 --->  Ty_int  
 var__temp_h'2232 --->  Ty_heap  
 var__temp_v_err2233 --->  error  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2230, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2230, res ) ==((sel)( , var_h1718, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h2230, other ) ==(sel)( , var_h1718, other ) => 
 	 Rel (sel)( , var__temp_h2230, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h2230, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2232, res ) ==(var__temp_v2231) AND 
 	 Rel (sel)( , var__temp_h2230, res ) ==(sel)( , var__temp_h2230, res ) AND 
 	 Rel (sel)( , var__temp_h'2232, other ) ==(sel)( , var__temp_h2230, other ) => 
 	 True
 
VC_END(declare-const var_h_i1719 T7939)
(declare-const var_h1718 T7939)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2230 T7939)
(declare-const var__temp_v2231 Int)
(declare-const |var__temp_h'2232| T7939)
(declare-const var__temp_v_err2233 T7940)
(declare-const var_h1718 T7939)
(declare-const err T7953)

solver 
 (declare-sort T7939)
(declare-fun sel (T7939 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T7939)
(declare-fun other () Int)
(declare-fun var__temp_h2230 () T7939)
(declare-fun |var__temp_h'2232| () T7939)
(declare-fun var__temp_v2231 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2230 res) v)
                (= (sel var__temp_h2230 res) (+ (sel var_h1718 res) 5))
                (= (sel var__temp_h2230 other) (sel var_h1718 other))))
      (a!3 (=> (and (= (sel |var__temp_h'2232| res) var__temp_v2231)
                    (= (sel var__temp_h2230 res) (sel var__temp_h2230 res))
                    (= (sel |var__temp_h'2232| other)
                       (sel var__temp_h2230 other)))
               true)))
(let ((a!2 (=> a!1 (not (> (sel var__temp_h2230 res) 20))))
      (a!4 (=> (not (> (sel var__temp_h2230 res) 20)) a!3)))
  (not (and a!2 a!4)))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************612
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1719, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1719, res ) ==((sel)( , var_h1718, res ) + (5))
 	 , (sel)( , var_h_i1719, other ) ==(sel)( , var_h1718, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2221:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2234 --->  Ty_heap  
 var__temp_v2235 --->  Ty_int  
 var__temp_h'2236 --->  Ty_heap  
 var__temp_v_err2237 --->  error  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2234, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2234, res ) ==((sel)( , var_h1718, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h2234, other ) ==(sel)( , var_h1718, other ) => 
 	 Rel (sel)( , var__temp_h2234, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h2234, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2236, res ) ==(var__temp_v2235) AND 
 	 Rel (sel)( , var__temp_h'2236, res ) ==((sel)( , var__temp_h2234, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'2236, other ) ==(sel)( , var__temp_h2234, other ) => 
 	 True
 
VC_END(declare-const var_h_i1719 T7956)
(declare-const var_h1718 T7956)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2234 T7956)
(declare-const var__temp_v2235 Int)
(declare-const |var__temp_h'2236| T7956)
(declare-const var__temp_v_err2237 T7957)
(declare-const var_h1718 T7956)
(declare-const err T7970)

solver 
 (declare-sort T7956)
(declare-fun sel (T7956 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T7956)
(declare-fun other () Int)
(declare-fun var__temp_h2234 () T7956)
(declare-fun |var__temp_h'2236| () T7956)
(declare-fun var__temp_v2235 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2234 res) v)
                (= (sel var__temp_h2234 res) (+ (sel var_h1718 res) 5))
                (= (sel var__temp_h2234 other) (sel var_h1718 other))))
      (a!2 (and (= (sel |var__temp_h'2236| res) var__temp_v2235)
                (= (sel |var__temp_h'2236| res)
                   (+ (sel var__temp_h2234 res) 10))
                (= (sel |var__temp_h'2236| other) (sel var__temp_h2234 other)))))
(let ((a!3 (and (=> a!1 (> (sel var__temp_h2234 res) 4))
                (=> (> (sel var__temp_h2234 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************613
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1719, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1719, res ) ==((sel)( , var_h1718, res ) + (5))
 	 , (sel)( , var_h_i1719, other ) ==(sel)( , var_h1718, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2221:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2238 --->  Ty_heap  
 var__temp_v2239 --->  Ty_int  
 var__temp_h'2240 --->  Ty_heap  
 var__temp_v_err2241 --->  error  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2238, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2238, res ) ==((sel)( , var_h1718, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h2238, other ) ==(sel)( , var_h1718, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2240, res ) ==(var__temp_v2239) AND 
 	 Base var__temp_v2239 = 5 AND 
 	 Rel (sel)( , var__temp_h'2240, other ) ==(sel)( , var__temp_h2238, other ) => 
 	 True
 
VC_END(declare-const var_h_i1719 T7973)
(declare-const var_h1718 T7973)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2238 T7973)
(declare-const var__temp_v2239 Int)
(declare-const |var__temp_h'2240| T7973)
(declare-const var__temp_v_err2241 T7974)
(declare-const var_h1718 T7973)
(declare-const err T7987)
    (declare-const |5| Int)
  
solver 
 (declare-sort T7973)
(declare-fun sel (T7973 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T7973)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2238 () T7973)
(declare-fun |var__temp_h'2240| () T7973)
(declare-fun var__temp_v2239 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h2238 res) v)
                (= (sel var__temp_h2238 res) (+ (sel var_h1718 res) 5))
                (= (sel var__temp_h2238 other) (sel var_h1718 other))))
      (a!2 (=> (and (= (sel |var__temp_h'2240| res) var__temp_v2239)
                    (= var__temp_v2239 |5|)
                    (= (sel |var__temp_h'2240| other)
                       (sel var__temp_h2238 other)))
               true)))
  (not (and (=> a!1 true) (=> true a!2)))))

***************Selection Successful************foo
PARTIAL PATH NEW
SUB 
 	 --foo
 	 --c4
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2243 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2243 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2243, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2243, other ) ==(sel)( , var_h2242, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2244:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2243 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
bar
 *********************Enumeration Iteration*****************614
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2243 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2243, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2243, other ) ==(sel)( , var_h2242, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2244:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2243 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2245 --->  Ty_heap  
 var__temp_v2246 --->  Ty_int  
 var__temp_h'2247 --->  Ty_heap  
 var__temp_v_err2248 --->  error  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2245, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2245, other ) ==(sel)( , var_h2242, other ) => 
 	 Rel (sel)( , var__temp_h2245, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2245, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2247, res ) ==(var__temp_v2246) AND 
 	 Rel (sel)( , var__temp_h'2247, res ) ==((sel)( , var__temp_h2245, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2247, other ) ==(sel)( , var__temp_h2245, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2247, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2247, other ) > (4)
 
VC_END(declare-const var_h_i2243 T7990)
(declare-const var_h2242 T7990)
(declare-const v Int)
(declare-const var_h_i1719 T7990)
(declare-const var_h1718 T7990)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2245 T7990)
(declare-const var__temp_v2246 Int)
(declare-const |var__temp_h'2247| T7990)
(declare-const var__temp_v_err2248 T7991)
(declare-const var_h2242 T7990)
(declare-const var_h1718 T7990)
(declare-const err T8004)
    (declare-const |5| Int)
  
solver 
 (declare-sort T7990)
(declare-fun sel (T7990 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T7990)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2247| () T7990)
(declare-fun var__temp_h2245 () T7990)
(declare-fun var__temp_v2246 () Int)
(declare-fun var_h2242 () T7990)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2245 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2245 other) (sel var_h2242 other)))
               (= (sel var__temp_h2245 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2247| res) var__temp_v2246)
                (= (sel |var__temp_h'2247| res) (+ (sel var__temp_h2245 res) 3))
                (= (sel |var__temp_h'2247| other) (sel var__temp_h2245 other))))
      (a!3 (and (= (sel |var__temp_h'2247| res) 10)
                (not (> (sel |var__temp_h'2247| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2245 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************615
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2243 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2243, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2243, other ) ==(sel)( , var_h2242, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2244:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2243 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2249 --->  Ty_heap  
 var__temp_v2250 --->  Ty_int  
 var__temp_h'2251 --->  Ty_heap  
 var__temp_v_err2252 --->  error  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2249, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2249, other ) ==(sel)( , var_h2242, other ) => 
 	 Rel (sel)( , var__temp_h2249, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2249, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2251, res ) ==(var__temp_v2250) AND 
 	 Rel (sel)( , var__temp_h'2251, res ) ==((sel)( , var__temp_h2249, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2251, other ) ==(sel)( , var__temp_h2249, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2251, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2251, other ) > (4)
 
VC_END(declare-const var_h_i2243 T8007)
(declare-const var_h2242 T8007)
(declare-const v Int)
(declare-const var_h_i1719 T8007)
(declare-const var_h1718 T8007)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2249 T8007)
(declare-const var__temp_v2250 Int)
(declare-const |var__temp_h'2251| T8007)
(declare-const var__temp_v_err2252 T8008)
(declare-const var_h2242 T8007)
(declare-const var_h1718 T8007)
(declare-const err T8021)
    (declare-const |5| Int)
  
solver 
 (declare-sort T8007)
(declare-fun sel (T8007 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T8007)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2251| () T8007)
(declare-fun var__temp_h2249 () T8007)
(declare-fun var__temp_v2250 () Int)
(declare-fun var_h2242 () T8007)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2249 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2249 other) (sel var_h2242 other)))
               (= (sel var__temp_h2249 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2251| res) var__temp_v2250)
                (= (sel |var__temp_h'2251| res) (+ (sel var__temp_h2249 res) 5))
                (= (sel |var__temp_h'2251| other) (sel var__temp_h2249 other))))
      (a!3 (and (= (sel |var__temp_h'2251| res) 10)
                (not (> (sel |var__temp_h'2251| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2249 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************616
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2243 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2243, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2243, other ) ==(sel)( , var_h2242, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2244:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2243 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2253 --->  Ty_heap  
 var__temp_v2254 --->  Ty_int  
 var__temp_h'2255 --->  Ty_heap  
 var__temp_v_err2256 --->  error  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2253, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2253, other ) ==(sel)( , var_h2242, other ) => 
 	 Rel (sel)( , var__temp_h2253, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h2253, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2255, res ) ==(var__temp_v2254) AND 
 	 Rel (sel)( , var__temp_h2253, res ) ==(sel)( , var__temp_h2253, res ) AND 
 	 Rel (sel)( , var__temp_h'2255, other ) ==(sel)( , var__temp_h2253, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2255, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2255, other ) > (4)
 
VC_END(declare-const var_h_i2243 T8024)
(declare-const var_h2242 T8024)
(declare-const v Int)
(declare-const var_h_i1719 T8024)
(declare-const var_h1718 T8024)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2253 T8024)
(declare-const var__temp_v2254 Int)
(declare-const |var__temp_h'2255| T8024)
(declare-const var__temp_v_err2256 T8025)
(declare-const var_h2242 T8024)
(declare-const var_h1718 T8024)
(declare-const err T8038)
    (declare-const |5| Int)
  
solver 
 (declare-sort T8024)
(declare-fun sel (T8024 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T8024)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2255| () T8024)
(declare-fun var__temp_h2253 () T8024)
(declare-fun var__temp_v2254 () Int)
(declare-fun var_h2242 () T8024)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2253 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2253 other) (sel var_h2242 other)))
               (not (> (sel var__temp_h2253 res) 20))))
      (a!2 (and (= (sel |var__temp_h'2255| res) 10)
                (not (> (sel |var__temp_h'2255| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'2255| res) var__temp_v2254)
                    (= (sel var__temp_h2253 res) (sel var__temp_h2253 res))
                    (= (sel |var__temp_h'2255| other)
                       (sel var__temp_h2253 other)))
               a!2)))
(let ((a!4 (=> (not (> (sel var__temp_h2253 res) 20)) a!3)))
  (not (and a!1 a!4))))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************617
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2243 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2243, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2243, other ) ==(sel)( , var_h2242, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2244:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2243 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2257 --->  Ty_heap  
 var__temp_v2258 --->  Ty_int  
 var__temp_h'2259 --->  Ty_heap  
 var__temp_v_err2260 --->  error  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2257, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2257, other ) ==(sel)( , var_h2242, other ) => 
 	 Rel (sel)( , var__temp_h2257, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h2257, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2259, res ) ==(var__temp_v2258) AND 
 	 Rel (sel)( , var__temp_h'2259, res ) ==((sel)( , var__temp_h2257, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'2259, other ) ==(sel)( , var__temp_h2257, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2259, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2259, other ) > (4)
 
VC_END(declare-const var_h_i2243 T8041)
(declare-const var_h2242 T8041)
(declare-const v Int)
(declare-const var_h_i1719 T8041)
(declare-const var_h1718 T8041)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2257 T8041)
(declare-const var__temp_v2258 Int)
(declare-const |var__temp_h'2259| T8041)
(declare-const var__temp_v_err2260 T8042)
(declare-const var_h2242 T8041)
(declare-const var_h1718 T8041)
(declare-const err T8055)
    (declare-const |5| Int)
  
solver 
 (declare-sort T8041)
(declare-fun sel (T8041 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T8041)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2259| () T8041)
(declare-fun var__temp_h2257 () T8041)
(declare-fun var__temp_v2258 () Int)
(declare-fun var_h2242 () T8041)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2257 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2257 other) (sel var_h2242 other)))
               (> (sel var__temp_h2257 res) 4)))
      (a!2 (and (= (sel |var__temp_h'2259| res) var__temp_v2258)
                (= (sel |var__temp_h'2259| res)
                   (+ (sel var__temp_h2257 res) 10))
                (= (sel |var__temp_h'2259| other) (sel var__temp_h2257 other))))
      (a!3 (and (= (sel |var__temp_h'2259| res) 10)
                (not (> (sel |var__temp_h'2259| other) 4)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h2257 res) 4) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************618
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2243 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2243, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2243, other ) ==(sel)( , var_h2242, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2244:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2243 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2261 --->  Ty_heap  
 var__temp_v2262 --->  Ty_int  
 var__temp_h'2263 --->  Ty_heap  
 var__temp_v_err2264 --->  error  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2261, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2261, other ) ==(sel)( , var_h2242, other ) => 
 	 Rel (sel)( , var__temp_h2261, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2261, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2263, res ) ==(var__temp_v2262) AND 
 	 Rel (sel)( , var__temp_h'2263, res ) ==((sel)( , var__temp_h2261, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2263, other ) ==(sel)( , var__temp_h2261, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2263, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2263, other ) > (4)
 
VC_END(declare-const var_h_i2243 T8058)
(declare-const var_h2242 T8058)
(declare-const v Int)
(declare-const var_h_i1719 T8058)
(declare-const var_h1718 T8058)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2261 T8058)
(declare-const var__temp_v2262 Int)
(declare-const |var__temp_h'2263| T8058)
(declare-const var__temp_v_err2264 T8059)
(declare-const var_h2242 T8058)
(declare-const var_h1718 T8058)
(declare-const err T8072)
    (declare-const |5| Int)
  
solver 
 (declare-sort T8058)
(declare-fun sel (T8058 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T8058)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2263| () T8058)
(declare-fun var__temp_h2261 () T8058)
(declare-fun var__temp_v2262 () Int)
(declare-fun var_h2242 () T8058)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2261 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2261 other) (sel var_h2242 other)))
               (= (sel var__temp_h2261 res) 5)))
      (a!2 (and (= (sel |var__temp_h'2263| res) var__temp_v2262)
                (= (sel |var__temp_h'2263| res) (+ (sel var__temp_h2261 res) 2))
                (= (sel |var__temp_h'2263| other) (sel var__temp_h2261 other))))
      (a!3 (and (= (sel |var__temp_h'2263| res) 10)
                (not (> (sel |var__temp_h'2263| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2261 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************619
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2244:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2244:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfoofoo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --foo
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2243 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2243, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2243, other ) ==(sel)( , var_h2242, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2265:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
bar
 *********************Enumeration Iteration*****************620
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2243 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2243, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2243, other ) ==(sel)( , var_h2242, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2265:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2266 --->  Ty_heap  
 var__temp_v2267 --->  Ty_int  
 var__temp_h'2268 --->  Ty_heap  
 var__temp_v_err2269 --->  error  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2266, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2266, other ) ==(sel)( , var_h2242, other ) => 
 	 Rel (sel)( , var__temp_h2266, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2266, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2268, res ) ==(var__temp_v2267) AND 
 	 Rel (sel)( , var__temp_h'2268, res ) ==((sel)( , var__temp_h2266, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2268, other ) ==(sel)( , var__temp_h2266, other ) => 
 	 True
 
VC_END(declare-const var_h_i2243 T8075)
(declare-const var_h2242 T8075)
(declare-const v Int)
(declare-const var_h_i1719 T8075)
(declare-const var_h1718 T8075)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2266 T8075)
(declare-const var__temp_v2267 Int)
(declare-const |var__temp_h'2268| T8075)
(declare-const var__temp_v_err2269 T8076)
(declare-const var_h2242 T8075)
(declare-const var_h1718 T8075)
(declare-const err T8089)
    (declare-const |5| Int)
  
solver 
 (declare-sort T8075)
(declare-fun sel (T8075 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T8075)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2266 () T8075)
(declare-fun |var__temp_h'2268| () T8075)
(declare-fun var__temp_v2267 () Int)
(declare-fun var_h2242 () T8075)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2266 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2266 other) (sel var_h2242 other)))
               (= (sel var__temp_h2266 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2268| res) var__temp_v2267)
                (= (sel |var__temp_h'2268| res) (+ (sel var__temp_h2266 res) 3))
                (= (sel |var__temp_h'2268| other) (sel var__temp_h2266 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2266 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************621
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2243 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2243, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2243, other ) ==(sel)( , var_h2242, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2265:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2270 --->  Ty_heap  
 var__temp_v2271 --->  Ty_int  
 var__temp_h'2272 --->  Ty_heap  
 var__temp_v_err2273 --->  error  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2270, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2270, other ) ==(sel)( , var_h2242, other ) => 
 	 Rel (sel)( , var__temp_h2270, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2270, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2272, res ) ==(var__temp_v2271) AND 
 	 Rel (sel)( , var__temp_h'2272, res ) ==((sel)( , var__temp_h2270, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2272, other ) ==(sel)( , var__temp_h2270, other ) => 
 	 True
 
VC_END(declare-const var_h_i2243 T8092)
(declare-const var_h2242 T8092)
(declare-const v Int)
(declare-const var_h_i1719 T8092)
(declare-const var_h1718 T8092)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2270 T8092)
(declare-const var__temp_v2271 Int)
(declare-const |var__temp_h'2272| T8092)
(declare-const var__temp_v_err2273 T8093)
(declare-const var_h2242 T8092)
(declare-const var_h1718 T8092)
(declare-const err T8106)
    (declare-const |5| Int)
  
solver 
 (declare-sort T8092)
(declare-fun sel (T8092 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T8092)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2270 () T8092)
(declare-fun |var__temp_h'2272| () T8092)
(declare-fun var__temp_v2271 () Int)
(declare-fun var_h2242 () T8092)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2270 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2270 other) (sel var_h2242 other)))
               (= (sel var__temp_h2270 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2272| res) var__temp_v2271)
                (= (sel |var__temp_h'2272| res) (+ (sel var__temp_h2270 res) 5))
                (= (sel |var__temp_h'2272| other) (sel var__temp_h2270 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2270 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************622
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2243 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2243, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2243, other ) ==(sel)( , var_h2242, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2265:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2274 --->  Ty_heap  
 var__temp_v2275 --->  Ty_int  
 var__temp_h'2276 --->  Ty_heap  
 var__temp_v_err2277 --->  error  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2274, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2274, other ) ==(sel)( , var_h2242, other ) => 
 	 Rel (sel)( , var__temp_h2274, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h2274, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2276, res ) ==(var__temp_v2275) AND 
 	 Rel (sel)( , var__temp_h2274, res ) ==(sel)( , var__temp_h2274, res ) AND 
 	 Rel (sel)( , var__temp_h'2276, other ) ==(sel)( , var__temp_h2274, other ) => 
 	 True
 
VC_END(declare-const var_h_i2243 T8109)
(declare-const var_h2242 T8109)
(declare-const v Int)
(declare-const var_h_i1719 T8109)
(declare-const var_h1718 T8109)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2274 T8109)
(declare-const var__temp_v2275 Int)
(declare-const |var__temp_h'2276| T8109)
(declare-const var__temp_v_err2277 T8110)
(declare-const var_h2242 T8109)
(declare-const var_h1718 T8109)
(declare-const err T8123)
    (declare-const |5| Int)
  
solver 
 (declare-sort T8109)
(declare-fun sel (T8109 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T8109)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2274 () T8109)
(declare-fun |var__temp_h'2276| () T8109)
(declare-fun var__temp_v2275 () Int)
(declare-fun var_h2242 () T8109)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2274 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2274 other) (sel var_h2242 other)))
               (not (> (sel var__temp_h2274 res) 20))))
      (a!2 (=> (and (= (sel |var__temp_h'2276| res) var__temp_v2275)
                    (= (sel var__temp_h2274 res) (sel var__temp_h2274 res))
                    (= (sel |var__temp_h'2276| other)
                       (sel var__temp_h2274 other)))
               true)))
(let ((a!3 (=> (not (> (sel var__temp_h2274 res) 20)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Successful************c2'
PARTIAL PATH NEW
SUB 
 	 --c2'
 	 --foo
 	 --c4
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2279 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2279 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2279, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2278, res ) ==(sel)( , var_h2278, res )
 	 , (sel)( , var_h_i2279, other ) ==(sel)( , var_h2278, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2280:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2279 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
bar
 *********************Enumeration Iteration*****************623
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2279 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2279, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2278, res ) ==(sel)( , var_h2278, res )
 	 , (sel)( , var_h_i2279, other ) ==(sel)( , var_h2278, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2280:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2279 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2279 --->  Ty_heap  
 var_h2278 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2281 --->  Ty_heap  
 var__temp_v2282 --->  Ty_int  
 var__temp_h'2283 --->  Ty_heap  
 var__temp_v_err2284 --->  error  
 var_h2278 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2278, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2281, res ) ==(v) AND 
 	 Rel (sel)( , var_h2278, res ) ==(sel)( , var_h2278, res ) AND 
 	 Rel (sel)( , var__temp_h2281, other ) ==(sel)( , var_h2278, other ) => 
 	 Rel (sel)( , var__temp_h2281, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2281, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2283, res ) ==(var__temp_v2282) AND 
 	 Rel (sel)( , var__temp_h'2283, res ) ==((sel)( , var__temp_h2281, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2283, other ) ==(sel)( , var__temp_h2281, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2283, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2283, other ) > (4)
 
VC_END(declare-const var_h_i2279 T8126)
(declare-const var_h2278 T8126)
(declare-const v Int)
(declare-const var_h_i2243 T8126)
(declare-const var_h2242 T8126)
(declare-const v Int)
(declare-const var_h_i1719 T8126)
(declare-const var_h1718 T8126)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2281 T8126)
(declare-const var__temp_v2282 Int)
(declare-const |var__temp_h'2283| T8126)
(declare-const var__temp_v_err2284 T8127)
(declare-const var_h2278 T8126)
(declare-const var_h2242 T8126)
(declare-const var_h1718 T8126)
(declare-const err T8140)

solver 
 (declare-sort T8126)
(declare-fun sel (T8126 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2278 () T8126)
(declare-fun var_h1718 () T8126)
(declare-fun other () Int)
(declare-fun |var__temp_h'2283| () T8126)
(declare-fun var__temp_h2281 () T8126)
(declare-fun var__temp_v2282 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h2278 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2281 res) v)
                    (= (sel var_h2278 res) (sel var_h2278 res))
                    (= (sel var__temp_h2281 other) (sel var_h2278 other)))
               (= (sel var__temp_h2281 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2283| res) var__temp_v2282)
                (= (sel |var__temp_h'2283| res) (+ (sel var__temp_h2281 res) 3))
                (= (sel |var__temp_h'2283| other) (sel var__temp_h2281 other))))
      (a!3 (and (= (sel |var__temp_h'2283| res) 10)
                (not (> (sel |var__temp_h'2283| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2281 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************624
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2279 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2279, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2278, res ) ==(sel)( , var_h2278, res )
 	 , (sel)( , var_h_i2279, other ) ==(sel)( , var_h2278, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2280:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2279 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2279 --->  Ty_heap  
 var_h2278 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2285 --->  Ty_heap  
 var__temp_v2286 --->  Ty_int  
 var__temp_h'2287 --->  Ty_heap  
 var__temp_v_err2288 --->  error  
 var_h2278 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2278, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2285, res ) ==(v) AND 
 	 Rel (sel)( , var_h2278, res ) ==(sel)( , var_h2278, res ) AND 
 	 Rel (sel)( , var__temp_h2285, other ) ==(sel)( , var_h2278, other ) => 
 	 Rel (sel)( , var__temp_h2285, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2285, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2287, res ) ==(var__temp_v2286) AND 
 	 Rel (sel)( , var__temp_h'2287, res ) ==((sel)( , var__temp_h2285, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2287, other ) ==(sel)( , var__temp_h2285, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2287, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2287, other ) > (4)
 
VC_END(declare-const var_h_i2279 T8143)
(declare-const var_h2278 T8143)
(declare-const v Int)
(declare-const var_h_i2243 T8143)
(declare-const var_h2242 T8143)
(declare-const v Int)
(declare-const var_h_i1719 T8143)
(declare-const var_h1718 T8143)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2285 T8143)
(declare-const var__temp_v2286 Int)
(declare-const |var__temp_h'2287| T8143)
(declare-const var__temp_v_err2288 T8144)
(declare-const var_h2278 T8143)
(declare-const var_h2242 T8143)
(declare-const var_h1718 T8143)
(declare-const err T8157)

solver 
 (declare-sort T8143)
(declare-fun sel (T8143 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2278 () T8143)
(declare-fun var_h1718 () T8143)
(declare-fun other () Int)
(declare-fun |var__temp_h'2287| () T8143)
(declare-fun var__temp_h2285 () T8143)
(declare-fun var__temp_v2286 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h2278 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2285 res) v)
                    (= (sel var_h2278 res) (sel var_h2278 res))
                    (= (sel var__temp_h2285 other) (sel var_h2278 other)))
               (= (sel var__temp_h2285 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2287| res) var__temp_v2286)
                (= (sel |var__temp_h'2287| res) (+ (sel var__temp_h2285 res) 5))
                (= (sel |var__temp_h'2287| other) (sel var__temp_h2285 other))))
      (a!3 (and (= (sel |var__temp_h'2287| res) 10)
                (not (> (sel |var__temp_h'2287| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2285 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************625
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2279 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2279, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2278, res ) ==(sel)( , var_h2278, res )
 	 , (sel)( , var_h_i2279, other ) ==(sel)( , var_h2278, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2280:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2279 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2279 --->  Ty_heap  
 var_h2278 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2289 --->  Ty_heap  
 var__temp_v2290 --->  Ty_int  
 var__temp_h'2291 --->  Ty_heap  
 var__temp_v_err2292 --->  error  
 var_h2278 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2278, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2289, res ) ==(v) AND 
 	 Rel (sel)( , var_h2278, res ) ==(sel)( , var_h2278, res ) AND 
 	 Rel (sel)( , var__temp_h2289, other ) ==(sel)( , var_h2278, other ) => 
 	 Rel (sel)( , var__temp_h2289, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h2289, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2291, res ) ==(var__temp_v2290) AND 
 	 Rel (sel)( , var__temp_h'2291, res ) ==((sel)( , var__temp_h2289, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'2291, other ) ==(sel)( , var__temp_h2289, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2291, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2291, other ) > (4)
 
VC_END(declare-const var_h_i2279 T8160)
(declare-const var_h2278 T8160)
(declare-const v Int)
(declare-const var_h_i2243 T8160)
(declare-const var_h2242 T8160)
(declare-const v Int)
(declare-const var_h_i1719 T8160)
(declare-const var_h1718 T8160)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2289 T8160)
(declare-const var__temp_v2290 Int)
(declare-const |var__temp_h'2291| T8160)
(declare-const var__temp_v_err2292 T8161)
(declare-const var_h2278 T8160)
(declare-const var_h2242 T8160)
(declare-const var_h1718 T8160)
(declare-const err T8174)

solver 
 (declare-sort T8160)
(declare-fun sel (T8160 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2278 () T8160)
(declare-fun var_h1718 () T8160)
(declare-fun other () Int)
(declare-fun |var__temp_h'2291| () T8160)
(declare-fun var__temp_h2289 () T8160)
(declare-fun var__temp_v2290 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h2278 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2289 res) v)
                    (= (sel var_h2278 res) (sel var_h2278 res))
                    (= (sel var__temp_h2289 other) (sel var_h2278 other)))
               (> (sel var__temp_h2289 res) 4)))
      (a!2 (and (= (sel |var__temp_h'2291| res) var__temp_v2290)
                (= (sel |var__temp_h'2291| res)
                   (+ (sel var__temp_h2289 res) 10))
                (= (sel |var__temp_h'2291| other) (sel var__temp_h2289 other))))
      (a!3 (and (= (sel |var__temp_h'2291| res) 10)
                (not (> (sel |var__temp_h'2291| other) 4)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h2289 res) 4) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************626
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2279 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2279, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2278, res ) ==(sel)( , var_h2278, res )
 	 , (sel)( , var_h_i2279, other ) ==(sel)( , var_h2278, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2280:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2279 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2279 --->  Ty_heap  
 var_h2278 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2293 --->  Ty_heap  
 var__temp_v2294 --->  Ty_int  
 var__temp_h'2295 --->  Ty_heap  
 var__temp_v_err2296 --->  error  
 var_h2278 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2278, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2293, res ) ==(v) AND 
 	 Rel (sel)( , var_h2278, res ) ==(sel)( , var_h2278, res ) AND 
 	 Rel (sel)( , var__temp_h2293, other ) ==(sel)( , var_h2278, other ) => 
 	 Rel (sel)( , var__temp_h2293, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2293, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2295, res ) ==(var__temp_v2294) AND 
 	 Rel (sel)( , var__temp_h'2295, res ) ==((sel)( , var__temp_h2293, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2295, other ) ==(sel)( , var__temp_h2293, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2295, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2295, other ) > (4)
 
VC_END(declare-const var_h_i2279 T8177)
(declare-const var_h2278 T8177)
(declare-const v Int)
(declare-const var_h_i2243 T8177)
(declare-const var_h2242 T8177)
(declare-const v Int)
(declare-const var_h_i1719 T8177)
(declare-const var_h1718 T8177)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2293 T8177)
(declare-const var__temp_v2294 Int)
(declare-const |var__temp_h'2295| T8177)
(declare-const var__temp_v_err2296 T8178)
(declare-const var_h2278 T8177)
(declare-const var_h2242 T8177)
(declare-const var_h1718 T8177)
(declare-const err T8191)

solver 
 (declare-sort T8177)
(declare-fun sel (T8177 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2278 () T8177)
(declare-fun var_h1718 () T8177)
(declare-fun other () Int)
(declare-fun |var__temp_h'2295| () T8177)
(declare-fun var__temp_h2293 () T8177)
(declare-fun var__temp_v2294 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h2278 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2293 res) v)
                    (= (sel var_h2278 res) (sel var_h2278 res))
                    (= (sel var__temp_h2293 other) (sel var_h2278 other)))
               (= (sel var__temp_h2293 res) 5)))
      (a!2 (and (= (sel |var__temp_h'2295| res) var__temp_v2294)
                (= (sel |var__temp_h'2295| res) (+ (sel var__temp_h2293 res) 2))
                (= (sel |var__temp_h'2295| other) (sel var__temp_h2293 other))))
      (a!3 (and (= (sel |var__temp_h'2295| res) 10)
                (not (> (sel |var__temp_h'2295| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2293 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************627
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2280:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2280:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2'foofoo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c2'
 	 --foo
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2279 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2279, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2278, res ) ==(sel)( , var_h2278, res )
 	 , (sel)( , var_h_i2279, other ) ==(sel)( , var_h2278, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2297:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
bar
 *********************Enumeration Iteration*****************628
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2279 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2279, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2278, res ) ==(sel)( , var_h2278, res )
 	 , (sel)( , var_h_i2279, other ) ==(sel)( , var_h2278, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2297:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2279 --->  Ty_heap  
 var_h2278 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2298 --->  Ty_heap  
 var__temp_v2299 --->  Ty_int  
 var__temp_h'2300 --->  Ty_heap  
 var__temp_v_err2301 --->  error  
 var_h2278 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2278, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2298, res ) ==(v) AND 
 	 Rel (sel)( , var_h2278, res ) ==(sel)( , var_h2278, res ) AND 
 	 Rel (sel)( , var__temp_h2298, other ) ==(sel)( , var_h2278, other ) => 
 	 Rel (sel)( , var__temp_h2298, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2298, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2300, res ) ==(var__temp_v2299) AND 
 	 Rel (sel)( , var__temp_h'2300, res ) ==((sel)( , var__temp_h2298, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2300, other ) ==(sel)( , var__temp_h2298, other ) => 
 	 True
 
VC_END(declare-const var_h_i2279 T8194)
(declare-const var_h2278 T8194)
(declare-const v Int)
(declare-const var_h_i2243 T8194)
(declare-const var_h2242 T8194)
(declare-const v Int)
(declare-const var_h_i1719 T8194)
(declare-const var_h1718 T8194)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2298 T8194)
(declare-const var__temp_v2299 Int)
(declare-const |var__temp_h'2300| T8194)
(declare-const var__temp_v_err2301 T8195)
(declare-const var_h2278 T8194)
(declare-const var_h2242 T8194)
(declare-const var_h1718 T8194)
(declare-const err T8208)

solver 
 (declare-sort T8194)
(declare-fun sel (T8194 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2278 () T8194)
(declare-fun var_h1718 () T8194)
(declare-fun other () Int)
(declare-fun var__temp_h2298 () T8194)
(declare-fun |var__temp_h'2300| () T8194)
(declare-fun var__temp_v2299 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h2278 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2298 res) v)
                    (= (sel var_h2278 res) (sel var_h2278 res))
                    (= (sel var__temp_h2298 other) (sel var_h2278 other)))
               (= (sel var__temp_h2298 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2300| res) var__temp_v2299)
                (= (sel |var__temp_h'2300| res) (+ (sel var__temp_h2298 res) 3))
                (= (sel |var__temp_h'2300| other) (sel var__temp_h2298 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2298 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************629
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2279 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2279, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2278, res ) ==(sel)( , var_h2278, res )
 	 , (sel)( , var_h_i2279, other ) ==(sel)( , var_h2278, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2297:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2279 --->  Ty_heap  
 var_h2278 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2302 --->  Ty_heap  
 var__temp_v2303 --->  Ty_int  
 var__temp_h'2304 --->  Ty_heap  
 var__temp_v_err2305 --->  error  
 var_h2278 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2278, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2302, res ) ==(v) AND 
 	 Rel (sel)( , var_h2278, res ) ==(sel)( , var_h2278, res ) AND 
 	 Rel (sel)( , var__temp_h2302, other ) ==(sel)( , var_h2278, other ) => 
 	 Rel (sel)( , var__temp_h2302, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2302, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2304, res ) ==(var__temp_v2303) AND 
 	 Rel (sel)( , var__temp_h'2304, res ) ==((sel)( , var__temp_h2302, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2304, other ) ==(sel)( , var__temp_h2302, other ) => 
 	 True
 
VC_END(declare-const var_h_i2279 T8211)
(declare-const var_h2278 T8211)
(declare-const v Int)
(declare-const var_h_i2243 T8211)
(declare-const var_h2242 T8211)
(declare-const v Int)
(declare-const var_h_i1719 T8211)
(declare-const var_h1718 T8211)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2302 T8211)
(declare-const var__temp_v2303 Int)
(declare-const |var__temp_h'2304| T8211)
(declare-const var__temp_v_err2305 T8212)
(declare-const var_h2278 T8211)
(declare-const var_h2242 T8211)
(declare-const var_h1718 T8211)
(declare-const err T8225)

solver 
 (declare-sort T8211)
(declare-fun sel (T8211 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2278 () T8211)
(declare-fun var_h1718 () T8211)
(declare-fun other () Int)
(declare-fun var__temp_h2302 () T8211)
(declare-fun |var__temp_h'2304| () T8211)
(declare-fun var__temp_v2303 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h2278 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2302 res) v)
                    (= (sel var_h2278 res) (sel var_h2278 res))
                    (= (sel var__temp_h2302 other) (sel var_h2278 other)))
               (= (sel var__temp_h2302 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2304| res) var__temp_v2303)
                (= (sel |var__temp_h'2304| res) (+ (sel var__temp_h2302 res) 5))
                (= (sel |var__temp_h'2304| other) (sel var__temp_h2302 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2302 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************630
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2279 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2279, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2278, res ) ==(sel)( , var_h2278, res )
 	 , (sel)( , var_h_i2279, other ) ==(sel)( , var_h2278, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2297:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2279 --->  Ty_heap  
 var_h2278 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2306 --->  Ty_heap  
 var__temp_v2307 --->  Ty_int  
 var__temp_h'2308 --->  Ty_heap  
 var__temp_v_err2309 --->  error  
 var_h2278 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2278, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2306, res ) ==(v) AND 
 	 Rel (sel)( , var_h2278, res ) ==(sel)( , var_h2278, res ) AND 
 	 Rel (sel)( , var__temp_h2306, other ) ==(sel)( , var_h2278, other ) => 
 	 Rel (sel)( , var__temp_h2306, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h2306, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2308, res ) ==(var__temp_v2307) AND 
 	 Rel (sel)( , var__temp_h'2308, res ) ==((sel)( , var__temp_h2306, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'2308, other ) ==(sel)( , var__temp_h2306, other ) => 
 	 True
 
VC_END(declare-const var_h_i2279 T8228)
(declare-const var_h2278 T8228)
(declare-const v Int)
(declare-const var_h_i2243 T8228)
(declare-const var_h2242 T8228)
(declare-const v Int)
(declare-const var_h_i1719 T8228)
(declare-const var_h1718 T8228)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2306 T8228)
(declare-const var__temp_v2307 Int)
(declare-const |var__temp_h'2308| T8228)
(declare-const var__temp_v_err2309 T8229)
(declare-const var_h2278 T8228)
(declare-const var_h2242 T8228)
(declare-const var_h1718 T8228)
(declare-const err T8242)

solver 
 (declare-sort T8228)
(declare-fun sel (T8228 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2278 () T8228)
(declare-fun var_h1718 () T8228)
(declare-fun other () Int)
(declare-fun var__temp_h2306 () T8228)
(declare-fun |var__temp_h'2308| () T8228)
(declare-fun var__temp_v2307 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h2278 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2306 res) v)
                    (= (sel var_h2278 res) (sel var_h2278 res))
                    (= (sel var__temp_h2306 other) (sel var_h2278 other)))
               (> (sel var__temp_h2306 res) 4)))
      (a!2 (and (= (sel |var__temp_h'2308| res) var__temp_v2307)
                (= (sel |var__temp_h'2308| res)
                   (+ (sel var__temp_h2306 res) 10))
                (= (sel |var__temp_h'2308| other) (sel var__temp_h2306 other)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h2306 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************631
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2279 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2279, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2278, res ) ==(sel)( , var_h2278, res )
 	 , (sel)( , var_h_i2279, other ) ==(sel)( , var_h2278, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2297:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2279 --->  Ty_heap  
 var_h2278 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2310 --->  Ty_heap  
 var__temp_v2311 --->  Ty_int  
 var__temp_h'2312 --->  Ty_heap  
 var__temp_v_err2313 --->  error  
 var_h2278 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2278, res ) > (20) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2310, res ) ==(v) AND 
 	 Rel (sel)( , var_h2278, res ) ==(sel)( , var_h2278, res ) AND 
 	 Rel (sel)( , var__temp_h2310, other ) ==(sel)( , var_h2278, other ) => 
 	 Rel (sel)( , var__temp_h2310, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2310, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2312, res ) ==(var__temp_v2311) AND 
 	 Rel (sel)( , var__temp_h'2312, res ) ==((sel)( , var__temp_h2310, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2312, other ) ==(sel)( , var__temp_h2310, other ) => 
 	 True
 
VC_END(declare-const var_h_i2279 T8245)
(declare-const var_h2278 T8245)
(declare-const v Int)
(declare-const var_h_i2243 T8245)
(declare-const var_h2242 T8245)
(declare-const v Int)
(declare-const var_h_i1719 T8245)
(declare-const var_h1718 T8245)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2310 T8245)
(declare-const var__temp_v2311 Int)
(declare-const |var__temp_h'2312| T8245)
(declare-const var__temp_v_err2313 T8246)
(declare-const var_h2278 T8245)
(declare-const var_h2242 T8245)
(declare-const var_h1718 T8245)
(declare-const err T8259)

solver 
 (declare-sort T8245)
(declare-fun sel (T8245 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2278 () T8245)
(declare-fun var_h1718 () T8245)
(declare-fun other () Int)
(declare-fun var__temp_h2310 () T8245)
(declare-fun |var__temp_h'2312| () T8245)
(declare-fun var__temp_v2311 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h2278 res) 20)))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2310 res) v)
                    (= (sel var_h2278 res) (sel var_h2278 res))
                    (= (sel var__temp_h2310 other) (sel var_h2278 other)))
               (= (sel var__temp_h2310 res) 5)))
      (a!2 (and (= (sel |var__temp_h'2312| res) var__temp_v2311)
                (= (sel |var__temp_h'2312| res) (+ (sel var__temp_h2310 res) 2))
                (= (sel |var__temp_h'2312| other) (sel var__temp_h2310 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2310 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************632
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2'
PARTIAL PATH
SUB 
 	 --foo
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2243 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2243, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2243, other ) ==(sel)( , var_h2242, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2314:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
bar
 *********************Enumeration Iteration*****************633
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2243 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2243, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2243, other ) ==(sel)( , var_h2242, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2314:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2315 --->  Ty_heap  
 var__temp_v2316 --->  Ty_int  
 var__temp_h'2317 --->  Ty_heap  
 var__temp_v_err2318 --->  error  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2315, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2315, other ) ==(sel)( , var_h2242, other ) => 
 	 Rel (sel)( , var__temp_h2315, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2315, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2317, res ) ==(var__temp_v2316) AND 
 	 Rel (sel)( , var__temp_h'2317, res ) ==((sel)( , var__temp_h2315, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2317, other ) ==(sel)( , var__temp_h2315, other ) => 
 	 True
 
VC_END(declare-const var_h_i2243 T8262)
(declare-const var_h2242 T8262)
(declare-const v Int)
(declare-const var_h_i1719 T8262)
(declare-const var_h1718 T8262)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2315 T8262)
(declare-const var__temp_v2316 Int)
(declare-const |var__temp_h'2317| T8262)
(declare-const var__temp_v_err2318 T8263)
(declare-const var_h2242 T8262)
(declare-const var_h1718 T8262)
(declare-const err T8276)
    (declare-const |5| Int)
  
solver 
 (declare-sort T8262)
(declare-fun sel (T8262 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T8262)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2315 () T8262)
(declare-fun |var__temp_h'2317| () T8262)
(declare-fun var__temp_v2316 () Int)
(declare-fun var_h2242 () T8262)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2315 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2315 other) (sel var_h2242 other)))
               (= (sel var__temp_h2315 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2317| res) var__temp_v2316)
                (= (sel |var__temp_h'2317| res) (+ (sel var__temp_h2315 res) 3))
                (= (sel |var__temp_h'2317| other) (sel var__temp_h2315 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2315 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************634
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2243 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2243, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2243, other ) ==(sel)( , var_h2242, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2314:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2319 --->  Ty_heap  
 var__temp_v2320 --->  Ty_int  
 var__temp_h'2321 --->  Ty_heap  
 var__temp_v_err2322 --->  error  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2319, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2319, other ) ==(sel)( , var_h2242, other ) => 
 	 Rel (sel)( , var__temp_h2319, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2319, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2321, res ) ==(var__temp_v2320) AND 
 	 Rel (sel)( , var__temp_h'2321, res ) ==((sel)( , var__temp_h2319, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2321, other ) ==(sel)( , var__temp_h2319, other ) => 
 	 True
 
VC_END(declare-const var_h_i2243 T8279)
(declare-const var_h2242 T8279)
(declare-const v Int)
(declare-const var_h_i1719 T8279)
(declare-const var_h1718 T8279)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2319 T8279)
(declare-const var__temp_v2320 Int)
(declare-const |var__temp_h'2321| T8279)
(declare-const var__temp_v_err2322 T8280)
(declare-const var_h2242 T8279)
(declare-const var_h1718 T8279)
(declare-const err T8293)
    (declare-const |5| Int)
  
solver 
 (declare-sort T8279)
(declare-fun sel (T8279 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T8279)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2319 () T8279)
(declare-fun |var__temp_h'2321| () T8279)
(declare-fun var__temp_v2320 () Int)
(declare-fun var_h2242 () T8279)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2319 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2319 other) (sel var_h2242 other)))
               (= (sel var__temp_h2319 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2321| res) var__temp_v2320)
                (= (sel |var__temp_h'2321| res) (+ (sel var__temp_h2319 res) 5))
                (= (sel |var__temp_h'2321| other) (sel var__temp_h2319 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2319 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************635
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2243 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2243, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2243, other ) ==(sel)( , var_h2242, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2314:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2323 --->  Ty_heap  
 var__temp_v2324 --->  Ty_int  
 var__temp_h'2325 --->  Ty_heap  
 var__temp_v_err2326 --->  error  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2323, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2323, other ) ==(sel)( , var_h2242, other ) => 
 	 Rel (sel)( , var__temp_h2323, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h2323, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2325, res ) ==(var__temp_v2324) AND 
 	 Rel (sel)( , var__temp_h'2325, res ) ==((sel)( , var__temp_h2323, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'2325, other ) ==(sel)( , var__temp_h2323, other ) => 
 	 True
 
VC_END(declare-const var_h_i2243 T8296)
(declare-const var_h2242 T8296)
(declare-const v Int)
(declare-const var_h_i1719 T8296)
(declare-const var_h1718 T8296)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2323 T8296)
(declare-const var__temp_v2324 Int)
(declare-const |var__temp_h'2325| T8296)
(declare-const var__temp_v_err2326 T8297)
(declare-const var_h2242 T8296)
(declare-const var_h1718 T8296)
(declare-const err T8310)
    (declare-const |5| Int)
  
solver 
 (declare-sort T8296)
(declare-fun sel (T8296 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T8296)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2323 () T8296)
(declare-fun |var__temp_h'2325| () T8296)
(declare-fun var__temp_v2324 () Int)
(declare-fun var_h2242 () T8296)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2323 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2323 other) (sel var_h2242 other)))
               (> (sel var__temp_h2323 res) 4)))
      (a!2 (and (= (sel |var__temp_h'2325| res) var__temp_v2324)
                (= (sel |var__temp_h'2325| res)
                   (+ (sel var__temp_h2323 res) 10))
                (= (sel |var__temp_h'2325| other) (sel var__temp_h2323 other)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h2323 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c2
PARTIAL PATH NEW
SUB 
 	 --c2
 	 --foo
 	 --c4
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2328 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2328 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2328, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2328, res ) ==((sel)( , var_h2327, res ) + (10))
 	 , (sel)( , var_h_i2328, other ) ==(sel)( , var_h2327, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2329:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2328 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************636
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2328 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2328, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2328, res ) ==((sel)( , var_h2327, res ) + (10))
 	 , (sel)( , var_h_i2328, other ) ==(sel)( , var_h2327, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2329:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2328 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2328 --->  Ty_heap  
 var_h2327 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2330 --->  Ty_heap  
 var__temp_v2331 --->  Ty_int  
 var__temp_h'2332 --->  Ty_heap  
 var__temp_v_err2333 --->  error  
 var_h2327 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2327, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2330, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2330, res ) ==((sel)( , var_h2327, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2330, other ) ==(sel)( , var_h2327, other ) => 
 	 Rel (sel)( , var__temp_h2330, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2330, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2332, res ) ==(var__temp_v2331) AND 
 	 Rel (sel)( , var__temp_h'2332, res ) ==((sel)( , var__temp_h2330, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2332, other ) ==(sel)( , var__temp_h2330, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2332, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2332, other ) > (4)
 
VC_END(declare-const var_h_i2328 T8313)
(declare-const var_h2327 T8313)
(declare-const v Int)
(declare-const var_h_i2243 T8313)
(declare-const var_h2242 T8313)
(declare-const v Int)
(declare-const var_h_i1719 T8313)
(declare-const var_h1718 T8313)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2330 T8313)
(declare-const var__temp_v2331 Int)
(declare-const |var__temp_h'2332| T8313)
(declare-const var__temp_v_err2333 T8314)
(declare-const var_h2327 T8313)
(declare-const var_h2242 T8313)
(declare-const var_h1718 T8313)
(declare-const err T8327)

solver 
 (declare-sort T8313)
(declare-fun sel (T8313 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2327 () T8313)
(declare-fun var_h1718 () T8313)
(declare-fun other () Int)
(declare-fun |var__temp_h'2332| () T8313)
(declare-fun var__temp_h2330 () T8313)
(declare-fun var__temp_v2331 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2327 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2330 res) v)
                (= (sel var__temp_h2330 res) (+ (sel var_h2327 res) 10))
                (= (sel var__temp_h2330 other) (sel var_h2327 other))))
      (a!2 (and (= (sel |var__temp_h'2332| res) var__temp_v2331)
                (= (sel |var__temp_h'2332| res) (+ (sel var__temp_h2330 res) 3))
                (= (sel |var__temp_h'2332| other) (sel var__temp_h2330 other))))
      (a!3 (and (= (sel |var__temp_h'2332| res) 10)
                (not (> (sel |var__temp_h'2332| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2330 res) 7))
                (=> (= (sel var__temp_h2330 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************637
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2328 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2328, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2328, res ) ==((sel)( , var_h2327, res ) + (10))
 	 , (sel)( , var_h_i2328, other ) ==(sel)( , var_h2327, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2329:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2328 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2328 --->  Ty_heap  
 var_h2327 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2334 --->  Ty_heap  
 var__temp_v2335 --->  Ty_int  
 var__temp_h'2336 --->  Ty_heap  
 var__temp_v_err2337 --->  error  
 var_h2327 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2327, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2334, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2334, res ) ==((sel)( , var_h2327, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2334, other ) ==(sel)( , var_h2327, other ) => 
 	 Rel (sel)( , var__temp_h2334, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2334, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2336, res ) ==(var__temp_v2335) AND 
 	 Rel (sel)( , var__temp_h'2336, res ) ==((sel)( , var__temp_h2334, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2336, other ) ==(sel)( , var__temp_h2334, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2336, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2336, other ) > (4)
 
VC_END(declare-const var_h_i2328 T8330)
(declare-const var_h2327 T8330)
(declare-const v Int)
(declare-const var_h_i2243 T8330)
(declare-const var_h2242 T8330)
(declare-const v Int)
(declare-const var_h_i1719 T8330)
(declare-const var_h1718 T8330)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2334 T8330)
(declare-const var__temp_v2335 Int)
(declare-const |var__temp_h'2336| T8330)
(declare-const var__temp_v_err2337 T8331)
(declare-const var_h2327 T8330)
(declare-const var_h2242 T8330)
(declare-const var_h1718 T8330)
(declare-const err T8344)

solver 
 (declare-sort T8330)
(declare-fun sel (T8330 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2327 () T8330)
(declare-fun var_h1718 () T8330)
(declare-fun other () Int)
(declare-fun |var__temp_h'2336| () T8330)
(declare-fun var__temp_h2334 () T8330)
(declare-fun var__temp_v2335 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2327 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2334 res) v)
                (= (sel var__temp_h2334 res) (+ (sel var_h2327 res) 10))
                (= (sel var__temp_h2334 other) (sel var_h2327 other))))
      (a!2 (and (= (sel |var__temp_h'2336| res) var__temp_v2335)
                (= (sel |var__temp_h'2336| res) (+ (sel var__temp_h2334 res) 5))
                (= (sel |var__temp_h'2336| other) (sel var__temp_h2334 other))))
      (a!3 (and (= (sel |var__temp_h'2336| res) 10)
                (not (> (sel |var__temp_h'2336| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2334 res) 7))
                (=> (= (sel var__temp_h2334 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************638
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2328 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2328, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2328, res ) ==((sel)( , var_h2327, res ) + (10))
 	 , (sel)( , var_h_i2328, other ) ==(sel)( , var_h2327, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2329:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2328 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2328 --->  Ty_heap  
 var_h2327 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2338 --->  Ty_heap  
 var__temp_v2339 --->  Ty_int  
 var__temp_h'2340 --->  Ty_heap  
 var__temp_v_err2341 --->  error  
 var_h2327 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2327, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2338, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2338, res ) ==((sel)( , var_h2327, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2338, other ) ==(sel)( , var_h2327, other ) => 
 	 Rel (sel)( , var__temp_h2338, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2338, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2340, res ) ==(var__temp_v2339) AND 
 	 Rel (sel)( , var__temp_h'2340, res ) ==((sel)( , var__temp_h2338, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2340, other ) ==(sel)( , var__temp_h2338, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2340, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2340, other ) > (4)
 
VC_END(declare-const var_h_i2328 T8347)
(declare-const var_h2327 T8347)
(declare-const v Int)
(declare-const var_h_i2243 T8347)
(declare-const var_h2242 T8347)
(declare-const v Int)
(declare-const var_h_i1719 T8347)
(declare-const var_h1718 T8347)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2338 T8347)
(declare-const var__temp_v2339 Int)
(declare-const |var__temp_h'2340| T8347)
(declare-const var__temp_v_err2341 T8348)
(declare-const var_h2327 T8347)
(declare-const var_h2242 T8347)
(declare-const var_h1718 T8347)
(declare-const err T8361)

solver 
 (declare-sort T8347)
(declare-fun sel (T8347 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2327 () T8347)
(declare-fun var_h1718 () T8347)
(declare-fun other () Int)
(declare-fun |var__temp_h'2340| () T8347)
(declare-fun var__temp_h2338 () T8347)
(declare-fun var__temp_v2339 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2327 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2338 res) v)
                (= (sel var__temp_h2338 res) (+ (sel var_h2327 res) 10))
                (= (sel var__temp_h2338 other) (sel var_h2327 other))))
      (a!2 (and (= (sel |var__temp_h'2340| res) var__temp_v2339)
                (= (sel |var__temp_h'2340| res) (+ (sel var__temp_h2338 res) 2))
                (= (sel |var__temp_h'2340| other) (sel var__temp_h2338 other))))
      (a!3 (and (= (sel |var__temp_h'2340| res) 10)
                (not (> (sel |var__temp_h'2340| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2338 res) 5))
                (=> (= (sel var__temp_h2338 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************639
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2329:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2329:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2c2'foofoo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c2
 	 --foo
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2328 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2328, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2328, res ) ==((sel)( , var_h2327, res ) + (10))
 	 , (sel)( , var_h_i2328, other ) ==(sel)( , var_h2327, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2342:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************640
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2328 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2328, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2328, res ) ==((sel)( , var_h2327, res ) + (10))
 	 , (sel)( , var_h_i2328, other ) ==(sel)( , var_h2327, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2342:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2328 --->  Ty_heap  
 var_h2327 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2343 --->  Ty_heap  
 var__temp_v2344 --->  Ty_int  
 var__temp_h'2345 --->  Ty_heap  
 var__temp_v_err2346 --->  error  
 var_h2327 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2327, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2343, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2343, res ) ==((sel)( , var_h2327, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2343, other ) ==(sel)( , var_h2327, other ) => 
 	 Rel (sel)( , var__temp_h2343, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2343, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2345, res ) ==(var__temp_v2344) AND 
 	 Rel (sel)( , var__temp_h'2345, res ) ==((sel)( , var__temp_h2343, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2345, other ) ==(sel)( , var__temp_h2343, other ) => 
 	 True
 
VC_END(declare-const var_h_i2328 T8364)
(declare-const var_h2327 T8364)
(declare-const v Int)
(declare-const var_h_i2243 T8364)
(declare-const var_h2242 T8364)
(declare-const v Int)
(declare-const var_h_i1719 T8364)
(declare-const var_h1718 T8364)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2343 T8364)
(declare-const var__temp_v2344 Int)
(declare-const |var__temp_h'2345| T8364)
(declare-const var__temp_v_err2346 T8365)
(declare-const var_h2327 T8364)
(declare-const var_h2242 T8364)
(declare-const var_h1718 T8364)
(declare-const err T8378)

solver 
 (declare-sort T8364)
(declare-fun sel (T8364 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2327 () T8364)
(declare-fun var_h1718 () T8364)
(declare-fun other () Int)
(declare-fun var__temp_h2343 () T8364)
(declare-fun |var__temp_h'2345| () T8364)
(declare-fun var__temp_v2344 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2327 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2343 res) v)
                (= (sel var__temp_h2343 res) (+ (sel var_h2327 res) 10))
                (= (sel var__temp_h2343 other) (sel var_h2327 other))))
      (a!2 (and (= (sel |var__temp_h'2345| res) var__temp_v2344)
                (= (sel |var__temp_h'2345| res) (+ (sel var__temp_h2343 res) 3))
                (= (sel |var__temp_h'2345| other) (sel var__temp_h2343 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2343 res) 7))
                (=> (= (sel var__temp_h2343 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************641
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2328 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2328, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2328, res ) ==((sel)( , var_h2327, res ) + (10))
 	 , (sel)( , var_h_i2328, other ) ==(sel)( , var_h2327, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2342:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2328 --->  Ty_heap  
 var_h2327 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2347 --->  Ty_heap  
 var__temp_v2348 --->  Ty_int  
 var__temp_h'2349 --->  Ty_heap  
 var__temp_v_err2350 --->  error  
 var_h2327 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2327, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2347, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2347, res ) ==((sel)( , var_h2327, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2347, other ) ==(sel)( , var_h2327, other ) => 
 	 Rel (sel)( , var__temp_h2347, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2347, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2349, res ) ==(var__temp_v2348) AND 
 	 Rel (sel)( , var__temp_h'2349, res ) ==((sel)( , var__temp_h2347, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2349, other ) ==(sel)( , var__temp_h2347, other ) => 
 	 True
 
VC_END(declare-const var_h_i2328 T8381)
(declare-const var_h2327 T8381)
(declare-const v Int)
(declare-const var_h_i2243 T8381)
(declare-const var_h2242 T8381)
(declare-const v Int)
(declare-const var_h_i1719 T8381)
(declare-const var_h1718 T8381)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2347 T8381)
(declare-const var__temp_v2348 Int)
(declare-const |var__temp_h'2349| T8381)
(declare-const var__temp_v_err2350 T8382)
(declare-const var_h2327 T8381)
(declare-const var_h2242 T8381)
(declare-const var_h1718 T8381)
(declare-const err T8395)

solver 
 (declare-sort T8381)
(declare-fun sel (T8381 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2327 () T8381)
(declare-fun var_h1718 () T8381)
(declare-fun other () Int)
(declare-fun var__temp_h2347 () T8381)
(declare-fun |var__temp_h'2349| () T8381)
(declare-fun var__temp_v2348 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2327 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2347 res) v)
                (= (sel var__temp_h2347 res) (+ (sel var_h2327 res) 10))
                (= (sel var__temp_h2347 other) (sel var_h2327 other))))
      (a!2 (and (= (sel |var__temp_h'2349| res) var__temp_v2348)
                (= (sel |var__temp_h'2349| res) (+ (sel var__temp_h2347 res) 5))
                (= (sel |var__temp_h'2349| other) (sel var__temp_h2347 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2347 res) 7))
                (=> (= (sel var__temp_h2347 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************642
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2328 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2328, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2328, res ) ==((sel)( , var_h2327, res ) + (10))
 	 , (sel)( , var_h_i2328, other ) ==(sel)( , var_h2327, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2342:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2328 --->  Ty_heap  
 var_h2327 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2351 --->  Ty_heap  
 var__temp_v2352 --->  Ty_int  
 var__temp_h'2353 --->  Ty_heap  
 var__temp_v_err2354 --->  error  
 var_h2327 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2327, res ) > (4) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2351, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2351, res ) ==((sel)( , var_h2327, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2351, other ) ==(sel)( , var_h2327, other ) => 
 	 Rel (sel)( , var__temp_h2351, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2351, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2353, res ) ==(var__temp_v2352) AND 
 	 Rel (sel)( , var__temp_h'2353, res ) ==((sel)( , var__temp_h2351, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2353, other ) ==(sel)( , var__temp_h2351, other ) => 
 	 True
 
VC_END(declare-const var_h_i2328 T8398)
(declare-const var_h2327 T8398)
(declare-const v Int)
(declare-const var_h_i2243 T8398)
(declare-const var_h2242 T8398)
(declare-const v Int)
(declare-const var_h_i1719 T8398)
(declare-const var_h1718 T8398)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2351 T8398)
(declare-const var__temp_v2352 Int)
(declare-const |var__temp_h'2353| T8398)
(declare-const var__temp_v_err2354 T8399)
(declare-const var_h2327 T8398)
(declare-const var_h2242 T8398)
(declare-const var_h1718 T8398)
(declare-const err T8412)

solver 
 (declare-sort T8398)
(declare-fun sel (T8398 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2327 () T8398)
(declare-fun var_h1718 () T8398)
(declare-fun other () Int)
(declare-fun var__temp_h2351 () T8398)
(declare-fun |var__temp_h'2353| () T8398)
(declare-fun var__temp_v2352 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2327 res) 4))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2351 res) v)
                (= (sel var__temp_h2351 res) (+ (sel var_h2327 res) 10))
                (= (sel var__temp_h2351 other) (sel var_h2327 other))))
      (a!2 (and (= (sel |var__temp_h'2353| res) var__temp_v2352)
                (= (sel |var__temp_h'2353| res) (+ (sel var__temp_h2351 res) 2))
                (= (sel |var__temp_h'2353| other) (sel var__temp_h2351 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2351 res) 5))
                (=> (= (sel var__temp_h2351 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************643
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 
 	 --foo
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2243 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2243, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2243, other ) ==(sel)( , var_h2242, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2355:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************644
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2243 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2243, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2243, other ) ==(sel)( , var_h2242, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2355:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2356 --->  Ty_heap  
 var__temp_v2357 --->  Ty_int  
 var__temp_h'2358 --->  Ty_heap  
 var__temp_v_err2359 --->  error  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2356, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2356, other ) ==(sel)( , var_h2242, other ) => 
 	 Rel (sel)( , var__temp_h2356, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2356, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2358, res ) ==(var__temp_v2357) AND 
 	 Rel (sel)( , var__temp_h'2358, res ) ==((sel)( , var__temp_h2356, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2358, other ) ==(sel)( , var__temp_h2356, other ) => 
 	 True
 
VC_END(declare-const var_h_i2243 T8415)
(declare-const var_h2242 T8415)
(declare-const v Int)
(declare-const var_h_i1719 T8415)
(declare-const var_h1718 T8415)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2356 T8415)
(declare-const var__temp_v2357 Int)
(declare-const |var__temp_h'2358| T8415)
(declare-const var__temp_v_err2359 T8416)
(declare-const var_h2242 T8415)
(declare-const var_h1718 T8415)
(declare-const err T8429)
    (declare-const |5| Int)
  
solver 
 (declare-sort T8415)
(declare-fun sel (T8415 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T8415)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2356 () T8415)
(declare-fun |var__temp_h'2358| () T8415)
(declare-fun var__temp_v2357 () Int)
(declare-fun var_h2242 () T8415)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2356 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2356 other) (sel var_h2242 other)))
               (= (sel var__temp_h2356 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2358| res) var__temp_v2357)
                (= (sel |var__temp_h'2358| res) (+ (sel var__temp_h2356 res) 3))
                (= (sel |var__temp_h'2358| other) (sel var__temp_h2356 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2356 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************645
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2243 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2243, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2243, other ) ==(sel)( , var_h2242, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2355:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2360 --->  Ty_heap  
 var__temp_v2361 --->  Ty_int  
 var__temp_h'2362 --->  Ty_heap  
 var__temp_v_err2363 --->  error  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2360, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2360, other ) ==(sel)( , var_h2242, other ) => 
 	 Rel (sel)( , var__temp_h2360, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2360, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2362, res ) ==(var__temp_v2361) AND 
 	 Rel (sel)( , var__temp_h'2362, res ) ==((sel)( , var__temp_h2360, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2362, other ) ==(sel)( , var__temp_h2360, other ) => 
 	 True
 
VC_END(declare-const var_h_i2243 T8432)
(declare-const var_h2242 T8432)
(declare-const v Int)
(declare-const var_h_i1719 T8432)
(declare-const var_h1718 T8432)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2360 T8432)
(declare-const var__temp_v2361 Int)
(declare-const |var__temp_h'2362| T8432)
(declare-const var__temp_v_err2363 T8433)
(declare-const var_h2242 T8432)
(declare-const var_h1718 T8432)
(declare-const err T8446)
    (declare-const |5| Int)
  
solver 
 (declare-sort T8432)
(declare-fun sel (T8432 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T8432)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2360 () T8432)
(declare-fun |var__temp_h'2362| () T8432)
(declare-fun var__temp_v2361 () Int)
(declare-fun var_h2242 () T8432)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2360 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2360 other) (sel var_h2242 other)))
               (= (sel var__temp_h2360 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2362| res) var__temp_v2361)
                (= (sel |var__temp_h'2362| res) (+ (sel var__temp_h2360 res) 5))
                (= (sel |var__temp_h'2362| other) (sel var__temp_h2360 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2360 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************646
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2243 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2243, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2243, other ) ==(sel)( , var_h2242, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2355:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2364 --->  Ty_heap  
 var__temp_v2365 --->  Ty_int  
 var__temp_h'2366 --->  Ty_heap  
 var__temp_v_err2367 --->  error  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2364, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2364, other ) ==(sel)( , var_h2242, other ) => 
 	 Rel (sel)( , var__temp_h2364, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2364, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2366, res ) ==(var__temp_v2365) AND 
 	 Rel (sel)( , var__temp_h'2366, res ) ==((sel)( , var__temp_h2364, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2366, other ) ==(sel)( , var__temp_h2364, other ) => 
 	 True
 
VC_END(declare-const var_h_i2243 T8449)
(declare-const var_h2242 T8449)
(declare-const v Int)
(declare-const var_h_i1719 T8449)
(declare-const var_h1718 T8449)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2364 T8449)
(declare-const var__temp_v2365 Int)
(declare-const |var__temp_h'2366| T8449)
(declare-const var__temp_v_err2367 T8450)
(declare-const var_h2242 T8449)
(declare-const var_h1718 T8449)
(declare-const err T8463)
    (declare-const |5| Int)
  
solver 
 (declare-sort T8449)
(declare-fun sel (T8449 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T8449)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2364 () T8449)
(declare-fun |var__temp_h'2366| () T8449)
(declare-fun var__temp_v2365 () Int)
(declare-fun var_h2242 () T8449)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2364 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2364 other) (sel var_h2242 other)))
               (= (sel var__temp_h2364 res) 5)))
      (a!2 (and (= (sel |var__temp_h'2366| res) var__temp_v2365)
                (= (sel |var__temp_h'2366| res) (+ (sel var__temp_h2364 res) 2))
                (= (sel |var__temp_h'2366| other) (sel var__temp_h2364 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2364 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************bar
PARTIAL PATH NEW
SUB 
 	 --bar
 	 --foo
 	 --c4
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2369 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2369 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2369, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2369, res ) ==((sel)( , var_h2368, res ) + (2))
 	 , (sel)( , var_h_i2369, other ) ==(sel)( , var_h2368, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2370:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2369 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************647
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2369 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2369, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2369, res ) ==((sel)( , var_h2368, res ) + (2))
 	 , (sel)( , var_h_i2369, other ) ==(sel)( , var_h2368, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2370:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2369 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2369 --->  Ty_heap  
 var_h2368 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2371 --->  Ty_heap  
 var__temp_v2372 --->  Ty_int  
 var__temp_h'2373 --->  Ty_heap  
 var__temp_v_err2374 --->  error  
 var_h2368 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2368, res ) ==(5) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2371, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2371, res ) ==((sel)( , var_h2368, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h2371, other ) ==(sel)( , var_h2368, other ) => 
 	 Rel (sel)( , var__temp_h2371, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2371, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2373, res ) ==(var__temp_v2372) AND 
 	 Rel (sel)( , var__temp_h'2373, res ) ==((sel)( , var__temp_h2371, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2373, other ) ==(sel)( , var__temp_h2371, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2373, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2373, other ) > (4)
 
VC_END(declare-const var_h_i2369 T8466)
(declare-const var_h2368 T8466)
(declare-const v Int)
(declare-const var_h_i2243 T8466)
(declare-const var_h2242 T8466)
(declare-const v Int)
(declare-const var_h_i1719 T8466)
(declare-const var_h1718 T8466)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2371 T8466)
(declare-const var__temp_v2372 Int)
(declare-const |var__temp_h'2373| T8466)
(declare-const var__temp_v_err2374 T8467)
(declare-const var_h2368 T8466)
(declare-const var_h2242 T8466)
(declare-const var_h1718 T8466)
(declare-const err T8480)

solver 
 (declare-sort T8466)
(declare-fun sel (T8466 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2368 () T8466)
(declare-fun var_h1718 () T8466)
(declare-fun other () Int)
(declare-fun |var__temp_h'2373| () T8466)
(declare-fun var__temp_h2371 () T8466)
(declare-fun var__temp_v2372 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2368 res) 5))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2371 res) v)
                (= (sel var__temp_h2371 res) (+ (sel var_h2368 res) 2))
                (= (sel var__temp_h2371 other) (sel var_h2368 other))))
      (a!2 (and (= (sel |var__temp_h'2373| res) var__temp_v2372)
                (= (sel |var__temp_h'2373| res) (+ (sel var__temp_h2371 res) 3))
                (= (sel |var__temp_h'2373| other) (sel var__temp_h2371 other))))
      (a!3 (and (= (sel |var__temp_h'2373| res) 10)
                (not (> (sel |var__temp_h'2373| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2371 res) 7))
                (=> (= (sel var__temp_h2371 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************648
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2369 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2369, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2369, res ) ==((sel)( , var_h2368, res ) + (2))
 	 , (sel)( , var_h_i2369, other ) ==(sel)( , var_h2368, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2370:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2369 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2369 --->  Ty_heap  
 var_h2368 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2375 --->  Ty_heap  
 var__temp_v2376 --->  Ty_int  
 var__temp_h'2377 --->  Ty_heap  
 var__temp_v_err2378 --->  error  
 var_h2368 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2368, res ) ==(5) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2375, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2375, res ) ==((sel)( , var_h2368, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h2375, other ) ==(sel)( , var_h2368, other ) => 
 	 Rel (sel)( , var__temp_h2375, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2375, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2377, res ) ==(var__temp_v2376) AND 
 	 Rel (sel)( , var__temp_h'2377, res ) ==((sel)( , var__temp_h2375, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2377, other ) ==(sel)( , var__temp_h2375, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2377, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2377, other ) > (4)
 
VC_END(declare-const var_h_i2369 T8483)
(declare-const var_h2368 T8483)
(declare-const v Int)
(declare-const var_h_i2243 T8483)
(declare-const var_h2242 T8483)
(declare-const v Int)
(declare-const var_h_i1719 T8483)
(declare-const var_h1718 T8483)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2375 T8483)
(declare-const var__temp_v2376 Int)
(declare-const |var__temp_h'2377| T8483)
(declare-const var__temp_v_err2378 T8484)
(declare-const var_h2368 T8483)
(declare-const var_h2242 T8483)
(declare-const var_h1718 T8483)
(declare-const err T8497)

solver 
 (declare-sort T8483)
(declare-fun sel (T8483 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2368 () T8483)
(declare-fun var_h1718 () T8483)
(declare-fun other () Int)
(declare-fun |var__temp_h'2377| () T8483)
(declare-fun var__temp_h2375 () T8483)
(declare-fun var__temp_v2376 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2368 res) 5))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2375 res) v)
                (= (sel var__temp_h2375 res) (+ (sel var_h2368 res) 2))
                (= (sel var__temp_h2375 other) (sel var_h2368 other))))
      (a!2 (and (= (sel |var__temp_h'2377| res) var__temp_v2376)
                (= (sel |var__temp_h'2377| res) (+ (sel var__temp_h2375 res) 5))
                (= (sel |var__temp_h'2377| other) (sel var__temp_h2375 other))))
      (a!3 (and (= (sel |var__temp_h'2377| res) 10)
                (not (> (sel |var__temp_h'2377| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2375 res) 7))
                (=> (= (sel var__temp_h2375 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************649
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2370:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2370:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbarc2c2'foofoo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2369 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2369, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2369, res ) ==((sel)( , var_h2368, res ) + (2))
 	 , (sel)( , var_h_i2369, other ) ==(sel)( , var_h2368, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2379:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************650
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2369 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2369, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2369, res ) ==((sel)( , var_h2368, res ) + (2))
 	 , (sel)( , var_h_i2369, other ) ==(sel)( , var_h2368, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2379:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2369 --->  Ty_heap  
 var_h2368 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2380 --->  Ty_heap  
 var__temp_v2381 --->  Ty_int  
 var__temp_h'2382 --->  Ty_heap  
 var__temp_v_err2383 --->  error  
 var_h2368 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2368, res ) ==(5) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2380, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2380, res ) ==((sel)( , var_h2368, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h2380, other ) ==(sel)( , var_h2368, other ) => 
 	 Rel (sel)( , var__temp_h2380, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2380, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2382, res ) ==(var__temp_v2381) AND 
 	 Rel (sel)( , var__temp_h'2382, res ) ==((sel)( , var__temp_h2380, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2382, other ) ==(sel)( , var__temp_h2380, other ) => 
 	 True
 
VC_END(declare-const var_h_i2369 T8500)
(declare-const var_h2368 T8500)
(declare-const v Int)
(declare-const var_h_i2243 T8500)
(declare-const var_h2242 T8500)
(declare-const v Int)
(declare-const var_h_i1719 T8500)
(declare-const var_h1718 T8500)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2380 T8500)
(declare-const var__temp_v2381 Int)
(declare-const |var__temp_h'2382| T8500)
(declare-const var__temp_v_err2383 T8501)
(declare-const var_h2368 T8500)
(declare-const var_h2242 T8500)
(declare-const var_h1718 T8500)
(declare-const err T8514)

solver 
 (declare-sort T8500)
(declare-fun sel (T8500 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2368 () T8500)
(declare-fun var_h1718 () T8500)
(declare-fun other () Int)
(declare-fun var__temp_h2380 () T8500)
(declare-fun |var__temp_h'2382| () T8500)
(declare-fun var__temp_v2381 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2368 res) 5))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2380 res) v)
                (= (sel var__temp_h2380 res) (+ (sel var_h2368 res) 2))
                (= (sel var__temp_h2380 other) (sel var_h2368 other))))
      (a!2 (and (= (sel |var__temp_h'2382| res) var__temp_v2381)
                (= (sel |var__temp_h'2382| res) (+ (sel var__temp_h2380 res) 3))
                (= (sel |var__temp_h'2382| other) (sel var__temp_h2380 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2380 res) 7))
                (=> (= (sel var__temp_h2380 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************baz
PARTIAL PATH NEW
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --c4
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2385 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2385 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2385, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2385, res ) ==((sel)( , var_h2384, res ) + (3))
 	 , (sel)( , var_h_i2385, other ) ==(sel)( , var_h2384, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2386:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2385 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************651
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2385 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2385, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2385, res ) ==((sel)( , var_h2384, res ) + (3))
 	 , (sel)( , var_h_i2385, other ) ==(sel)( , var_h2384, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2386:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2385 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2385 --->  Ty_heap  
 var_h2384 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2369 --->  Ty_heap  
 var_h2368 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2387 --->  Ty_heap  
 var__temp_v2388 --->  Ty_int  
 var__temp_h'2389 --->  Ty_heap  
 var__temp_v_err2390 --->  error  
 var_h2384 --->  Ty_heap  
 var_h2368 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h2384, res ) ==(7) AND 
 	 Rel (sel)( , var_h2368, res ) ==(5) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2387, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2387, res ) ==((sel)( , var_h2384, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h2387, other ) ==(sel)( , var_h2384, other ) => 
 	 Rel (sel)( , var__temp_h2387, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2387, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2389, res ) ==(var__temp_v2388) AND 
 	 Rel (sel)( , var__temp_h'2389, res ) ==((sel)( , var__temp_h2387, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2389, other ) ==(sel)( , var__temp_h2387, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2389, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2389, other ) > (4)
 
VC_END(declare-const var_h_i2385 T8517)
(declare-const var_h2384 T8517)
(declare-const v Int)
(declare-const var_h_i2369 T8517)
(declare-const var_h2368 T8517)
(declare-const v Int)
(declare-const var_h_i2243 T8517)
(declare-const var_h2242 T8517)
(declare-const v Int)
(declare-const var_h_i1719 T8517)
(declare-const var_h1718 T8517)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2387 T8517)
(declare-const var__temp_v2388 Int)
(declare-const |var__temp_h'2389| T8517)
(declare-const var__temp_v_err2390 T8518)
(declare-const var_h2384 T8517)
(declare-const var_h2368 T8517)
(declare-const var_h2242 T8517)
(declare-const var_h1718 T8517)
(declare-const err T8531)

solver 
 (declare-sort T8517)
(declare-fun sel (T8517 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2384 () T8517)
(declare-fun var_h2368 () T8517)
(declare-fun var_h1718 () T8517)
(declare-fun other () Int)
(declare-fun |var__temp_h'2389| () T8517)
(declare-fun var__temp_h2387 () T8517)
(declare-fun var__temp_v2388 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2384 res) 7))
(assert (= (sel var_h2368 res) 5))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2387 res) v)
                (= (sel var__temp_h2387 res) (+ (sel var_h2384 res) 3))
                (= (sel var__temp_h2387 other) (sel var_h2384 other))))
      (a!2 (and (= (sel |var__temp_h'2389| res) var__temp_v2388)
                (= (sel |var__temp_h'2389| res) (+ (sel var__temp_h2387 res) 5))
                (= (sel |var__temp_h'2389| other) (sel var__temp_h2387 other))))
      (a!3 (and (= (sel |var__temp_h'2389| res) 10)
                (not (> (sel |var__temp_h'2389| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2387 res) 7))
                (=> (= (sel var__temp_h2387 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************652
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2386:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2386:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbazbarc2c2'foofoo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2385 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2385, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2385, res ) ==((sel)( , var_h2384, res ) + (3))
 	 , (sel)( , var_h_i2385, other ) ==(sel)( , var_h2384, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2391:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************653
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2385 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2385, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2385, res ) ==((sel)( , var_h2384, res ) + (3))
 	 , (sel)( , var_h_i2385, other ) ==(sel)( , var_h2384, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2391:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2385 --->  Ty_heap  
 var_h2384 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2369 --->  Ty_heap  
 var_h2368 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2392 --->  Ty_heap  
 var__temp_v2393 --->  Ty_int  
 var__temp_h'2394 --->  Ty_heap  
 var__temp_v_err2395 --->  error  
 var_h2384 --->  Ty_heap  
 var_h2368 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h2384, res ) ==(7) AND 
 	 Rel (sel)( , var_h2368, res ) ==(5) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2392, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2392, res ) ==((sel)( , var_h2384, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h2392, other ) ==(sel)( , var_h2384, other ) => 
 	 Rel (sel)( , var__temp_h2392, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2392, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2394, res ) ==(var__temp_v2393) AND 
 	 Rel (sel)( , var__temp_h'2394, res ) ==((sel)( , var__temp_h2392, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2394, other ) ==(sel)( , var__temp_h2392, other ) => 
 	 True
 
VC_END(declare-const var_h_i2385 T8534)
(declare-const var_h2384 T8534)
(declare-const v Int)
(declare-const var_h_i2369 T8534)
(declare-const var_h2368 T8534)
(declare-const v Int)
(declare-const var_h_i2243 T8534)
(declare-const var_h2242 T8534)
(declare-const v Int)
(declare-const var_h_i1719 T8534)
(declare-const var_h1718 T8534)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2392 T8534)
(declare-const var__temp_v2393 Int)
(declare-const |var__temp_h'2394| T8534)
(declare-const var__temp_v_err2395 T8535)
(declare-const var_h2384 T8534)
(declare-const var_h2368 T8534)
(declare-const var_h2242 T8534)
(declare-const var_h1718 T8534)
(declare-const err T8548)

solver 
 (declare-sort T8534)
(declare-fun sel (T8534 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2384 () T8534)
(declare-fun var_h2368 () T8534)
(declare-fun var_h1718 () T8534)
(declare-fun other () Int)
(declare-fun var__temp_h2392 () T8534)
(declare-fun |var__temp_h'2394| () T8534)
(declare-fun var__temp_v2393 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2384 res) 7))
(assert (= (sel var_h2368 res) 5))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2392 res) v)
                (= (sel var__temp_h2392 res) (+ (sel var_h2384 res) 3))
                (= (sel var__temp_h2392 other) (sel var_h2384 other))))
      (a!2 (and (= (sel |var__temp_h'2394| res) var__temp_v2393)
                (= (sel |var__temp_h'2394| res) (+ (sel var__temp_h2392 res) 5))
                (= (sel |var__temp_h'2394| other) (sel var__temp_h2392 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2392 res) 7))
                (=> (= (sel var__temp_h2392 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************654
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT baz
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2369 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2369, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2369, res ) ==((sel)( , var_h2368, res ) + (2))
 	 , (sel)( , var_h_i2369, other ) ==(sel)( , var_h2368, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2396:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************655
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2369 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2369, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2369, res ) ==((sel)( , var_h2368, res ) + (2))
 	 , (sel)( , var_h_i2369, other ) ==(sel)( , var_h2368, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2396:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2369 --->  Ty_heap  
 var_h2368 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2397 --->  Ty_heap  
 var__temp_v2398 --->  Ty_int  
 var__temp_h'2399 --->  Ty_heap  
 var__temp_v_err2400 --->  error  
 var_h2368 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2368, res ) ==(5) AND 
 	 Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2397, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2397, res ) ==((sel)( , var_h2368, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h2397, other ) ==(sel)( , var_h2368, other ) => 
 	 Rel (sel)( , var__temp_h2397, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2397, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2399, res ) ==(var__temp_v2398) AND 
 	 Rel (sel)( , var__temp_h'2399, res ) ==((sel)( , var__temp_h2397, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2399, other ) ==(sel)( , var__temp_h2397, other ) => 
 	 True
 
VC_END(declare-const var_h_i2369 T8551)
(declare-const var_h2368 T8551)
(declare-const v Int)
(declare-const var_h_i2243 T8551)
(declare-const var_h2242 T8551)
(declare-const v Int)
(declare-const var_h_i1719 T8551)
(declare-const var_h1718 T8551)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2397 T8551)
(declare-const var__temp_v2398 Int)
(declare-const |var__temp_h'2399| T8551)
(declare-const var__temp_v_err2400 T8552)
(declare-const var_h2368 T8551)
(declare-const var_h2242 T8551)
(declare-const var_h1718 T8551)
(declare-const err T8565)

solver 
 (declare-sort T8551)
(declare-fun sel (T8551 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2368 () T8551)
(declare-fun var_h1718 () T8551)
(declare-fun other () Int)
(declare-fun var__temp_h2397 () T8551)
(declare-fun |var__temp_h'2399| () T8551)
(declare-fun var__temp_v2398 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2368 res) 5))
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2397 res) v)
                (= (sel var__temp_h2397 res) (+ (sel var_h2368 res) 2))
                (= (sel var__temp_h2397 other) (sel var_h2368 other))))
      (a!2 (and (= (sel |var__temp_h'2399| res) var__temp_v2398)
                (= (sel |var__temp_h'2399| res) (+ (sel var__temp_h2397 res) 5))
                (= (sel |var__temp_h'2399| other) (sel var__temp_h2397 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2397 res) 7))
                (=> (= (sel var__temp_h2397 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c5
PARTIAL PATH NEW
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --c4
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2402 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2402 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2402, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2402, res ) ==((sel)( , var_h2401, res ) + (5))
 	 , (sel)( , var_h_i2402, other ) ==(sel)( , var_h2401, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2403:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2402 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************656
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2403:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2403:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc5bazbarc2c2'foofoo'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2402 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2402, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2402, res ) ==((sel)( , var_h2401, res ) + (5))
 	 , (sel)( , var_h_i2402, other ) ==(sel)( , var_h2401, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2404:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************657
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2369 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2369, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2369, res ) ==((sel)( , var_h2368, res ) + (2))
 	 , (sel)( , var_h_i2369, other ) ==(sel)( , var_h2368, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2405:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************658
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --foo
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2243 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2243, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2243, other ) ==(sel)( , var_h2242, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2406:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************659
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2243 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2243, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2243, other ) ==(sel)( , var_h2242, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2406:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2407 --->  Ty_heap  
 var__temp_v2408 --->  Ty_int  
 var__temp_h'2409 --->  Ty_heap  
 var__temp_v_err2410 --->  error  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2407, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2407, other ) ==(sel)( , var_h2242, other ) => 
 	 Rel (sel)( , var__temp_h2407, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2407, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2409, res ) ==(var__temp_v2408) AND 
 	 Rel (sel)( , var__temp_h'2409, res ) ==((sel)( , var__temp_h2407, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2409, other ) ==(sel)( , var__temp_h2407, other ) => 
 	 True
 
VC_END(declare-const var_h_i2243 T8568)
(declare-const var_h2242 T8568)
(declare-const v Int)
(declare-const var_h_i1719 T8568)
(declare-const var_h1718 T8568)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2407 T8568)
(declare-const var__temp_v2408 Int)
(declare-const |var__temp_h'2409| T8568)
(declare-const var__temp_v_err2410 T8569)
(declare-const var_h2242 T8568)
(declare-const var_h1718 T8568)
(declare-const err T8582)
    (declare-const |5| Int)
  
solver 
 (declare-sort T8568)
(declare-fun sel (T8568 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T8568)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2407 () T8568)
(declare-fun |var__temp_h'2409| () T8568)
(declare-fun var__temp_v2408 () Int)
(declare-fun var_h2242 () T8568)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2407 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2407 other) (sel var_h2242 other)))
               (= (sel var__temp_h2407 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2409| res) var__temp_v2408)
                (= (sel |var__temp_h'2409| res) (+ (sel var__temp_h2407 res) 3))
                (= (sel |var__temp_h'2409| other) (sel var__temp_h2407 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2407 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************660
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2243 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2243, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2243, other ) ==(sel)( , var_h2242, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2406:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2243 --->  Ty_heap  
 var_h2242 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2411 --->  Ty_heap  
 var__temp_v2412 --->  Ty_int  
 var__temp_h'2413 --->  Ty_heap  
 var__temp_v_err2414 --->  error  
 var_h2242 --->  Ty_heap  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2411, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2411, other ) ==(sel)( , var_h2242, other ) => 
 	 Rel (sel)( , var__temp_h2411, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2411, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2413, res ) ==(var__temp_v2412) AND 
 	 Rel (sel)( , var__temp_h'2413, res ) ==((sel)( , var__temp_h2411, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2413, other ) ==(sel)( , var__temp_h2411, other ) => 
 	 True
 
VC_END(declare-const var_h_i2243 T8585)
(declare-const var_h2242 T8585)
(declare-const v Int)
(declare-const var_h_i1719 T8585)
(declare-const var_h1718 T8585)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2411 T8585)
(declare-const var__temp_v2412 Int)
(declare-const |var__temp_h'2413| T8585)
(declare-const var__temp_v_err2414 T8586)
(declare-const var_h2242 T8585)
(declare-const var_h1718 T8585)
(declare-const err T8599)
    (declare-const |5| Int)
  
solver 
 (declare-sort T8585)
(declare-fun sel (T8585 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T8585)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2411 () T8585)
(declare-fun |var__temp_h'2413| () T8585)
(declare-fun var__temp_v2412 () Int)
(declare-fun var_h2242 () T8585)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2411 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2411 other) (sel var_h2242 other)))
               (= (sel var__temp_h2411 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2413| res) var__temp_v2412)
                (= (sel |var__temp_h'2413| res) (+ (sel var__temp_h2411 res) 5))
                (= (sel |var__temp_h'2413| other) (sel var__temp_h2411 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2411 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************661
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT bar
PARTIAL PATH
SUB 
 	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1719, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1719, res ) ==((sel)( , var_h1718, res ) + (5))
 	 , (sel)( , var_h_i1719, other ) ==(sel)( , var_h1718, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2415:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
bar
 *********************Enumeration Iteration*****************662
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1719, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1719, res ) ==((sel)( , var_h1718, res ) + (5))
 	 , (sel)( , var_h_i1719, other ) ==(sel)( , var_h1718, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2415:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2416 --->  Ty_heap  
 var__temp_v2417 --->  Ty_int  
 var__temp_h'2418 --->  Ty_heap  
 var__temp_v_err2419 --->  error  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2416, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2416, res ) ==((sel)( , var_h1718, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h2416, other ) ==(sel)( , var_h1718, other ) => 
 	 Rel (sel)( , var__temp_h2416, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2416, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2418, res ) ==(var__temp_v2417) AND 
 	 Rel (sel)( , var__temp_h'2418, res ) ==((sel)( , var__temp_h2416, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2418, other ) ==(sel)( , var__temp_h2416, other ) => 
 	 True
 
VC_END(declare-const var_h_i1719 T8602)
(declare-const var_h1718 T8602)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2416 T8602)
(declare-const var__temp_v2417 Int)
(declare-const |var__temp_h'2418| T8602)
(declare-const var__temp_v_err2419 T8603)
(declare-const var_h1718 T8602)
(declare-const err T8616)

solver 
 (declare-sort T8602)
(declare-fun sel (T8602 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T8602)
(declare-fun other () Int)
(declare-fun var__temp_h2416 () T8602)
(declare-fun |var__temp_h'2418| () T8602)
(declare-fun var__temp_v2417 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2416 res) v)
                (= (sel var__temp_h2416 res) (+ (sel var_h1718 res) 5))
                (= (sel var__temp_h2416 other) (sel var_h1718 other))))
      (a!2 (and (= (sel |var__temp_h'2418| res) var__temp_v2417)
                (= (sel |var__temp_h'2418| res) (+ (sel var__temp_h2416 res) 3))
                (= (sel |var__temp_h'2418| other) (sel var__temp_h2416 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2416 res) 7))
                (=> (= (sel var__temp_h2416 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************663
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1719, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1719, res ) ==((sel)( , var_h1718, res ) + (5))
 	 , (sel)( , var_h_i1719, other ) ==(sel)( , var_h1718, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2415:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2420 --->  Ty_heap  
 var__temp_v2421 --->  Ty_int  
 var__temp_h'2422 --->  Ty_heap  
 var__temp_v_err2423 --->  error  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2420, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2420, res ) ==((sel)( , var_h1718, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h2420, other ) ==(sel)( , var_h1718, other ) => 
 	 Rel (sel)( , var__temp_h2420, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2420, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2422, res ) ==(var__temp_v2421) AND 
 	 Rel (sel)( , var__temp_h'2422, res ) ==((sel)( , var__temp_h2420, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2422, other ) ==(sel)( , var__temp_h2420, other ) => 
 	 True
 
VC_END(declare-const var_h_i1719 T8619)
(declare-const var_h1718 T8619)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2420 T8619)
(declare-const var__temp_v2421 Int)
(declare-const |var__temp_h'2422| T8619)
(declare-const var__temp_v_err2423 T8620)
(declare-const var_h1718 T8619)
(declare-const err T8633)

solver 
 (declare-sort T8619)
(declare-fun sel (T8619 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T8619)
(declare-fun other () Int)
(declare-fun var__temp_h2420 () T8619)
(declare-fun |var__temp_h'2422| () T8619)
(declare-fun var__temp_v2421 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2420 res) v)
                (= (sel var__temp_h2420 res) (+ (sel var_h1718 res) 5))
                (= (sel var__temp_h2420 other) (sel var_h1718 other))))
      (a!2 (and (= (sel |var__temp_h'2422| res) var__temp_v2421)
                (= (sel |var__temp_h'2422| res) (+ (sel var__temp_h2420 res) 5))
                (= (sel |var__temp_h'2422| other) (sel var__temp_h2420 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2420 res) 7))
                (=> (= (sel var__temp_h2420 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************664
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1719, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1719, res ) ==((sel)( , var_h1718, res ) + (5))
 	 , (sel)( , var_h_i1719, other ) ==(sel)( , var_h1718, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2415:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2424 --->  Ty_heap  
 var__temp_v2425 --->  Ty_int  
 var__temp_h'2426 --->  Ty_heap  
 var__temp_v_err2427 --->  error  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2424, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2424, res ) ==((sel)( , var_h1718, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h2424, other ) ==(sel)( , var_h1718, other ) => 
 	 Rel (sel)( , var__temp_h2424, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h2424, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2426, res ) ==(var__temp_v2425) AND 
 	 Rel (sel)( , var__temp_h2424, res ) ==(sel)( , var__temp_h2424, res ) AND 
 	 Rel (sel)( , var__temp_h'2426, other ) ==(sel)( , var__temp_h2424, other ) => 
 	 True
 
VC_END(declare-const var_h_i1719 T8636)
(declare-const var_h1718 T8636)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2424 T8636)
(declare-const var__temp_v2425 Int)
(declare-const |var__temp_h'2426| T8636)
(declare-const var__temp_v_err2427 T8637)
(declare-const var_h1718 T8636)
(declare-const err T8650)

solver 
 (declare-sort T8636)
(declare-fun sel (T8636 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T8636)
(declare-fun other () Int)
(declare-fun var__temp_h2424 () T8636)
(declare-fun |var__temp_h'2426| () T8636)
(declare-fun var__temp_v2425 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2424 res) v)
                (= (sel var__temp_h2424 res) (+ (sel var_h1718 res) 5))
                (= (sel var__temp_h2424 other) (sel var_h1718 other))))
      (a!3 (=> (and (= (sel |var__temp_h'2426| res) var__temp_v2425)
                    (= (sel var__temp_h2424 res) (sel var__temp_h2424 res))
                    (= (sel |var__temp_h'2426| other)
                       (sel var__temp_h2424 other)))
               true)))
(let ((a!2 (=> a!1 (not (> (sel var__temp_h2424 res) 20))))
      (a!4 (=> (not (> (sel var__temp_h2424 res) 20)) a!3)))
  (not (and a!2 a!4)))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************665
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1719, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1719, res ) ==((sel)( , var_h1718, res ) + (5))
 	 , (sel)( , var_h_i1719, other ) ==(sel)( , var_h1718, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2415:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2428 --->  Ty_heap  
 var__temp_v2429 --->  Ty_int  
 var__temp_h'2430 --->  Ty_heap  
 var__temp_v_err2431 --->  error  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2428, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2428, res ) ==((sel)( , var_h1718, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h2428, other ) ==(sel)( , var_h1718, other ) => 
 	 Rel (sel)( , var__temp_h2428, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h2428, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2430, res ) ==(var__temp_v2429) AND 
 	 Rel (sel)( , var__temp_h'2430, res ) ==((sel)( , var__temp_h2428, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'2430, other ) ==(sel)( , var__temp_h2428, other ) => 
 	 True
 
VC_END(declare-const var_h_i1719 T8653)
(declare-const var_h1718 T8653)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2428 T8653)
(declare-const var__temp_v2429 Int)
(declare-const |var__temp_h'2430| T8653)
(declare-const var__temp_v_err2431 T8654)
(declare-const var_h1718 T8653)
(declare-const err T8667)

solver 
 (declare-sort T8653)
(declare-fun sel (T8653 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T8653)
(declare-fun other () Int)
(declare-fun var__temp_h2428 () T8653)
(declare-fun |var__temp_h'2430| () T8653)
(declare-fun var__temp_v2429 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2428 res) v)
                (= (sel var__temp_h2428 res) (+ (sel var_h1718 res) 5))
                (= (sel var__temp_h2428 other) (sel var_h1718 other))))
      (a!2 (and (= (sel |var__temp_h'2430| res) var__temp_v2429)
                (= (sel |var__temp_h'2430| res)
                   (+ (sel var__temp_h2428 res) 10))
                (= (sel |var__temp_h'2430| other) (sel var__temp_h2428 other)))))
(let ((a!3 (and (=> a!1 (> (sel var__temp_h2428 res) 4))
                (=> (> (sel var__temp_h2428 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************666
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1719 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1719, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i1719, res ) ==((sel)( , var_h1718, res ) + (5))
 	 , (sel)( , var_h_i1719, other ) ==(sel)( , var_h1718, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2415:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1719 --->  Ty_heap  
 var_h1718 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2432 --->  Ty_heap  
 var__temp_v2433 --->  Ty_int  
 var__temp_h'2434 --->  Ty_heap  
 var__temp_v_err2435 --->  error  
 var_h1718 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h1718, res ) > (30) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2432, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2432, res ) ==((sel)( , var_h1718, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h2432, other ) ==(sel)( , var_h1718, other ) => 
 	 Rel (sel)( , var__temp_h2432, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2432, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2434, res ) ==(var__temp_v2433) AND 
 	 Rel (sel)( , var__temp_h'2434, res ) ==((sel)( , var__temp_h2432, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2434, other ) ==(sel)( , var__temp_h2432, other ) => 
 	 True
 
VC_END(declare-const var_h_i1719 T8670)
(declare-const var_h1718 T8670)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2432 T8670)
(declare-const var__temp_v2433 Int)
(declare-const |var__temp_h'2434| T8670)
(declare-const var__temp_v_err2435 T8671)
(declare-const var_h1718 T8670)
(declare-const err T8684)

solver 
 (declare-sort T8670)
(declare-fun sel (T8670 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1718 () T8670)
(declare-fun other () Int)
(declare-fun var__temp_h2432 () T8670)
(declare-fun |var__temp_h'2434| () T8670)
(declare-fun var__temp_v2433 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h1718 res) 30)))
(assert (let ((a!1 (and (= (sel var__temp_h2432 res) v)
                (= (sel var__temp_h2432 res) (+ (sel var_h1718 res) 5))
                (= (sel var__temp_h2432 other) (sel var_h1718 other))))
      (a!2 (and (= (sel |var__temp_h'2434| res) var__temp_v2433)
                (= (sel |var__temp_h'2434| res) (+ (sel var__temp_h2432 res) 2))
                (= (sel |var__temp_h'2434| other) (sel var__temp_h2432 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2432 res) 5))
                (=> (= (sel var__temp_h2432 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************667
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo
PARTIAL PATH
SUB 
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {var_v2436:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2'
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************668
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {var_v2436:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2437 --->  Ty_heap  
 var__temp_v2438 --->  Ty_int  
 var__temp_h'2439 --->  Ty_heap  
 var__temp_v_err2440 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2437, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h2437, other ) ==(0) => 
 	 Rel (sel)( , var__temp_h2437, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2437, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2439, res ) ==(var__temp_v2438) AND 
 	 Rel (sel)( , var__temp_h'2439, res ) ==((sel)( , var__temp_h2437, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2439, other ) ==(sel)( , var__temp_h2437, other ) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2437 T8687)
(declare-const var__temp_v2438 Int)
(declare-const |var__temp_h'2439| T8687)
(declare-const var__temp_v_err2440 T8688)
(declare-const err T8701)

solver 
 (declare-sort T8687)
(declare-fun sel (T8687 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h2437 () T8687)
(declare-fun |var__temp_h'2439| () T8687)
(declare-fun res () Int)
(declare-fun var__temp_v2438 () Int)
(assert true)
(assert (let ((a!1 (=> (and (= (sel var__temp_h2437 res) 0)
                    (= (sel var__temp_h2437 other) 0))
               (= (sel var__temp_h2437 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2439| res) var__temp_v2438)
                (= (sel |var__temp_h'2439| res) (+ (sel var__temp_h2437 res) 3))
                (= (sel |var__temp_h'2439| other) (sel var__temp_h2437 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2437 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************669
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {var_v2436:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2441 --->  Ty_heap  
 var__temp_v2442 --->  Ty_int  
 var__temp_h'2443 --->  Ty_heap  
 var__temp_v_err2444 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2441, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h2441, other ) ==(0) => 
 	 Rel (sel)( , var__temp_h2441, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2441, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2443, res ) ==(var__temp_v2442) AND 
 	 Rel (sel)( , var__temp_h'2443, res ) ==((sel)( , var__temp_h2441, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2443, other ) ==(sel)( , var__temp_h2441, other ) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2441 T8704)
(declare-const var__temp_v2442 Int)
(declare-const |var__temp_h'2443| T8704)
(declare-const var__temp_v_err2444 T8705)
(declare-const err T8718)

solver 
 (declare-sort T8704)
(declare-fun sel (T8704 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h2441 () T8704)
(declare-fun |var__temp_h'2443| () T8704)
(declare-fun res () Int)
(declare-fun var__temp_v2442 () Int)
(assert true)
(assert (let ((a!1 (=> (and (= (sel var__temp_h2441 res) 0)
                    (= (sel var__temp_h2441 other) 0))
               (= (sel var__temp_h2441 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2443| res) var__temp_v2442)
                (= (sel |var__temp_h'2443| res) (+ (sel var__temp_h2441 res) 5))
                (= (sel |var__temp_h'2443| other) (sel var__temp_h2441 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2441 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************670
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {var_v2436:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h, res ) ==(sel)( , h, res )
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2445 --->  Ty_heap  
 var__temp_v2446 --->  Ty_int  
 var__temp_h'2447 --->  Ty_heap  
 var__temp_v_err2448 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2445, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h2445, other ) ==(0) => 
 	 Rel (sel)( , var__temp_h2445, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h2445, res ) > (20) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2447, res ) ==(var__temp_v2446) AND 
 	 Rel (sel)( , var__temp_h2445, res ) ==(sel)( , var__temp_h2445, res ) AND 
 	 Rel (sel)( , var__temp_h'2447, other ) ==(sel)( , var__temp_h2445, other ) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2445 T8721)
(declare-const var__temp_v2446 Int)
(declare-const |var__temp_h'2447| T8721)
(declare-const var__temp_v_err2448 T8722)
(declare-const err T8735)

solver 
 (declare-sort T8721)
(declare-fun sel (T8721 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h2445 () T8721)
(declare-fun |var__temp_h'2447| () T8721)
(declare-fun res () Int)
(declare-fun var__temp_v2446 () Int)
(assert true)
(assert (let ((a!1 (=> (and (= (sel var__temp_h2445 res) 0)
                    (= (sel var__temp_h2445 other) 0))
               (not (> (sel var__temp_h2445 res) 20))))
      (a!2 (=> (and (= (sel |var__temp_h'2447| res) var__temp_v2446)
                    (= (sel var__temp_h2445 res) (sel var__temp_h2445 res))
                    (= (sel |var__temp_h'2447| other)
                       (sel var__temp_h2445 other)))
               true)))
(let ((a!3 (=> (not (> (sel var__temp_h2445 res) 20)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Successful************c2'
PARTIAL PATH NEW
SUB 
 	 --c2'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2450, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res )
 	 , (sel)( , var_h_i2450, other ) ==(sel)( , var_h2449, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2451:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************671
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2450, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res )
 	 , (sel)( , var_h_i2450, other ) ==(sel)( , var_h2449, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2451:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2452 --->  Ty_heap  
 var__temp_v2453 --->  Ty_int  
 var__temp_h'2454 --->  Ty_heap  
 var__temp_v_err2455 --->  error  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2452, res ) ==(v) AND 
 	 Rel (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res ) AND 
 	 Rel (sel)( , var__temp_h2452, other ) ==(sel)( , var_h2449, other ) => 
 	 Rel (sel)( , var__temp_h2452, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2452, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2454, res ) ==(var__temp_v2453) AND 
 	 Rel (sel)( , var__temp_h'2454, res ) ==((sel)( , var__temp_h2452, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2454, other ) ==(sel)( , var__temp_h2452, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2454, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2454, other ) > (4)
 
VC_END(declare-const var_h_i2450 T8738)
(declare-const var_h2449 T8738)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2452 T8738)
(declare-const var__temp_v2453 Int)
(declare-const |var__temp_h'2454| T8738)
(declare-const var__temp_v_err2455 T8739)
(declare-const var_h2449 T8738)
(declare-const err T8752)

solver 
 (declare-sort T8738)
(declare-fun sel (T8738 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T8738)
(declare-fun other () Int)
(declare-fun |var__temp_h'2454| () T8738)
(declare-fun var__temp_h2452 () T8738)
(declare-fun var__temp_v2453 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2452 res) v)
                    (= (sel var_h2449 res) (sel var_h2449 res))
                    (= (sel var__temp_h2452 other) (sel var_h2449 other)))
               (= (sel var__temp_h2452 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2454| res) var__temp_v2453)
                (= (sel |var__temp_h'2454| res) (+ (sel var__temp_h2452 res) 3))
                (= (sel |var__temp_h'2454| other) (sel var__temp_h2452 other))))
      (a!3 (and (= (sel |var__temp_h'2454| res) 10)
                (not (> (sel |var__temp_h'2454| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2452 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************672
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2450, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res )
 	 , (sel)( , var_h_i2450, other ) ==(sel)( , var_h2449, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2451:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2456 --->  Ty_heap  
 var__temp_v2457 --->  Ty_int  
 var__temp_h'2458 --->  Ty_heap  
 var__temp_v_err2459 --->  error  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2456, res ) ==(v) AND 
 	 Rel (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res ) AND 
 	 Rel (sel)( , var__temp_h2456, other ) ==(sel)( , var_h2449, other ) => 
 	 Rel (sel)( , var__temp_h2456, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2456, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2458, res ) ==(var__temp_v2457) AND 
 	 Rel (sel)( , var__temp_h'2458, res ) ==((sel)( , var__temp_h2456, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2458, other ) ==(sel)( , var__temp_h2456, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2458, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2458, other ) > (4)
 
VC_END(declare-const var_h_i2450 T8755)
(declare-const var_h2449 T8755)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2456 T8755)
(declare-const var__temp_v2457 Int)
(declare-const |var__temp_h'2458| T8755)
(declare-const var__temp_v_err2459 T8756)
(declare-const var_h2449 T8755)
(declare-const err T8769)

solver 
 (declare-sort T8755)
(declare-fun sel (T8755 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T8755)
(declare-fun other () Int)
(declare-fun |var__temp_h'2458| () T8755)
(declare-fun var__temp_h2456 () T8755)
(declare-fun var__temp_v2457 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2456 res) v)
                    (= (sel var_h2449 res) (sel var_h2449 res))
                    (= (sel var__temp_h2456 other) (sel var_h2449 other)))
               (= (sel var__temp_h2456 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2458| res) var__temp_v2457)
                (= (sel |var__temp_h'2458| res) (+ (sel var__temp_h2456 res) 5))
                (= (sel |var__temp_h'2458| other) (sel var__temp_h2456 other))))
      (a!3 (and (= (sel |var__temp_h'2458| res) 10)
                (not (> (sel |var__temp_h'2458| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2456 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************673
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2450, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res )
 	 , (sel)( , var_h_i2450, other ) ==(sel)( , var_h2449, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2451:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2460 --->  Ty_heap  
 var__temp_v2461 --->  Ty_int  
 var__temp_h'2462 --->  Ty_heap  
 var__temp_v_err2463 --->  error  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2460, res ) ==(v) AND 
 	 Rel (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res ) AND 
 	 Rel (sel)( , var__temp_h2460, other ) ==(sel)( , var_h2449, other ) => 
 	 Rel (sel)( , var__temp_h2460, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h2460, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2462, res ) ==(var__temp_v2461) AND 
 	 Rel (sel)( , var__temp_h'2462, res ) ==((sel)( , var__temp_h2460, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'2462, other ) ==(sel)( , var__temp_h2460, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2462, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2462, other ) > (4)
 
VC_END(declare-const var_h_i2450 T8772)
(declare-const var_h2449 T8772)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2460 T8772)
(declare-const var__temp_v2461 Int)
(declare-const |var__temp_h'2462| T8772)
(declare-const var__temp_v_err2463 T8773)
(declare-const var_h2449 T8772)
(declare-const err T8786)

solver 
 (declare-sort T8772)
(declare-fun sel (T8772 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T8772)
(declare-fun other () Int)
(declare-fun |var__temp_h'2462| () T8772)
(declare-fun var__temp_h2460 () T8772)
(declare-fun var__temp_v2461 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2460 res) v)
                    (= (sel var_h2449 res) (sel var_h2449 res))
                    (= (sel var__temp_h2460 other) (sel var_h2449 other)))
               (> (sel var__temp_h2460 res) 4)))
      (a!2 (and (= (sel |var__temp_h'2462| res) var__temp_v2461)
                (= (sel |var__temp_h'2462| res)
                   (+ (sel var__temp_h2460 res) 10))
                (= (sel |var__temp_h'2462| other) (sel var__temp_h2460 other))))
      (a!3 (and (= (sel |var__temp_h'2462| res) 10)
                (not (> (sel |var__temp_h'2462| other) 4)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h2460 res) 4) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************674
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2450, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res )
 	 , (sel)( , var_h_i2450, other ) ==(sel)( , var_h2449, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2451:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2464 --->  Ty_heap  
 var__temp_v2465 --->  Ty_int  
 var__temp_h'2466 --->  Ty_heap  
 var__temp_v_err2467 --->  error  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2464, res ) ==(v) AND 
 	 Rel (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res ) AND 
 	 Rel (sel)( , var__temp_h2464, other ) ==(sel)( , var_h2449, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2466, res ) ==(var__temp_v2465) AND 
 	 Base var__temp_v2465 = 20 AND 
 	 Rel (sel)( , var__temp_h'2466, other ) ==(sel)( , var__temp_h2464, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2466, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2466, other ) > (4)
 
VC_END(declare-const var_h_i2450 T8789)
(declare-const var_h2449 T8789)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2464 T8789)
(declare-const var__temp_v2465 Int)
(declare-const |var__temp_h'2466| T8789)
(declare-const var__temp_v_err2467 T8790)
(declare-const var_h2449 T8789)
(declare-const err T8803)
    (declare-const |20| Int)
  
solver 
 (declare-sort T8789)
(declare-fun sel (T8789 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T8789)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2466| () T8789)
(declare-fun var__temp_h2464 () T8789)
(declare-fun var__temp_v2465 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2464 res) v)
                    (= (sel var_h2449 res) (sel var_h2449 res))
                    (= (sel var__temp_h2464 other) (sel var_h2449 other)))
               true))
      (a!2 (and (= (sel |var__temp_h'2466| res) 10)
                (not (> (sel |var__temp_h'2466| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'2466| res) var__temp_v2465)
                    (= var__temp_v2465 |20|)
                    (= (sel |var__temp_h'2466| other)
                       (sel var__temp_h2464 other)))
               a!2)))
  (not (and a!1 (=> true a!3))))))

***************Selection Failed************foo'
 *********************Enumeration Iteration*****************675
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2450, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res )
 	 , (sel)( , var_h_i2450, other ) ==(sel)( , var_h2449, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2451:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2468 --->  Ty_heap  
 var__temp_v2469 --->  Ty_int  
 var__temp_h'2470 --->  Ty_heap  
 var__temp_v_err2471 --->  error  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2468, res ) ==(v) AND 
 	 Rel (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res ) AND 
 	 Rel (sel)( , var__temp_h2468, other ) ==(sel)( , var_h2449, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2470, res ) ==(var__temp_v2469) AND 
 	 Base var__temp_v2469 = 5 AND 
 	 Rel (sel)( , var__temp_h'2470, other ) ==(sel)( , var__temp_h2468, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2470, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2470, other ) > (4)
 
VC_END(declare-const var_h_i2450 T8806)
(declare-const var_h2449 T8806)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2468 T8806)
(declare-const var__temp_v2469 Int)
(declare-const |var__temp_h'2470| T8806)
(declare-const var__temp_v_err2471 T8807)
(declare-const var_h2449 T8806)
(declare-const err T8820)
    (declare-const |5| Int)
  
solver 
 (declare-sort T8806)
(declare-fun sel (T8806 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T8806)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2470| () T8806)
(declare-fun var__temp_h2468 () T8806)
(declare-fun var__temp_v2469 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2468 res) v)
                    (= (sel var_h2449 res) (sel var_h2449 res))
                    (= (sel var__temp_h2468 other) (sel var_h2449 other)))
               true))
      (a!2 (and (= (sel |var__temp_h'2470| res) 10)
                (not (> (sel |var__temp_h'2470| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'2470| res) var__temp_v2469)
                    (= var__temp_v2469 |5|)
                    (= (sel |var__temp_h'2470| other)
                       (sel var__temp_h2468 other)))
               a!2)))
  (not (and a!1 (=> true a!3))))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************676
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2450, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res )
 	 , (sel)( , var_h_i2450, other ) ==(sel)( , var_h2449, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2451:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2472 --->  Ty_heap  
 var__temp_v2473 --->  Ty_int  
 var__temp_h'2474 --->  Ty_heap  
 var__temp_v_err2475 --->  error  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2472, res ) ==(v) AND 
 	 Rel (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res ) AND 
 	 Rel (sel)( , var__temp_h2472, other ) ==(sel)( , var_h2449, other ) => 
 	 Rel (sel)( , var__temp_h2472, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2472, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2474, res ) ==(var__temp_v2473) AND 
 	 Rel (sel)( , var__temp_h'2474, res ) ==((sel)( , var__temp_h2472, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2474, other ) ==(sel)( , var__temp_h2472, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2474, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2474, other ) > (4)
 
VC_END(declare-const var_h_i2450 T8823)
(declare-const var_h2449 T8823)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2472 T8823)
(declare-const var__temp_v2473 Int)
(declare-const |var__temp_h'2474| T8823)
(declare-const var__temp_v_err2475 T8824)
(declare-const var_h2449 T8823)
(declare-const err T8837)

solver 
 (declare-sort T8823)
(declare-fun sel (T8823 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T8823)
(declare-fun other () Int)
(declare-fun |var__temp_h'2474| () T8823)
(declare-fun var__temp_h2472 () T8823)
(declare-fun var__temp_v2473 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2472 res) v)
                    (= (sel var_h2449 res) (sel var_h2449 res))
                    (= (sel var__temp_h2472 other) (sel var_h2449 other)))
               (= (sel var__temp_h2472 res) 5)))
      (a!2 (and (= (sel |var__temp_h'2474| res) var__temp_v2473)
                (= (sel |var__temp_h'2474| res) (+ (sel var__temp_h2472 res) 2))
                (= (sel |var__temp_h'2474| other) (sel var__temp_h2472 other))))
      (a!3 (and (= (sel |var__temp_h'2474| res) 10)
                (not (> (sel |var__temp_h'2474| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2472 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************677
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2451:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2451:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2450, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res )
 	 , (sel)( , var_h_i2450, other ) ==(sel)( , var_h2449, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2476:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************678
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2450, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res )
 	 , (sel)( , var_h_i2450, other ) ==(sel)( , var_h2449, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2476:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2477 --->  Ty_heap  
 var__temp_v2478 --->  Ty_int  
 var__temp_h'2479 --->  Ty_heap  
 var__temp_v_err2480 --->  error  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2477, res ) ==(v) AND 
 	 Rel (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res ) AND 
 	 Rel (sel)( , var__temp_h2477, other ) ==(sel)( , var_h2449, other ) => 
 	 Rel (sel)( , var__temp_h2477, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2477, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2479, res ) ==(var__temp_v2478) AND 
 	 Rel (sel)( , var__temp_h'2479, res ) ==((sel)( , var__temp_h2477, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2479, other ) ==(sel)( , var__temp_h2477, other ) => 
 	 True
 
VC_END(declare-const var_h_i2450 T8840)
(declare-const var_h2449 T8840)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2477 T8840)
(declare-const var__temp_v2478 Int)
(declare-const |var__temp_h'2479| T8840)
(declare-const var__temp_v_err2480 T8841)
(declare-const var_h2449 T8840)
(declare-const err T8854)

solver 
 (declare-sort T8840)
(declare-fun sel (T8840 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T8840)
(declare-fun other () Int)
(declare-fun var__temp_h2477 () T8840)
(declare-fun |var__temp_h'2479| () T8840)
(declare-fun var__temp_v2478 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2477 res) v)
                    (= (sel var_h2449 res) (sel var_h2449 res))
                    (= (sel var__temp_h2477 other) (sel var_h2449 other)))
               (= (sel var__temp_h2477 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2479| res) var__temp_v2478)
                (= (sel |var__temp_h'2479| res) (+ (sel var__temp_h2477 res) 3))
                (= (sel |var__temp_h'2479| other) (sel var__temp_h2477 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2477 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************679
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2450, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res )
 	 , (sel)( , var_h_i2450, other ) ==(sel)( , var_h2449, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2476:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2481 --->  Ty_heap  
 var__temp_v2482 --->  Ty_int  
 var__temp_h'2483 --->  Ty_heap  
 var__temp_v_err2484 --->  error  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2481, res ) ==(v) AND 
 	 Rel (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res ) AND 
 	 Rel (sel)( , var__temp_h2481, other ) ==(sel)( , var_h2449, other ) => 
 	 Rel (sel)( , var__temp_h2481, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2481, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2483, res ) ==(var__temp_v2482) AND 
 	 Rel (sel)( , var__temp_h'2483, res ) ==((sel)( , var__temp_h2481, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2483, other ) ==(sel)( , var__temp_h2481, other ) => 
 	 True
 
VC_END(declare-const var_h_i2450 T8857)
(declare-const var_h2449 T8857)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2481 T8857)
(declare-const var__temp_v2482 Int)
(declare-const |var__temp_h'2483| T8857)
(declare-const var__temp_v_err2484 T8858)
(declare-const var_h2449 T8857)
(declare-const err T8871)

solver 
 (declare-sort T8857)
(declare-fun sel (T8857 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T8857)
(declare-fun other () Int)
(declare-fun var__temp_h2481 () T8857)
(declare-fun |var__temp_h'2483| () T8857)
(declare-fun var__temp_v2482 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2481 res) v)
                    (= (sel var_h2449 res) (sel var_h2449 res))
                    (= (sel var__temp_h2481 other) (sel var_h2449 other)))
               (= (sel var__temp_h2481 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2483| res) var__temp_v2482)
                (= (sel |var__temp_h'2483| res) (+ (sel var__temp_h2481 res) 5))
                (= (sel |var__temp_h'2483| other) (sel var__temp_h2481 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2481 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************680
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2450, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res )
 	 , (sel)( , var_h_i2450, other ) ==(sel)( , var_h2449, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2476:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2485 --->  Ty_heap  
 var__temp_v2486 --->  Ty_int  
 var__temp_h'2487 --->  Ty_heap  
 var__temp_v_err2488 --->  error  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2485, res ) ==(v) AND 
 	 Rel (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res ) AND 
 	 Rel (sel)( , var__temp_h2485, other ) ==(sel)( , var_h2449, other ) => 
 	 Rel (sel)( , var__temp_h2485, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h2485, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2487, res ) ==(var__temp_v2486) AND 
 	 Rel (sel)( , var__temp_h'2487, res ) ==((sel)( , var__temp_h2485, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'2487, other ) ==(sel)( , var__temp_h2485, other ) => 
 	 True
 
VC_END(declare-const var_h_i2450 T8874)
(declare-const var_h2449 T8874)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2485 T8874)
(declare-const var__temp_v2486 Int)
(declare-const |var__temp_h'2487| T8874)
(declare-const var__temp_v_err2488 T8875)
(declare-const var_h2449 T8874)
(declare-const err T8888)

solver 
 (declare-sort T8874)
(declare-fun sel (T8874 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T8874)
(declare-fun other () Int)
(declare-fun var__temp_h2485 () T8874)
(declare-fun |var__temp_h'2487| () T8874)
(declare-fun var__temp_v2486 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2485 res) v)
                    (= (sel var_h2449 res) (sel var_h2449 res))
                    (= (sel var__temp_h2485 other) (sel var_h2449 other)))
               (> (sel var__temp_h2485 res) 4)))
      (a!2 (and (= (sel |var__temp_h'2487| res) var__temp_v2486)
                (= (sel |var__temp_h'2487| res)
                   (+ (sel var__temp_h2485 res) 10))
                (= (sel |var__temp_h'2487| other) (sel var__temp_h2485 other)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h2485 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************681
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2450, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res )
 	 , (sel)( , var_h_i2450, other ) ==(sel)( , var_h2449, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2476:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2489 --->  Ty_heap  
 var__temp_v2490 --->  Ty_int  
 var__temp_h'2491 --->  Ty_heap  
 var__temp_v_err2492 --->  error  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2489, res ) ==(v) AND 
 	 Rel (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res ) AND 
 	 Rel (sel)( , var__temp_h2489, other ) ==(sel)( , var_h2449, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2491, res ) ==(var__temp_v2490) AND 
 	 Base var__temp_v2490 = 20 AND 
 	 Rel (sel)( , var__temp_h'2491, other ) ==(sel)( , var__temp_h2489, other ) => 
 	 True
 
VC_END(declare-const var_h_i2450 T8891)
(declare-const var_h2449 T8891)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2489 T8891)
(declare-const var__temp_v2490 Int)
(declare-const |var__temp_h'2491| T8891)
(declare-const var__temp_v_err2492 T8892)
(declare-const var_h2449 T8891)
(declare-const err T8905)
    (declare-const |20| Int)
  
solver 
 (declare-sort T8891)
(declare-fun sel (T8891 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T8891)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2489 () T8891)
(declare-fun |var__temp_h'2491| () T8891)
(declare-fun var__temp_v2490 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2489 res) v)
                    (= (sel var_h2449 res) (sel var_h2449 res))
                    (= (sel var__temp_h2489 other) (sel var_h2449 other)))
               true))
      (a!2 (=> (and (= (sel |var__temp_h'2491| res) var__temp_v2490)
                    (= var__temp_v2490 |20|)
                    (= (sel |var__temp_h'2491| other)
                       (sel var__temp_h2489 other)))
               true)))
  (not (and a!1 (=> true a!2)))))

***************Selection Successful************foo'
PARTIAL PATH NEW
SUB 
 	 --foo'
 	 --c2'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2494 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2494 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2494, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2494, other ) ==(sel)( , var_h2493, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2495:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2494 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************682
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2494 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2494, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2494, other ) ==(sel)( , var_h2493, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2495:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2494 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2496 --->  Ty_heap  
 var__temp_v2497 --->  Ty_int  
 var__temp_h'2498 --->  Ty_heap  
 var__temp_v_err2499 --->  error  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2496, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h2496, other ) ==(sel)( , var_h2493, other ) => 
 	 Rel (sel)( , var__temp_h2496, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2496, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2498, res ) ==(var__temp_v2497) AND 
 	 Rel (sel)( , var__temp_h'2498, res ) ==((sel)( , var__temp_h2496, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2498, other ) ==(sel)( , var__temp_h2496, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2498, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2498, other ) > (4)
 
VC_END(declare-const var_h_i2494 T8908)
(declare-const var_h2493 T8908)
(declare-const v Int)
(declare-const var_h_i2450 T8908)
(declare-const var_h2449 T8908)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2496 T8908)
(declare-const var__temp_v2497 Int)
(declare-const |var__temp_h'2498| T8908)
(declare-const var__temp_v_err2499 T8909)
(declare-const var_h2493 T8908)
(declare-const var_h2449 T8908)
(declare-const err T8922)
    (declare-const |20| Int)
  
solver 
 (declare-sort T8908)
(declare-fun sel (T8908 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T8908)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2498| () T8908)
(declare-fun var__temp_h2496 () T8908)
(declare-fun var__temp_v2497 () Int)
(declare-fun var_h2493 () T8908)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2496 res) v)
                    (= v |20|)
                    (= (sel var__temp_h2496 other) (sel var_h2493 other)))
               (= (sel var__temp_h2496 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2498| res) var__temp_v2497)
                (= (sel |var__temp_h'2498| res) (+ (sel var__temp_h2496 res) 3))
                (= (sel |var__temp_h'2498| other) (sel var__temp_h2496 other))))
      (a!3 (and (= (sel |var__temp_h'2498| res) 10)
                (not (> (sel |var__temp_h'2498| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2496 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************683
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2494 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2494, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2494, other ) ==(sel)( , var_h2493, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2495:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2494 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2500 --->  Ty_heap  
 var__temp_v2501 --->  Ty_int  
 var__temp_h'2502 --->  Ty_heap  
 var__temp_v_err2503 --->  error  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2500, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h2500, other ) ==(sel)( , var_h2493, other ) => 
 	 Rel (sel)( , var__temp_h2500, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2500, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2502, res ) ==(var__temp_v2501) AND 
 	 Rel (sel)( , var__temp_h'2502, res ) ==((sel)( , var__temp_h2500, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2502, other ) ==(sel)( , var__temp_h2500, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2502, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2502, other ) > (4)
 
VC_END(declare-const var_h_i2494 T8925)
(declare-const var_h2493 T8925)
(declare-const v Int)
(declare-const var_h_i2450 T8925)
(declare-const var_h2449 T8925)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2500 T8925)
(declare-const var__temp_v2501 Int)
(declare-const |var__temp_h'2502| T8925)
(declare-const var__temp_v_err2503 T8926)
(declare-const var_h2493 T8925)
(declare-const var_h2449 T8925)
(declare-const err T8939)
    (declare-const |20| Int)
  
solver 
 (declare-sort T8925)
(declare-fun sel (T8925 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T8925)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2502| () T8925)
(declare-fun var__temp_h2500 () T8925)
(declare-fun var__temp_v2501 () Int)
(declare-fun var_h2493 () T8925)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2500 res) v)
                    (= v |20|)
                    (= (sel var__temp_h2500 other) (sel var_h2493 other)))
               (= (sel var__temp_h2500 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2502| res) var__temp_v2501)
                (= (sel |var__temp_h'2502| res) (+ (sel var__temp_h2500 res) 5))
                (= (sel |var__temp_h'2502| other) (sel var__temp_h2500 other))))
      (a!3 (and (= (sel |var__temp_h'2502| res) 10)
                (not (> (sel |var__temp_h'2502| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2500 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************684
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2494 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2494, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2494, other ) ==(sel)( , var_h2493, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2495:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2494 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2504 --->  Ty_heap  
 var__temp_v2505 --->  Ty_int  
 var__temp_h'2506 --->  Ty_heap  
 var__temp_v_err2507 --->  error  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2504, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h2504, other ) ==(sel)( , var_h2493, other ) => 
 	 Rel (sel)( , var__temp_h2504, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h2504, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2506, res ) ==(var__temp_v2505) AND 
 	 Rel (sel)( , var__temp_h'2506, res ) ==((sel)( , var__temp_h2504, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'2506, other ) ==(sel)( , var__temp_h2504, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2506, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2506, other ) > (4)
 
VC_END(declare-const var_h_i2494 T8942)
(declare-const var_h2493 T8942)
(declare-const v Int)
(declare-const var_h_i2450 T8942)
(declare-const var_h2449 T8942)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2504 T8942)
(declare-const var__temp_v2505 Int)
(declare-const |var__temp_h'2506| T8942)
(declare-const var__temp_v_err2507 T8943)
(declare-const var_h2493 T8942)
(declare-const var_h2449 T8942)
(declare-const err T8956)
    (declare-const |20| Int)
  
solver 
 (declare-sort T8942)
(declare-fun sel (T8942 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T8942)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2506| () T8942)
(declare-fun var__temp_h2504 () T8942)
(declare-fun var__temp_v2505 () Int)
(declare-fun var_h2493 () T8942)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2504 res) v)
                    (= v |20|)
                    (= (sel var__temp_h2504 other) (sel var_h2493 other)))
               (> (sel var__temp_h2504 res) 4)))
      (a!2 (and (= (sel |var__temp_h'2506| res) var__temp_v2505)
                (= (sel |var__temp_h'2506| res)
                   (+ (sel var__temp_h2504 res) 10))
                (= (sel |var__temp_h'2506| other) (sel var__temp_h2504 other))))
      (a!3 (and (= (sel |var__temp_h'2506| res) 10)
                (not (> (sel |var__temp_h'2506| other) 4)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h2504 res) 4) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************685
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2494 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2494, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2494, other ) ==(sel)( , var_h2493, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2495:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2494 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2508 --->  Ty_heap  
 var__temp_v2509 --->  Ty_int  
 var__temp_h'2510 --->  Ty_heap  
 var__temp_v_err2511 --->  error  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2508, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h2508, other ) ==(sel)( , var_h2493, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2510, res ) ==(var__temp_v2509) AND 
 	 Base var__temp_v2509 = 5 AND 
 	 Rel (sel)( , var__temp_h'2510, other ) ==(sel)( , var__temp_h2508, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2510, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2510, other ) > (4)
 
VC_END(declare-const var_h_i2494 T8959)
(declare-const var_h2493 T8959)
(declare-const v Int)
(declare-const var_h_i2450 T8959)
(declare-const var_h2449 T8959)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2508 T8959)
(declare-const var__temp_v2509 Int)
(declare-const |var__temp_h'2510| T8959)
(declare-const var__temp_v_err2511 T8960)
(declare-const var_h2493 T8959)
(declare-const var_h2449 T8959)
(declare-const err T8973)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T8959)
(declare-fun sel (T8959 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T8959)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2510| () T8959)
(declare-fun var__temp_h2508 () T8959)
(declare-fun var__temp_v2509 () Int)
(declare-fun var_h2493 () T8959)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2508 res) v)
                    (= v |20|)
                    (= (sel var__temp_h2508 other) (sel var_h2493 other)))
               true))
      (a!2 (and (= (sel |var__temp_h'2510| res) 10)
                (not (> (sel |var__temp_h'2510| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'2510| res) var__temp_v2509)
                    (= var__temp_v2509 |5|)
                    (= (sel |var__temp_h'2510| other)
                       (sel var__temp_h2508 other)))
               a!2)))
  (not (and a!1 (=> true a!3))))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************686
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2494 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2494, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2494, other ) ==(sel)( , var_h2493, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2495:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2494 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2512 --->  Ty_heap  
 var__temp_v2513 --->  Ty_int  
 var__temp_h'2514 --->  Ty_heap  
 var__temp_v_err2515 --->  error  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2512, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h2512, other ) ==(sel)( , var_h2493, other ) => 
 	 Rel (sel)( , var__temp_h2512, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2512, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2514, res ) ==(var__temp_v2513) AND 
 	 Rel (sel)( , var__temp_h'2514, res ) ==((sel)( , var__temp_h2512, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2514, other ) ==(sel)( , var__temp_h2512, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2514, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2514, other ) > (4)
 
VC_END(declare-const var_h_i2494 T8976)
(declare-const var_h2493 T8976)
(declare-const v Int)
(declare-const var_h_i2450 T8976)
(declare-const var_h2449 T8976)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2512 T8976)
(declare-const var__temp_v2513 Int)
(declare-const |var__temp_h'2514| T8976)
(declare-const var__temp_v_err2515 T8977)
(declare-const var_h2493 T8976)
(declare-const var_h2449 T8976)
(declare-const err T8990)
    (declare-const |20| Int)
  
solver 
 (declare-sort T8976)
(declare-fun sel (T8976 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T8976)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2514| () T8976)
(declare-fun var__temp_h2512 () T8976)
(declare-fun var__temp_v2513 () Int)
(declare-fun var_h2493 () T8976)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2512 res) v)
                    (= v |20|)
                    (= (sel var__temp_h2512 other) (sel var_h2493 other)))
               (= (sel var__temp_h2512 res) 5)))
      (a!2 (and (= (sel |var__temp_h'2514| res) var__temp_v2513)
                (= (sel |var__temp_h'2514| res) (+ (sel var__temp_h2512 res) 2))
                (= (sel |var__temp_h'2514| other) (sel var__temp_h2512 other))))
      (a!3 (and (= (sel |var__temp_h'2514| res) 10)
                (not (> (sel |var__temp_h'2514| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2512 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************687
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2495:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2495:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --foo'
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2494 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2494, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2494, other ) ==(sel)( , var_h2493, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2516:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************688
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2494 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2494, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2494, other ) ==(sel)( , var_h2493, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2516:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2517 --->  Ty_heap  
 var__temp_v2518 --->  Ty_int  
 var__temp_h'2519 --->  Ty_heap  
 var__temp_v_err2520 --->  error  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2517, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h2517, other ) ==(sel)( , var_h2493, other ) => 
 	 Rel (sel)( , var__temp_h2517, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2517, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2519, res ) ==(var__temp_v2518) AND 
 	 Rel (sel)( , var__temp_h'2519, res ) ==((sel)( , var__temp_h2517, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2519, other ) ==(sel)( , var__temp_h2517, other ) => 
 	 True
 
VC_END(declare-const var_h_i2494 T8993)
(declare-const var_h2493 T8993)
(declare-const v Int)
(declare-const var_h_i2450 T8993)
(declare-const var_h2449 T8993)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2517 T8993)
(declare-const var__temp_v2518 Int)
(declare-const |var__temp_h'2519| T8993)
(declare-const var__temp_v_err2520 T8994)
(declare-const var_h2493 T8993)
(declare-const var_h2449 T8993)
(declare-const err T9007)
    (declare-const |20| Int)
  
solver 
 (declare-sort T8993)
(declare-fun sel (T8993 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T8993)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2517 () T8993)
(declare-fun |var__temp_h'2519| () T8993)
(declare-fun var__temp_v2518 () Int)
(declare-fun var_h2493 () T8993)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2517 res) v)
                    (= v |20|)
                    (= (sel var__temp_h2517 other) (sel var_h2493 other)))
               (= (sel var__temp_h2517 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2519| res) var__temp_v2518)
                (= (sel |var__temp_h'2519| res) (+ (sel var__temp_h2517 res) 3))
                (= (sel |var__temp_h'2519| other) (sel var__temp_h2517 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2517 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************689
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2494 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2494, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2494, other ) ==(sel)( , var_h2493, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2516:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2521 --->  Ty_heap  
 var__temp_v2522 --->  Ty_int  
 var__temp_h'2523 --->  Ty_heap  
 var__temp_v_err2524 --->  error  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2521, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h2521, other ) ==(sel)( , var_h2493, other ) => 
 	 Rel (sel)( , var__temp_h2521, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2521, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2523, res ) ==(var__temp_v2522) AND 
 	 Rel (sel)( , var__temp_h'2523, res ) ==((sel)( , var__temp_h2521, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2523, other ) ==(sel)( , var__temp_h2521, other ) => 
 	 True
 
VC_END(declare-const var_h_i2494 T9010)
(declare-const var_h2493 T9010)
(declare-const v Int)
(declare-const var_h_i2450 T9010)
(declare-const var_h2449 T9010)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2521 T9010)
(declare-const var__temp_v2522 Int)
(declare-const |var__temp_h'2523| T9010)
(declare-const var__temp_v_err2524 T9011)
(declare-const var_h2493 T9010)
(declare-const var_h2449 T9010)
(declare-const err T9024)
    (declare-const |20| Int)
  
solver 
 (declare-sort T9010)
(declare-fun sel (T9010 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T9010)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2521 () T9010)
(declare-fun |var__temp_h'2523| () T9010)
(declare-fun var__temp_v2522 () Int)
(declare-fun var_h2493 () T9010)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2521 res) v)
                    (= v |20|)
                    (= (sel var__temp_h2521 other) (sel var_h2493 other)))
               (= (sel var__temp_h2521 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2523| res) var__temp_v2522)
                (= (sel |var__temp_h'2523| res) (+ (sel var__temp_h2521 res) 5))
                (= (sel |var__temp_h'2523| other) (sel var__temp_h2521 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2521 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************690
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2494 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2494, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2494, other ) ==(sel)( , var_h2493, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2516:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2525 --->  Ty_heap  
 var__temp_v2526 --->  Ty_int  
 var__temp_h'2527 --->  Ty_heap  
 var__temp_v_err2528 --->  error  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2525, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h2525, other ) ==(sel)( , var_h2493, other ) => 
 	 Rel (sel)( , var__temp_h2525, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h2525, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2527, res ) ==(var__temp_v2526) AND 
 	 Rel (sel)( , var__temp_h'2527, res ) ==((sel)( , var__temp_h2525, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'2527, other ) ==(sel)( , var__temp_h2525, other ) => 
 	 True
 
VC_END(declare-const var_h_i2494 T9027)
(declare-const var_h2493 T9027)
(declare-const v Int)
(declare-const var_h_i2450 T9027)
(declare-const var_h2449 T9027)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2525 T9027)
(declare-const var__temp_v2526 Int)
(declare-const |var__temp_h'2527| T9027)
(declare-const var__temp_v_err2528 T9028)
(declare-const var_h2493 T9027)
(declare-const var_h2449 T9027)
(declare-const err T9041)
    (declare-const |20| Int)
  
solver 
 (declare-sort T9027)
(declare-fun sel (T9027 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T9027)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2525 () T9027)
(declare-fun |var__temp_h'2527| () T9027)
(declare-fun var__temp_v2526 () Int)
(declare-fun var_h2493 () T9027)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2525 res) v)
                    (= v |20|)
                    (= (sel var__temp_h2525 other) (sel var_h2493 other)))
               (> (sel var__temp_h2525 res) 4)))
      (a!2 (and (= (sel |var__temp_h'2527| res) var__temp_v2526)
                (= (sel |var__temp_h'2527| res)
                   (+ (sel var__temp_h2525 res) 10))
                (= (sel |var__temp_h'2527| other) (sel var__temp_h2525 other)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h2525 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c2
PARTIAL PATH NEW
SUB 
 	 --c2
 	 --foo'
 	 --c2'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2530 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2530 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2530, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2530, res ) ==((sel)( , var_h2529, res ) + (10))
 	 , (sel)( , var_h_i2530, other ) ==(sel)( , var_h2529, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2531:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2530 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************691
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2530 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2530, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2530, res ) ==((sel)( , var_h2529, res ) + (10))
 	 , (sel)( , var_h_i2530, other ) ==(sel)( , var_h2529, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2531:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2530 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2530 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2532 --->  Ty_heap  
 var__temp_v2533 --->  Ty_int  
 var__temp_h'2534 --->  Ty_heap  
 var__temp_v_err2535 --->  error  
 var_h2529 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2529, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2532, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2532, res ) ==((sel)( , var_h2529, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2532, other ) ==(sel)( , var_h2529, other ) => 
 	 Rel (sel)( , var__temp_h2532, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2532, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2534, res ) ==(var__temp_v2533) AND 
 	 Rel (sel)( , var__temp_h'2534, res ) ==((sel)( , var__temp_h2532, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2534, other ) ==(sel)( , var__temp_h2532, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2534, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2534, other ) > (4)
 
VC_END(declare-const var_h_i2530 T9044)
(declare-const var_h2529 T9044)
(declare-const v Int)
(declare-const var_h_i2494 T9044)
(declare-const var_h2493 T9044)
(declare-const v Int)
(declare-const var_h_i2450 T9044)
(declare-const var_h2449 T9044)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2532 T9044)
(declare-const var__temp_v2533 Int)
(declare-const |var__temp_h'2534| T9044)
(declare-const var__temp_v_err2535 T9045)
(declare-const var_h2529 T9044)
(declare-const var_h2493 T9044)
(declare-const var_h2449 T9044)
(declare-const err T9058)

solver 
 (declare-sort T9044)
(declare-fun sel (T9044 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2529 () T9044)
(declare-fun var_h2449 () T9044)
(declare-fun other () Int)
(declare-fun |var__temp_h'2534| () T9044)
(declare-fun var__temp_h2532 () T9044)
(declare-fun var__temp_v2533 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2529 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2532 res) v)
                (= (sel var__temp_h2532 res) (+ (sel var_h2529 res) 10))
                (= (sel var__temp_h2532 other) (sel var_h2529 other))))
      (a!2 (and (= (sel |var__temp_h'2534| res) var__temp_v2533)
                (= (sel |var__temp_h'2534| res) (+ (sel var__temp_h2532 res) 3))
                (= (sel |var__temp_h'2534| other) (sel var__temp_h2532 other))))
      (a!3 (and (= (sel |var__temp_h'2534| res) 10)
                (not (> (sel |var__temp_h'2534| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2532 res) 7))
                (=> (= (sel var__temp_h2532 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************692
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2530 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2530, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2530, res ) ==((sel)( , var_h2529, res ) + (10))
 	 , (sel)( , var_h_i2530, other ) ==(sel)( , var_h2529, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2531:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2530 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2530 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2536 --->  Ty_heap  
 var__temp_v2537 --->  Ty_int  
 var__temp_h'2538 --->  Ty_heap  
 var__temp_v_err2539 --->  error  
 var_h2529 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2529, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2536, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2536, res ) ==((sel)( , var_h2529, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2536, other ) ==(sel)( , var_h2529, other ) => 
 	 Rel (sel)( , var__temp_h2536, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2536, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2538, res ) ==(var__temp_v2537) AND 
 	 Rel (sel)( , var__temp_h'2538, res ) ==((sel)( , var__temp_h2536, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2538, other ) ==(sel)( , var__temp_h2536, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2538, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2538, other ) > (4)
 
VC_END(declare-const var_h_i2530 T9061)
(declare-const var_h2529 T9061)
(declare-const v Int)
(declare-const var_h_i2494 T9061)
(declare-const var_h2493 T9061)
(declare-const v Int)
(declare-const var_h_i2450 T9061)
(declare-const var_h2449 T9061)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2536 T9061)
(declare-const var__temp_v2537 Int)
(declare-const |var__temp_h'2538| T9061)
(declare-const var__temp_v_err2539 T9062)
(declare-const var_h2529 T9061)
(declare-const var_h2493 T9061)
(declare-const var_h2449 T9061)
(declare-const err T9075)

solver 
 (declare-sort T9061)
(declare-fun sel (T9061 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2529 () T9061)
(declare-fun var_h2449 () T9061)
(declare-fun other () Int)
(declare-fun |var__temp_h'2538| () T9061)
(declare-fun var__temp_h2536 () T9061)
(declare-fun var__temp_v2537 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2529 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2536 res) v)
                (= (sel var__temp_h2536 res) (+ (sel var_h2529 res) 10))
                (= (sel var__temp_h2536 other) (sel var_h2529 other))))
      (a!2 (and (= (sel |var__temp_h'2538| res) var__temp_v2537)
                (= (sel |var__temp_h'2538| res) (+ (sel var__temp_h2536 res) 5))
                (= (sel |var__temp_h'2538| other) (sel var__temp_h2536 other))))
      (a!3 (and (= (sel |var__temp_h'2538| res) 10)
                (not (> (sel |var__temp_h'2538| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2536 res) 7))
                (=> (= (sel var__temp_h2536 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************693
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2530 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2530, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2530, res ) ==((sel)( , var_h2529, res ) + (10))
 	 , (sel)( , var_h_i2530, other ) ==(sel)( , var_h2529, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2531:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2530 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2530 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2540 --->  Ty_heap  
 var__temp_v2541 --->  Ty_int  
 var__temp_h'2542 --->  Ty_heap  
 var__temp_v_err2543 --->  error  
 var_h2529 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2529, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2540, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2540, res ) ==((sel)( , var_h2529, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2540, other ) ==(sel)( , var_h2529, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2542, res ) ==(var__temp_v2541) AND 
 	 Base var__temp_v2541 = 5 AND 
 	 Rel (sel)( , var__temp_h'2542, other ) ==(sel)( , var__temp_h2540, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2542, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2542, other ) > (4)
 
VC_END(declare-const var_h_i2530 T9078)
(declare-const var_h2529 T9078)
(declare-const v Int)
(declare-const var_h_i2494 T9078)
(declare-const var_h2493 T9078)
(declare-const v Int)
(declare-const var_h_i2450 T9078)
(declare-const var_h2449 T9078)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2540 T9078)
(declare-const var__temp_v2541 Int)
(declare-const |var__temp_h'2542| T9078)
(declare-const var__temp_v_err2543 T9079)
(declare-const var_h2529 T9078)
(declare-const var_h2493 T9078)
(declare-const var_h2449 T9078)
(declare-const err T9092)
    (declare-const |5| Int)
  
solver 
 (declare-sort T9078)
(declare-fun sel (T9078 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2529 () T9078)
(declare-fun var_h2449 () T9078)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2542| () T9078)
(declare-fun var__temp_h2540 () T9078)
(declare-fun var__temp_v2541 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2529 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h2540 res) v)
                (= (sel var__temp_h2540 res) (+ (sel var_h2529 res) 10))
                (= (sel var__temp_h2540 other) (sel var_h2529 other))))
      (a!2 (and (= (sel |var__temp_h'2542| res) 10)
                (not (> (sel |var__temp_h'2542| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'2542| res) var__temp_v2541)
                    (= var__temp_v2541 |5|)
                    (= (sel |var__temp_h'2542| other)
                       (sel var__temp_h2540 other)))
               a!2)))
  (not (and (=> a!1 true) (=> true a!3))))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************694
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2530 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2530, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2530, res ) ==((sel)( , var_h2529, res ) + (10))
 	 , (sel)( , var_h_i2530, other ) ==(sel)( , var_h2529, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2531:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2530 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2530 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2544 --->  Ty_heap  
 var__temp_v2545 --->  Ty_int  
 var__temp_h'2546 --->  Ty_heap  
 var__temp_v_err2547 --->  error  
 var_h2529 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2529, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2544, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2544, res ) ==((sel)( , var_h2529, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2544, other ) ==(sel)( , var_h2529, other ) => 
 	 Rel (sel)( , var__temp_h2544, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2544, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2546, res ) ==(var__temp_v2545) AND 
 	 Rel (sel)( , var__temp_h'2546, res ) ==((sel)( , var__temp_h2544, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2546, other ) ==(sel)( , var__temp_h2544, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2546, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2546, other ) > (4)
 
VC_END(declare-const var_h_i2530 T9095)
(declare-const var_h2529 T9095)
(declare-const v Int)
(declare-const var_h_i2494 T9095)
(declare-const var_h2493 T9095)
(declare-const v Int)
(declare-const var_h_i2450 T9095)
(declare-const var_h2449 T9095)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2544 T9095)
(declare-const var__temp_v2545 Int)
(declare-const |var__temp_h'2546| T9095)
(declare-const var__temp_v_err2547 T9096)
(declare-const var_h2529 T9095)
(declare-const var_h2493 T9095)
(declare-const var_h2449 T9095)
(declare-const err T9109)

solver 
 (declare-sort T9095)
(declare-fun sel (T9095 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2529 () T9095)
(declare-fun var_h2449 () T9095)
(declare-fun other () Int)
(declare-fun |var__temp_h'2546| () T9095)
(declare-fun var__temp_h2544 () T9095)
(declare-fun var__temp_v2545 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2529 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2544 res) v)
                (= (sel var__temp_h2544 res) (+ (sel var_h2529 res) 10))
                (= (sel var__temp_h2544 other) (sel var_h2529 other))))
      (a!2 (and (= (sel |var__temp_h'2546| res) var__temp_v2545)
                (= (sel |var__temp_h'2546| res) (+ (sel var__temp_h2544 res) 2))
                (= (sel |var__temp_h'2546| other) (sel var__temp_h2544 other))))
      (a!3 (and (= (sel |var__temp_h'2546| res) 10)
                (not (> (sel |var__temp_h'2546| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2544 res) 5))
                (=> (= (sel var__temp_h2544 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************695
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2531:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2531:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c2
 	 --foo'
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2530 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2530, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2530, res ) ==((sel)( , var_h2529, res ) + (10))
 	 , (sel)( , var_h_i2530, other ) ==(sel)( , var_h2529, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2548:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************696
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2530 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2530, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2530, res ) ==((sel)( , var_h2529, res ) + (10))
 	 , (sel)( , var_h_i2530, other ) ==(sel)( , var_h2529, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2548:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2530 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2549 --->  Ty_heap  
 var__temp_v2550 --->  Ty_int  
 var__temp_h'2551 --->  Ty_heap  
 var__temp_v_err2552 --->  error  
 var_h2529 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2529, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2549, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2549, res ) ==((sel)( , var_h2529, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2549, other ) ==(sel)( , var_h2529, other ) => 
 	 Rel (sel)( , var__temp_h2549, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2549, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2551, res ) ==(var__temp_v2550) AND 
 	 Rel (sel)( , var__temp_h'2551, res ) ==((sel)( , var__temp_h2549, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2551, other ) ==(sel)( , var__temp_h2549, other ) => 
 	 True
 
VC_END(declare-const var_h_i2530 T9112)
(declare-const var_h2529 T9112)
(declare-const v Int)
(declare-const var_h_i2494 T9112)
(declare-const var_h2493 T9112)
(declare-const v Int)
(declare-const var_h_i2450 T9112)
(declare-const var_h2449 T9112)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2549 T9112)
(declare-const var__temp_v2550 Int)
(declare-const |var__temp_h'2551| T9112)
(declare-const var__temp_v_err2552 T9113)
(declare-const var_h2529 T9112)
(declare-const var_h2493 T9112)
(declare-const var_h2449 T9112)
(declare-const err T9126)

solver 
 (declare-sort T9112)
(declare-fun sel (T9112 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2529 () T9112)
(declare-fun var_h2449 () T9112)
(declare-fun other () Int)
(declare-fun var__temp_h2549 () T9112)
(declare-fun |var__temp_h'2551| () T9112)
(declare-fun var__temp_v2550 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2529 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2549 res) v)
                (= (sel var__temp_h2549 res) (+ (sel var_h2529 res) 10))
                (= (sel var__temp_h2549 other) (sel var_h2529 other))))
      (a!2 (and (= (sel |var__temp_h'2551| res) var__temp_v2550)
                (= (sel |var__temp_h'2551| res) (+ (sel var__temp_h2549 res) 3))
                (= (sel |var__temp_h'2551| other) (sel var__temp_h2549 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2549 res) 7))
                (=> (= (sel var__temp_h2549 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************697
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2530 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2530, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2530, res ) ==((sel)( , var_h2529, res ) + (10))
 	 , (sel)( , var_h_i2530, other ) ==(sel)( , var_h2529, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2548:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2530 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2553 --->  Ty_heap  
 var__temp_v2554 --->  Ty_int  
 var__temp_h'2555 --->  Ty_heap  
 var__temp_v_err2556 --->  error  
 var_h2529 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2529, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2553, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2553, res ) ==((sel)( , var_h2529, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2553, other ) ==(sel)( , var_h2529, other ) => 
 	 Rel (sel)( , var__temp_h2553, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2553, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2555, res ) ==(var__temp_v2554) AND 
 	 Rel (sel)( , var__temp_h'2555, res ) ==((sel)( , var__temp_h2553, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2555, other ) ==(sel)( , var__temp_h2553, other ) => 
 	 True
 
VC_END(declare-const var_h_i2530 T9129)
(declare-const var_h2529 T9129)
(declare-const v Int)
(declare-const var_h_i2494 T9129)
(declare-const var_h2493 T9129)
(declare-const v Int)
(declare-const var_h_i2450 T9129)
(declare-const var_h2449 T9129)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2553 T9129)
(declare-const var__temp_v2554 Int)
(declare-const |var__temp_h'2555| T9129)
(declare-const var__temp_v_err2556 T9130)
(declare-const var_h2529 T9129)
(declare-const var_h2493 T9129)
(declare-const var_h2449 T9129)
(declare-const err T9143)

solver 
 (declare-sort T9129)
(declare-fun sel (T9129 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2529 () T9129)
(declare-fun var_h2449 () T9129)
(declare-fun other () Int)
(declare-fun var__temp_h2553 () T9129)
(declare-fun |var__temp_h'2555| () T9129)
(declare-fun var__temp_v2554 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2529 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2553 res) v)
                (= (sel var__temp_h2553 res) (+ (sel var_h2529 res) 10))
                (= (sel var__temp_h2553 other) (sel var_h2529 other))))
      (a!2 (and (= (sel |var__temp_h'2555| res) var__temp_v2554)
                (= (sel |var__temp_h'2555| res) (+ (sel var__temp_h2553 res) 5))
                (= (sel |var__temp_h'2555| other) (sel var__temp_h2553 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2553 res) 7))
                (=> (= (sel var__temp_h2553 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************698
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2530 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2530, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2530, res ) ==((sel)( , var_h2529, res ) + (10))
 	 , (sel)( , var_h_i2530, other ) ==(sel)( , var_h2529, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2548:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2530 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2557 --->  Ty_heap  
 var__temp_v2558 --->  Ty_int  
 var__temp_h'2559 --->  Ty_heap  
 var__temp_v_err2560 --->  error  
 var_h2529 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2529, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2557, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2557, res ) ==((sel)( , var_h2529, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2557, other ) ==(sel)( , var_h2529, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2559, res ) ==(var__temp_v2558) AND 
 	 Base var__temp_v2558 = 5 AND 
 	 Rel (sel)( , var__temp_h'2559, other ) ==(sel)( , var__temp_h2557, other ) => 
 	 True
 
VC_END(declare-const var_h_i2530 T9146)
(declare-const var_h2529 T9146)
(declare-const v Int)
(declare-const var_h_i2494 T9146)
(declare-const var_h2493 T9146)
(declare-const v Int)
(declare-const var_h_i2450 T9146)
(declare-const var_h2449 T9146)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2557 T9146)
(declare-const var__temp_v2558 Int)
(declare-const |var__temp_h'2559| T9146)
(declare-const var__temp_v_err2560 T9147)
(declare-const var_h2529 T9146)
(declare-const var_h2493 T9146)
(declare-const var_h2449 T9146)
(declare-const err T9160)
    (declare-const |5| Int)
  
solver 
 (declare-sort T9146)
(declare-fun sel (T9146 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2529 () T9146)
(declare-fun var_h2449 () T9146)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2557 () T9146)
(declare-fun |var__temp_h'2559| () T9146)
(declare-fun var__temp_v2558 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2529 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h2557 res) v)
                (= (sel var__temp_h2557 res) (+ (sel var_h2529 res) 10))
                (= (sel var__temp_h2557 other) (sel var_h2529 other))))
      (a!2 (=> (and (= (sel |var__temp_h'2559| res) var__temp_v2558)
                    (= var__temp_v2558 |5|)
                    (= (sel |var__temp_h'2559| other)
                       (sel var__temp_h2557 other)))
               true)))
  (not (and (=> a!1 true) (=> true a!2)))))

***************Selection Successful************foo
PARTIAL PATH NEW
SUB 
 	 --foo
 	 --c2
 	 --foo'
 	 --c2'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2562 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2562 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2562, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2562, other ) ==(sel)( , var_h2561, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2563:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2562 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************699
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2562 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2562, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2562, other ) ==(sel)( , var_h2561, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2563:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2562 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2562 --->  Ty_heap  
 var_h2561 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2530 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2564 --->  Ty_heap  
 var__temp_v2565 --->  Ty_int  
 var__temp_h'2566 --->  Ty_heap  
 var__temp_v_err2567 --->  error  
 var_h2561 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2529, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2564, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2564, other ) ==(sel)( , var_h2561, other ) => 
 	 Rel (sel)( , var__temp_h2564, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2564, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2566, res ) ==(var__temp_v2565) AND 
 	 Rel (sel)( , var__temp_h'2566, res ) ==((sel)( , var__temp_h2564, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2566, other ) ==(sel)( , var__temp_h2564, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2566, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2566, other ) > (4)
 
VC_END(declare-const var_h_i2562 T9163)
(declare-const var_h2561 T9163)
(declare-const v Int)
(declare-const var_h_i2530 T9163)
(declare-const var_h2529 T9163)
(declare-const v Int)
(declare-const var_h_i2494 T9163)
(declare-const var_h2493 T9163)
(declare-const v Int)
(declare-const var_h_i2450 T9163)
(declare-const var_h2449 T9163)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2564 T9163)
(declare-const var__temp_v2565 Int)
(declare-const |var__temp_h'2566| T9163)
(declare-const var__temp_v_err2567 T9164)
(declare-const var_h2561 T9163)
(declare-const var_h2529 T9163)
(declare-const var_h2493 T9163)
(declare-const var_h2449 T9163)
(declare-const err T9177)
    (declare-const |5| Int)
  
solver 
 (declare-sort T9163)
(declare-fun sel (T9163 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2529 () T9163)
(declare-fun var_h2449 () T9163)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2566| () T9163)
(declare-fun var__temp_h2564 () T9163)
(declare-fun var__temp_v2565 () Int)
(declare-fun var_h2561 () T9163)
(declare-fun v () Int)
(assert (> (sel var_h2529 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2564 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2564 other) (sel var_h2561 other)))
               (= (sel var__temp_h2564 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2566| res) var__temp_v2565)
                (= (sel |var__temp_h'2566| res) (+ (sel var__temp_h2564 res) 3))
                (= (sel |var__temp_h'2566| other) (sel var__temp_h2564 other))))
      (a!3 (and (= (sel |var__temp_h'2566| res) 10)
                (not (> (sel |var__temp_h'2566| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2564 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************700
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2562 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2562, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2562, other ) ==(sel)( , var_h2561, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2563:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2562 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2562 --->  Ty_heap  
 var_h2561 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2530 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2568 --->  Ty_heap  
 var__temp_v2569 --->  Ty_int  
 var__temp_h'2570 --->  Ty_heap  
 var__temp_v_err2571 --->  error  
 var_h2561 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2529, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2568, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2568, other ) ==(sel)( , var_h2561, other ) => 
 	 Rel (sel)( , var__temp_h2568, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2568, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2570, res ) ==(var__temp_v2569) AND 
 	 Rel (sel)( , var__temp_h'2570, res ) ==((sel)( , var__temp_h2568, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2570, other ) ==(sel)( , var__temp_h2568, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2570, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2570, other ) > (4)
 
VC_END(declare-const var_h_i2562 T9180)
(declare-const var_h2561 T9180)
(declare-const v Int)
(declare-const var_h_i2530 T9180)
(declare-const var_h2529 T9180)
(declare-const v Int)
(declare-const var_h_i2494 T9180)
(declare-const var_h2493 T9180)
(declare-const v Int)
(declare-const var_h_i2450 T9180)
(declare-const var_h2449 T9180)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2568 T9180)
(declare-const var__temp_v2569 Int)
(declare-const |var__temp_h'2570| T9180)
(declare-const var__temp_v_err2571 T9181)
(declare-const var_h2561 T9180)
(declare-const var_h2529 T9180)
(declare-const var_h2493 T9180)
(declare-const var_h2449 T9180)
(declare-const err T9194)
    (declare-const |5| Int)
  
solver 
 (declare-sort T9180)
(declare-fun sel (T9180 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2529 () T9180)
(declare-fun var_h2449 () T9180)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2570| () T9180)
(declare-fun var__temp_h2568 () T9180)
(declare-fun var__temp_v2569 () Int)
(declare-fun var_h2561 () T9180)
(declare-fun v () Int)
(assert (> (sel var_h2529 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2568 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2568 other) (sel var_h2561 other)))
               (= (sel var__temp_h2568 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2570| res) var__temp_v2569)
                (= (sel |var__temp_h'2570| res) (+ (sel var__temp_h2568 res) 5))
                (= (sel |var__temp_h'2570| other) (sel var__temp_h2568 other))))
      (a!3 (and (= (sel |var__temp_h'2570| res) 10)
                (not (> (sel |var__temp_h'2570| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2568 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************701
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2562 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2562, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2562, other ) ==(sel)( , var_h2561, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2563:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2562 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2562 --->  Ty_heap  
 var_h2561 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2530 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2572 --->  Ty_heap  
 var__temp_v2573 --->  Ty_int  
 var__temp_h'2574 --->  Ty_heap  
 var__temp_v_err2575 --->  error  
 var_h2561 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2529, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2572, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2572, other ) ==(sel)( , var_h2561, other ) => 
 	 Rel (sel)( , var__temp_h2572, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2572, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2574, res ) ==(var__temp_v2573) AND 
 	 Rel (sel)( , var__temp_h'2574, res ) ==((sel)( , var__temp_h2572, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2574, other ) ==(sel)( , var__temp_h2572, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2574, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2574, other ) > (4)
 
VC_END(declare-const var_h_i2562 T9197)
(declare-const var_h2561 T9197)
(declare-const v Int)
(declare-const var_h_i2530 T9197)
(declare-const var_h2529 T9197)
(declare-const v Int)
(declare-const var_h_i2494 T9197)
(declare-const var_h2493 T9197)
(declare-const v Int)
(declare-const var_h_i2450 T9197)
(declare-const var_h2449 T9197)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2572 T9197)
(declare-const var__temp_v2573 Int)
(declare-const |var__temp_h'2574| T9197)
(declare-const var__temp_v_err2575 T9198)
(declare-const var_h2561 T9197)
(declare-const var_h2529 T9197)
(declare-const var_h2493 T9197)
(declare-const var_h2449 T9197)
(declare-const err T9211)
    (declare-const |5| Int)
  
solver 
 (declare-sort T9197)
(declare-fun sel (T9197 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2529 () T9197)
(declare-fun var_h2449 () T9197)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2574| () T9197)
(declare-fun var__temp_h2572 () T9197)
(declare-fun var__temp_v2573 () Int)
(declare-fun var_h2561 () T9197)
(declare-fun v () Int)
(assert (> (sel var_h2529 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2572 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2572 other) (sel var_h2561 other)))
               (= (sel var__temp_h2572 res) 5)))
      (a!2 (and (= (sel |var__temp_h'2574| res) var__temp_v2573)
                (= (sel |var__temp_h'2574| res) (+ (sel var__temp_h2572 res) 2))
                (= (sel |var__temp_h'2574| other) (sel var__temp_h2572 other))))
      (a!3 (and (= (sel |var__temp_h'2574| res) 10)
                (not (> (sel |var__temp_h'2574| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2572 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************702
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2563:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2563:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --foo
 	 --c2
 	 --foo'
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2562 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2562, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2562, other ) ==(sel)( , var_h2561, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2576:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************703
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2562 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2562, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2562, other ) ==(sel)( , var_h2561, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2576:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2562 --->  Ty_heap  
 var_h2561 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2530 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2577 --->  Ty_heap  
 var__temp_v2578 --->  Ty_int  
 var__temp_h'2579 --->  Ty_heap  
 var__temp_v_err2580 --->  error  
 var_h2561 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2529, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2577, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2577, other ) ==(sel)( , var_h2561, other ) => 
 	 Rel (sel)( , var__temp_h2577, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2577, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2579, res ) ==(var__temp_v2578) AND 
 	 Rel (sel)( , var__temp_h'2579, res ) ==((sel)( , var__temp_h2577, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2579, other ) ==(sel)( , var__temp_h2577, other ) => 
 	 True
 
VC_END(declare-const var_h_i2562 T9214)
(declare-const var_h2561 T9214)
(declare-const v Int)
(declare-const var_h_i2530 T9214)
(declare-const var_h2529 T9214)
(declare-const v Int)
(declare-const var_h_i2494 T9214)
(declare-const var_h2493 T9214)
(declare-const v Int)
(declare-const var_h_i2450 T9214)
(declare-const var_h2449 T9214)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2577 T9214)
(declare-const var__temp_v2578 Int)
(declare-const |var__temp_h'2579| T9214)
(declare-const var__temp_v_err2580 T9215)
(declare-const var_h2561 T9214)
(declare-const var_h2529 T9214)
(declare-const var_h2493 T9214)
(declare-const var_h2449 T9214)
(declare-const err T9228)
    (declare-const |5| Int)
  
solver 
 (declare-sort T9214)
(declare-fun sel (T9214 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2529 () T9214)
(declare-fun var_h2449 () T9214)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2577 () T9214)
(declare-fun |var__temp_h'2579| () T9214)
(declare-fun var__temp_v2578 () Int)
(declare-fun var_h2561 () T9214)
(declare-fun v () Int)
(assert (> (sel var_h2529 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2577 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2577 other) (sel var_h2561 other)))
               (= (sel var__temp_h2577 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2579| res) var__temp_v2578)
                (= (sel |var__temp_h'2579| res) (+ (sel var__temp_h2577 res) 3))
                (= (sel |var__temp_h'2579| other) (sel var__temp_h2577 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2577 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************704
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2562 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2562, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2562, other ) ==(sel)( , var_h2561, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2576:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2562 --->  Ty_heap  
 var_h2561 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2530 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2581 --->  Ty_heap  
 var__temp_v2582 --->  Ty_int  
 var__temp_h'2583 --->  Ty_heap  
 var__temp_v_err2584 --->  error  
 var_h2561 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2529, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2581, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2581, other ) ==(sel)( , var_h2561, other ) => 
 	 Rel (sel)( , var__temp_h2581, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2581, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2583, res ) ==(var__temp_v2582) AND 
 	 Rel (sel)( , var__temp_h'2583, res ) ==((sel)( , var__temp_h2581, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2583, other ) ==(sel)( , var__temp_h2581, other ) => 
 	 True
 
VC_END(declare-const var_h_i2562 T9231)
(declare-const var_h2561 T9231)
(declare-const v Int)
(declare-const var_h_i2530 T9231)
(declare-const var_h2529 T9231)
(declare-const v Int)
(declare-const var_h_i2494 T9231)
(declare-const var_h2493 T9231)
(declare-const v Int)
(declare-const var_h_i2450 T9231)
(declare-const var_h2449 T9231)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2581 T9231)
(declare-const var__temp_v2582 Int)
(declare-const |var__temp_h'2583| T9231)
(declare-const var__temp_v_err2584 T9232)
(declare-const var_h2561 T9231)
(declare-const var_h2529 T9231)
(declare-const var_h2493 T9231)
(declare-const var_h2449 T9231)
(declare-const err T9245)
    (declare-const |5| Int)
  
solver 
 (declare-sort T9231)
(declare-fun sel (T9231 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2529 () T9231)
(declare-fun var_h2449 () T9231)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2581 () T9231)
(declare-fun |var__temp_h'2583| () T9231)
(declare-fun var__temp_v2582 () Int)
(declare-fun var_h2561 () T9231)
(declare-fun v () Int)
(assert (> (sel var_h2529 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2581 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2581 other) (sel var_h2561 other)))
               (= (sel var__temp_h2581 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2583| res) var__temp_v2582)
                (= (sel |var__temp_h'2583| res) (+ (sel var__temp_h2581 res) 5))
                (= (sel |var__temp_h'2583| other) (sel var__temp_h2581 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2581 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************705
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2562 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2562, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2562, other ) ==(sel)( , var_h2561, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2576:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2562 --->  Ty_heap  
 var_h2561 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2530 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2585 --->  Ty_heap  
 var__temp_v2586 --->  Ty_int  
 var__temp_h'2587 --->  Ty_heap  
 var__temp_v_err2588 --->  error  
 var_h2561 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2529, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2585, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2585, other ) ==(sel)( , var_h2561, other ) => 
 	 Rel (sel)( , var__temp_h2585, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2585, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2587, res ) ==(var__temp_v2586) AND 
 	 Rel (sel)( , var__temp_h'2587, res ) ==((sel)( , var__temp_h2585, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2587, other ) ==(sel)( , var__temp_h2585, other ) => 
 	 True
 
VC_END(declare-const var_h_i2562 T9248)
(declare-const var_h2561 T9248)
(declare-const v Int)
(declare-const var_h_i2530 T9248)
(declare-const var_h2529 T9248)
(declare-const v Int)
(declare-const var_h_i2494 T9248)
(declare-const var_h2493 T9248)
(declare-const v Int)
(declare-const var_h_i2450 T9248)
(declare-const var_h2449 T9248)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2585 T9248)
(declare-const var__temp_v2586 Int)
(declare-const |var__temp_h'2587| T9248)
(declare-const var__temp_v_err2588 T9249)
(declare-const var_h2561 T9248)
(declare-const var_h2529 T9248)
(declare-const var_h2493 T9248)
(declare-const var_h2449 T9248)
(declare-const err T9262)
    (declare-const |5| Int)
  
solver 
 (declare-sort T9248)
(declare-fun sel (T9248 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2529 () T9248)
(declare-fun var_h2449 () T9248)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2585 () T9248)
(declare-fun |var__temp_h'2587| () T9248)
(declare-fun var__temp_v2586 () Int)
(declare-fun var_h2561 () T9248)
(declare-fun v () Int)
(assert (> (sel var_h2529 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2585 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2585 other) (sel var_h2561 other)))
               (= (sel var__temp_h2585 res) 5)))
      (a!2 (and (= (sel |var__temp_h'2587| res) var__temp_v2586)
                (= (sel |var__temp_h'2587| res) (+ (sel var__temp_h2585 res) 2))
                (= (sel |var__temp_h'2587| other) (sel var__temp_h2585 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2585 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************bar
PARTIAL PATH NEW
SUB 
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c2'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2590 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2590 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2590, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2590, res ) ==((sel)( , var_h2589, res ) + (2))
 	 , (sel)( , var_h_i2590, other ) ==(sel)( , var_h2589, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2591:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2590 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************706
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2590 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2590, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2590, res ) ==((sel)( , var_h2589, res ) + (2))
 	 , (sel)( , var_h_i2590, other ) ==(sel)( , var_h2589, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2591:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2590 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2590 --->  Ty_heap  
 var_h2589 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2562 --->  Ty_heap  
 var_h2561 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2530 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2592 --->  Ty_heap  
 var__temp_v2593 --->  Ty_int  
 var__temp_h'2594 --->  Ty_heap  
 var__temp_v_err2595 --->  error  
 var_h2589 --->  Ty_heap  
 var_h2561 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h2589, res ) ==(5) AND 
 	 Rel (sel)( , var_h2529, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2592, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2592, res ) ==((sel)( , var_h2589, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h2592, other ) ==(sel)( , var_h2589, other ) => 
 	 Rel (sel)( , var__temp_h2592, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2592, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2594, res ) ==(var__temp_v2593) AND 
 	 Rel (sel)( , var__temp_h'2594, res ) ==((sel)( , var__temp_h2592, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2594, other ) ==(sel)( , var__temp_h2592, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2594, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2594, other ) > (4)
 
VC_END(declare-const var_h_i2590 T9265)
(declare-const var_h2589 T9265)
(declare-const v Int)
(declare-const var_h_i2562 T9265)
(declare-const var_h2561 T9265)
(declare-const v Int)
(declare-const var_h_i2530 T9265)
(declare-const var_h2529 T9265)
(declare-const v Int)
(declare-const var_h_i2494 T9265)
(declare-const var_h2493 T9265)
(declare-const v Int)
(declare-const var_h_i2450 T9265)
(declare-const var_h2449 T9265)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2592 T9265)
(declare-const var__temp_v2593 Int)
(declare-const |var__temp_h'2594| T9265)
(declare-const var__temp_v_err2595 T9266)
(declare-const var_h2589 T9265)
(declare-const var_h2561 T9265)
(declare-const var_h2529 T9265)
(declare-const var_h2493 T9265)
(declare-const var_h2449 T9265)
(declare-const err T9279)

solver 
 (declare-sort T9265)
(declare-fun sel (T9265 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2589 () T9265)
(declare-fun var_h2529 () T9265)
(declare-fun var_h2449 () T9265)
(declare-fun other () Int)
(declare-fun |var__temp_h'2594| () T9265)
(declare-fun var__temp_h2592 () T9265)
(declare-fun var__temp_v2593 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2589 res) 5))
(assert (> (sel var_h2529 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2592 res) v)
                (= (sel var__temp_h2592 res) (+ (sel var_h2589 res) 2))
                (= (sel var__temp_h2592 other) (sel var_h2589 other))))
      (a!2 (and (= (sel |var__temp_h'2594| res) var__temp_v2593)
                (= (sel |var__temp_h'2594| res) (+ (sel var__temp_h2592 res) 3))
                (= (sel |var__temp_h'2594| other) (sel var__temp_h2592 other))))
      (a!3 (and (= (sel |var__temp_h'2594| res) 10)
                (not (> (sel |var__temp_h'2594| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2592 res) 7))
                (=> (= (sel var__temp_h2592 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************707
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2590 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2590, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2590, res ) ==((sel)( , var_h2589, res ) + (2))
 	 , (sel)( , var_h_i2590, other ) ==(sel)( , var_h2589, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2591:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2590 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2590 --->  Ty_heap  
 var_h2589 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2562 --->  Ty_heap  
 var_h2561 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2530 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2596 --->  Ty_heap  
 var__temp_v2597 --->  Ty_int  
 var__temp_h'2598 --->  Ty_heap  
 var__temp_v_err2599 --->  error  
 var_h2589 --->  Ty_heap  
 var_h2561 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h2589, res ) ==(5) AND 
 	 Rel (sel)( , var_h2529, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2596, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2596, res ) ==((sel)( , var_h2589, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h2596, other ) ==(sel)( , var_h2589, other ) => 
 	 Rel (sel)( , var__temp_h2596, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2596, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2598, res ) ==(var__temp_v2597) AND 
 	 Rel (sel)( , var__temp_h'2598, res ) ==((sel)( , var__temp_h2596, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2598, other ) ==(sel)( , var__temp_h2596, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2598, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2598, other ) > (4)
 
VC_END(declare-const var_h_i2590 T9282)
(declare-const var_h2589 T9282)
(declare-const v Int)
(declare-const var_h_i2562 T9282)
(declare-const var_h2561 T9282)
(declare-const v Int)
(declare-const var_h_i2530 T9282)
(declare-const var_h2529 T9282)
(declare-const v Int)
(declare-const var_h_i2494 T9282)
(declare-const var_h2493 T9282)
(declare-const v Int)
(declare-const var_h_i2450 T9282)
(declare-const var_h2449 T9282)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2596 T9282)
(declare-const var__temp_v2597 Int)
(declare-const |var__temp_h'2598| T9282)
(declare-const var__temp_v_err2599 T9283)
(declare-const var_h2589 T9282)
(declare-const var_h2561 T9282)
(declare-const var_h2529 T9282)
(declare-const var_h2493 T9282)
(declare-const var_h2449 T9282)
(declare-const err T9296)

solver 
 (declare-sort T9282)
(declare-fun sel (T9282 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2589 () T9282)
(declare-fun var_h2529 () T9282)
(declare-fun var_h2449 () T9282)
(declare-fun other () Int)
(declare-fun |var__temp_h'2598| () T9282)
(declare-fun var__temp_h2596 () T9282)
(declare-fun var__temp_v2597 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2589 res) 5))
(assert (> (sel var_h2529 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2596 res) v)
                (= (sel var__temp_h2596 res) (+ (sel var_h2589 res) 2))
                (= (sel var__temp_h2596 other) (sel var_h2589 other))))
      (a!2 (and (= (sel |var__temp_h'2598| res) var__temp_v2597)
                (= (sel |var__temp_h'2598| res) (+ (sel var__temp_h2596 res) 5))
                (= (sel |var__temp_h'2598| other) (sel var__temp_h2596 other))))
      (a!3 (and (= (sel |var__temp_h'2598| res) 10)
                (not (> (sel |var__temp_h'2598| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2596 res) 7))
                (=> (= (sel var__temp_h2596 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************708
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2591:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2591:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbarfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2590 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2590, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2590, res ) ==((sel)( , var_h2589, res ) + (2))
 	 , (sel)( , var_h_i2590, other ) ==(sel)( , var_h2589, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2600:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************709
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2590 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2590, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2590, res ) ==((sel)( , var_h2589, res ) + (2))
 	 , (sel)( , var_h_i2590, other ) ==(sel)( , var_h2589, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2600:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2590 --->  Ty_heap  
 var_h2589 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2562 --->  Ty_heap  
 var_h2561 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2530 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2601 --->  Ty_heap  
 var__temp_v2602 --->  Ty_int  
 var__temp_h'2603 --->  Ty_heap  
 var__temp_v_err2604 --->  error  
 var_h2589 --->  Ty_heap  
 var_h2561 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h2589, res ) ==(5) AND 
 	 Rel (sel)( , var_h2529, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2601, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2601, res ) ==((sel)( , var_h2589, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h2601, other ) ==(sel)( , var_h2589, other ) => 
 	 Rel (sel)( , var__temp_h2601, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2601, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2603, res ) ==(var__temp_v2602) AND 
 	 Rel (sel)( , var__temp_h'2603, res ) ==((sel)( , var__temp_h2601, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2603, other ) ==(sel)( , var__temp_h2601, other ) => 
 	 True
 
VC_END(declare-const var_h_i2590 T9299)
(declare-const var_h2589 T9299)
(declare-const v Int)
(declare-const var_h_i2562 T9299)
(declare-const var_h2561 T9299)
(declare-const v Int)
(declare-const var_h_i2530 T9299)
(declare-const var_h2529 T9299)
(declare-const v Int)
(declare-const var_h_i2494 T9299)
(declare-const var_h2493 T9299)
(declare-const v Int)
(declare-const var_h_i2450 T9299)
(declare-const var_h2449 T9299)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2601 T9299)
(declare-const var__temp_v2602 Int)
(declare-const |var__temp_h'2603| T9299)
(declare-const var__temp_v_err2604 T9300)
(declare-const var_h2589 T9299)
(declare-const var_h2561 T9299)
(declare-const var_h2529 T9299)
(declare-const var_h2493 T9299)
(declare-const var_h2449 T9299)
(declare-const err T9313)

solver 
 (declare-sort T9299)
(declare-fun sel (T9299 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2589 () T9299)
(declare-fun var_h2529 () T9299)
(declare-fun var_h2449 () T9299)
(declare-fun other () Int)
(declare-fun var__temp_h2601 () T9299)
(declare-fun |var__temp_h'2603| () T9299)
(declare-fun var__temp_v2602 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2589 res) 5))
(assert (> (sel var_h2529 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2601 res) v)
                (= (sel var__temp_h2601 res) (+ (sel var_h2589 res) 2))
                (= (sel var__temp_h2601 other) (sel var_h2589 other))))
      (a!2 (and (= (sel |var__temp_h'2603| res) var__temp_v2602)
                (= (sel |var__temp_h'2603| res) (+ (sel var__temp_h2601 res) 3))
                (= (sel |var__temp_h'2603| other) (sel var__temp_h2601 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2601 res) 7))
                (=> (= (sel var__temp_h2601 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************baz
PARTIAL PATH NEW
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c2'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2606 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2606 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2606, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2606, res ) ==((sel)( , var_h2605, res ) + (3))
 	 , (sel)( , var_h_i2606, other ) ==(sel)( , var_h2605, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2607:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2606 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************710
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2606 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2606, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2606, res ) ==((sel)( , var_h2605, res ) + (3))
 	 , (sel)( , var_h_i2606, other ) ==(sel)( , var_h2605, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2607:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2606 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2606 --->  Ty_heap  
 var_h2605 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2590 --->  Ty_heap  
 var_h2589 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2562 --->  Ty_heap  
 var_h2561 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2530 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2608 --->  Ty_heap  
 var__temp_v2609 --->  Ty_int  
 var__temp_h'2610 --->  Ty_heap  
 var__temp_v_err2611 --->  error  
 var_h2605 --->  Ty_heap  
 var_h2589 --->  Ty_heap  
 var_h2561 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h2605, res ) ==(7) AND 
 	 Rel (sel)( , var_h2589, res ) ==(5) AND 
 	 Rel (sel)( , var_h2529, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2608, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2608, res ) ==((sel)( , var_h2605, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h2608, other ) ==(sel)( , var_h2605, other ) => 
 	 Rel (sel)( , var__temp_h2608, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2608, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2610, res ) ==(var__temp_v2609) AND 
 	 Rel (sel)( , var__temp_h'2610, res ) ==((sel)( , var__temp_h2608, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2610, other ) ==(sel)( , var__temp_h2608, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2610, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2610, other ) > (4)
 
VC_END(declare-const var_h_i2606 T9316)
(declare-const var_h2605 T9316)
(declare-const v Int)
(declare-const var_h_i2590 T9316)
(declare-const var_h2589 T9316)
(declare-const v Int)
(declare-const var_h_i2562 T9316)
(declare-const var_h2561 T9316)
(declare-const v Int)
(declare-const var_h_i2530 T9316)
(declare-const var_h2529 T9316)
(declare-const v Int)
(declare-const var_h_i2494 T9316)
(declare-const var_h2493 T9316)
(declare-const v Int)
(declare-const var_h_i2450 T9316)
(declare-const var_h2449 T9316)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2608 T9316)
(declare-const var__temp_v2609 Int)
(declare-const |var__temp_h'2610| T9316)
(declare-const var__temp_v_err2611 T9317)
(declare-const var_h2605 T9316)
(declare-const var_h2589 T9316)
(declare-const var_h2561 T9316)
(declare-const var_h2529 T9316)
(declare-const var_h2493 T9316)
(declare-const var_h2449 T9316)
(declare-const err T9330)

solver 
 (declare-sort T9316)
(declare-fun sel (T9316 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2605 () T9316)
(declare-fun var_h2589 () T9316)
(declare-fun var_h2529 () T9316)
(declare-fun var_h2449 () T9316)
(declare-fun other () Int)
(declare-fun |var__temp_h'2610| () T9316)
(declare-fun var__temp_h2608 () T9316)
(declare-fun var__temp_v2609 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2605 res) 7))
(assert (= (sel var_h2589 res) 5))
(assert (> (sel var_h2529 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2608 res) v)
                (= (sel var__temp_h2608 res) (+ (sel var_h2605 res) 3))
                (= (sel var__temp_h2608 other) (sel var_h2605 other))))
      (a!2 (and (= (sel |var__temp_h'2610| res) var__temp_v2609)
                (= (sel |var__temp_h'2610| res) (+ (sel var__temp_h2608 res) 5))
                (= (sel |var__temp_h'2610| other) (sel var__temp_h2608 other))))
      (a!3 (and (= (sel |var__temp_h'2610| res) 10)
                (not (> (sel |var__temp_h'2610| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2608 res) 7))
                (=> (= (sel var__temp_h2608 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************711
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2607:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2607:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbazbarfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2606 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2606, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2606, res ) ==((sel)( , var_h2605, res ) + (3))
 	 , (sel)( , var_h_i2606, other ) ==(sel)( , var_h2605, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2612:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************712
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2606 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2606, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2606, res ) ==((sel)( , var_h2605, res ) + (3))
 	 , (sel)( , var_h_i2606, other ) ==(sel)( , var_h2605, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2612:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2606 --->  Ty_heap  
 var_h2605 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2590 --->  Ty_heap  
 var_h2589 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2562 --->  Ty_heap  
 var_h2561 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2530 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2613 --->  Ty_heap  
 var__temp_v2614 --->  Ty_int  
 var__temp_h'2615 --->  Ty_heap  
 var__temp_v_err2616 --->  error  
 var_h2605 --->  Ty_heap  
 var_h2589 --->  Ty_heap  
 var_h2561 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h2605, res ) ==(7) AND 
 	 Rel (sel)( , var_h2589, res ) ==(5) AND 
 	 Rel (sel)( , var_h2529, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2613, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2613, res ) ==((sel)( , var_h2605, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h2613, other ) ==(sel)( , var_h2605, other ) => 
 	 Rel (sel)( , var__temp_h2613, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2613, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2615, res ) ==(var__temp_v2614) AND 
 	 Rel (sel)( , var__temp_h'2615, res ) ==((sel)( , var__temp_h2613, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2615, other ) ==(sel)( , var__temp_h2613, other ) => 
 	 True
 
VC_END(declare-const var_h_i2606 T9333)
(declare-const var_h2605 T9333)
(declare-const v Int)
(declare-const var_h_i2590 T9333)
(declare-const var_h2589 T9333)
(declare-const v Int)
(declare-const var_h_i2562 T9333)
(declare-const var_h2561 T9333)
(declare-const v Int)
(declare-const var_h_i2530 T9333)
(declare-const var_h2529 T9333)
(declare-const v Int)
(declare-const var_h_i2494 T9333)
(declare-const var_h2493 T9333)
(declare-const v Int)
(declare-const var_h_i2450 T9333)
(declare-const var_h2449 T9333)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2613 T9333)
(declare-const var__temp_v2614 Int)
(declare-const |var__temp_h'2615| T9333)
(declare-const var__temp_v_err2616 T9334)
(declare-const var_h2605 T9333)
(declare-const var_h2589 T9333)
(declare-const var_h2561 T9333)
(declare-const var_h2529 T9333)
(declare-const var_h2493 T9333)
(declare-const var_h2449 T9333)
(declare-const err T9347)

solver 
 (declare-sort T9333)
(declare-fun sel (T9333 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2605 () T9333)
(declare-fun var_h2589 () T9333)
(declare-fun var_h2529 () T9333)
(declare-fun var_h2449 () T9333)
(declare-fun other () Int)
(declare-fun var__temp_h2613 () T9333)
(declare-fun |var__temp_h'2615| () T9333)
(declare-fun var__temp_v2614 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2605 res) 7))
(assert (= (sel var_h2589 res) 5))
(assert (> (sel var_h2529 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2613 res) v)
                (= (sel var__temp_h2613 res) (+ (sel var_h2605 res) 3))
                (= (sel var__temp_h2613 other) (sel var_h2605 other))))
      (a!2 (and (= (sel |var__temp_h'2615| res) var__temp_v2614)
                (= (sel |var__temp_h'2615| res) (+ (sel var__temp_h2613 res) 5))
                (= (sel |var__temp_h'2615| other) (sel var__temp_h2613 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2613 res) 7))
                (=> (= (sel var__temp_h2613 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************713
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT baz
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2590 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2590, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2590, res ) ==((sel)( , var_h2589, res ) + (2))
 	 , (sel)( , var_h_i2590, other ) ==(sel)( , var_h2589, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2617:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************714
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2590 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2590, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2590, res ) ==((sel)( , var_h2589, res ) + (2))
 	 , (sel)( , var_h_i2590, other ) ==(sel)( , var_h2589, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2617:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2590 --->  Ty_heap  
 var_h2589 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2562 --->  Ty_heap  
 var_h2561 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2530 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2618 --->  Ty_heap  
 var__temp_v2619 --->  Ty_int  
 var__temp_h'2620 --->  Ty_heap  
 var__temp_v_err2621 --->  error  
 var_h2589 --->  Ty_heap  
 var_h2561 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h2589, res ) ==(5) AND 
 	 Rel (sel)( , var_h2529, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2618, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2618, res ) ==((sel)( , var_h2589, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h2618, other ) ==(sel)( , var_h2589, other ) => 
 	 Rel (sel)( , var__temp_h2618, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2618, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2620, res ) ==(var__temp_v2619) AND 
 	 Rel (sel)( , var__temp_h'2620, res ) ==((sel)( , var__temp_h2618, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2620, other ) ==(sel)( , var__temp_h2618, other ) => 
 	 True
 
VC_END(declare-const var_h_i2590 T9350)
(declare-const var_h2589 T9350)
(declare-const v Int)
(declare-const var_h_i2562 T9350)
(declare-const var_h2561 T9350)
(declare-const v Int)
(declare-const var_h_i2530 T9350)
(declare-const var_h2529 T9350)
(declare-const v Int)
(declare-const var_h_i2494 T9350)
(declare-const var_h2493 T9350)
(declare-const v Int)
(declare-const var_h_i2450 T9350)
(declare-const var_h2449 T9350)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2618 T9350)
(declare-const var__temp_v2619 Int)
(declare-const |var__temp_h'2620| T9350)
(declare-const var__temp_v_err2621 T9351)
(declare-const var_h2589 T9350)
(declare-const var_h2561 T9350)
(declare-const var_h2529 T9350)
(declare-const var_h2493 T9350)
(declare-const var_h2449 T9350)
(declare-const err T9364)

solver 
 (declare-sort T9350)
(declare-fun sel (T9350 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2589 () T9350)
(declare-fun var_h2529 () T9350)
(declare-fun var_h2449 () T9350)
(declare-fun other () Int)
(declare-fun var__temp_h2618 () T9350)
(declare-fun |var__temp_h'2620| () T9350)
(declare-fun var__temp_v2619 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2589 res) 5))
(assert (> (sel var_h2529 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2618 res) v)
                (= (sel var__temp_h2618 res) (+ (sel var_h2589 res) 2))
                (= (sel var__temp_h2618 other) (sel var_h2589 other))))
      (a!2 (and (= (sel |var__temp_h'2620| res) var__temp_v2619)
                (= (sel |var__temp_h'2620| res) (+ (sel var__temp_h2618 res) 5))
                (= (sel |var__temp_h'2620| other) (sel var__temp_h2618 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2618 res) 7))
                (=> (= (sel var__temp_h2618 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c5
PARTIAL PATH NEW
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c2'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2623 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2623 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2623, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2623, res ) ==((sel)( , var_h2622, res ) + (5))
 	 , (sel)( , var_h_i2623, other ) ==(sel)( , var_h2622, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2624:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2623 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************715
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2624:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2624:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc5bazbarfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2623 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2623, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2623, res ) ==((sel)( , var_h2622, res ) + (5))
 	 , (sel)( , var_h_i2623, other ) ==(sel)( , var_h2622, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2625:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************716
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2590 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2590, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2590, res ) ==((sel)( , var_h2589, res ) + (2))
 	 , (sel)( , var_h_i2590, other ) ==(sel)( , var_h2589, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2626:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************717
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --foo
 	 --c2
 	 --foo'
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2562 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2562, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2562, other ) ==(sel)( , var_h2561, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2627:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************718
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2562 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2562, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2562, other ) ==(sel)( , var_h2561, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2627:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2562 --->  Ty_heap  
 var_h2561 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2530 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2628 --->  Ty_heap  
 var__temp_v2629 --->  Ty_int  
 var__temp_h'2630 --->  Ty_heap  
 var__temp_v_err2631 --->  error  
 var_h2561 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2529, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2628, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2628, other ) ==(sel)( , var_h2561, other ) => 
 	 Rel (sel)( , var__temp_h2628, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2628, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2630, res ) ==(var__temp_v2629) AND 
 	 Rel (sel)( , var__temp_h'2630, res ) ==((sel)( , var__temp_h2628, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2630, other ) ==(sel)( , var__temp_h2628, other ) => 
 	 True
 
VC_END(declare-const var_h_i2562 T9367)
(declare-const var_h2561 T9367)
(declare-const v Int)
(declare-const var_h_i2530 T9367)
(declare-const var_h2529 T9367)
(declare-const v Int)
(declare-const var_h_i2494 T9367)
(declare-const var_h2493 T9367)
(declare-const v Int)
(declare-const var_h_i2450 T9367)
(declare-const var_h2449 T9367)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2628 T9367)
(declare-const var__temp_v2629 Int)
(declare-const |var__temp_h'2630| T9367)
(declare-const var__temp_v_err2631 T9368)
(declare-const var_h2561 T9367)
(declare-const var_h2529 T9367)
(declare-const var_h2493 T9367)
(declare-const var_h2449 T9367)
(declare-const err T9381)
    (declare-const |5| Int)
  
solver 
 (declare-sort T9367)
(declare-fun sel (T9367 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2529 () T9367)
(declare-fun var_h2449 () T9367)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2628 () T9367)
(declare-fun |var__temp_h'2630| () T9367)
(declare-fun var__temp_v2629 () Int)
(declare-fun var_h2561 () T9367)
(declare-fun v () Int)
(assert (> (sel var_h2529 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2628 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2628 other) (sel var_h2561 other)))
               (= (sel var__temp_h2628 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2630| res) var__temp_v2629)
                (= (sel |var__temp_h'2630| res) (+ (sel var__temp_h2628 res) 3))
                (= (sel |var__temp_h'2630| other) (sel var__temp_h2628 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2628 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************719
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2562 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2562, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2562, other ) ==(sel)( , var_h2561, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2627:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2562 --->  Ty_heap  
 var_h2561 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2530 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2632 --->  Ty_heap  
 var__temp_v2633 --->  Ty_int  
 var__temp_h'2634 --->  Ty_heap  
 var__temp_v_err2635 --->  error  
 var_h2561 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2529, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2632, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2632, other ) ==(sel)( , var_h2561, other ) => 
 	 Rel (sel)( , var__temp_h2632, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2632, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2634, res ) ==(var__temp_v2633) AND 
 	 Rel (sel)( , var__temp_h'2634, res ) ==((sel)( , var__temp_h2632, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2634, other ) ==(sel)( , var__temp_h2632, other ) => 
 	 True
 
VC_END(declare-const var_h_i2562 T9384)
(declare-const var_h2561 T9384)
(declare-const v Int)
(declare-const var_h_i2530 T9384)
(declare-const var_h2529 T9384)
(declare-const v Int)
(declare-const var_h_i2494 T9384)
(declare-const var_h2493 T9384)
(declare-const v Int)
(declare-const var_h_i2450 T9384)
(declare-const var_h2449 T9384)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2632 T9384)
(declare-const var__temp_v2633 Int)
(declare-const |var__temp_h'2634| T9384)
(declare-const var__temp_v_err2635 T9385)
(declare-const var_h2561 T9384)
(declare-const var_h2529 T9384)
(declare-const var_h2493 T9384)
(declare-const var_h2449 T9384)
(declare-const err T9398)
    (declare-const |5| Int)
  
solver 
 (declare-sort T9384)
(declare-fun sel (T9384 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2529 () T9384)
(declare-fun var_h2449 () T9384)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2632 () T9384)
(declare-fun |var__temp_h'2634| () T9384)
(declare-fun var__temp_v2633 () Int)
(declare-fun var_h2561 () T9384)
(declare-fun v () Int)
(assert (> (sel var_h2529 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2632 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2632 other) (sel var_h2561 other)))
               (= (sel var__temp_h2632 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2634| res) var__temp_v2633)
                (= (sel |var__temp_h'2634| res) (+ (sel var__temp_h2632 res) 5))
                (= (sel |var__temp_h'2634| other) (sel var__temp_h2632 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2632 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************720
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT bar
PARTIAL PATH
SUB 
 	 --c2
 	 --foo'
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2530 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2530, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2530, res ) ==((sel)( , var_h2529, res ) + (10))
 	 , (sel)( , var_h_i2530, other ) ==(sel)( , var_h2529, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2636:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************721
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2530 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2530, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2530, res ) ==((sel)( , var_h2529, res ) + (10))
 	 , (sel)( , var_h_i2530, other ) ==(sel)( , var_h2529, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2636:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2530 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2637 --->  Ty_heap  
 var__temp_v2638 --->  Ty_int  
 var__temp_h'2639 --->  Ty_heap  
 var__temp_v_err2640 --->  error  
 var_h2529 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2529, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2637, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2637, res ) ==((sel)( , var_h2529, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2637, other ) ==(sel)( , var_h2529, other ) => 
 	 Rel (sel)( , var__temp_h2637, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2637, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2639, res ) ==(var__temp_v2638) AND 
 	 Rel (sel)( , var__temp_h'2639, res ) ==((sel)( , var__temp_h2637, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2639, other ) ==(sel)( , var__temp_h2637, other ) => 
 	 True
 
VC_END(declare-const var_h_i2530 T9401)
(declare-const var_h2529 T9401)
(declare-const v Int)
(declare-const var_h_i2494 T9401)
(declare-const var_h2493 T9401)
(declare-const v Int)
(declare-const var_h_i2450 T9401)
(declare-const var_h2449 T9401)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2637 T9401)
(declare-const var__temp_v2638 Int)
(declare-const |var__temp_h'2639| T9401)
(declare-const var__temp_v_err2640 T9402)
(declare-const var_h2529 T9401)
(declare-const var_h2493 T9401)
(declare-const var_h2449 T9401)
(declare-const err T9415)

solver 
 (declare-sort T9401)
(declare-fun sel (T9401 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2529 () T9401)
(declare-fun var_h2449 () T9401)
(declare-fun other () Int)
(declare-fun var__temp_h2637 () T9401)
(declare-fun |var__temp_h'2639| () T9401)
(declare-fun var__temp_v2638 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2529 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2637 res) v)
                (= (sel var__temp_h2637 res) (+ (sel var_h2529 res) 10))
                (= (sel var__temp_h2637 other) (sel var_h2529 other))))
      (a!2 (and (= (sel |var__temp_h'2639| res) var__temp_v2638)
                (= (sel |var__temp_h'2639| res) (+ (sel var__temp_h2637 res) 3))
                (= (sel |var__temp_h'2639| other) (sel var__temp_h2637 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2637 res) 7))
                (=> (= (sel var__temp_h2637 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************722
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2530 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2530, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2530, res ) ==((sel)( , var_h2529, res ) + (10))
 	 , (sel)( , var_h_i2530, other ) ==(sel)( , var_h2529, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2636:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2530 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2641 --->  Ty_heap  
 var__temp_v2642 --->  Ty_int  
 var__temp_h'2643 --->  Ty_heap  
 var__temp_v_err2644 --->  error  
 var_h2529 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2529, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2641, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2641, res ) ==((sel)( , var_h2529, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2641, other ) ==(sel)( , var_h2529, other ) => 
 	 Rel (sel)( , var__temp_h2641, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2641, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2643, res ) ==(var__temp_v2642) AND 
 	 Rel (sel)( , var__temp_h'2643, res ) ==((sel)( , var__temp_h2641, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2643, other ) ==(sel)( , var__temp_h2641, other ) => 
 	 True
 
VC_END(declare-const var_h_i2530 T9418)
(declare-const var_h2529 T9418)
(declare-const v Int)
(declare-const var_h_i2494 T9418)
(declare-const var_h2493 T9418)
(declare-const v Int)
(declare-const var_h_i2450 T9418)
(declare-const var_h2449 T9418)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2641 T9418)
(declare-const var__temp_v2642 Int)
(declare-const |var__temp_h'2643| T9418)
(declare-const var__temp_v_err2644 T9419)
(declare-const var_h2529 T9418)
(declare-const var_h2493 T9418)
(declare-const var_h2449 T9418)
(declare-const err T9432)

solver 
 (declare-sort T9418)
(declare-fun sel (T9418 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2529 () T9418)
(declare-fun var_h2449 () T9418)
(declare-fun other () Int)
(declare-fun var__temp_h2641 () T9418)
(declare-fun |var__temp_h'2643| () T9418)
(declare-fun var__temp_v2642 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2529 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2641 res) v)
                (= (sel var__temp_h2641 res) (+ (sel var_h2529 res) 10))
                (= (sel var__temp_h2641 other) (sel var_h2529 other))))
      (a!2 (and (= (sel |var__temp_h'2643| res) var__temp_v2642)
                (= (sel |var__temp_h'2643| res) (+ (sel var__temp_h2641 res) 5))
                (= (sel |var__temp_h'2643| other) (sel var__temp_h2641 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2641 res) 7))
                (=> (= (sel var__temp_h2641 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************723
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2530 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2530, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2530, res ) ==((sel)( , var_h2529, res ) + (10))
 	 , (sel)( , var_h_i2530, other ) ==(sel)( , var_h2529, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2636:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2530 --->  Ty_heap  
 var_h2529 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2645 --->  Ty_heap  
 var__temp_v2646 --->  Ty_int  
 var__temp_h'2647 --->  Ty_heap  
 var__temp_v_err2648 --->  error  
 var_h2529 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2529, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2645, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2645, res ) ==((sel)( , var_h2529, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2645, other ) ==(sel)( , var_h2529, other ) => 
 	 Rel (sel)( , var__temp_h2645, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2645, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2647, res ) ==(var__temp_v2646) AND 
 	 Rel (sel)( , var__temp_h'2647, res ) ==((sel)( , var__temp_h2645, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2647, other ) ==(sel)( , var__temp_h2645, other ) => 
 	 True
 
VC_END(declare-const var_h_i2530 T9435)
(declare-const var_h2529 T9435)
(declare-const v Int)
(declare-const var_h_i2494 T9435)
(declare-const var_h2493 T9435)
(declare-const v Int)
(declare-const var_h_i2450 T9435)
(declare-const var_h2449 T9435)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2645 T9435)
(declare-const var__temp_v2646 Int)
(declare-const |var__temp_h'2647| T9435)
(declare-const var__temp_v_err2648 T9436)
(declare-const var_h2529 T9435)
(declare-const var_h2493 T9435)
(declare-const var_h2449 T9435)
(declare-const err T9449)

solver 
 (declare-sort T9435)
(declare-fun sel (T9435 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2529 () T9435)
(declare-fun var_h2449 () T9435)
(declare-fun other () Int)
(declare-fun var__temp_h2645 () T9435)
(declare-fun |var__temp_h'2647| () T9435)
(declare-fun var__temp_v2646 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2529 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2645 res) v)
                (= (sel var__temp_h2645 res) (+ (sel var_h2529 res) 10))
                (= (sel var__temp_h2645 other) (sel var_h2529 other))))
      (a!2 (and (= (sel |var__temp_h'2647| res) var__temp_v2646)
                (= (sel |var__temp_h'2647| res) (+ (sel var__temp_h2645 res) 2))
                (= (sel |var__temp_h'2647| other) (sel var__temp_h2645 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2645 res) 5))
                (=> (= (sel var__temp_h2645 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************724
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo
PARTIAL PATH
SUB 
 	 --foo'
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2494 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2494, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2494, other ) ==(sel)( , var_h2493, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2649:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************725
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2494 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2494, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2494, other ) ==(sel)( , var_h2493, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2649:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2650 --->  Ty_heap  
 var__temp_v2651 --->  Ty_int  
 var__temp_h'2652 --->  Ty_heap  
 var__temp_v_err2653 --->  error  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2650, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h2650, other ) ==(sel)( , var_h2493, other ) => 
 	 Rel (sel)( , var__temp_h2650, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2650, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2652, res ) ==(var__temp_v2651) AND 
 	 Rel (sel)( , var__temp_h'2652, res ) ==((sel)( , var__temp_h2650, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2652, other ) ==(sel)( , var__temp_h2650, other ) => 
 	 True
 
VC_END(declare-const var_h_i2494 T9452)
(declare-const var_h2493 T9452)
(declare-const v Int)
(declare-const var_h_i2450 T9452)
(declare-const var_h2449 T9452)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2650 T9452)
(declare-const var__temp_v2651 Int)
(declare-const |var__temp_h'2652| T9452)
(declare-const var__temp_v_err2653 T9453)
(declare-const var_h2493 T9452)
(declare-const var_h2449 T9452)
(declare-const err T9466)
    (declare-const |20| Int)
  
solver 
 (declare-sort T9452)
(declare-fun sel (T9452 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T9452)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2650 () T9452)
(declare-fun |var__temp_h'2652| () T9452)
(declare-fun var__temp_v2651 () Int)
(declare-fun var_h2493 () T9452)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2650 res) v)
                    (= v |20|)
                    (= (sel var__temp_h2650 other) (sel var_h2493 other)))
               (= (sel var__temp_h2650 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2652| res) var__temp_v2651)
                (= (sel |var__temp_h'2652| res) (+ (sel var__temp_h2650 res) 3))
                (= (sel |var__temp_h'2652| other) (sel var__temp_h2650 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2650 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************726
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2494 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2494, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2494, other ) ==(sel)( , var_h2493, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2649:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2654 --->  Ty_heap  
 var__temp_v2655 --->  Ty_int  
 var__temp_h'2656 --->  Ty_heap  
 var__temp_v_err2657 --->  error  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2654, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h2654, other ) ==(sel)( , var_h2493, other ) => 
 	 Rel (sel)( , var__temp_h2654, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2654, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2656, res ) ==(var__temp_v2655) AND 
 	 Rel (sel)( , var__temp_h'2656, res ) ==((sel)( , var__temp_h2654, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2656, other ) ==(sel)( , var__temp_h2654, other ) => 
 	 True
 
VC_END(declare-const var_h_i2494 T9469)
(declare-const var_h2493 T9469)
(declare-const v Int)
(declare-const var_h_i2450 T9469)
(declare-const var_h2449 T9469)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2654 T9469)
(declare-const var__temp_v2655 Int)
(declare-const |var__temp_h'2656| T9469)
(declare-const var__temp_v_err2657 T9470)
(declare-const var_h2493 T9469)
(declare-const var_h2449 T9469)
(declare-const err T9483)
    (declare-const |20| Int)
  
solver 
 (declare-sort T9469)
(declare-fun sel (T9469 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T9469)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2654 () T9469)
(declare-fun |var__temp_h'2656| () T9469)
(declare-fun var__temp_v2655 () Int)
(declare-fun var_h2493 () T9469)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2654 res) v)
                    (= v |20|)
                    (= (sel var__temp_h2654 other) (sel var_h2493 other)))
               (= (sel var__temp_h2654 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2656| res) var__temp_v2655)
                (= (sel |var__temp_h'2656| res) (+ (sel var__temp_h2654 res) 5))
                (= (sel |var__temp_h'2656| other) (sel var__temp_h2654 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2654 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************727
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2494 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2494, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2494, other ) ==(sel)( , var_h2493, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2649:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2658 --->  Ty_heap  
 var__temp_v2659 --->  Ty_int  
 var__temp_h'2660 --->  Ty_heap  
 var__temp_v_err2661 --->  error  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2658, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h2658, other ) ==(sel)( , var_h2493, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2660, res ) ==(var__temp_v2659) AND 
 	 Base var__temp_v2659 = 5 AND 
 	 Rel (sel)( , var__temp_h'2660, other ) ==(sel)( , var__temp_h2658, other ) => 
 	 True
 
VC_END(declare-const var_h_i2494 T9486)
(declare-const var_h2493 T9486)
(declare-const v Int)
(declare-const var_h_i2450 T9486)
(declare-const var_h2449 T9486)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2658 T9486)
(declare-const var__temp_v2659 Int)
(declare-const |var__temp_h'2660| T9486)
(declare-const var__temp_v_err2661 T9487)
(declare-const var_h2493 T9486)
(declare-const var_h2449 T9486)
(declare-const err T9500)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T9486)
(declare-fun sel (T9486 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T9486)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2658 () T9486)
(declare-fun |var__temp_h'2660| () T9486)
(declare-fun var__temp_v2659 () Int)
(declare-fun var_h2493 () T9486)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2658 res) v)
                    (= v |20|)
                    (= (sel var__temp_h2658 other) (sel var_h2493 other)))
               true))
      (a!2 (=> (and (= (sel |var__temp_h'2660| res) var__temp_v2659)
                    (= var__temp_v2659 |5|)
                    (= (sel |var__temp_h'2660| other)
                       (sel var__temp_h2658 other)))
               true)))
  (not (and a!1 (=> true a!2)))))

***************Selection Successful************foo
PARTIAL PATH NEW
SUB 
 	 --foo
 	 --foo'
 	 --c2'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2663 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2663 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2663, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2663, other ) ==(sel)( , var_h2662, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2664:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2663 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************728
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2663 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2663, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2663, other ) ==(sel)( , var_h2662, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2664:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2663 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2663 --->  Ty_heap  
 var_h2662 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2665 --->  Ty_heap  
 var__temp_v2666 --->  Ty_int  
 var__temp_h'2667 --->  Ty_heap  
 var__temp_v_err2668 --->  error  
 var_h2662 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2665, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2665, other ) ==(sel)( , var_h2662, other ) => 
 	 Rel (sel)( , var__temp_h2665, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2665, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2667, res ) ==(var__temp_v2666) AND 
 	 Rel (sel)( , var__temp_h'2667, res ) ==((sel)( , var__temp_h2665, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2667, other ) ==(sel)( , var__temp_h2665, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2667, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2667, other ) > (4)
 
VC_END(declare-const var_h_i2663 T9503)
(declare-const var_h2662 T9503)
(declare-const v Int)
(declare-const var_h_i2494 T9503)
(declare-const var_h2493 T9503)
(declare-const v Int)
(declare-const var_h_i2450 T9503)
(declare-const var_h2449 T9503)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2665 T9503)
(declare-const var__temp_v2666 Int)
(declare-const |var__temp_h'2667| T9503)
(declare-const var__temp_v_err2668 T9504)
(declare-const var_h2662 T9503)
(declare-const var_h2493 T9503)
(declare-const var_h2449 T9503)
(declare-const err T9517)
    (declare-const |5| Int)
  
solver 
 (declare-sort T9503)
(declare-fun sel (T9503 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T9503)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2667| () T9503)
(declare-fun var__temp_h2665 () T9503)
(declare-fun var__temp_v2666 () Int)
(declare-fun var_h2662 () T9503)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2665 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2665 other) (sel var_h2662 other)))
               (= (sel var__temp_h2665 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2667| res) var__temp_v2666)
                (= (sel |var__temp_h'2667| res) (+ (sel var__temp_h2665 res) 3))
                (= (sel |var__temp_h'2667| other) (sel var__temp_h2665 other))))
      (a!3 (and (= (sel |var__temp_h'2667| res) 10)
                (not (> (sel |var__temp_h'2667| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2665 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************729
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2663 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2663, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2663, other ) ==(sel)( , var_h2662, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2664:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2663 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2663 --->  Ty_heap  
 var_h2662 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2669 --->  Ty_heap  
 var__temp_v2670 --->  Ty_int  
 var__temp_h'2671 --->  Ty_heap  
 var__temp_v_err2672 --->  error  
 var_h2662 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2669, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2669, other ) ==(sel)( , var_h2662, other ) => 
 	 Rel (sel)( , var__temp_h2669, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2669, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2671, res ) ==(var__temp_v2670) AND 
 	 Rel (sel)( , var__temp_h'2671, res ) ==((sel)( , var__temp_h2669, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2671, other ) ==(sel)( , var__temp_h2669, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2671, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2671, other ) > (4)
 
VC_END(declare-const var_h_i2663 T9520)
(declare-const var_h2662 T9520)
(declare-const v Int)
(declare-const var_h_i2494 T9520)
(declare-const var_h2493 T9520)
(declare-const v Int)
(declare-const var_h_i2450 T9520)
(declare-const var_h2449 T9520)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2669 T9520)
(declare-const var__temp_v2670 Int)
(declare-const |var__temp_h'2671| T9520)
(declare-const var__temp_v_err2672 T9521)
(declare-const var_h2662 T9520)
(declare-const var_h2493 T9520)
(declare-const var_h2449 T9520)
(declare-const err T9534)
    (declare-const |5| Int)
  
solver 
 (declare-sort T9520)
(declare-fun sel (T9520 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T9520)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2671| () T9520)
(declare-fun var__temp_h2669 () T9520)
(declare-fun var__temp_v2670 () Int)
(declare-fun var_h2662 () T9520)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2669 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2669 other) (sel var_h2662 other)))
               (= (sel var__temp_h2669 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2671| res) var__temp_v2670)
                (= (sel |var__temp_h'2671| res) (+ (sel var__temp_h2669 res) 5))
                (= (sel |var__temp_h'2671| other) (sel var__temp_h2669 other))))
      (a!3 (and (= (sel |var__temp_h'2671| res) 10)
                (not (> (sel |var__temp_h'2671| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2669 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************730
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2663 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2663, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2663, other ) ==(sel)( , var_h2662, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2664:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2663 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2663 --->  Ty_heap  
 var_h2662 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2673 --->  Ty_heap  
 var__temp_v2674 --->  Ty_int  
 var__temp_h'2675 --->  Ty_heap  
 var__temp_v_err2676 --->  error  
 var_h2662 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2673, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2673, other ) ==(sel)( , var_h2662, other ) => 
 	 Rel (sel)( , var__temp_h2673, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2673, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2675, res ) ==(var__temp_v2674) AND 
 	 Rel (sel)( , var__temp_h'2675, res ) ==((sel)( , var__temp_h2673, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2675, other ) ==(sel)( , var__temp_h2673, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2675, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2675, other ) > (4)
 
VC_END(declare-const var_h_i2663 T9537)
(declare-const var_h2662 T9537)
(declare-const v Int)
(declare-const var_h_i2494 T9537)
(declare-const var_h2493 T9537)
(declare-const v Int)
(declare-const var_h_i2450 T9537)
(declare-const var_h2449 T9537)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2673 T9537)
(declare-const var__temp_v2674 Int)
(declare-const |var__temp_h'2675| T9537)
(declare-const var__temp_v_err2676 T9538)
(declare-const var_h2662 T9537)
(declare-const var_h2493 T9537)
(declare-const var_h2449 T9537)
(declare-const err T9551)
    (declare-const |5| Int)
  
solver 
 (declare-sort T9537)
(declare-fun sel (T9537 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T9537)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2675| () T9537)
(declare-fun var__temp_h2673 () T9537)
(declare-fun var__temp_v2674 () Int)
(declare-fun var_h2662 () T9537)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2673 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2673 other) (sel var_h2662 other)))
               (= (sel var__temp_h2673 res) 5)))
      (a!2 (and (= (sel |var__temp_h'2675| res) var__temp_v2674)
                (= (sel |var__temp_h'2675| res) (+ (sel var__temp_h2673 res) 2))
                (= (sel |var__temp_h'2675| other) (sel var__temp_h2673 other))))
      (a!3 (and (= (sel |var__temp_h'2675| res) 10)
                (not (> (sel |var__temp_h'2675| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2673 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************731
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2664:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2664:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --foo
 	 --foo'
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2663 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2663, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2663, other ) ==(sel)( , var_h2662, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2677:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************732
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2663 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2663, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2663, other ) ==(sel)( , var_h2662, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2677:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2663 --->  Ty_heap  
 var_h2662 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2678 --->  Ty_heap  
 var__temp_v2679 --->  Ty_int  
 var__temp_h'2680 --->  Ty_heap  
 var__temp_v_err2681 --->  error  
 var_h2662 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2678, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2678, other ) ==(sel)( , var_h2662, other ) => 
 	 Rel (sel)( , var__temp_h2678, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2678, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2680, res ) ==(var__temp_v2679) AND 
 	 Rel (sel)( , var__temp_h'2680, res ) ==((sel)( , var__temp_h2678, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2680, other ) ==(sel)( , var__temp_h2678, other ) => 
 	 True
 
VC_END(declare-const var_h_i2663 T9554)
(declare-const var_h2662 T9554)
(declare-const v Int)
(declare-const var_h_i2494 T9554)
(declare-const var_h2493 T9554)
(declare-const v Int)
(declare-const var_h_i2450 T9554)
(declare-const var_h2449 T9554)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2678 T9554)
(declare-const var__temp_v2679 Int)
(declare-const |var__temp_h'2680| T9554)
(declare-const var__temp_v_err2681 T9555)
(declare-const var_h2662 T9554)
(declare-const var_h2493 T9554)
(declare-const var_h2449 T9554)
(declare-const err T9568)
    (declare-const |5| Int)
  
solver 
 (declare-sort T9554)
(declare-fun sel (T9554 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T9554)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2678 () T9554)
(declare-fun |var__temp_h'2680| () T9554)
(declare-fun var__temp_v2679 () Int)
(declare-fun var_h2662 () T9554)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2678 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2678 other) (sel var_h2662 other)))
               (= (sel var__temp_h2678 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2680| res) var__temp_v2679)
                (= (sel |var__temp_h'2680| res) (+ (sel var__temp_h2678 res) 3))
                (= (sel |var__temp_h'2680| other) (sel var__temp_h2678 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2678 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************733
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2663 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2663, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2663, other ) ==(sel)( , var_h2662, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2677:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2663 --->  Ty_heap  
 var_h2662 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2682 --->  Ty_heap  
 var__temp_v2683 --->  Ty_int  
 var__temp_h'2684 --->  Ty_heap  
 var__temp_v_err2685 --->  error  
 var_h2662 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2682, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2682, other ) ==(sel)( , var_h2662, other ) => 
 	 Rel (sel)( , var__temp_h2682, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2682, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2684, res ) ==(var__temp_v2683) AND 
 	 Rel (sel)( , var__temp_h'2684, res ) ==((sel)( , var__temp_h2682, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2684, other ) ==(sel)( , var__temp_h2682, other ) => 
 	 True
 
VC_END(declare-const var_h_i2663 T9571)
(declare-const var_h2662 T9571)
(declare-const v Int)
(declare-const var_h_i2494 T9571)
(declare-const var_h2493 T9571)
(declare-const v Int)
(declare-const var_h_i2450 T9571)
(declare-const var_h2449 T9571)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2682 T9571)
(declare-const var__temp_v2683 Int)
(declare-const |var__temp_h'2684| T9571)
(declare-const var__temp_v_err2685 T9572)
(declare-const var_h2662 T9571)
(declare-const var_h2493 T9571)
(declare-const var_h2449 T9571)
(declare-const err T9585)
    (declare-const |5| Int)
  
solver 
 (declare-sort T9571)
(declare-fun sel (T9571 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T9571)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2682 () T9571)
(declare-fun |var__temp_h'2684| () T9571)
(declare-fun var__temp_v2683 () Int)
(declare-fun var_h2662 () T9571)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2682 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2682 other) (sel var_h2662 other)))
               (= (sel var__temp_h2682 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2684| res) var__temp_v2683)
                (= (sel |var__temp_h'2684| res) (+ (sel var__temp_h2682 res) 5))
                (= (sel |var__temp_h'2684| other) (sel var__temp_h2682 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2682 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************734
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2663 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2663, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2663, other ) ==(sel)( , var_h2662, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2677:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2663 --->  Ty_heap  
 var_h2662 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2686 --->  Ty_heap  
 var__temp_v2687 --->  Ty_int  
 var__temp_h'2688 --->  Ty_heap  
 var__temp_v_err2689 --->  error  
 var_h2662 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2686, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2686, other ) ==(sel)( , var_h2662, other ) => 
 	 Rel (sel)( , var__temp_h2686, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2686, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2688, res ) ==(var__temp_v2687) AND 
 	 Rel (sel)( , var__temp_h'2688, res ) ==((sel)( , var__temp_h2686, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2688, other ) ==(sel)( , var__temp_h2686, other ) => 
 	 True
 
VC_END(declare-const var_h_i2663 T9588)
(declare-const var_h2662 T9588)
(declare-const v Int)
(declare-const var_h_i2494 T9588)
(declare-const var_h2493 T9588)
(declare-const v Int)
(declare-const var_h_i2450 T9588)
(declare-const var_h2449 T9588)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2686 T9588)
(declare-const var__temp_v2687 Int)
(declare-const |var__temp_h'2688| T9588)
(declare-const var__temp_v_err2689 T9589)
(declare-const var_h2662 T9588)
(declare-const var_h2493 T9588)
(declare-const var_h2449 T9588)
(declare-const err T9602)
    (declare-const |5| Int)
  
solver 
 (declare-sort T9588)
(declare-fun sel (T9588 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T9588)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2686 () T9588)
(declare-fun |var__temp_h'2688| () T9588)
(declare-fun var__temp_v2687 () Int)
(declare-fun var_h2662 () T9588)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2686 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2686 other) (sel var_h2662 other)))
               (= (sel var__temp_h2686 res) 5)))
      (a!2 (and (= (sel |var__temp_h'2688| res) var__temp_v2687)
                (= (sel |var__temp_h'2688| res) (+ (sel var__temp_h2686 res) 2))
                (= (sel |var__temp_h'2688| other) (sel var__temp_h2686 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2686 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************bar
PARTIAL PATH NEW
SUB 
 	 --bar
 	 --foo
 	 --foo'
 	 --c2'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2691 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2691 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2691, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2691, res ) ==((sel)( , var_h2690, res ) + (2))
 	 , (sel)( , var_h_i2691, other ) ==(sel)( , var_h2690, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2692:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2691 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************735
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2691 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2691, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2691, res ) ==((sel)( , var_h2690, res ) + (2))
 	 , (sel)( , var_h_i2691, other ) ==(sel)( , var_h2690, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2692:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2691 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2691 --->  Ty_heap  
 var_h2690 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2663 --->  Ty_heap  
 var_h2662 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2693 --->  Ty_heap  
 var__temp_v2694 --->  Ty_int  
 var__temp_h'2695 --->  Ty_heap  
 var__temp_v_err2696 --->  error  
 var_h2690 --->  Ty_heap  
 var_h2662 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2690, res ) ==(5) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2693, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2693, res ) ==((sel)( , var_h2690, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h2693, other ) ==(sel)( , var_h2690, other ) => 
 	 Rel (sel)( , var__temp_h2693, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2693, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2695, res ) ==(var__temp_v2694) AND 
 	 Rel (sel)( , var__temp_h'2695, res ) ==((sel)( , var__temp_h2693, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2695, other ) ==(sel)( , var__temp_h2693, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2695, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2695, other ) > (4)
 
VC_END(declare-const var_h_i2691 T9605)
(declare-const var_h2690 T9605)
(declare-const v Int)
(declare-const var_h_i2663 T9605)
(declare-const var_h2662 T9605)
(declare-const v Int)
(declare-const var_h_i2494 T9605)
(declare-const var_h2493 T9605)
(declare-const v Int)
(declare-const var_h_i2450 T9605)
(declare-const var_h2449 T9605)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2693 T9605)
(declare-const var__temp_v2694 Int)
(declare-const |var__temp_h'2695| T9605)
(declare-const var__temp_v_err2696 T9606)
(declare-const var_h2690 T9605)
(declare-const var_h2662 T9605)
(declare-const var_h2493 T9605)
(declare-const var_h2449 T9605)
(declare-const err T9619)

solver 
 (declare-sort T9605)
(declare-fun sel (T9605 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2690 () T9605)
(declare-fun var_h2449 () T9605)
(declare-fun other () Int)
(declare-fun |var__temp_h'2695| () T9605)
(declare-fun var__temp_h2693 () T9605)
(declare-fun var__temp_v2694 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2690 res) 5))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2693 res) v)
                (= (sel var__temp_h2693 res) (+ (sel var_h2690 res) 2))
                (= (sel var__temp_h2693 other) (sel var_h2690 other))))
      (a!2 (and (= (sel |var__temp_h'2695| res) var__temp_v2694)
                (= (sel |var__temp_h'2695| res) (+ (sel var__temp_h2693 res) 3))
                (= (sel |var__temp_h'2695| other) (sel var__temp_h2693 other))))
      (a!3 (and (= (sel |var__temp_h'2695| res) 10)
                (not (> (sel |var__temp_h'2695| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2693 res) 7))
                (=> (= (sel var__temp_h2693 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************736
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2691 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2691, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2691, res ) ==((sel)( , var_h2690, res ) + (2))
 	 , (sel)( , var_h_i2691, other ) ==(sel)( , var_h2690, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2692:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2691 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2691 --->  Ty_heap  
 var_h2690 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2663 --->  Ty_heap  
 var_h2662 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2697 --->  Ty_heap  
 var__temp_v2698 --->  Ty_int  
 var__temp_h'2699 --->  Ty_heap  
 var__temp_v_err2700 --->  error  
 var_h2690 --->  Ty_heap  
 var_h2662 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2690, res ) ==(5) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2697, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2697, res ) ==((sel)( , var_h2690, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h2697, other ) ==(sel)( , var_h2690, other ) => 
 	 Rel (sel)( , var__temp_h2697, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2697, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2699, res ) ==(var__temp_v2698) AND 
 	 Rel (sel)( , var__temp_h'2699, res ) ==((sel)( , var__temp_h2697, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2699, other ) ==(sel)( , var__temp_h2697, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2699, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2699, other ) > (4)
 
VC_END(declare-const var_h_i2691 T9622)
(declare-const var_h2690 T9622)
(declare-const v Int)
(declare-const var_h_i2663 T9622)
(declare-const var_h2662 T9622)
(declare-const v Int)
(declare-const var_h_i2494 T9622)
(declare-const var_h2493 T9622)
(declare-const v Int)
(declare-const var_h_i2450 T9622)
(declare-const var_h2449 T9622)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2697 T9622)
(declare-const var__temp_v2698 Int)
(declare-const |var__temp_h'2699| T9622)
(declare-const var__temp_v_err2700 T9623)
(declare-const var_h2690 T9622)
(declare-const var_h2662 T9622)
(declare-const var_h2493 T9622)
(declare-const var_h2449 T9622)
(declare-const err T9636)

solver 
 (declare-sort T9622)
(declare-fun sel (T9622 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2690 () T9622)
(declare-fun var_h2449 () T9622)
(declare-fun other () Int)
(declare-fun |var__temp_h'2699| () T9622)
(declare-fun var__temp_h2697 () T9622)
(declare-fun var__temp_v2698 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2690 res) 5))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2697 res) v)
                (= (sel var__temp_h2697 res) (+ (sel var_h2690 res) 2))
                (= (sel var__temp_h2697 other) (sel var_h2690 other))))
      (a!2 (and (= (sel |var__temp_h'2699| res) var__temp_v2698)
                (= (sel |var__temp_h'2699| res) (+ (sel var__temp_h2697 res) 5))
                (= (sel |var__temp_h'2699| other) (sel var__temp_h2697 other))))
      (a!3 (and (= (sel |var__temp_h'2699| res) 10)
                (not (> (sel |var__temp_h'2699| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2697 res) 7))
                (=> (= (sel var__temp_h2697 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************737
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2692:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2692:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbarfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --foo'
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2691 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2691, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2691, res ) ==((sel)( , var_h2690, res ) + (2))
 	 , (sel)( , var_h_i2691, other ) ==(sel)( , var_h2690, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2701:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************738
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2691 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2691, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2691, res ) ==((sel)( , var_h2690, res ) + (2))
 	 , (sel)( , var_h_i2691, other ) ==(sel)( , var_h2690, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2701:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2691 --->  Ty_heap  
 var_h2690 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2663 --->  Ty_heap  
 var_h2662 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2702 --->  Ty_heap  
 var__temp_v2703 --->  Ty_int  
 var__temp_h'2704 --->  Ty_heap  
 var__temp_v_err2705 --->  error  
 var_h2690 --->  Ty_heap  
 var_h2662 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2690, res ) ==(5) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2702, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2702, res ) ==((sel)( , var_h2690, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h2702, other ) ==(sel)( , var_h2690, other ) => 
 	 Rel (sel)( , var__temp_h2702, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2702, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2704, res ) ==(var__temp_v2703) AND 
 	 Rel (sel)( , var__temp_h'2704, res ) ==((sel)( , var__temp_h2702, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2704, other ) ==(sel)( , var__temp_h2702, other ) => 
 	 True
 
VC_END(declare-const var_h_i2691 T9639)
(declare-const var_h2690 T9639)
(declare-const v Int)
(declare-const var_h_i2663 T9639)
(declare-const var_h2662 T9639)
(declare-const v Int)
(declare-const var_h_i2494 T9639)
(declare-const var_h2493 T9639)
(declare-const v Int)
(declare-const var_h_i2450 T9639)
(declare-const var_h2449 T9639)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2702 T9639)
(declare-const var__temp_v2703 Int)
(declare-const |var__temp_h'2704| T9639)
(declare-const var__temp_v_err2705 T9640)
(declare-const var_h2690 T9639)
(declare-const var_h2662 T9639)
(declare-const var_h2493 T9639)
(declare-const var_h2449 T9639)
(declare-const err T9653)

solver 
 (declare-sort T9639)
(declare-fun sel (T9639 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2690 () T9639)
(declare-fun var_h2449 () T9639)
(declare-fun other () Int)
(declare-fun var__temp_h2702 () T9639)
(declare-fun |var__temp_h'2704| () T9639)
(declare-fun var__temp_v2703 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2690 res) 5))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2702 res) v)
                (= (sel var__temp_h2702 res) (+ (sel var_h2690 res) 2))
                (= (sel var__temp_h2702 other) (sel var_h2690 other))))
      (a!2 (and (= (sel |var__temp_h'2704| res) var__temp_v2703)
                (= (sel |var__temp_h'2704| res) (+ (sel var__temp_h2702 res) 3))
                (= (sel |var__temp_h'2704| other) (sel var__temp_h2702 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2702 res) 7))
                (=> (= (sel var__temp_h2702 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************baz
PARTIAL PATH NEW
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --foo'
 	 --c2'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2707 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2707 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2707, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2707, res ) ==((sel)( , var_h2706, res ) + (3))
 	 , (sel)( , var_h_i2707, other ) ==(sel)( , var_h2706, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2708:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2707 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************739
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2707 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2707, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2707, res ) ==((sel)( , var_h2706, res ) + (3))
 	 , (sel)( , var_h_i2707, other ) ==(sel)( , var_h2706, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2708:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2707 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2707 --->  Ty_heap  
 var_h2706 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2691 --->  Ty_heap  
 var_h2690 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2663 --->  Ty_heap  
 var_h2662 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2709 --->  Ty_heap  
 var__temp_v2710 --->  Ty_int  
 var__temp_h'2711 --->  Ty_heap  
 var__temp_v_err2712 --->  error  
 var_h2706 --->  Ty_heap  
 var_h2690 --->  Ty_heap  
 var_h2662 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h2706, res ) ==(7) AND 
 	 Rel (sel)( , var_h2690, res ) ==(5) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2709, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2709, res ) ==((sel)( , var_h2706, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h2709, other ) ==(sel)( , var_h2706, other ) => 
 	 Rel (sel)( , var__temp_h2709, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2709, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2711, res ) ==(var__temp_v2710) AND 
 	 Rel (sel)( , var__temp_h'2711, res ) ==((sel)( , var__temp_h2709, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2711, other ) ==(sel)( , var__temp_h2709, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2711, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2711, other ) > (4)
 
VC_END(declare-const var_h_i2707 T9656)
(declare-const var_h2706 T9656)
(declare-const v Int)
(declare-const var_h_i2691 T9656)
(declare-const var_h2690 T9656)
(declare-const v Int)
(declare-const var_h_i2663 T9656)
(declare-const var_h2662 T9656)
(declare-const v Int)
(declare-const var_h_i2494 T9656)
(declare-const var_h2493 T9656)
(declare-const v Int)
(declare-const var_h_i2450 T9656)
(declare-const var_h2449 T9656)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2709 T9656)
(declare-const var__temp_v2710 Int)
(declare-const |var__temp_h'2711| T9656)
(declare-const var__temp_v_err2712 T9657)
(declare-const var_h2706 T9656)
(declare-const var_h2690 T9656)
(declare-const var_h2662 T9656)
(declare-const var_h2493 T9656)
(declare-const var_h2449 T9656)
(declare-const err T9670)

solver 
 (declare-sort T9656)
(declare-fun sel (T9656 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2706 () T9656)
(declare-fun var_h2690 () T9656)
(declare-fun var_h2449 () T9656)
(declare-fun other () Int)
(declare-fun |var__temp_h'2711| () T9656)
(declare-fun var__temp_h2709 () T9656)
(declare-fun var__temp_v2710 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2706 res) 7))
(assert (= (sel var_h2690 res) 5))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2709 res) v)
                (= (sel var__temp_h2709 res) (+ (sel var_h2706 res) 3))
                (= (sel var__temp_h2709 other) (sel var_h2706 other))))
      (a!2 (and (= (sel |var__temp_h'2711| res) var__temp_v2710)
                (= (sel |var__temp_h'2711| res) (+ (sel var__temp_h2709 res) 5))
                (= (sel |var__temp_h'2711| other) (sel var__temp_h2709 other))))
      (a!3 (and (= (sel |var__temp_h'2711| res) 10)
                (not (> (sel |var__temp_h'2711| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2709 res) 7))
                (=> (= (sel var__temp_h2709 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************740
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2708:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2708:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbazbarfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --foo'
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2707 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2707, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2707, res ) ==((sel)( , var_h2706, res ) + (3))
 	 , (sel)( , var_h_i2707, other ) ==(sel)( , var_h2706, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2713:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************741
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2707 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2707, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2707, res ) ==((sel)( , var_h2706, res ) + (3))
 	 , (sel)( , var_h_i2707, other ) ==(sel)( , var_h2706, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2713:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2707 --->  Ty_heap  
 var_h2706 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2691 --->  Ty_heap  
 var_h2690 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2663 --->  Ty_heap  
 var_h2662 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2714 --->  Ty_heap  
 var__temp_v2715 --->  Ty_int  
 var__temp_h'2716 --->  Ty_heap  
 var__temp_v_err2717 --->  error  
 var_h2706 --->  Ty_heap  
 var_h2690 --->  Ty_heap  
 var_h2662 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h2706, res ) ==(7) AND 
 	 Rel (sel)( , var_h2690, res ) ==(5) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2714, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2714, res ) ==((sel)( , var_h2706, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h2714, other ) ==(sel)( , var_h2706, other ) => 
 	 Rel (sel)( , var__temp_h2714, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2714, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2716, res ) ==(var__temp_v2715) AND 
 	 Rel (sel)( , var__temp_h'2716, res ) ==((sel)( , var__temp_h2714, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2716, other ) ==(sel)( , var__temp_h2714, other ) => 
 	 True
 
VC_END(declare-const var_h_i2707 T9673)
(declare-const var_h2706 T9673)
(declare-const v Int)
(declare-const var_h_i2691 T9673)
(declare-const var_h2690 T9673)
(declare-const v Int)
(declare-const var_h_i2663 T9673)
(declare-const var_h2662 T9673)
(declare-const v Int)
(declare-const var_h_i2494 T9673)
(declare-const var_h2493 T9673)
(declare-const v Int)
(declare-const var_h_i2450 T9673)
(declare-const var_h2449 T9673)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2714 T9673)
(declare-const var__temp_v2715 Int)
(declare-const |var__temp_h'2716| T9673)
(declare-const var__temp_v_err2717 T9674)
(declare-const var_h2706 T9673)
(declare-const var_h2690 T9673)
(declare-const var_h2662 T9673)
(declare-const var_h2493 T9673)
(declare-const var_h2449 T9673)
(declare-const err T9687)

solver 
 (declare-sort T9673)
(declare-fun sel (T9673 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2706 () T9673)
(declare-fun var_h2690 () T9673)
(declare-fun var_h2449 () T9673)
(declare-fun other () Int)
(declare-fun var__temp_h2714 () T9673)
(declare-fun |var__temp_h'2716| () T9673)
(declare-fun var__temp_v2715 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2706 res) 7))
(assert (= (sel var_h2690 res) 5))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2714 res) v)
                (= (sel var__temp_h2714 res) (+ (sel var_h2706 res) 3))
                (= (sel var__temp_h2714 other) (sel var_h2706 other))))
      (a!2 (and (= (sel |var__temp_h'2716| res) var__temp_v2715)
                (= (sel |var__temp_h'2716| res) (+ (sel var__temp_h2714 res) 5))
                (= (sel |var__temp_h'2716| other) (sel var__temp_h2714 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2714 res) 7))
                (=> (= (sel var__temp_h2714 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************742
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT baz
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --foo'
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2691 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2691, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2691, res ) ==((sel)( , var_h2690, res ) + (2))
 	 , (sel)( , var_h_i2691, other ) ==(sel)( , var_h2690, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2718:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************743
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2691 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2691, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2691, res ) ==((sel)( , var_h2690, res ) + (2))
 	 , (sel)( , var_h_i2691, other ) ==(sel)( , var_h2690, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2718:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2691 --->  Ty_heap  
 var_h2690 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2663 --->  Ty_heap  
 var_h2662 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2719 --->  Ty_heap  
 var__temp_v2720 --->  Ty_int  
 var__temp_h'2721 --->  Ty_heap  
 var__temp_v_err2722 --->  error  
 var_h2690 --->  Ty_heap  
 var_h2662 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2690, res ) ==(5) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2719, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2719, res ) ==((sel)( , var_h2690, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h2719, other ) ==(sel)( , var_h2690, other ) => 
 	 Rel (sel)( , var__temp_h2719, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2719, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2721, res ) ==(var__temp_v2720) AND 
 	 Rel (sel)( , var__temp_h'2721, res ) ==((sel)( , var__temp_h2719, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2721, other ) ==(sel)( , var__temp_h2719, other ) => 
 	 True
 
VC_END(declare-const var_h_i2691 T9690)
(declare-const var_h2690 T9690)
(declare-const v Int)
(declare-const var_h_i2663 T9690)
(declare-const var_h2662 T9690)
(declare-const v Int)
(declare-const var_h_i2494 T9690)
(declare-const var_h2493 T9690)
(declare-const v Int)
(declare-const var_h_i2450 T9690)
(declare-const var_h2449 T9690)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2719 T9690)
(declare-const var__temp_v2720 Int)
(declare-const |var__temp_h'2721| T9690)
(declare-const var__temp_v_err2722 T9691)
(declare-const var_h2690 T9690)
(declare-const var_h2662 T9690)
(declare-const var_h2493 T9690)
(declare-const var_h2449 T9690)
(declare-const err T9704)

solver 
 (declare-sort T9690)
(declare-fun sel (T9690 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2690 () T9690)
(declare-fun var_h2449 () T9690)
(declare-fun other () Int)
(declare-fun var__temp_h2719 () T9690)
(declare-fun |var__temp_h'2721| () T9690)
(declare-fun var__temp_v2720 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2690 res) 5))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2719 res) v)
                (= (sel var__temp_h2719 res) (+ (sel var_h2690 res) 2))
                (= (sel var__temp_h2719 other) (sel var_h2690 other))))
      (a!2 (and (= (sel |var__temp_h'2721| res) var__temp_v2720)
                (= (sel |var__temp_h'2721| res) (+ (sel var__temp_h2719 res) 5))
                (= (sel |var__temp_h'2721| other) (sel var__temp_h2719 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2719 res) 7))
                (=> (= (sel var__temp_h2719 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c5
PARTIAL PATH NEW
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --foo'
 	 --c2'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2724 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2724 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2724, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2724, res ) ==((sel)( , var_h2723, res ) + (5))
 	 , (sel)( , var_h_i2724, other ) ==(sel)( , var_h2723, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2725:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2724 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************744
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2725:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2725:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc5bazbarfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --foo'
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2724 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2724, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2724, res ) ==((sel)( , var_h2723, res ) + (5))
 	 , (sel)( , var_h_i2724, other ) ==(sel)( , var_h2723, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2726:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************745
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --foo'
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2691 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2691, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2691, res ) ==((sel)( , var_h2690, res ) + (2))
 	 , (sel)( , var_h_i2691, other ) ==(sel)( , var_h2690, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2727:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************746
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --foo
 	 --foo'
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2663 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2663, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2663, other ) ==(sel)( , var_h2662, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2728:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************747
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2663 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2663, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2663, other ) ==(sel)( , var_h2662, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2728:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2663 --->  Ty_heap  
 var_h2662 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2729 --->  Ty_heap  
 var__temp_v2730 --->  Ty_int  
 var__temp_h'2731 --->  Ty_heap  
 var__temp_v_err2732 --->  error  
 var_h2662 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2729, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2729, other ) ==(sel)( , var_h2662, other ) => 
 	 Rel (sel)( , var__temp_h2729, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2729, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2731, res ) ==(var__temp_v2730) AND 
 	 Rel (sel)( , var__temp_h'2731, res ) ==((sel)( , var__temp_h2729, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2731, other ) ==(sel)( , var__temp_h2729, other ) => 
 	 True
 
VC_END(declare-const var_h_i2663 T9707)
(declare-const var_h2662 T9707)
(declare-const v Int)
(declare-const var_h_i2494 T9707)
(declare-const var_h2493 T9707)
(declare-const v Int)
(declare-const var_h_i2450 T9707)
(declare-const var_h2449 T9707)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2729 T9707)
(declare-const var__temp_v2730 Int)
(declare-const |var__temp_h'2731| T9707)
(declare-const var__temp_v_err2732 T9708)
(declare-const var_h2662 T9707)
(declare-const var_h2493 T9707)
(declare-const var_h2449 T9707)
(declare-const err T9721)
    (declare-const |5| Int)
  
solver 
 (declare-sort T9707)
(declare-fun sel (T9707 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T9707)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2729 () T9707)
(declare-fun |var__temp_h'2731| () T9707)
(declare-fun var__temp_v2730 () Int)
(declare-fun var_h2662 () T9707)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2729 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2729 other) (sel var_h2662 other)))
               (= (sel var__temp_h2729 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2731| res) var__temp_v2730)
                (= (sel |var__temp_h'2731| res) (+ (sel var__temp_h2729 res) 3))
                (= (sel |var__temp_h'2731| other) (sel var__temp_h2729 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2729 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************748
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2663 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2663, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2663, other ) ==(sel)( , var_h2662, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2728:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2663 --->  Ty_heap  
 var_h2662 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2733 --->  Ty_heap  
 var__temp_v2734 --->  Ty_int  
 var__temp_h'2735 --->  Ty_heap  
 var__temp_v_err2736 --->  error  
 var_h2662 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2733, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2733, other ) ==(sel)( , var_h2662, other ) => 
 	 Rel (sel)( , var__temp_h2733, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2733, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2735, res ) ==(var__temp_v2734) AND 
 	 Rel (sel)( , var__temp_h'2735, res ) ==((sel)( , var__temp_h2733, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2735, other ) ==(sel)( , var__temp_h2733, other ) => 
 	 True
 
VC_END(declare-const var_h_i2663 T9724)
(declare-const var_h2662 T9724)
(declare-const v Int)
(declare-const var_h_i2494 T9724)
(declare-const var_h2493 T9724)
(declare-const v Int)
(declare-const var_h_i2450 T9724)
(declare-const var_h2449 T9724)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2733 T9724)
(declare-const var__temp_v2734 Int)
(declare-const |var__temp_h'2735| T9724)
(declare-const var__temp_v_err2736 T9725)
(declare-const var_h2662 T9724)
(declare-const var_h2493 T9724)
(declare-const var_h2449 T9724)
(declare-const err T9738)
    (declare-const |5| Int)
  
solver 
 (declare-sort T9724)
(declare-fun sel (T9724 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T9724)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2733 () T9724)
(declare-fun |var__temp_h'2735| () T9724)
(declare-fun var__temp_v2734 () Int)
(declare-fun var_h2662 () T9724)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2733 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2733 other) (sel var_h2662 other)))
               (= (sel var__temp_h2733 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2735| res) var__temp_v2734)
                (= (sel |var__temp_h'2735| res) (+ (sel var__temp_h2733 res) 5))
                (= (sel |var__temp_h'2735| other) (sel var__temp_h2733 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2733 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************749
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT bar
PARTIAL PATH
SUB 
 	 --foo'
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2494 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2494, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2494, other ) ==(sel)( , var_h2493, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2737:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************750
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2494 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2494, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2494, other ) ==(sel)( , var_h2493, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2737:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2738 --->  Ty_heap  
 var__temp_v2739 --->  Ty_int  
 var__temp_h'2740 --->  Ty_heap  
 var__temp_v_err2741 --->  error  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2738, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h2738, other ) ==(sel)( , var_h2493, other ) => 
 	 Rel (sel)( , var__temp_h2738, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2738, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2740, res ) ==(var__temp_v2739) AND 
 	 Rel (sel)( , var__temp_h'2740, res ) ==((sel)( , var__temp_h2738, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2740, other ) ==(sel)( , var__temp_h2738, other ) => 
 	 True
 
VC_END(declare-const var_h_i2494 T9741)
(declare-const var_h2493 T9741)
(declare-const v Int)
(declare-const var_h_i2450 T9741)
(declare-const var_h2449 T9741)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2738 T9741)
(declare-const var__temp_v2739 Int)
(declare-const |var__temp_h'2740| T9741)
(declare-const var__temp_v_err2741 T9742)
(declare-const var_h2493 T9741)
(declare-const var_h2449 T9741)
(declare-const err T9755)
    (declare-const |20| Int)
  
solver 
 (declare-sort T9741)
(declare-fun sel (T9741 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T9741)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2738 () T9741)
(declare-fun |var__temp_h'2740| () T9741)
(declare-fun var__temp_v2739 () Int)
(declare-fun var_h2493 () T9741)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2738 res) v)
                    (= v |20|)
                    (= (sel var__temp_h2738 other) (sel var_h2493 other)))
               (= (sel var__temp_h2738 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2740| res) var__temp_v2739)
                (= (sel |var__temp_h'2740| res) (+ (sel var__temp_h2738 res) 3))
                (= (sel |var__temp_h'2740| other) (sel var__temp_h2738 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2738 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************751
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2494 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2494, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2494, other ) ==(sel)( , var_h2493, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2737:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2742 --->  Ty_heap  
 var__temp_v2743 --->  Ty_int  
 var__temp_h'2744 --->  Ty_heap  
 var__temp_v_err2745 --->  error  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2742, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h2742, other ) ==(sel)( , var_h2493, other ) => 
 	 Rel (sel)( , var__temp_h2742, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2742, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2744, res ) ==(var__temp_v2743) AND 
 	 Rel (sel)( , var__temp_h'2744, res ) ==((sel)( , var__temp_h2742, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2744, other ) ==(sel)( , var__temp_h2742, other ) => 
 	 True
 
VC_END(declare-const var_h_i2494 T9758)
(declare-const var_h2493 T9758)
(declare-const v Int)
(declare-const var_h_i2450 T9758)
(declare-const var_h2449 T9758)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2742 T9758)
(declare-const var__temp_v2743 Int)
(declare-const |var__temp_h'2744| T9758)
(declare-const var__temp_v_err2745 T9759)
(declare-const var_h2493 T9758)
(declare-const var_h2449 T9758)
(declare-const err T9772)
    (declare-const |20| Int)
  
solver 
 (declare-sort T9758)
(declare-fun sel (T9758 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T9758)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2742 () T9758)
(declare-fun |var__temp_h'2744| () T9758)
(declare-fun var__temp_v2743 () Int)
(declare-fun var_h2493 () T9758)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2742 res) v)
                    (= v |20|)
                    (= (sel var__temp_h2742 other) (sel var_h2493 other)))
               (= (sel var__temp_h2742 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2744| res) var__temp_v2743)
                (= (sel |var__temp_h'2744| res) (+ (sel var__temp_h2742 res) 5))
                (= (sel |var__temp_h'2744| other) (sel var__temp_h2742 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2742 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************752
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2494 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2494, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2494, other ) ==(sel)( , var_h2493, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2737:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2494 --->  Ty_heap  
 var_h2493 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2746 --->  Ty_heap  
 var__temp_v2747 --->  Ty_int  
 var__temp_h'2748 --->  Ty_heap  
 var__temp_v_err2749 --->  error  
 var_h2493 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2746, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h2746, other ) ==(sel)( , var_h2493, other ) => 
 	 Rel (sel)( , var__temp_h2746, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2746, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2748, res ) ==(var__temp_v2747) AND 
 	 Rel (sel)( , var__temp_h'2748, res ) ==((sel)( , var__temp_h2746, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2748, other ) ==(sel)( , var__temp_h2746, other ) => 
 	 True
 
VC_END(declare-const var_h_i2494 T9775)
(declare-const var_h2493 T9775)
(declare-const v Int)
(declare-const var_h_i2450 T9775)
(declare-const var_h2449 T9775)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2746 T9775)
(declare-const var__temp_v2747 Int)
(declare-const |var__temp_h'2748| T9775)
(declare-const var__temp_v_err2749 T9776)
(declare-const var_h2493 T9775)
(declare-const var_h2449 T9775)
(declare-const err T9789)
    (declare-const |20| Int)
  
solver 
 (declare-sort T9775)
(declare-fun sel (T9775 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T9775)
(declare-fun |20| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2746 () T9775)
(declare-fun |var__temp_h'2748| () T9775)
(declare-fun var__temp_v2747 () Int)
(declare-fun var_h2493 () T9775)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2746 res) v)
                    (= v |20|)
                    (= (sel var__temp_h2746 other) (sel var_h2493 other)))
               (= (sel var__temp_h2746 res) 5)))
      (a!2 (and (= (sel |var__temp_h'2748| res) var__temp_v2747)
                (= (sel |var__temp_h'2748| res) (+ (sel var__temp_h2746 res) 2))
                (= (sel |var__temp_h'2748| other) (sel var__temp_h2746 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2746 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************753
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo
PARTIAL PATH
SUB 
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2450, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res )
 	 , (sel)( , var_h_i2450, other ) ==(sel)( , var_h2449, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2750:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************754
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2450, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res )
 	 , (sel)( , var_h_i2450, other ) ==(sel)( , var_h2449, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2750:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2751 --->  Ty_heap  
 var__temp_v2752 --->  Ty_int  
 var__temp_h'2753 --->  Ty_heap  
 var__temp_v_err2754 --->  error  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2751, res ) ==(v) AND 
 	 Rel (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res ) AND 
 	 Rel (sel)( , var__temp_h2751, other ) ==(sel)( , var_h2449, other ) => 
 	 Rel (sel)( , var__temp_h2751, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2751, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2753, res ) ==(var__temp_v2752) AND 
 	 Rel (sel)( , var__temp_h'2753, res ) ==((sel)( , var__temp_h2751, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2753, other ) ==(sel)( , var__temp_h2751, other ) => 
 	 True
 
VC_END(declare-const var_h_i2450 T9792)
(declare-const var_h2449 T9792)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2751 T9792)
(declare-const var__temp_v2752 Int)
(declare-const |var__temp_h'2753| T9792)
(declare-const var__temp_v_err2754 T9793)
(declare-const var_h2449 T9792)
(declare-const err T9806)

solver 
 (declare-sort T9792)
(declare-fun sel (T9792 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T9792)
(declare-fun other () Int)
(declare-fun var__temp_h2751 () T9792)
(declare-fun |var__temp_h'2753| () T9792)
(declare-fun var__temp_v2752 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2751 res) v)
                    (= (sel var_h2449 res) (sel var_h2449 res))
                    (= (sel var__temp_h2751 other) (sel var_h2449 other)))
               (= (sel var__temp_h2751 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2753| res) var__temp_v2752)
                (= (sel |var__temp_h'2753| res) (+ (sel var__temp_h2751 res) 3))
                (= (sel |var__temp_h'2753| other) (sel var__temp_h2751 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2751 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************755
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2450, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res )
 	 , (sel)( , var_h_i2450, other ) ==(sel)( , var_h2449, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2750:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2755 --->  Ty_heap  
 var__temp_v2756 --->  Ty_int  
 var__temp_h'2757 --->  Ty_heap  
 var__temp_v_err2758 --->  error  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2755, res ) ==(v) AND 
 	 Rel (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res ) AND 
 	 Rel (sel)( , var__temp_h2755, other ) ==(sel)( , var_h2449, other ) => 
 	 Rel (sel)( , var__temp_h2755, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2755, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2757, res ) ==(var__temp_v2756) AND 
 	 Rel (sel)( , var__temp_h'2757, res ) ==((sel)( , var__temp_h2755, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2757, other ) ==(sel)( , var__temp_h2755, other ) => 
 	 True
 
VC_END(declare-const var_h_i2450 T9809)
(declare-const var_h2449 T9809)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2755 T9809)
(declare-const var__temp_v2756 Int)
(declare-const |var__temp_h'2757| T9809)
(declare-const var__temp_v_err2758 T9810)
(declare-const var_h2449 T9809)
(declare-const err T9823)

solver 
 (declare-sort T9809)
(declare-fun sel (T9809 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T9809)
(declare-fun other () Int)
(declare-fun var__temp_h2755 () T9809)
(declare-fun |var__temp_h'2757| () T9809)
(declare-fun var__temp_v2756 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2755 res) v)
                    (= (sel var_h2449 res) (sel var_h2449 res))
                    (= (sel var__temp_h2755 other) (sel var_h2449 other)))
               (= (sel var__temp_h2755 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2757| res) var__temp_v2756)
                (= (sel |var__temp_h'2757| res) (+ (sel var__temp_h2755 res) 5))
                (= (sel |var__temp_h'2757| other) (sel var__temp_h2755 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2755 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************756
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2450, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res )
 	 , (sel)( , var_h_i2450, other ) ==(sel)( , var_h2449, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2750:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2759 --->  Ty_heap  
 var__temp_v2760 --->  Ty_int  
 var__temp_h'2761 --->  Ty_heap  
 var__temp_v_err2762 --->  error  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2759, res ) ==(v) AND 
 	 Rel (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res ) AND 
 	 Rel (sel)( , var__temp_h2759, other ) ==(sel)( , var_h2449, other ) => 
 	 Rel (sel)( , var__temp_h2759, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h2759, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2761, res ) ==(var__temp_v2760) AND 
 	 Rel (sel)( , var__temp_h'2761, res ) ==((sel)( , var__temp_h2759, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'2761, other ) ==(sel)( , var__temp_h2759, other ) => 
 	 True
 
VC_END(declare-const var_h_i2450 T9826)
(declare-const var_h2449 T9826)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2759 T9826)
(declare-const var__temp_v2760 Int)
(declare-const |var__temp_h'2761| T9826)
(declare-const var__temp_v_err2762 T9827)
(declare-const var_h2449 T9826)
(declare-const err T9840)

solver 
 (declare-sort T9826)
(declare-fun sel (T9826 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T9826)
(declare-fun other () Int)
(declare-fun var__temp_h2759 () T9826)
(declare-fun |var__temp_h'2761| () T9826)
(declare-fun var__temp_v2760 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2759 res) v)
                    (= (sel var_h2449 res) (sel var_h2449 res))
                    (= (sel var__temp_h2759 other) (sel var_h2449 other)))
               (> (sel var__temp_h2759 res) 4)))
      (a!2 (and (= (sel |var__temp_h'2761| res) var__temp_v2760)
                (= (sel |var__temp_h'2761| res)
                   (+ (sel var__temp_h2759 res) 10))
                (= (sel |var__temp_h'2761| other) (sel var__temp_h2759 other)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h2759 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************757
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2450, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res )
 	 , (sel)( , var_h_i2450, other ) ==(sel)( , var_h2449, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2750:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2763 --->  Ty_heap  
 var__temp_v2764 --->  Ty_int  
 var__temp_h'2765 --->  Ty_heap  
 var__temp_v_err2766 --->  error  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2763, res ) ==(v) AND 
 	 Rel (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res ) AND 
 	 Rel (sel)( , var__temp_h2763, other ) ==(sel)( , var_h2449, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2765, res ) ==(var__temp_v2764) AND 
 	 Base var__temp_v2764 = 5 AND 
 	 Rel (sel)( , var__temp_h'2765, other ) ==(sel)( , var__temp_h2763, other ) => 
 	 True
 
VC_END(declare-const var_h_i2450 T9843)
(declare-const var_h2449 T9843)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2763 T9843)
(declare-const var__temp_v2764 Int)
(declare-const |var__temp_h'2765| T9843)
(declare-const var__temp_v_err2766 T9844)
(declare-const var_h2449 T9843)
(declare-const err T9857)
    (declare-const |5| Int)
  
solver 
 (declare-sort T9843)
(declare-fun sel (T9843 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T9843)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2763 () T9843)
(declare-fun |var__temp_h'2765| () T9843)
(declare-fun var__temp_v2764 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2763 res) v)
                    (= (sel var_h2449 res) (sel var_h2449 res))
                    (= (sel var__temp_h2763 other) (sel var_h2449 other)))
               true))
      (a!2 (=> (and (= (sel |var__temp_h'2765| res) var__temp_v2764)
                    (= var__temp_v2764 |5|)
                    (= (sel |var__temp_h'2765| other)
                       (sel var__temp_h2763 other)))
               true)))
  (not (and a!1 (=> true a!2)))))

***************Selection Successful************foo
PARTIAL PATH NEW
SUB 
 	 --foo
 	 --c2'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2768 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2768 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2768, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2768, other ) ==(sel)( , var_h2767, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2769:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2768 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
bar
 *********************Enumeration Iteration*****************758
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2768 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2768, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2768, other ) ==(sel)( , var_h2767, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2769:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2768 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2768 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2770 --->  Ty_heap  
 var__temp_v2771 --->  Ty_int  
 var__temp_h'2772 --->  Ty_heap  
 var__temp_v_err2773 --->  error  
 var_h2767 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2770, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2770, other ) ==(sel)( , var_h2767, other ) => 
 	 Rel (sel)( , var__temp_h2770, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2770, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2772, res ) ==(var__temp_v2771) AND 
 	 Rel (sel)( , var__temp_h'2772, res ) ==((sel)( , var__temp_h2770, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2772, other ) ==(sel)( , var__temp_h2770, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2772, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2772, other ) > (4)
 
VC_END(declare-const var_h_i2768 T9860)
(declare-const var_h2767 T9860)
(declare-const v Int)
(declare-const var_h_i2450 T9860)
(declare-const var_h2449 T9860)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2770 T9860)
(declare-const var__temp_v2771 Int)
(declare-const |var__temp_h'2772| T9860)
(declare-const var__temp_v_err2773 T9861)
(declare-const var_h2767 T9860)
(declare-const var_h2449 T9860)
(declare-const err T9874)
    (declare-const |5| Int)
  
solver 
 (declare-sort T9860)
(declare-fun sel (T9860 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T9860)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2772| () T9860)
(declare-fun var__temp_h2770 () T9860)
(declare-fun var__temp_v2771 () Int)
(declare-fun var_h2767 () T9860)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2770 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2770 other) (sel var_h2767 other)))
               (= (sel var__temp_h2770 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2772| res) var__temp_v2771)
                (= (sel |var__temp_h'2772| res) (+ (sel var__temp_h2770 res) 3))
                (= (sel |var__temp_h'2772| other) (sel var__temp_h2770 other))))
      (a!3 (and (= (sel |var__temp_h'2772| res) 10)
                (not (> (sel |var__temp_h'2772| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2770 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************759
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2768 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2768, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2768, other ) ==(sel)( , var_h2767, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2769:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2768 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2768 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2774 --->  Ty_heap  
 var__temp_v2775 --->  Ty_int  
 var__temp_h'2776 --->  Ty_heap  
 var__temp_v_err2777 --->  error  
 var_h2767 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2774, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2774, other ) ==(sel)( , var_h2767, other ) => 
 	 Rel (sel)( , var__temp_h2774, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2774, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2776, res ) ==(var__temp_v2775) AND 
 	 Rel (sel)( , var__temp_h'2776, res ) ==((sel)( , var__temp_h2774, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2776, other ) ==(sel)( , var__temp_h2774, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2776, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2776, other ) > (4)
 
VC_END(declare-const var_h_i2768 T9877)
(declare-const var_h2767 T9877)
(declare-const v Int)
(declare-const var_h_i2450 T9877)
(declare-const var_h2449 T9877)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2774 T9877)
(declare-const var__temp_v2775 Int)
(declare-const |var__temp_h'2776| T9877)
(declare-const var__temp_v_err2777 T9878)
(declare-const var_h2767 T9877)
(declare-const var_h2449 T9877)
(declare-const err T9891)
    (declare-const |5| Int)
  
solver 
 (declare-sort T9877)
(declare-fun sel (T9877 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T9877)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2776| () T9877)
(declare-fun var__temp_h2774 () T9877)
(declare-fun var__temp_v2775 () Int)
(declare-fun var_h2767 () T9877)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2774 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2774 other) (sel var_h2767 other)))
               (= (sel var__temp_h2774 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2776| res) var__temp_v2775)
                (= (sel |var__temp_h'2776| res) (+ (sel var__temp_h2774 res) 5))
                (= (sel |var__temp_h'2776| other) (sel var__temp_h2774 other))))
      (a!3 (and (= (sel |var__temp_h'2776| res) 10)
                (not (> (sel |var__temp_h'2776| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2774 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************760
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2768 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2768, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2768, other ) ==(sel)( , var_h2767, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2769:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2768 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2768 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2778 --->  Ty_heap  
 var__temp_v2779 --->  Ty_int  
 var__temp_h'2780 --->  Ty_heap  
 var__temp_v_err2781 --->  error  
 var_h2767 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2778, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2778, other ) ==(sel)( , var_h2767, other ) => 
 	 Rel (sel)( , var__temp_h2778, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h2778, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2780, res ) ==(var__temp_v2779) AND 
 	 Rel (sel)( , var__temp_h'2780, res ) ==((sel)( , var__temp_h2778, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'2780, other ) ==(sel)( , var__temp_h2778, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2780, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2780, other ) > (4)
 
VC_END(declare-const var_h_i2768 T9894)
(declare-const var_h2767 T9894)
(declare-const v Int)
(declare-const var_h_i2450 T9894)
(declare-const var_h2449 T9894)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2778 T9894)
(declare-const var__temp_v2779 Int)
(declare-const |var__temp_h'2780| T9894)
(declare-const var__temp_v_err2781 T9895)
(declare-const var_h2767 T9894)
(declare-const var_h2449 T9894)
(declare-const err T9908)
    (declare-const |5| Int)
  
solver 
 (declare-sort T9894)
(declare-fun sel (T9894 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T9894)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2780| () T9894)
(declare-fun var__temp_h2778 () T9894)
(declare-fun var__temp_v2779 () Int)
(declare-fun var_h2767 () T9894)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2778 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2778 other) (sel var_h2767 other)))
               (> (sel var__temp_h2778 res) 4)))
      (a!2 (and (= (sel |var__temp_h'2780| res) var__temp_v2779)
                (= (sel |var__temp_h'2780| res)
                   (+ (sel var__temp_h2778 res) 10))
                (= (sel |var__temp_h'2780| other) (sel var__temp_h2778 other))))
      (a!3 (and (= (sel |var__temp_h'2780| res) 10)
                (not (> (sel |var__temp_h'2780| other) 4)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h2778 res) 4) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************761
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2768 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2768, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2768, other ) ==(sel)( , var_h2767, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2769:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2768 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2768 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2782 --->  Ty_heap  
 var__temp_v2783 --->  Ty_int  
 var__temp_h'2784 --->  Ty_heap  
 var__temp_v_err2785 --->  error  
 var_h2767 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2782, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2782, other ) ==(sel)( , var_h2767, other ) => 
 	 Rel (sel)( , var__temp_h2782, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2782, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2784, res ) ==(var__temp_v2783) AND 
 	 Rel (sel)( , var__temp_h'2784, res ) ==((sel)( , var__temp_h2782, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2784, other ) ==(sel)( , var__temp_h2782, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2784, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2784, other ) > (4)
 
VC_END(declare-const var_h_i2768 T9911)
(declare-const var_h2767 T9911)
(declare-const v Int)
(declare-const var_h_i2450 T9911)
(declare-const var_h2449 T9911)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2782 T9911)
(declare-const var__temp_v2783 Int)
(declare-const |var__temp_h'2784| T9911)
(declare-const var__temp_v_err2785 T9912)
(declare-const var_h2767 T9911)
(declare-const var_h2449 T9911)
(declare-const err T9925)
    (declare-const |5| Int)
  
solver 
 (declare-sort T9911)
(declare-fun sel (T9911 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T9911)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2784| () T9911)
(declare-fun var__temp_h2782 () T9911)
(declare-fun var__temp_v2783 () Int)
(declare-fun var_h2767 () T9911)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2782 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2782 other) (sel var_h2767 other)))
               (= (sel var__temp_h2782 res) 5)))
      (a!2 (and (= (sel |var__temp_h'2784| res) var__temp_v2783)
                (= (sel |var__temp_h'2784| res) (+ (sel var__temp_h2782 res) 2))
                (= (sel |var__temp_h'2784| other) (sel var__temp_h2782 other))))
      (a!3 (and (= (sel |var__temp_h'2784| res) 10)
                (not (> (sel |var__temp_h'2784| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2782 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************762
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2769:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2769:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfoofoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --foo
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2768 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2768, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2768, other ) ==(sel)( , var_h2767, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2786:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
bar
 *********************Enumeration Iteration*****************763
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2768 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2768, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2768, other ) ==(sel)( , var_h2767, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2786:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2768 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2787 --->  Ty_heap  
 var__temp_v2788 --->  Ty_int  
 var__temp_h'2789 --->  Ty_heap  
 var__temp_v_err2790 --->  error  
 var_h2767 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2787, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2787, other ) ==(sel)( , var_h2767, other ) => 
 	 Rel (sel)( , var__temp_h2787, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2787, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2789, res ) ==(var__temp_v2788) AND 
 	 Rel (sel)( , var__temp_h'2789, res ) ==((sel)( , var__temp_h2787, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2789, other ) ==(sel)( , var__temp_h2787, other ) => 
 	 True
 
VC_END(declare-const var_h_i2768 T9928)
(declare-const var_h2767 T9928)
(declare-const v Int)
(declare-const var_h_i2450 T9928)
(declare-const var_h2449 T9928)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2787 T9928)
(declare-const var__temp_v2788 Int)
(declare-const |var__temp_h'2789| T9928)
(declare-const var__temp_v_err2790 T9929)
(declare-const var_h2767 T9928)
(declare-const var_h2449 T9928)
(declare-const err T9942)
    (declare-const |5| Int)
  
solver 
 (declare-sort T9928)
(declare-fun sel (T9928 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T9928)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2787 () T9928)
(declare-fun |var__temp_h'2789| () T9928)
(declare-fun var__temp_v2788 () Int)
(declare-fun var_h2767 () T9928)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2787 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2787 other) (sel var_h2767 other)))
               (= (sel var__temp_h2787 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2789| res) var__temp_v2788)
                (= (sel |var__temp_h'2789| res) (+ (sel var__temp_h2787 res) 3))
                (= (sel |var__temp_h'2789| other) (sel var__temp_h2787 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2787 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************764
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2768 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2768, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2768, other ) ==(sel)( , var_h2767, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2786:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2768 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2791 --->  Ty_heap  
 var__temp_v2792 --->  Ty_int  
 var__temp_h'2793 --->  Ty_heap  
 var__temp_v_err2794 --->  error  
 var_h2767 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2791, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2791, other ) ==(sel)( , var_h2767, other ) => 
 	 Rel (sel)( , var__temp_h2791, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2791, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2793, res ) ==(var__temp_v2792) AND 
 	 Rel (sel)( , var__temp_h'2793, res ) ==((sel)( , var__temp_h2791, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2793, other ) ==(sel)( , var__temp_h2791, other ) => 
 	 True
 
VC_END(declare-const var_h_i2768 T9945)
(declare-const var_h2767 T9945)
(declare-const v Int)
(declare-const var_h_i2450 T9945)
(declare-const var_h2449 T9945)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2791 T9945)
(declare-const var__temp_v2792 Int)
(declare-const |var__temp_h'2793| T9945)
(declare-const var__temp_v_err2794 T9946)
(declare-const var_h2767 T9945)
(declare-const var_h2449 T9945)
(declare-const err T9959)
    (declare-const |5| Int)
  
solver 
 (declare-sort T9945)
(declare-fun sel (T9945 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T9945)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2791 () T9945)
(declare-fun |var__temp_h'2793| () T9945)
(declare-fun var__temp_v2792 () Int)
(declare-fun var_h2767 () T9945)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2791 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2791 other) (sel var_h2767 other)))
               (= (sel var__temp_h2791 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2793| res) var__temp_v2792)
                (= (sel |var__temp_h'2793| res) (+ (sel var__temp_h2791 res) 5))
                (= (sel |var__temp_h'2793| other) (sel var__temp_h2791 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2791 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************765
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2768 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2768, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2768, other ) ==(sel)( , var_h2767, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2786:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2768 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2795 --->  Ty_heap  
 var__temp_v2796 --->  Ty_int  
 var__temp_h'2797 --->  Ty_heap  
 var__temp_v_err2798 --->  error  
 var_h2767 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2795, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2795, other ) ==(sel)( , var_h2767, other ) => 
 	 Rel (sel)( , var__temp_h2795, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h2795, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2797, res ) ==(var__temp_v2796) AND 
 	 Rel (sel)( , var__temp_h'2797, res ) ==((sel)( , var__temp_h2795, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'2797, other ) ==(sel)( , var__temp_h2795, other ) => 
 	 True
 
VC_END(declare-const var_h_i2768 T9962)
(declare-const var_h2767 T9962)
(declare-const v Int)
(declare-const var_h_i2450 T9962)
(declare-const var_h2449 T9962)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2795 T9962)
(declare-const var__temp_v2796 Int)
(declare-const |var__temp_h'2797| T9962)
(declare-const var__temp_v_err2798 T9963)
(declare-const var_h2767 T9962)
(declare-const var_h2449 T9962)
(declare-const err T9976)
    (declare-const |5| Int)
  
solver 
 (declare-sort T9962)
(declare-fun sel (T9962 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T9962)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2795 () T9962)
(declare-fun |var__temp_h'2797| () T9962)
(declare-fun var__temp_v2796 () Int)
(declare-fun var_h2767 () T9962)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2795 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2795 other) (sel var_h2767 other)))
               (> (sel var__temp_h2795 res) 4)))
      (a!2 (and (= (sel |var__temp_h'2797| res) var__temp_v2796)
                (= (sel |var__temp_h'2797| res)
                   (+ (sel var__temp_h2795 res) 10))
                (= (sel |var__temp_h'2797| other) (sel var__temp_h2795 other)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h2795 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c2
PARTIAL PATH NEW
SUB 
 	 --c2
 	 --foo
 	 --c2'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2800 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2800 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2800, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2800, res ) ==((sel)( , var_h2799, res ) + (10))
 	 , (sel)( , var_h_i2800, other ) ==(sel)( , var_h2799, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2801:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2800 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************766
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2800 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2800, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2800, res ) ==((sel)( , var_h2799, res ) + (10))
 	 , (sel)( , var_h_i2800, other ) ==(sel)( , var_h2799, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2801:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2800 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2800 --->  Ty_heap  
 var_h2799 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2768 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2802 --->  Ty_heap  
 var__temp_v2803 --->  Ty_int  
 var__temp_h'2804 --->  Ty_heap  
 var__temp_v_err2805 --->  error  
 var_h2799 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2799, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2802, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2802, res ) ==((sel)( , var_h2799, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2802, other ) ==(sel)( , var_h2799, other ) => 
 	 Rel (sel)( , var__temp_h2802, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2802, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2804, res ) ==(var__temp_v2803) AND 
 	 Rel (sel)( , var__temp_h'2804, res ) ==((sel)( , var__temp_h2802, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2804, other ) ==(sel)( , var__temp_h2802, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2804, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2804, other ) > (4)
 
VC_END(declare-const var_h_i2800 T9979)
(declare-const var_h2799 T9979)
(declare-const v Int)
(declare-const var_h_i2768 T9979)
(declare-const var_h2767 T9979)
(declare-const v Int)
(declare-const var_h_i2450 T9979)
(declare-const var_h2449 T9979)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2802 T9979)
(declare-const var__temp_v2803 Int)
(declare-const |var__temp_h'2804| T9979)
(declare-const var__temp_v_err2805 T9980)
(declare-const var_h2799 T9979)
(declare-const var_h2767 T9979)
(declare-const var_h2449 T9979)
(declare-const err T9993)

solver 
 (declare-sort T9979)
(declare-fun sel (T9979 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2799 () T9979)
(declare-fun var_h2449 () T9979)
(declare-fun other () Int)
(declare-fun |var__temp_h'2804| () T9979)
(declare-fun var__temp_h2802 () T9979)
(declare-fun var__temp_v2803 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2799 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2802 res) v)
                (= (sel var__temp_h2802 res) (+ (sel var_h2799 res) 10))
                (= (sel var__temp_h2802 other) (sel var_h2799 other))))
      (a!2 (and (= (sel |var__temp_h'2804| res) var__temp_v2803)
                (= (sel |var__temp_h'2804| res) (+ (sel var__temp_h2802 res) 3))
                (= (sel |var__temp_h'2804| other) (sel var__temp_h2802 other))))
      (a!3 (and (= (sel |var__temp_h'2804| res) 10)
                (not (> (sel |var__temp_h'2804| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2802 res) 7))
                (=> (= (sel var__temp_h2802 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************767
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2800 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2800, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2800, res ) ==((sel)( , var_h2799, res ) + (10))
 	 , (sel)( , var_h_i2800, other ) ==(sel)( , var_h2799, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2801:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2800 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2800 --->  Ty_heap  
 var_h2799 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2768 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2806 --->  Ty_heap  
 var__temp_v2807 --->  Ty_int  
 var__temp_h'2808 --->  Ty_heap  
 var__temp_v_err2809 --->  error  
 var_h2799 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2799, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2806, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2806, res ) ==((sel)( , var_h2799, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2806, other ) ==(sel)( , var_h2799, other ) => 
 	 Rel (sel)( , var__temp_h2806, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2806, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2808, res ) ==(var__temp_v2807) AND 
 	 Rel (sel)( , var__temp_h'2808, res ) ==((sel)( , var__temp_h2806, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2808, other ) ==(sel)( , var__temp_h2806, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2808, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2808, other ) > (4)
 
VC_END(declare-const var_h_i2800 T9996)
(declare-const var_h2799 T9996)
(declare-const v Int)
(declare-const var_h_i2768 T9996)
(declare-const var_h2767 T9996)
(declare-const v Int)
(declare-const var_h_i2450 T9996)
(declare-const var_h2449 T9996)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2806 T9996)
(declare-const var__temp_v2807 Int)
(declare-const |var__temp_h'2808| T9996)
(declare-const var__temp_v_err2809 T9997)
(declare-const var_h2799 T9996)
(declare-const var_h2767 T9996)
(declare-const var_h2449 T9996)
(declare-const err T10010)

solver 
 (declare-sort T9996)
(declare-fun sel (T9996 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2799 () T9996)
(declare-fun var_h2449 () T9996)
(declare-fun other () Int)
(declare-fun |var__temp_h'2808| () T9996)
(declare-fun var__temp_h2806 () T9996)
(declare-fun var__temp_v2807 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2799 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2806 res) v)
                (= (sel var__temp_h2806 res) (+ (sel var_h2799 res) 10))
                (= (sel var__temp_h2806 other) (sel var_h2799 other))))
      (a!2 (and (= (sel |var__temp_h'2808| res) var__temp_v2807)
                (= (sel |var__temp_h'2808| res) (+ (sel var__temp_h2806 res) 5))
                (= (sel |var__temp_h'2808| other) (sel var__temp_h2806 other))))
      (a!3 (and (= (sel |var__temp_h'2808| res) 10)
                (not (> (sel |var__temp_h'2808| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2806 res) 7))
                (=> (= (sel var__temp_h2806 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************768
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2800 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2800, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2800, res ) ==((sel)( , var_h2799, res ) + (10))
 	 , (sel)( , var_h_i2800, other ) ==(sel)( , var_h2799, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2801:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2800 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2800 --->  Ty_heap  
 var_h2799 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2768 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2810 --->  Ty_heap  
 var__temp_v2811 --->  Ty_int  
 var__temp_h'2812 --->  Ty_heap  
 var__temp_v_err2813 --->  error  
 var_h2799 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2799, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2810, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2810, res ) ==((sel)( , var_h2799, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2810, other ) ==(sel)( , var_h2799, other ) => 
 	 Rel (sel)( , var__temp_h2810, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2810, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2812, res ) ==(var__temp_v2811) AND 
 	 Rel (sel)( , var__temp_h'2812, res ) ==((sel)( , var__temp_h2810, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2812, other ) ==(sel)( , var__temp_h2810, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2812, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2812, other ) > (4)
 
VC_END(declare-const var_h_i2800 T10013)
(declare-const var_h2799 T10013)
(declare-const v Int)
(declare-const var_h_i2768 T10013)
(declare-const var_h2767 T10013)
(declare-const v Int)
(declare-const var_h_i2450 T10013)
(declare-const var_h2449 T10013)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2810 T10013)
(declare-const var__temp_v2811 Int)
(declare-const |var__temp_h'2812| T10013)
(declare-const var__temp_v_err2813 T10014)
(declare-const var_h2799 T10013)
(declare-const var_h2767 T10013)
(declare-const var_h2449 T10013)
(declare-const err T10027)

solver 
 (declare-sort T10013)
(declare-fun sel (T10013 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2799 () T10013)
(declare-fun var_h2449 () T10013)
(declare-fun other () Int)
(declare-fun |var__temp_h'2812| () T10013)
(declare-fun var__temp_h2810 () T10013)
(declare-fun var__temp_v2811 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2799 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2810 res) v)
                (= (sel var__temp_h2810 res) (+ (sel var_h2799 res) 10))
                (= (sel var__temp_h2810 other) (sel var_h2799 other))))
      (a!2 (and (= (sel |var__temp_h'2812| res) var__temp_v2811)
                (= (sel |var__temp_h'2812| res) (+ (sel var__temp_h2810 res) 2))
                (= (sel |var__temp_h'2812| other) (sel var__temp_h2810 other))))
      (a!3 (and (= (sel |var__temp_h'2812| res) 10)
                (not (> (sel |var__temp_h'2812| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2810 res) 5))
                (=> (= (sel var__temp_h2810 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************769
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2801:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2801:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2foofoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c2
 	 --foo
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2800 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2800, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2800, res ) ==((sel)( , var_h2799, res ) + (10))
 	 , (sel)( , var_h_i2800, other ) ==(sel)( , var_h2799, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2814:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************770
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2800 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2800, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2800, res ) ==((sel)( , var_h2799, res ) + (10))
 	 , (sel)( , var_h_i2800, other ) ==(sel)( , var_h2799, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2814:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2800 --->  Ty_heap  
 var_h2799 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2768 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2815 --->  Ty_heap  
 var__temp_v2816 --->  Ty_int  
 var__temp_h'2817 --->  Ty_heap  
 var__temp_v_err2818 --->  error  
 var_h2799 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2799, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2815, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2815, res ) ==((sel)( , var_h2799, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2815, other ) ==(sel)( , var_h2799, other ) => 
 	 Rel (sel)( , var__temp_h2815, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2815, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2817, res ) ==(var__temp_v2816) AND 
 	 Rel (sel)( , var__temp_h'2817, res ) ==((sel)( , var__temp_h2815, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2817, other ) ==(sel)( , var__temp_h2815, other ) => 
 	 True
 
VC_END(declare-const var_h_i2800 T10030)
(declare-const var_h2799 T10030)
(declare-const v Int)
(declare-const var_h_i2768 T10030)
(declare-const var_h2767 T10030)
(declare-const v Int)
(declare-const var_h_i2450 T10030)
(declare-const var_h2449 T10030)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2815 T10030)
(declare-const var__temp_v2816 Int)
(declare-const |var__temp_h'2817| T10030)
(declare-const var__temp_v_err2818 T10031)
(declare-const var_h2799 T10030)
(declare-const var_h2767 T10030)
(declare-const var_h2449 T10030)
(declare-const err T10044)

solver 
 (declare-sort T10030)
(declare-fun sel (T10030 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2799 () T10030)
(declare-fun var_h2449 () T10030)
(declare-fun other () Int)
(declare-fun var__temp_h2815 () T10030)
(declare-fun |var__temp_h'2817| () T10030)
(declare-fun var__temp_v2816 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2799 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2815 res) v)
                (= (sel var__temp_h2815 res) (+ (sel var_h2799 res) 10))
                (= (sel var__temp_h2815 other) (sel var_h2799 other))))
      (a!2 (and (= (sel |var__temp_h'2817| res) var__temp_v2816)
                (= (sel |var__temp_h'2817| res) (+ (sel var__temp_h2815 res) 3))
                (= (sel |var__temp_h'2817| other) (sel var__temp_h2815 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2815 res) 7))
                (=> (= (sel var__temp_h2815 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************771
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2800 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2800, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2800, res ) ==((sel)( , var_h2799, res ) + (10))
 	 , (sel)( , var_h_i2800, other ) ==(sel)( , var_h2799, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2814:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2800 --->  Ty_heap  
 var_h2799 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2768 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2819 --->  Ty_heap  
 var__temp_v2820 --->  Ty_int  
 var__temp_h'2821 --->  Ty_heap  
 var__temp_v_err2822 --->  error  
 var_h2799 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2799, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2819, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2819, res ) ==((sel)( , var_h2799, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2819, other ) ==(sel)( , var_h2799, other ) => 
 	 Rel (sel)( , var__temp_h2819, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2819, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2821, res ) ==(var__temp_v2820) AND 
 	 Rel (sel)( , var__temp_h'2821, res ) ==((sel)( , var__temp_h2819, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2821, other ) ==(sel)( , var__temp_h2819, other ) => 
 	 True
 
VC_END(declare-const var_h_i2800 T10047)
(declare-const var_h2799 T10047)
(declare-const v Int)
(declare-const var_h_i2768 T10047)
(declare-const var_h2767 T10047)
(declare-const v Int)
(declare-const var_h_i2450 T10047)
(declare-const var_h2449 T10047)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2819 T10047)
(declare-const var__temp_v2820 Int)
(declare-const |var__temp_h'2821| T10047)
(declare-const var__temp_v_err2822 T10048)
(declare-const var_h2799 T10047)
(declare-const var_h2767 T10047)
(declare-const var_h2449 T10047)
(declare-const err T10061)

solver 
 (declare-sort T10047)
(declare-fun sel (T10047 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2799 () T10047)
(declare-fun var_h2449 () T10047)
(declare-fun other () Int)
(declare-fun var__temp_h2819 () T10047)
(declare-fun |var__temp_h'2821| () T10047)
(declare-fun var__temp_v2820 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2799 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2819 res) v)
                (= (sel var__temp_h2819 res) (+ (sel var_h2799 res) 10))
                (= (sel var__temp_h2819 other) (sel var_h2799 other))))
      (a!2 (and (= (sel |var__temp_h'2821| res) var__temp_v2820)
                (= (sel |var__temp_h'2821| res) (+ (sel var__temp_h2819 res) 5))
                (= (sel |var__temp_h'2821| other) (sel var__temp_h2819 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2819 res) 7))
                (=> (= (sel var__temp_h2819 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************772
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2800 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2800, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2800, res ) ==((sel)( , var_h2799, res ) + (10))
 	 , (sel)( , var_h_i2800, other ) ==(sel)( , var_h2799, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2814:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2800 --->  Ty_heap  
 var_h2799 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2768 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2823 --->  Ty_heap  
 var__temp_v2824 --->  Ty_int  
 var__temp_h'2825 --->  Ty_heap  
 var__temp_v_err2826 --->  error  
 var_h2799 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2799, res ) > (4) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2823, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2823, res ) ==((sel)( , var_h2799, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2823, other ) ==(sel)( , var_h2799, other ) => 
 	 Rel (sel)( , var__temp_h2823, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2823, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2825, res ) ==(var__temp_v2824) AND 
 	 Rel (sel)( , var__temp_h'2825, res ) ==((sel)( , var__temp_h2823, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2825, other ) ==(sel)( , var__temp_h2823, other ) => 
 	 True
 
VC_END(declare-const var_h_i2800 T10064)
(declare-const var_h2799 T10064)
(declare-const v Int)
(declare-const var_h_i2768 T10064)
(declare-const var_h2767 T10064)
(declare-const v Int)
(declare-const var_h_i2450 T10064)
(declare-const var_h2449 T10064)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2823 T10064)
(declare-const var__temp_v2824 Int)
(declare-const |var__temp_h'2825| T10064)
(declare-const var__temp_v_err2826 T10065)
(declare-const var_h2799 T10064)
(declare-const var_h2767 T10064)
(declare-const var_h2449 T10064)
(declare-const err T10078)

solver 
 (declare-sort T10064)
(declare-fun sel (T10064 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2799 () T10064)
(declare-fun var_h2449 () T10064)
(declare-fun other () Int)
(declare-fun var__temp_h2823 () T10064)
(declare-fun |var__temp_h'2825| () T10064)
(declare-fun var__temp_v2824 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2799 res) 4))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2823 res) v)
                (= (sel var__temp_h2823 res) (+ (sel var_h2799 res) 10))
                (= (sel var__temp_h2823 other) (sel var_h2799 other))))
      (a!2 (and (= (sel |var__temp_h'2825| res) var__temp_v2824)
                (= (sel |var__temp_h'2825| res) (+ (sel var__temp_h2823 res) 2))
                (= (sel |var__temp_h'2825| other) (sel var__temp_h2823 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2823 res) 5))
                (=> (= (sel var__temp_h2823 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************773
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 
 	 --foo
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2768 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2768, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2768, other ) ==(sel)( , var_h2767, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2827:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************774
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2768 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2768, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2768, other ) ==(sel)( , var_h2767, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2827:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2768 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2828 --->  Ty_heap  
 var__temp_v2829 --->  Ty_int  
 var__temp_h'2830 --->  Ty_heap  
 var__temp_v_err2831 --->  error  
 var_h2767 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2828, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2828, other ) ==(sel)( , var_h2767, other ) => 
 	 Rel (sel)( , var__temp_h2828, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2828, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2830, res ) ==(var__temp_v2829) AND 
 	 Rel (sel)( , var__temp_h'2830, res ) ==((sel)( , var__temp_h2828, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2830, other ) ==(sel)( , var__temp_h2828, other ) => 
 	 True
 
VC_END(declare-const var_h_i2768 T10081)
(declare-const var_h2767 T10081)
(declare-const v Int)
(declare-const var_h_i2450 T10081)
(declare-const var_h2449 T10081)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2828 T10081)
(declare-const var__temp_v2829 Int)
(declare-const |var__temp_h'2830| T10081)
(declare-const var__temp_v_err2831 T10082)
(declare-const var_h2767 T10081)
(declare-const var_h2449 T10081)
(declare-const err T10095)
    (declare-const |5| Int)
  
solver 
 (declare-sort T10081)
(declare-fun sel (T10081 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T10081)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2828 () T10081)
(declare-fun |var__temp_h'2830| () T10081)
(declare-fun var__temp_v2829 () Int)
(declare-fun var_h2767 () T10081)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2828 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2828 other) (sel var_h2767 other)))
               (= (sel var__temp_h2828 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2830| res) var__temp_v2829)
                (= (sel |var__temp_h'2830| res) (+ (sel var__temp_h2828 res) 3))
                (= (sel |var__temp_h'2830| other) (sel var__temp_h2828 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2828 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************775
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2768 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2768, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2768, other ) ==(sel)( , var_h2767, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2827:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2768 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2832 --->  Ty_heap  
 var__temp_v2833 --->  Ty_int  
 var__temp_h'2834 --->  Ty_heap  
 var__temp_v_err2835 --->  error  
 var_h2767 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2832, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2832, other ) ==(sel)( , var_h2767, other ) => 
 	 Rel (sel)( , var__temp_h2832, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2832, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2834, res ) ==(var__temp_v2833) AND 
 	 Rel (sel)( , var__temp_h'2834, res ) ==((sel)( , var__temp_h2832, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2834, other ) ==(sel)( , var__temp_h2832, other ) => 
 	 True
 
VC_END(declare-const var_h_i2768 T10098)
(declare-const var_h2767 T10098)
(declare-const v Int)
(declare-const var_h_i2450 T10098)
(declare-const var_h2449 T10098)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2832 T10098)
(declare-const var__temp_v2833 Int)
(declare-const |var__temp_h'2834| T10098)
(declare-const var__temp_v_err2835 T10099)
(declare-const var_h2767 T10098)
(declare-const var_h2449 T10098)
(declare-const err T10112)
    (declare-const |5| Int)
  
solver 
 (declare-sort T10098)
(declare-fun sel (T10098 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T10098)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2832 () T10098)
(declare-fun |var__temp_h'2834| () T10098)
(declare-fun var__temp_v2833 () Int)
(declare-fun var_h2767 () T10098)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2832 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2832 other) (sel var_h2767 other)))
               (= (sel var__temp_h2832 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2834| res) var__temp_v2833)
                (= (sel |var__temp_h'2834| res) (+ (sel var__temp_h2832 res) 5))
                (= (sel |var__temp_h'2834| other) (sel var__temp_h2832 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2832 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************776
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2768 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2768, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2768, other ) ==(sel)( , var_h2767, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2827:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2768 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2836 --->  Ty_heap  
 var__temp_v2837 --->  Ty_int  
 var__temp_h'2838 --->  Ty_heap  
 var__temp_v_err2839 --->  error  
 var_h2767 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2836, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2836, other ) ==(sel)( , var_h2767, other ) => 
 	 Rel (sel)( , var__temp_h2836, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2836, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2838, res ) ==(var__temp_v2837) AND 
 	 Rel (sel)( , var__temp_h'2838, res ) ==((sel)( , var__temp_h2836, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2838, other ) ==(sel)( , var__temp_h2836, other ) => 
 	 True
 
VC_END(declare-const var_h_i2768 T10115)
(declare-const var_h2767 T10115)
(declare-const v Int)
(declare-const var_h_i2450 T10115)
(declare-const var_h2449 T10115)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2836 T10115)
(declare-const var__temp_v2837 Int)
(declare-const |var__temp_h'2838| T10115)
(declare-const var__temp_v_err2839 T10116)
(declare-const var_h2767 T10115)
(declare-const var_h2449 T10115)
(declare-const err T10129)
    (declare-const |5| Int)
  
solver 
 (declare-sort T10115)
(declare-fun sel (T10115 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T10115)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2836 () T10115)
(declare-fun |var__temp_h'2838| () T10115)
(declare-fun var__temp_v2837 () Int)
(declare-fun var_h2767 () T10115)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2836 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2836 other) (sel var_h2767 other)))
               (= (sel var__temp_h2836 res) 5)))
      (a!2 (and (= (sel |var__temp_h'2838| res) var__temp_v2837)
                (= (sel |var__temp_h'2838| res) (+ (sel var__temp_h2836 res) 2))
                (= (sel |var__temp_h'2838| other) (sel var__temp_h2836 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2836 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************bar
PARTIAL PATH NEW
SUB 
 	 --bar
 	 --foo
 	 --c2'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2841 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2841 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2841, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2841, res ) ==((sel)( , var_h2840, res ) + (2))
 	 , (sel)( , var_h_i2841, other ) ==(sel)( , var_h2840, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2842:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2841 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************777
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2841 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2841, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2841, res ) ==((sel)( , var_h2840, res ) + (2))
 	 , (sel)( , var_h_i2841, other ) ==(sel)( , var_h2840, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2842:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2841 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2841 --->  Ty_heap  
 var_h2840 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2768 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2843 --->  Ty_heap  
 var__temp_v2844 --->  Ty_int  
 var__temp_h'2845 --->  Ty_heap  
 var__temp_v_err2846 --->  error  
 var_h2840 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2840, res ) ==(5) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2843, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2843, res ) ==((sel)( , var_h2840, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h2843, other ) ==(sel)( , var_h2840, other ) => 
 	 Rel (sel)( , var__temp_h2843, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2843, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2845, res ) ==(var__temp_v2844) AND 
 	 Rel (sel)( , var__temp_h'2845, res ) ==((sel)( , var__temp_h2843, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2845, other ) ==(sel)( , var__temp_h2843, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2845, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2845, other ) > (4)
 
VC_END(declare-const var_h_i2841 T10132)
(declare-const var_h2840 T10132)
(declare-const v Int)
(declare-const var_h_i2768 T10132)
(declare-const var_h2767 T10132)
(declare-const v Int)
(declare-const var_h_i2450 T10132)
(declare-const var_h2449 T10132)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2843 T10132)
(declare-const var__temp_v2844 Int)
(declare-const |var__temp_h'2845| T10132)
(declare-const var__temp_v_err2846 T10133)
(declare-const var_h2840 T10132)
(declare-const var_h2767 T10132)
(declare-const var_h2449 T10132)
(declare-const err T10146)

solver 
 (declare-sort T10132)
(declare-fun sel (T10132 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2840 () T10132)
(declare-fun var_h2449 () T10132)
(declare-fun other () Int)
(declare-fun |var__temp_h'2845| () T10132)
(declare-fun var__temp_h2843 () T10132)
(declare-fun var__temp_v2844 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2840 res) 5))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2843 res) v)
                (= (sel var__temp_h2843 res) (+ (sel var_h2840 res) 2))
                (= (sel var__temp_h2843 other) (sel var_h2840 other))))
      (a!2 (and (= (sel |var__temp_h'2845| res) var__temp_v2844)
                (= (sel |var__temp_h'2845| res) (+ (sel var__temp_h2843 res) 3))
                (= (sel |var__temp_h'2845| other) (sel var__temp_h2843 other))))
      (a!3 (and (= (sel |var__temp_h'2845| res) 10)
                (not (> (sel |var__temp_h'2845| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2843 res) 7))
                (=> (= (sel var__temp_h2843 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************778
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2841 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2841, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2841, res ) ==((sel)( , var_h2840, res ) + (2))
 	 , (sel)( , var_h_i2841, other ) ==(sel)( , var_h2840, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2842:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2841 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2841 --->  Ty_heap  
 var_h2840 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2768 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2847 --->  Ty_heap  
 var__temp_v2848 --->  Ty_int  
 var__temp_h'2849 --->  Ty_heap  
 var__temp_v_err2850 --->  error  
 var_h2840 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2840, res ) ==(5) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2847, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2847, res ) ==((sel)( , var_h2840, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h2847, other ) ==(sel)( , var_h2840, other ) => 
 	 Rel (sel)( , var__temp_h2847, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2847, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2849, res ) ==(var__temp_v2848) AND 
 	 Rel (sel)( , var__temp_h'2849, res ) ==((sel)( , var__temp_h2847, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2849, other ) ==(sel)( , var__temp_h2847, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2849, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2849, other ) > (4)
 
VC_END(declare-const var_h_i2841 T10149)
(declare-const var_h2840 T10149)
(declare-const v Int)
(declare-const var_h_i2768 T10149)
(declare-const var_h2767 T10149)
(declare-const v Int)
(declare-const var_h_i2450 T10149)
(declare-const var_h2449 T10149)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2847 T10149)
(declare-const var__temp_v2848 Int)
(declare-const |var__temp_h'2849| T10149)
(declare-const var__temp_v_err2850 T10150)
(declare-const var_h2840 T10149)
(declare-const var_h2767 T10149)
(declare-const var_h2449 T10149)
(declare-const err T10163)

solver 
 (declare-sort T10149)
(declare-fun sel (T10149 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2840 () T10149)
(declare-fun var_h2449 () T10149)
(declare-fun other () Int)
(declare-fun |var__temp_h'2849| () T10149)
(declare-fun var__temp_h2847 () T10149)
(declare-fun var__temp_v2848 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2840 res) 5))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2847 res) v)
                (= (sel var__temp_h2847 res) (+ (sel var_h2840 res) 2))
                (= (sel var__temp_h2847 other) (sel var_h2840 other))))
      (a!2 (and (= (sel |var__temp_h'2849| res) var__temp_v2848)
                (= (sel |var__temp_h'2849| res) (+ (sel var__temp_h2847 res) 5))
                (= (sel |var__temp_h'2849| other) (sel var__temp_h2847 other))))
      (a!3 (and (= (sel |var__temp_h'2849| res) 10)
                (not (> (sel |var__temp_h'2849| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2847 res) 7))
                (=> (= (sel var__temp_h2847 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************779
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2842:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2842:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbarc2foofoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2841 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2841, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2841, res ) ==((sel)( , var_h2840, res ) + (2))
 	 , (sel)( , var_h_i2841, other ) ==(sel)( , var_h2840, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2851:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************780
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2841 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2841, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2841, res ) ==((sel)( , var_h2840, res ) + (2))
 	 , (sel)( , var_h_i2841, other ) ==(sel)( , var_h2840, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2851:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2841 --->  Ty_heap  
 var_h2840 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2768 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2852 --->  Ty_heap  
 var__temp_v2853 --->  Ty_int  
 var__temp_h'2854 --->  Ty_heap  
 var__temp_v_err2855 --->  error  
 var_h2840 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2840, res ) ==(5) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2852, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2852, res ) ==((sel)( , var_h2840, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h2852, other ) ==(sel)( , var_h2840, other ) => 
 	 Rel (sel)( , var__temp_h2852, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2852, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2854, res ) ==(var__temp_v2853) AND 
 	 Rel (sel)( , var__temp_h'2854, res ) ==((sel)( , var__temp_h2852, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2854, other ) ==(sel)( , var__temp_h2852, other ) => 
 	 True
 
VC_END(declare-const var_h_i2841 T10166)
(declare-const var_h2840 T10166)
(declare-const v Int)
(declare-const var_h_i2768 T10166)
(declare-const var_h2767 T10166)
(declare-const v Int)
(declare-const var_h_i2450 T10166)
(declare-const var_h2449 T10166)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2852 T10166)
(declare-const var__temp_v2853 Int)
(declare-const |var__temp_h'2854| T10166)
(declare-const var__temp_v_err2855 T10167)
(declare-const var_h2840 T10166)
(declare-const var_h2767 T10166)
(declare-const var_h2449 T10166)
(declare-const err T10180)

solver 
 (declare-sort T10166)
(declare-fun sel (T10166 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2840 () T10166)
(declare-fun var_h2449 () T10166)
(declare-fun other () Int)
(declare-fun var__temp_h2852 () T10166)
(declare-fun |var__temp_h'2854| () T10166)
(declare-fun var__temp_v2853 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2840 res) 5))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2852 res) v)
                (= (sel var__temp_h2852 res) (+ (sel var_h2840 res) 2))
                (= (sel var__temp_h2852 other) (sel var_h2840 other))))
      (a!2 (and (= (sel |var__temp_h'2854| res) var__temp_v2853)
                (= (sel |var__temp_h'2854| res) (+ (sel var__temp_h2852 res) 3))
                (= (sel |var__temp_h'2854| other) (sel var__temp_h2852 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2852 res) 7))
                (=> (= (sel var__temp_h2852 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************baz
PARTIAL PATH NEW
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --c2'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2857 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2857 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2857, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2857, res ) ==((sel)( , var_h2856, res ) + (3))
 	 , (sel)( , var_h_i2857, other ) ==(sel)( , var_h2856, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2858:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2857 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************781
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2857 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2857, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2857, res ) ==((sel)( , var_h2856, res ) + (3))
 	 , (sel)( , var_h_i2857, other ) ==(sel)( , var_h2856, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2858:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2857 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2857 --->  Ty_heap  
 var_h2856 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2841 --->  Ty_heap  
 var_h2840 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2768 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2859 --->  Ty_heap  
 var__temp_v2860 --->  Ty_int  
 var__temp_h'2861 --->  Ty_heap  
 var__temp_v_err2862 --->  error  
 var_h2856 --->  Ty_heap  
 var_h2840 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h2856, res ) ==(7) AND 
 	 Rel (sel)( , var_h2840, res ) ==(5) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2859, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2859, res ) ==((sel)( , var_h2856, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h2859, other ) ==(sel)( , var_h2856, other ) => 
 	 Rel (sel)( , var__temp_h2859, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2859, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2861, res ) ==(var__temp_v2860) AND 
 	 Rel (sel)( , var__temp_h'2861, res ) ==((sel)( , var__temp_h2859, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2861, other ) ==(sel)( , var__temp_h2859, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2861, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2861, other ) > (4)
 
VC_END(declare-const var_h_i2857 T10183)
(declare-const var_h2856 T10183)
(declare-const v Int)
(declare-const var_h_i2841 T10183)
(declare-const var_h2840 T10183)
(declare-const v Int)
(declare-const var_h_i2768 T10183)
(declare-const var_h2767 T10183)
(declare-const v Int)
(declare-const var_h_i2450 T10183)
(declare-const var_h2449 T10183)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2859 T10183)
(declare-const var__temp_v2860 Int)
(declare-const |var__temp_h'2861| T10183)
(declare-const var__temp_v_err2862 T10184)
(declare-const var_h2856 T10183)
(declare-const var_h2840 T10183)
(declare-const var_h2767 T10183)
(declare-const var_h2449 T10183)
(declare-const err T10197)

solver 
 (declare-sort T10183)
(declare-fun sel (T10183 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2856 () T10183)
(declare-fun var_h2840 () T10183)
(declare-fun var_h2449 () T10183)
(declare-fun other () Int)
(declare-fun |var__temp_h'2861| () T10183)
(declare-fun var__temp_h2859 () T10183)
(declare-fun var__temp_v2860 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2856 res) 7))
(assert (= (sel var_h2840 res) 5))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2859 res) v)
                (= (sel var__temp_h2859 res) (+ (sel var_h2856 res) 3))
                (= (sel var__temp_h2859 other) (sel var_h2856 other))))
      (a!2 (and (= (sel |var__temp_h'2861| res) var__temp_v2860)
                (= (sel |var__temp_h'2861| res) (+ (sel var__temp_h2859 res) 5))
                (= (sel |var__temp_h'2861| other) (sel var__temp_h2859 other))))
      (a!3 (and (= (sel |var__temp_h'2861| res) 10)
                (not (> (sel |var__temp_h'2861| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2859 res) 7))
                (=> (= (sel var__temp_h2859 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************782
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2858:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2858:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbazbarc2foofoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2857 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2857, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2857, res ) ==((sel)( , var_h2856, res ) + (3))
 	 , (sel)( , var_h_i2857, other ) ==(sel)( , var_h2856, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2863:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************783
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2857 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2857, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2857, res ) ==((sel)( , var_h2856, res ) + (3))
 	 , (sel)( , var_h_i2857, other ) ==(sel)( , var_h2856, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2863:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2857 --->  Ty_heap  
 var_h2856 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2841 --->  Ty_heap  
 var_h2840 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2768 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2864 --->  Ty_heap  
 var__temp_v2865 --->  Ty_int  
 var__temp_h'2866 --->  Ty_heap  
 var__temp_v_err2867 --->  error  
 var_h2856 --->  Ty_heap  
 var_h2840 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var_h2856, res ) ==(7) AND 
 	 Rel (sel)( , var_h2840, res ) ==(5) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2864, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2864, res ) ==((sel)( , var_h2856, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h2864, other ) ==(sel)( , var_h2856, other ) => 
 	 Rel (sel)( , var__temp_h2864, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2864, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2866, res ) ==(var__temp_v2865) AND 
 	 Rel (sel)( , var__temp_h'2866, res ) ==((sel)( , var__temp_h2864, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2866, other ) ==(sel)( , var__temp_h2864, other ) => 
 	 True
 
VC_END(declare-const var_h_i2857 T10200)
(declare-const var_h2856 T10200)
(declare-const v Int)
(declare-const var_h_i2841 T10200)
(declare-const var_h2840 T10200)
(declare-const v Int)
(declare-const var_h_i2768 T10200)
(declare-const var_h2767 T10200)
(declare-const v Int)
(declare-const var_h_i2450 T10200)
(declare-const var_h2449 T10200)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2864 T10200)
(declare-const var__temp_v2865 Int)
(declare-const |var__temp_h'2866| T10200)
(declare-const var__temp_v_err2867 T10201)
(declare-const var_h2856 T10200)
(declare-const var_h2840 T10200)
(declare-const var_h2767 T10200)
(declare-const var_h2449 T10200)
(declare-const err T10214)

solver 
 (declare-sort T10200)
(declare-fun sel (T10200 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2856 () T10200)
(declare-fun var_h2840 () T10200)
(declare-fun var_h2449 () T10200)
(declare-fun other () Int)
(declare-fun var__temp_h2864 () T10200)
(declare-fun |var__temp_h'2866| () T10200)
(declare-fun var__temp_v2865 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2856 res) 7))
(assert (= (sel var_h2840 res) 5))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2864 res) v)
                (= (sel var__temp_h2864 res) (+ (sel var_h2856 res) 3))
                (= (sel var__temp_h2864 other) (sel var_h2856 other))))
      (a!2 (and (= (sel |var__temp_h'2866| res) var__temp_v2865)
                (= (sel |var__temp_h'2866| res) (+ (sel var__temp_h2864 res) 5))
                (= (sel |var__temp_h'2866| other) (sel var__temp_h2864 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2864 res) 7))
                (=> (= (sel var__temp_h2864 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************784
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT baz
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2841 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2841, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2841, res ) ==((sel)( , var_h2840, res ) + (2))
 	 , (sel)( , var_h_i2841, other ) ==(sel)( , var_h2840, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2868:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************785
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2841 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2841, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2841, res ) ==((sel)( , var_h2840, res ) + (2))
 	 , (sel)( , var_h_i2841, other ) ==(sel)( , var_h2840, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2868:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2841 --->  Ty_heap  
 var_h2840 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2768 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2869 --->  Ty_heap  
 var__temp_v2870 --->  Ty_int  
 var__temp_h'2871 --->  Ty_heap  
 var__temp_v_err2872 --->  error  
 var_h2840 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h2840, res ) ==(5) AND 
 	 Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2869, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2869, res ) ==((sel)( , var_h2840, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h2869, other ) ==(sel)( , var_h2840, other ) => 
 	 Rel (sel)( , var__temp_h2869, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2869, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2871, res ) ==(var__temp_v2870) AND 
 	 Rel (sel)( , var__temp_h'2871, res ) ==((sel)( , var__temp_h2869, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2871, other ) ==(sel)( , var__temp_h2869, other ) => 
 	 True
 
VC_END(declare-const var_h_i2841 T10217)
(declare-const var_h2840 T10217)
(declare-const v Int)
(declare-const var_h_i2768 T10217)
(declare-const var_h2767 T10217)
(declare-const v Int)
(declare-const var_h_i2450 T10217)
(declare-const var_h2449 T10217)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2869 T10217)
(declare-const var__temp_v2870 Int)
(declare-const |var__temp_h'2871| T10217)
(declare-const var__temp_v_err2872 T10218)
(declare-const var_h2840 T10217)
(declare-const var_h2767 T10217)
(declare-const var_h2449 T10217)
(declare-const err T10231)

solver 
 (declare-sort T10217)
(declare-fun sel (T10217 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2840 () T10217)
(declare-fun var_h2449 () T10217)
(declare-fun other () Int)
(declare-fun var__temp_h2869 () T10217)
(declare-fun |var__temp_h'2871| () T10217)
(declare-fun var__temp_v2870 () Int)
(declare-fun v () Int)
(assert (= (sel var_h2840 res) 5))
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (and (= (sel var__temp_h2869 res) v)
                (= (sel var__temp_h2869 res) (+ (sel var_h2840 res) 2))
                (= (sel var__temp_h2869 other) (sel var_h2840 other))))
      (a!2 (and (= (sel |var__temp_h'2871| res) var__temp_v2870)
                (= (sel |var__temp_h'2871| res) (+ (sel var__temp_h2869 res) 5))
                (= (sel |var__temp_h'2871| other) (sel var__temp_h2869 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2869 res) 7))
                (=> (= (sel var__temp_h2869 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c5
PARTIAL PATH NEW
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --c2'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2874 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2874 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2874, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2874, res ) ==((sel)( , var_h2873, res ) + (5))
 	 , (sel)( , var_h_i2874, other ) ==(sel)( , var_h2873, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2875:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2874 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************786
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2875:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2875:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc5bazbarc2foofoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2874 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2874, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2874, res ) ==((sel)( , var_h2873, res ) + (5))
 	 , (sel)( , var_h_i2874, other ) ==(sel)( , var_h2873, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2876:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************787
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2841 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2841, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2841, res ) ==((sel)( , var_h2840, res ) + (2))
 	 , (sel)( , var_h_i2841, other ) ==(sel)( , var_h2840, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2877:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************788
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --foo
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2768 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2768, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2768, other ) ==(sel)( , var_h2767, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2878:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************789
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2768 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2768, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2768, other ) ==(sel)( , var_h2767, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2878:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2768 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2879 --->  Ty_heap  
 var__temp_v2880 --->  Ty_int  
 var__temp_h'2881 --->  Ty_heap  
 var__temp_v_err2882 --->  error  
 var_h2767 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2879, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2879, other ) ==(sel)( , var_h2767, other ) => 
 	 Rel (sel)( , var__temp_h2879, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2879, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2881, res ) ==(var__temp_v2880) AND 
 	 Rel (sel)( , var__temp_h'2881, res ) ==((sel)( , var__temp_h2879, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2881, other ) ==(sel)( , var__temp_h2879, other ) => 
 	 True
 
VC_END(declare-const var_h_i2768 T10234)
(declare-const var_h2767 T10234)
(declare-const v Int)
(declare-const var_h_i2450 T10234)
(declare-const var_h2449 T10234)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2879 T10234)
(declare-const var__temp_v2880 Int)
(declare-const |var__temp_h'2881| T10234)
(declare-const var__temp_v_err2882 T10235)
(declare-const var_h2767 T10234)
(declare-const var_h2449 T10234)
(declare-const err T10248)
    (declare-const |5| Int)
  
solver 
 (declare-sort T10234)
(declare-fun sel (T10234 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T10234)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2879 () T10234)
(declare-fun |var__temp_h'2881| () T10234)
(declare-fun var__temp_v2880 () Int)
(declare-fun var_h2767 () T10234)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2879 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2879 other) (sel var_h2767 other)))
               (= (sel var__temp_h2879 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2881| res) var__temp_v2880)
                (= (sel |var__temp_h'2881| res) (+ (sel var__temp_h2879 res) 3))
                (= (sel |var__temp_h'2881| other) (sel var__temp_h2879 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2879 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************790
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2768 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2768, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2768, other ) ==(sel)( , var_h2767, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2878:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2768 --->  Ty_heap  
 var_h2767 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2883 --->  Ty_heap  
 var__temp_v2884 --->  Ty_int  
 var__temp_h'2885 --->  Ty_heap  
 var__temp_v_err2886 --->  error  
 var_h2767 --->  Ty_heap  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2883, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2883, other ) ==(sel)( , var_h2767, other ) => 
 	 Rel (sel)( , var__temp_h2883, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2883, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2885, res ) ==(var__temp_v2884) AND 
 	 Rel (sel)( , var__temp_h'2885, res ) ==((sel)( , var__temp_h2883, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2885, other ) ==(sel)( , var__temp_h2883, other ) => 
 	 True
 
VC_END(declare-const var_h_i2768 T10251)
(declare-const var_h2767 T10251)
(declare-const v Int)
(declare-const var_h_i2450 T10251)
(declare-const var_h2449 T10251)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2883 T10251)
(declare-const var__temp_v2884 Int)
(declare-const |var__temp_h'2885| T10251)
(declare-const var__temp_v_err2886 T10252)
(declare-const var_h2767 T10251)
(declare-const var_h2449 T10251)
(declare-const err T10265)
    (declare-const |5| Int)
  
solver 
 (declare-sort T10251)
(declare-fun sel (T10251 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T10251)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2883 () T10251)
(declare-fun |var__temp_h'2885| () T10251)
(declare-fun var__temp_v2884 () Int)
(declare-fun var_h2767 () T10251)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2883 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2883 other) (sel var_h2767 other)))
               (= (sel var__temp_h2883 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2885| res) var__temp_v2884)
                (= (sel |var__temp_h'2885| res) (+ (sel var__temp_h2883 res) 5))
                (= (sel |var__temp_h'2885| other) (sel var__temp_h2883 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2883 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************791
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT bar
PARTIAL PATH
SUB 
 	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2450, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res )
 	 , (sel)( , var_h_i2450, other ) ==(sel)( , var_h2449, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2887:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
bar
 *********************Enumeration Iteration*****************792
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2450, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res )
 	 , (sel)( , var_h_i2450, other ) ==(sel)( , var_h2449, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2887:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2888 --->  Ty_heap  
 var__temp_v2889 --->  Ty_int  
 var__temp_h'2890 --->  Ty_heap  
 var__temp_v_err2891 --->  error  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2888, res ) ==(v) AND 
 	 Rel (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res ) AND 
 	 Rel (sel)( , var__temp_h2888, other ) ==(sel)( , var_h2449, other ) => 
 	 Rel (sel)( , var__temp_h2888, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2888, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2890, res ) ==(var__temp_v2889) AND 
 	 Rel (sel)( , var__temp_h'2890, res ) ==((sel)( , var__temp_h2888, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2890, other ) ==(sel)( , var__temp_h2888, other ) => 
 	 True
 
VC_END(declare-const var_h_i2450 T10268)
(declare-const var_h2449 T10268)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2888 T10268)
(declare-const var__temp_v2889 Int)
(declare-const |var__temp_h'2890| T10268)
(declare-const var__temp_v_err2891 T10269)
(declare-const var_h2449 T10268)
(declare-const err T10282)

solver 
 (declare-sort T10268)
(declare-fun sel (T10268 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T10268)
(declare-fun other () Int)
(declare-fun var__temp_h2888 () T10268)
(declare-fun |var__temp_h'2890| () T10268)
(declare-fun var__temp_v2889 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2888 res) v)
                    (= (sel var_h2449 res) (sel var_h2449 res))
                    (= (sel var__temp_h2888 other) (sel var_h2449 other)))
               (= (sel var__temp_h2888 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2890| res) var__temp_v2889)
                (= (sel |var__temp_h'2890| res) (+ (sel var__temp_h2888 res) 3))
                (= (sel |var__temp_h'2890| other) (sel var__temp_h2888 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2888 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************793
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2450, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res )
 	 , (sel)( , var_h_i2450, other ) ==(sel)( , var_h2449, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2887:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2892 --->  Ty_heap  
 var__temp_v2893 --->  Ty_int  
 var__temp_h'2894 --->  Ty_heap  
 var__temp_v_err2895 --->  error  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2892, res ) ==(v) AND 
 	 Rel (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res ) AND 
 	 Rel (sel)( , var__temp_h2892, other ) ==(sel)( , var_h2449, other ) => 
 	 Rel (sel)( , var__temp_h2892, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2892, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2894, res ) ==(var__temp_v2893) AND 
 	 Rel (sel)( , var__temp_h'2894, res ) ==((sel)( , var__temp_h2892, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2894, other ) ==(sel)( , var__temp_h2892, other ) => 
 	 True
 
VC_END(declare-const var_h_i2450 T10285)
(declare-const var_h2449 T10285)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2892 T10285)
(declare-const var__temp_v2893 Int)
(declare-const |var__temp_h'2894| T10285)
(declare-const var__temp_v_err2895 T10286)
(declare-const var_h2449 T10285)
(declare-const err T10299)

solver 
 (declare-sort T10285)
(declare-fun sel (T10285 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T10285)
(declare-fun other () Int)
(declare-fun var__temp_h2892 () T10285)
(declare-fun |var__temp_h'2894| () T10285)
(declare-fun var__temp_v2893 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2892 res) v)
                    (= (sel var_h2449 res) (sel var_h2449 res))
                    (= (sel var__temp_h2892 other) (sel var_h2449 other)))
               (= (sel var__temp_h2892 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2894| res) var__temp_v2893)
                (= (sel |var__temp_h'2894| res) (+ (sel var__temp_h2892 res) 5))
                (= (sel |var__temp_h'2894| other) (sel var__temp_h2892 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2892 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************794
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2450, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res )
 	 , (sel)( , var_h_i2450, other ) ==(sel)( , var_h2449, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2887:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2896 --->  Ty_heap  
 var__temp_v2897 --->  Ty_int  
 var__temp_h'2898 --->  Ty_heap  
 var__temp_v_err2899 --->  error  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2896, res ) ==(v) AND 
 	 Rel (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res ) AND 
 	 Rel (sel)( , var__temp_h2896, other ) ==(sel)( , var_h2449, other ) => 
 	 Rel (sel)( , var__temp_h2896, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h2896, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2898, res ) ==(var__temp_v2897) AND 
 	 Rel (sel)( , var__temp_h'2898, res ) ==((sel)( , var__temp_h2896, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'2898, other ) ==(sel)( , var__temp_h2896, other ) => 
 	 True
 
VC_END(declare-const var_h_i2450 T10302)
(declare-const var_h2449 T10302)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2896 T10302)
(declare-const var__temp_v2897 Int)
(declare-const |var__temp_h'2898| T10302)
(declare-const var__temp_v_err2899 T10303)
(declare-const var_h2449 T10302)
(declare-const err T10316)

solver 
 (declare-sort T10302)
(declare-fun sel (T10302 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T10302)
(declare-fun other () Int)
(declare-fun var__temp_h2896 () T10302)
(declare-fun |var__temp_h'2898| () T10302)
(declare-fun var__temp_v2897 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2896 res) v)
                    (= (sel var_h2449 res) (sel var_h2449 res))
                    (= (sel var__temp_h2896 other) (sel var_h2449 other)))
               (> (sel var__temp_h2896 res) 4)))
      (a!2 (and (= (sel |var__temp_h'2898| res) var__temp_v2897)
                (= (sel |var__temp_h'2898| res)
                   (+ (sel var__temp_h2896 res) 10))
                (= (sel |var__temp_h'2898| other) (sel var__temp_h2896 other)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h2896 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************795
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2450 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2450, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res )
 	 , (sel)( , var_h_i2450, other ) ==(sel)( , var_h2449, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2887:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2450 --->  Ty_heap  
 var_h2449 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2900 --->  Ty_heap  
 var__temp_v2901 --->  Ty_int  
 var__temp_h'2902 --->  Ty_heap  
 var__temp_v_err2903 --->  error  
 var_h2449 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2449, res ) > (20) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2900, res ) ==(v) AND 
 	 Rel (sel)( , var_h2449, res ) ==(sel)( , var_h2449, res ) AND 
 	 Rel (sel)( , var__temp_h2900, other ) ==(sel)( , var_h2449, other ) => 
 	 Rel (sel)( , var__temp_h2900, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2900, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2902, res ) ==(var__temp_v2901) AND 
 	 Rel (sel)( , var__temp_h'2902, res ) ==((sel)( , var__temp_h2900, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2902, other ) ==(sel)( , var__temp_h2900, other ) => 
 	 True
 
VC_END(declare-const var_h_i2450 T10319)
(declare-const var_h2449 T10319)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2900 T10319)
(declare-const var__temp_v2901 Int)
(declare-const |var__temp_h'2902| T10319)
(declare-const var__temp_v_err2903 T10320)
(declare-const var_h2449 T10319)
(declare-const err T10333)

solver 
 (declare-sort T10319)
(declare-fun sel (T10319 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2449 () T10319)
(declare-fun other () Int)
(declare-fun var__temp_h2900 () T10319)
(declare-fun |var__temp_h'2902| () T10319)
(declare-fun var__temp_v2901 () Int)
(declare-fun v () Int)
(assert (not (> (sel var_h2449 res) 20)))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2900 res) v)
                    (= (sel var_h2449 res) (sel var_h2449 res))
                    (= (sel var__temp_h2900 other) (sel var_h2449 other)))
               (= (sel var__temp_h2900 res) 5)))
      (a!2 (and (= (sel |var__temp_h'2902| res) var__temp_v2901)
                (= (sel |var__temp_h'2902| res) (+ (sel var__temp_h2900 res) 2))
                (= (sel |var__temp_h'2902| other) (sel var__temp_h2900 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2900 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************796
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo
PARTIAL PATH
SUB 
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {var_v2904:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo'
foo
bar
 *********************Enumeration Iteration*****************797
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {var_v2904:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2905 --->  Ty_heap  
 var__temp_v2906 --->  Ty_int  
 var__temp_h'2907 --->  Ty_heap  
 var__temp_v_err2908 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2905, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h2905, other ) ==(0) => 
 	 Rel (sel)( , var__temp_h2905, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2905, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2907, res ) ==(var__temp_v2906) AND 
 	 Rel (sel)( , var__temp_h'2907, res ) ==((sel)( , var__temp_h2905, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2907, other ) ==(sel)( , var__temp_h2905, other ) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2905 T10336)
(declare-const var__temp_v2906 Int)
(declare-const |var__temp_h'2907| T10336)
(declare-const var__temp_v_err2908 T10337)
(declare-const err T10350)

solver 
 (declare-sort T10336)
(declare-fun sel (T10336 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h2905 () T10336)
(declare-fun |var__temp_h'2907| () T10336)
(declare-fun res () Int)
(declare-fun var__temp_v2906 () Int)
(assert true)
(assert (let ((a!1 (=> (and (= (sel var__temp_h2905 res) 0)
                    (= (sel var__temp_h2905 other) 0))
               (= (sel var__temp_h2905 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2907| res) var__temp_v2906)
                (= (sel |var__temp_h'2907| res) (+ (sel var__temp_h2905 res) 3))
                (= (sel |var__temp_h'2907| other) (sel var__temp_h2905 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2905 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************798
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {var_v2904:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2909 --->  Ty_heap  
 var__temp_v2910 --->  Ty_int  
 var__temp_h'2911 --->  Ty_heap  
 var__temp_v_err2912 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2909, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h2909, other ) ==(0) => 
 	 Rel (sel)( , var__temp_h2909, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2909, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2911, res ) ==(var__temp_v2910) AND 
 	 Rel (sel)( , var__temp_h'2911, res ) ==((sel)( , var__temp_h2909, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2911, other ) ==(sel)( , var__temp_h2909, other ) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2909 T10353)
(declare-const var__temp_v2910 Int)
(declare-const |var__temp_h'2911| T10353)
(declare-const var__temp_v_err2912 T10354)
(declare-const err T10367)

solver 
 (declare-sort T10353)
(declare-fun sel (T10353 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h2909 () T10353)
(declare-fun |var__temp_h'2911| () T10353)
(declare-fun res () Int)
(declare-fun var__temp_v2910 () Int)
(assert true)
(assert (let ((a!1 (=> (and (= (sel var__temp_h2909 res) 0)
                    (= (sel var__temp_h2909 other) 0))
               (= (sel var__temp_h2909 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2911| res) var__temp_v2910)
                (= (sel |var__temp_h'2911| res) (+ (sel var__temp_h2909 res) 5))
                (= (sel |var__temp_h'2911| other) (sel var__temp_h2909 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2909 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************799
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {var_v2904:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2913 --->  Ty_heap  
 var__temp_v2914 --->  Ty_int  
 var__temp_h'2915 --->  Ty_heap  
 var__temp_v_err2916 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2913, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h2913, other ) ==(0) => 
 	 Rel (sel)( , var__temp_h2913, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h2913, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2915, res ) ==(var__temp_v2914) AND 
 	 Rel (sel)( , var__temp_h'2915, res ) ==((sel)( , var__temp_h2913, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'2915, other ) ==(sel)( , var__temp_h2913, other ) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2913 T10370)
(declare-const var__temp_v2914 Int)
(declare-const |var__temp_h'2915| T10370)
(declare-const var__temp_v_err2916 T10371)
(declare-const err T10384)

solver 
 (declare-sort T10370)
(declare-fun sel (T10370 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h2913 () T10370)
(declare-fun |var__temp_h'2915| () T10370)
(declare-fun res () Int)
(declare-fun var__temp_v2914 () Int)
(assert true)
(assert (let ((a!1 (=> (and (= (sel var__temp_h2913 res) 0)
                    (= (sel var__temp_h2913 other) 0))
               (> (sel var__temp_h2913 res) 4)))
      (a!2 (and (= (sel |var__temp_h'2915| res) var__temp_v2914)
                (= (sel |var__temp_h'2915| res)
                   (+ (sel var__temp_h2913 res) 10))
                (= (sel |var__temp_h'2915| other) (sel var__temp_h2913 other)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h2913 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************800
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {var_v2904:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2917 --->  Ty_heap  
 var__temp_v2918 --->  Ty_int  
 var__temp_h'2919 --->  Ty_heap  
 var__temp_v_err2920 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2917, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h2917, other ) ==(0) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2919, res ) ==(var__temp_v2918) AND 
 	 Base var__temp_v2918 = 20 AND 
 	 Rel (sel)( , var__temp_h'2919, other ) ==(sel)( , var__temp_h2917, other ) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2917 T10387)
(declare-const var__temp_v2918 Int)
(declare-const |var__temp_h'2919| T10387)
(declare-const var__temp_v_err2920 T10388)
(declare-const err T10401)
    (declare-const |20| Int)
  
solver 
 (declare-sort T10387)
(declare-fun |20| () Int)
(declare-fun sel (T10387 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h2917 () T10387)
(declare-fun |var__temp_h'2919| () T10387)
(declare-fun var__temp_v2918 () Int)
(declare-fun res () Int)
(assert true)
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2917 res) 0)
                    (= (sel var__temp_h2917 other) 0))
               true))
      (a!2 (=> (and (= (sel |var__temp_h'2919| res) var__temp_v2918)
                    (= var__temp_v2918 |20|)
                    (= (sel |var__temp_h'2919| other)
                       (sel var__temp_h2917 other)))
               true)))
  (not (and a!1 (=> true a!2)))))

***************Selection Successful************foo'
PARTIAL PATH NEW
SUB 
 	 --foo'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2922 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2922 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2922, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2922, other ) ==(sel)( , var_h2921, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2923:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2922 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************801
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2922 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2922, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2922, other ) ==(sel)( , var_h2921, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2923:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2922 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2924 --->  Ty_heap  
 var__temp_v2925 --->  Ty_int  
 var__temp_h'2926 --->  Ty_heap  
 var__temp_v_err2927 --->  error  
 var_h2921 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2924, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h2924, other ) ==(sel)( , var_h2921, other ) => 
 	 Rel (sel)( , var__temp_h2924, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2924, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2926, res ) ==(var__temp_v2925) AND 
 	 Rel (sel)( , var__temp_h'2926, res ) ==((sel)( , var__temp_h2924, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2926, other ) ==(sel)( , var__temp_h2924, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2926, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2926, other ) > (4)
 
VC_END(declare-const var_h_i2922 T10404)
(declare-const var_h2921 T10404)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2924 T10404)
(declare-const var__temp_v2925 Int)
(declare-const |var__temp_h'2926| T10404)
(declare-const var__temp_v_err2927 T10405)
(declare-const var_h2921 T10404)
(declare-const err T10418)
    (declare-const |20| Int)
  
solver 
 (declare-sort T10404)
(declare-fun |20| () Int)
(declare-fun sel (T10404 Int) Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2926| () T10404)
(declare-fun res () Int)
(declare-fun var__temp_h2924 () T10404)
(declare-fun var__temp_v2925 () Int)
(declare-fun var_h2921 () T10404)
(declare-fun v () Int)
(assert true)
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2924 res) v)
                    (= v |20|)
                    (= (sel var__temp_h2924 other) (sel var_h2921 other)))
               (= (sel var__temp_h2924 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2926| res) var__temp_v2925)
                (= (sel |var__temp_h'2926| res) (+ (sel var__temp_h2924 res) 3))
                (= (sel |var__temp_h'2926| other) (sel var__temp_h2924 other))))
      (a!3 (and (= (sel |var__temp_h'2926| res) 10)
                (not (> (sel |var__temp_h'2926| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2924 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************802
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2922 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2922, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2922, other ) ==(sel)( , var_h2921, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2923:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2922 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2928 --->  Ty_heap  
 var__temp_v2929 --->  Ty_int  
 var__temp_h'2930 --->  Ty_heap  
 var__temp_v_err2931 --->  error  
 var_h2921 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2928, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h2928, other ) ==(sel)( , var_h2921, other ) => 
 	 Rel (sel)( , var__temp_h2928, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2928, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2930, res ) ==(var__temp_v2929) AND 
 	 Rel (sel)( , var__temp_h'2930, res ) ==((sel)( , var__temp_h2928, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2930, other ) ==(sel)( , var__temp_h2928, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2930, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2930, other ) > (4)
 
VC_END(declare-const var_h_i2922 T10421)
(declare-const var_h2921 T10421)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2928 T10421)
(declare-const var__temp_v2929 Int)
(declare-const |var__temp_h'2930| T10421)
(declare-const var__temp_v_err2931 T10422)
(declare-const var_h2921 T10421)
(declare-const err T10435)
    (declare-const |20| Int)
  
solver 
 (declare-sort T10421)
(declare-fun |20| () Int)
(declare-fun sel (T10421 Int) Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2930| () T10421)
(declare-fun res () Int)
(declare-fun var__temp_h2928 () T10421)
(declare-fun var__temp_v2929 () Int)
(declare-fun var_h2921 () T10421)
(declare-fun v () Int)
(assert true)
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2928 res) v)
                    (= v |20|)
                    (= (sel var__temp_h2928 other) (sel var_h2921 other)))
               (= (sel var__temp_h2928 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2930| res) var__temp_v2929)
                (= (sel |var__temp_h'2930| res) (+ (sel var__temp_h2928 res) 5))
                (= (sel |var__temp_h'2930| other) (sel var__temp_h2928 other))))
      (a!3 (and (= (sel |var__temp_h'2930| res) 10)
                (not (> (sel |var__temp_h'2930| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2928 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************803
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2922 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2922, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2922, other ) ==(sel)( , var_h2921, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2923:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2922 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2932 --->  Ty_heap  
 var__temp_v2933 --->  Ty_int  
 var__temp_h'2934 --->  Ty_heap  
 var__temp_v_err2935 --->  error  
 var_h2921 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2932, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h2932, other ) ==(sel)( , var_h2921, other ) => 
 	 Rel (sel)( , var__temp_h2932, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h2932, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2934, res ) ==(var__temp_v2933) AND 
 	 Rel (sel)( , var__temp_h'2934, res ) ==((sel)( , var__temp_h2932, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'2934, other ) ==(sel)( , var__temp_h2932, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2934, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2934, other ) > (4)
 
VC_END(declare-const var_h_i2922 T10438)
(declare-const var_h2921 T10438)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2932 T10438)
(declare-const var__temp_v2933 Int)
(declare-const |var__temp_h'2934| T10438)
(declare-const var__temp_v_err2935 T10439)
(declare-const var_h2921 T10438)
(declare-const err T10452)
    (declare-const |20| Int)
  
solver 
 (declare-sort T10438)
(declare-fun |20| () Int)
(declare-fun sel (T10438 Int) Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2934| () T10438)
(declare-fun res () Int)
(declare-fun var__temp_h2932 () T10438)
(declare-fun var__temp_v2933 () Int)
(declare-fun var_h2921 () T10438)
(declare-fun v () Int)
(assert true)
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2932 res) v)
                    (= v |20|)
                    (= (sel var__temp_h2932 other) (sel var_h2921 other)))
               (> (sel var__temp_h2932 res) 4)))
      (a!2 (and (= (sel |var__temp_h'2934| res) var__temp_v2933)
                (= (sel |var__temp_h'2934| res)
                   (+ (sel var__temp_h2932 res) 10))
                (= (sel |var__temp_h'2934| other) (sel var__temp_h2932 other))))
      (a!3 (and (= (sel |var__temp_h'2934| res) 10)
                (not (> (sel |var__temp_h'2934| other) 4)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h2932 res) 4) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************804
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2922 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2922, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2922, other ) ==(sel)( , var_h2921, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2923:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2922 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2936 --->  Ty_heap  
 var__temp_v2937 --->  Ty_int  
 var__temp_h'2938 --->  Ty_heap  
 var__temp_v_err2939 --->  error  
 var_h2921 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2936, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h2936, other ) ==(sel)( , var_h2921, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2938, res ) ==(var__temp_v2937) AND 
 	 Base var__temp_v2937 = 5 AND 
 	 Rel (sel)( , var__temp_h'2938, other ) ==(sel)( , var__temp_h2936, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2938, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2938, other ) > (4)
 
VC_END(declare-const var_h_i2922 T10455)
(declare-const var_h2921 T10455)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2936 T10455)
(declare-const var__temp_v2937 Int)
(declare-const |var__temp_h'2938| T10455)
(declare-const var__temp_v_err2939 T10456)
(declare-const var_h2921 T10455)
(declare-const err T10469)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T10455)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun sel (T10455 Int) Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2938| () T10455)
(declare-fun res () Int)
(declare-fun var__temp_h2936 () T10455)
(declare-fun var__temp_v2937 () Int)
(declare-fun var_h2921 () T10455)
(declare-fun v () Int)
(assert true)
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2936 res) v)
                    (= v |20|)
                    (= (sel var__temp_h2936 other) (sel var_h2921 other)))
               true))
      (a!2 (and (= (sel |var__temp_h'2938| res) 10)
                (not (> (sel |var__temp_h'2938| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'2938| res) var__temp_v2937)
                    (= var__temp_v2937 |5|)
                    (= (sel |var__temp_h'2938| other)
                       (sel var__temp_h2936 other)))
               a!2)))
  (not (and a!1 (=> true a!3))))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************805
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2922 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2922, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2922, other ) ==(sel)( , var_h2921, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2923:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2922 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2940 --->  Ty_heap  
 var__temp_v2941 --->  Ty_int  
 var__temp_h'2942 --->  Ty_heap  
 var__temp_v_err2943 --->  error  
 var_h2921 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2940, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h2940, other ) ==(sel)( , var_h2921, other ) => 
 	 Rel (sel)( , var__temp_h2940, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2940, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2942, res ) ==(var__temp_v2941) AND 
 	 Rel (sel)( , var__temp_h'2942, res ) ==((sel)( , var__temp_h2940, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2942, other ) ==(sel)( , var__temp_h2940, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2942, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2942, other ) > (4)
 
VC_END(declare-const var_h_i2922 T10472)
(declare-const var_h2921 T10472)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2940 T10472)
(declare-const var__temp_v2941 Int)
(declare-const |var__temp_h'2942| T10472)
(declare-const var__temp_v_err2943 T10473)
(declare-const var_h2921 T10472)
(declare-const err T10486)
    (declare-const |20| Int)
  
solver 
 (declare-sort T10472)
(declare-fun |20| () Int)
(declare-fun sel (T10472 Int) Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2942| () T10472)
(declare-fun res () Int)
(declare-fun var__temp_h2940 () T10472)
(declare-fun var__temp_v2941 () Int)
(declare-fun var_h2921 () T10472)
(declare-fun v () Int)
(assert true)
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2940 res) v)
                    (= v |20|)
                    (= (sel var__temp_h2940 other) (sel var_h2921 other)))
               (= (sel var__temp_h2940 res) 5)))
      (a!2 (and (= (sel |var__temp_h'2942| res) var__temp_v2941)
                (= (sel |var__temp_h'2942| res) (+ (sel var__temp_h2940 res) 2))
                (= (sel |var__temp_h'2942| other) (sel var__temp_h2940 other))))
      (a!3 (and (= (sel |var__temp_h'2942| res) 10)
                (not (> (sel |var__temp_h'2942| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2940 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************806
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2923:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2923:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2922 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2922, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2922, other ) ==(sel)( , var_h2921, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2944:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************807
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2922 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2922, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2922, other ) ==(sel)( , var_h2921, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2944:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2945 --->  Ty_heap  
 var__temp_v2946 --->  Ty_int  
 var__temp_h'2947 --->  Ty_heap  
 var__temp_v_err2948 --->  error  
 var_h2921 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2945, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h2945, other ) ==(sel)( , var_h2921, other ) => 
 	 Rel (sel)( , var__temp_h2945, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2945, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2947, res ) ==(var__temp_v2946) AND 
 	 Rel (sel)( , var__temp_h'2947, res ) ==((sel)( , var__temp_h2945, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2947, other ) ==(sel)( , var__temp_h2945, other ) => 
 	 True
 
VC_END(declare-const var_h_i2922 T10489)
(declare-const var_h2921 T10489)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2945 T10489)
(declare-const var__temp_v2946 Int)
(declare-const |var__temp_h'2947| T10489)
(declare-const var__temp_v_err2948 T10490)
(declare-const var_h2921 T10489)
(declare-const err T10503)
    (declare-const |20| Int)
  
solver 
 (declare-sort T10489)
(declare-fun |20| () Int)
(declare-fun sel (T10489 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h2945 () T10489)
(declare-fun |var__temp_h'2947| () T10489)
(declare-fun res () Int)
(declare-fun var__temp_v2946 () Int)
(declare-fun var_h2921 () T10489)
(declare-fun v () Int)
(assert true)
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2945 res) v)
                    (= v |20|)
                    (= (sel var__temp_h2945 other) (sel var_h2921 other)))
               (= (sel var__temp_h2945 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2947| res) var__temp_v2946)
                (= (sel |var__temp_h'2947| res) (+ (sel var__temp_h2945 res) 3))
                (= (sel |var__temp_h'2947| other) (sel var__temp_h2945 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2945 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************808
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2922 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2922, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2922, other ) ==(sel)( , var_h2921, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2944:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2949 --->  Ty_heap  
 var__temp_v2950 --->  Ty_int  
 var__temp_h'2951 --->  Ty_heap  
 var__temp_v_err2952 --->  error  
 var_h2921 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2949, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h2949, other ) ==(sel)( , var_h2921, other ) => 
 	 Rel (sel)( , var__temp_h2949, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2949, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2951, res ) ==(var__temp_v2950) AND 
 	 Rel (sel)( , var__temp_h'2951, res ) ==((sel)( , var__temp_h2949, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2951, other ) ==(sel)( , var__temp_h2949, other ) => 
 	 True
 
VC_END(declare-const var_h_i2922 T10506)
(declare-const var_h2921 T10506)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2949 T10506)
(declare-const var__temp_v2950 Int)
(declare-const |var__temp_h'2951| T10506)
(declare-const var__temp_v_err2952 T10507)
(declare-const var_h2921 T10506)
(declare-const err T10520)
    (declare-const |20| Int)
  
solver 
 (declare-sort T10506)
(declare-fun |20| () Int)
(declare-fun sel (T10506 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h2949 () T10506)
(declare-fun |var__temp_h'2951| () T10506)
(declare-fun res () Int)
(declare-fun var__temp_v2950 () Int)
(declare-fun var_h2921 () T10506)
(declare-fun v () Int)
(assert true)
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2949 res) v)
                    (= v |20|)
                    (= (sel var__temp_h2949 other) (sel var_h2921 other)))
               (= (sel var__temp_h2949 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2951| res) var__temp_v2950)
                (= (sel |var__temp_h'2951| res) (+ (sel var__temp_h2949 res) 5))
                (= (sel |var__temp_h'2951| other) (sel var__temp_h2949 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h2949 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************809
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2922 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2922, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2922, other ) ==(sel)( , var_h2921, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2944:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2953 --->  Ty_heap  
 var__temp_v2954 --->  Ty_int  
 var__temp_h'2955 --->  Ty_heap  
 var__temp_v_err2956 --->  error  
 var_h2921 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2953, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h2953, other ) ==(sel)( , var_h2921, other ) => 
 	 Rel (sel)( , var__temp_h2953, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h2953, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2955, res ) ==(var__temp_v2954) AND 
 	 Rel (sel)( , var__temp_h'2955, res ) ==((sel)( , var__temp_h2953, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'2955, other ) ==(sel)( , var__temp_h2953, other ) => 
 	 True
 
VC_END(declare-const var_h_i2922 T10523)
(declare-const var_h2921 T10523)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2953 T10523)
(declare-const var__temp_v2954 Int)
(declare-const |var__temp_h'2955| T10523)
(declare-const var__temp_v_err2956 T10524)
(declare-const var_h2921 T10523)
(declare-const err T10537)
    (declare-const |20| Int)
  
solver 
 (declare-sort T10523)
(declare-fun |20| () Int)
(declare-fun sel (T10523 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h2953 () T10523)
(declare-fun |var__temp_h'2955| () T10523)
(declare-fun res () Int)
(declare-fun var__temp_v2954 () Int)
(declare-fun var_h2921 () T10523)
(declare-fun v () Int)
(assert true)
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2953 res) v)
                    (= v |20|)
                    (= (sel var__temp_h2953 other) (sel var_h2921 other)))
               (> (sel var__temp_h2953 res) 4)))
      (a!2 (and (= (sel |var__temp_h'2955| res) var__temp_v2954)
                (= (sel |var__temp_h'2955| res)
                   (+ (sel var__temp_h2953 res) 10))
                (= (sel |var__temp_h'2955| other) (sel var__temp_h2953 other)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h2953 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c2
PARTIAL PATH NEW
SUB 
 	 --c2
 	 --foo'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2958 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2958 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2958, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2958, res ) ==((sel)( , var_h2957, res ) + (10))
 	 , (sel)( , var_h_i2958, other ) ==(sel)( , var_h2957, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2959:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2958 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************810
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2958 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2958, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2958, res ) ==((sel)( , var_h2957, res ) + (10))
 	 , (sel)( , var_h_i2958, other ) ==(sel)( , var_h2957, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2959:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2958 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2958 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2960 --->  Ty_heap  
 var__temp_v2961 --->  Ty_int  
 var__temp_h'2962 --->  Ty_heap  
 var__temp_v_err2963 --->  error  
 var_h2957 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2957, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2960, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2960, res ) ==((sel)( , var_h2957, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2960, other ) ==(sel)( , var_h2957, other ) => 
 	 Rel (sel)( , var__temp_h2960, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2960, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2962, res ) ==(var__temp_v2961) AND 
 	 Rel (sel)( , var__temp_h'2962, res ) ==((sel)( , var__temp_h2960, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2962, other ) ==(sel)( , var__temp_h2960, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2962, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2962, other ) > (4)
 
VC_END(declare-const var_h_i2958 T10540)
(declare-const var_h2957 T10540)
(declare-const v Int)
(declare-const var_h_i2922 T10540)
(declare-const var_h2921 T10540)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2960 T10540)
(declare-const var__temp_v2961 Int)
(declare-const |var__temp_h'2962| T10540)
(declare-const var__temp_v_err2963 T10541)
(declare-const var_h2957 T10540)
(declare-const var_h2921 T10540)
(declare-const err T10554)

solver 
 (declare-sort T10540)
(declare-fun sel (T10540 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2957 () T10540)
(declare-fun other () Int)
(declare-fun |var__temp_h'2962| () T10540)
(declare-fun var__temp_h2960 () T10540)
(declare-fun var__temp_v2961 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2957 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h2960 res) v)
                (= (sel var__temp_h2960 res) (+ (sel var_h2957 res) 10))
                (= (sel var__temp_h2960 other) (sel var_h2957 other))))
      (a!2 (and (= (sel |var__temp_h'2962| res) var__temp_v2961)
                (= (sel |var__temp_h'2962| res) (+ (sel var__temp_h2960 res) 3))
                (= (sel |var__temp_h'2962| other) (sel var__temp_h2960 other))))
      (a!3 (and (= (sel |var__temp_h'2962| res) 10)
                (not (> (sel |var__temp_h'2962| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2960 res) 7))
                (=> (= (sel var__temp_h2960 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************811
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2958 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2958, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2958, res ) ==((sel)( , var_h2957, res ) + (10))
 	 , (sel)( , var_h_i2958, other ) ==(sel)( , var_h2957, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2959:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2958 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2958 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2964 --->  Ty_heap  
 var__temp_v2965 --->  Ty_int  
 var__temp_h'2966 --->  Ty_heap  
 var__temp_v_err2967 --->  error  
 var_h2957 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2957, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2964, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2964, res ) ==((sel)( , var_h2957, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2964, other ) ==(sel)( , var_h2957, other ) => 
 	 Rel (sel)( , var__temp_h2964, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2964, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2966, res ) ==(var__temp_v2965) AND 
 	 Rel (sel)( , var__temp_h'2966, res ) ==((sel)( , var__temp_h2964, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2966, other ) ==(sel)( , var__temp_h2964, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2966, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2966, other ) > (4)
 
VC_END(declare-const var_h_i2958 T10557)
(declare-const var_h2957 T10557)
(declare-const v Int)
(declare-const var_h_i2922 T10557)
(declare-const var_h2921 T10557)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2964 T10557)
(declare-const var__temp_v2965 Int)
(declare-const |var__temp_h'2966| T10557)
(declare-const var__temp_v_err2967 T10558)
(declare-const var_h2957 T10557)
(declare-const var_h2921 T10557)
(declare-const err T10571)

solver 
 (declare-sort T10557)
(declare-fun sel (T10557 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2957 () T10557)
(declare-fun other () Int)
(declare-fun |var__temp_h'2966| () T10557)
(declare-fun var__temp_h2964 () T10557)
(declare-fun var__temp_v2965 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2957 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h2964 res) v)
                (= (sel var__temp_h2964 res) (+ (sel var_h2957 res) 10))
                (= (sel var__temp_h2964 other) (sel var_h2957 other))))
      (a!2 (and (= (sel |var__temp_h'2966| res) var__temp_v2965)
                (= (sel |var__temp_h'2966| res) (+ (sel var__temp_h2964 res) 5))
                (= (sel |var__temp_h'2966| other) (sel var__temp_h2964 other))))
      (a!3 (and (= (sel |var__temp_h'2966| res) 10)
                (not (> (sel |var__temp_h'2966| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2964 res) 7))
                (=> (= (sel var__temp_h2964 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************812
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2958 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2958, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2958, res ) ==((sel)( , var_h2957, res ) + (10))
 	 , (sel)( , var_h_i2958, other ) ==(sel)( , var_h2957, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2959:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2958 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2958 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2968 --->  Ty_heap  
 var__temp_v2969 --->  Ty_int  
 var__temp_h'2970 --->  Ty_heap  
 var__temp_v_err2971 --->  error  
 var_h2957 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2957, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2968, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2968, res ) ==((sel)( , var_h2957, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2968, other ) ==(sel)( , var_h2957, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2970, res ) ==(var__temp_v2969) AND 
 	 Base var__temp_v2969 = 5 AND 
 	 Rel (sel)( , var__temp_h'2970, other ) ==(sel)( , var__temp_h2968, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2970, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2970, other ) > (4)
 
VC_END(declare-const var_h_i2958 T10574)
(declare-const var_h2957 T10574)
(declare-const v Int)
(declare-const var_h_i2922 T10574)
(declare-const var_h2921 T10574)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2968 T10574)
(declare-const var__temp_v2969 Int)
(declare-const |var__temp_h'2970| T10574)
(declare-const var__temp_v_err2971 T10575)
(declare-const var_h2957 T10574)
(declare-const var_h2921 T10574)
(declare-const err T10588)
    (declare-const |5| Int)
  
solver 
 (declare-sort T10574)
(declare-fun sel (T10574 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2957 () T10574)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2970| () T10574)
(declare-fun var__temp_h2968 () T10574)
(declare-fun var__temp_v2969 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2957 res) 4))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h2968 res) v)
                (= (sel var__temp_h2968 res) (+ (sel var_h2957 res) 10))
                (= (sel var__temp_h2968 other) (sel var_h2957 other))))
      (a!2 (and (= (sel |var__temp_h'2970| res) 10)
                (not (> (sel |var__temp_h'2970| other) 4)))))
(let ((a!3 (=> (and (= (sel |var__temp_h'2970| res) var__temp_v2969)
                    (= var__temp_v2969 |5|)
                    (= (sel |var__temp_h'2970| other)
                       (sel var__temp_h2968 other)))
               a!2)))
  (not (and (=> a!1 true) (=> true a!3))))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************813
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2958 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2958, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2958, res ) ==((sel)( , var_h2957, res ) + (10))
 	 , (sel)( , var_h_i2958, other ) ==(sel)( , var_h2957, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2959:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2958 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2958 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2972 --->  Ty_heap  
 var__temp_v2973 --->  Ty_int  
 var__temp_h'2974 --->  Ty_heap  
 var__temp_v_err2975 --->  error  
 var_h2957 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2957, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2972, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2972, res ) ==((sel)( , var_h2957, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2972, other ) ==(sel)( , var_h2957, other ) => 
 	 Rel (sel)( , var__temp_h2972, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h2972, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2974, res ) ==(var__temp_v2973) AND 
 	 Rel (sel)( , var__temp_h'2974, res ) ==((sel)( , var__temp_h2972, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'2974, other ) ==(sel)( , var__temp_h2972, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2974, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2974, other ) > (4)
 
VC_END(declare-const var_h_i2958 T10591)
(declare-const var_h2957 T10591)
(declare-const v Int)
(declare-const var_h_i2922 T10591)
(declare-const var_h2921 T10591)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2972 T10591)
(declare-const var__temp_v2973 Int)
(declare-const |var__temp_h'2974| T10591)
(declare-const var__temp_v_err2975 T10592)
(declare-const var_h2957 T10591)
(declare-const var_h2921 T10591)
(declare-const err T10605)

solver 
 (declare-sort T10591)
(declare-fun sel (T10591 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2957 () T10591)
(declare-fun other () Int)
(declare-fun |var__temp_h'2974| () T10591)
(declare-fun var__temp_h2972 () T10591)
(declare-fun var__temp_v2973 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2957 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h2972 res) v)
                (= (sel var__temp_h2972 res) (+ (sel var_h2957 res) 10))
                (= (sel var__temp_h2972 other) (sel var_h2957 other))))
      (a!2 (and (= (sel |var__temp_h'2974| res) var__temp_v2973)
                (= (sel |var__temp_h'2974| res) (+ (sel var__temp_h2972 res) 2))
                (= (sel |var__temp_h'2974| other) (sel var__temp_h2972 other))))
      (a!3 (and (= (sel |var__temp_h'2974| res) 10)
                (not (> (sel |var__temp_h'2974| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h2972 res) 5))
                (=> (= (sel var__temp_h2972 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************814
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2959:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2959:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c2
 	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2958 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2958, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2958, res ) ==((sel)( , var_h2957, res ) + (10))
 	 , (sel)( , var_h_i2958, other ) ==(sel)( , var_h2957, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2976:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************815
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2958 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2958, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2958, res ) ==((sel)( , var_h2957, res ) + (10))
 	 , (sel)( , var_h_i2958, other ) ==(sel)( , var_h2957, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2976:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2958 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2977 --->  Ty_heap  
 var__temp_v2978 --->  Ty_int  
 var__temp_h'2979 --->  Ty_heap  
 var__temp_v_err2980 --->  error  
 var_h2957 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2957, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2977, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2977, res ) ==((sel)( , var_h2957, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2977, other ) ==(sel)( , var_h2957, other ) => 
 	 Rel (sel)( , var__temp_h2977, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2977, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2979, res ) ==(var__temp_v2978) AND 
 	 Rel (sel)( , var__temp_h'2979, res ) ==((sel)( , var__temp_h2977, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2979, other ) ==(sel)( , var__temp_h2977, other ) => 
 	 True
 
VC_END(declare-const var_h_i2958 T10608)
(declare-const var_h2957 T10608)
(declare-const v Int)
(declare-const var_h_i2922 T10608)
(declare-const var_h2921 T10608)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2977 T10608)
(declare-const var__temp_v2978 Int)
(declare-const |var__temp_h'2979| T10608)
(declare-const var__temp_v_err2980 T10609)
(declare-const var_h2957 T10608)
(declare-const var_h2921 T10608)
(declare-const err T10622)

solver 
 (declare-sort T10608)
(declare-fun sel (T10608 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2957 () T10608)
(declare-fun other () Int)
(declare-fun var__temp_h2977 () T10608)
(declare-fun |var__temp_h'2979| () T10608)
(declare-fun var__temp_v2978 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2957 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h2977 res) v)
                (= (sel var__temp_h2977 res) (+ (sel var_h2957 res) 10))
                (= (sel var__temp_h2977 other) (sel var_h2957 other))))
      (a!2 (and (= (sel |var__temp_h'2979| res) var__temp_v2978)
                (= (sel |var__temp_h'2979| res) (+ (sel var__temp_h2977 res) 3))
                (= (sel |var__temp_h'2979| other) (sel var__temp_h2977 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2977 res) 7))
                (=> (= (sel var__temp_h2977 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************816
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2958 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2958, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2958, res ) ==((sel)( , var_h2957, res ) + (10))
 	 , (sel)( , var_h_i2958, other ) ==(sel)( , var_h2957, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2976:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2958 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2981 --->  Ty_heap  
 var__temp_v2982 --->  Ty_int  
 var__temp_h'2983 --->  Ty_heap  
 var__temp_v_err2984 --->  error  
 var_h2957 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2957, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2981, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2981, res ) ==((sel)( , var_h2957, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2981, other ) ==(sel)( , var_h2957, other ) => 
 	 Rel (sel)( , var__temp_h2981, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2981, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2983, res ) ==(var__temp_v2982) AND 
 	 Rel (sel)( , var__temp_h'2983, res ) ==((sel)( , var__temp_h2981, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2983, other ) ==(sel)( , var__temp_h2981, other ) => 
 	 True
 
VC_END(declare-const var_h_i2958 T10625)
(declare-const var_h2957 T10625)
(declare-const v Int)
(declare-const var_h_i2922 T10625)
(declare-const var_h2921 T10625)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2981 T10625)
(declare-const var__temp_v2982 Int)
(declare-const |var__temp_h'2983| T10625)
(declare-const var__temp_v_err2984 T10626)
(declare-const var_h2957 T10625)
(declare-const var_h2921 T10625)
(declare-const err T10639)

solver 
 (declare-sort T10625)
(declare-fun sel (T10625 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2957 () T10625)
(declare-fun other () Int)
(declare-fun var__temp_h2981 () T10625)
(declare-fun |var__temp_h'2983| () T10625)
(declare-fun var__temp_v2982 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2957 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h2981 res) v)
                (= (sel var__temp_h2981 res) (+ (sel var_h2957 res) 10))
                (= (sel var__temp_h2981 other) (sel var_h2957 other))))
      (a!2 (and (= (sel |var__temp_h'2983| res) var__temp_v2982)
                (= (sel |var__temp_h'2983| res) (+ (sel var__temp_h2981 res) 5))
                (= (sel |var__temp_h'2983| other) (sel var__temp_h2981 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h2981 res) 7))
                (=> (= (sel var__temp_h2981 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************817
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2958 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2958, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2958, res ) ==((sel)( , var_h2957, res ) + (10))
 	 , (sel)( , var_h_i2958, other ) ==(sel)( , var_h2957, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2976:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2958 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2985 --->  Ty_heap  
 var__temp_v2986 --->  Ty_int  
 var__temp_h'2987 --->  Ty_heap  
 var__temp_v_err2988 --->  error  
 var_h2957 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2957, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2985, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h2985, res ) ==((sel)( , var_h2957, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h2985, other ) ==(sel)( , var_h2957, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2987, res ) ==(var__temp_v2986) AND 
 	 Base var__temp_v2986 = 5 AND 
 	 Rel (sel)( , var__temp_h'2987, other ) ==(sel)( , var__temp_h2985, other ) => 
 	 True
 
VC_END(declare-const var_h_i2958 T10642)
(declare-const var_h2957 T10642)
(declare-const v Int)
(declare-const var_h_i2922 T10642)
(declare-const var_h2921 T10642)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2985 T10642)
(declare-const var__temp_v2986 Int)
(declare-const |var__temp_h'2987| T10642)
(declare-const var__temp_v_err2988 T10643)
(declare-const var_h2957 T10642)
(declare-const var_h2921 T10642)
(declare-const err T10656)
    (declare-const |5| Int)
  
solver 
 (declare-sort T10642)
(declare-fun sel (T10642 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2957 () T10642)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h2985 () T10642)
(declare-fun |var__temp_h'2987| () T10642)
(declare-fun var__temp_v2986 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2957 res) 4))
(assert (= |5| 5))
(assert (let ((a!1 (and (= (sel var__temp_h2985 res) v)
                (= (sel var__temp_h2985 res) (+ (sel var_h2957 res) 10))
                (= (sel var__temp_h2985 other) (sel var_h2957 other))))
      (a!2 (=> (and (= (sel |var__temp_h'2987| res) var__temp_v2986)
                    (= var__temp_v2986 |5|)
                    (= (sel |var__temp_h'2987| other)
                       (sel var__temp_h2985 other)))
               true)))
  (not (and (=> a!1 true) (=> true a!2)))))

***************Selection Successful************foo
PARTIAL PATH NEW
SUB 
 	 --foo
 	 --c2
 	 --foo'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i2990 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2990 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2990, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2990, other ) ==(sel)( , var_h2989, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2991:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2990 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************818
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2990 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2990, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2990, other ) ==(sel)( , var_h2989, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2991:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2990 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2990 --->  Ty_heap  
 var_h2989 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2958 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2992 --->  Ty_heap  
 var__temp_v2993 --->  Ty_int  
 var__temp_h'2994 --->  Ty_heap  
 var__temp_v_err2995 --->  error  
 var_h2989 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2957, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2992, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2992, other ) ==(sel)( , var_h2989, other ) => 
 	 Rel (sel)( , var__temp_h2992, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2992, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2994, res ) ==(var__temp_v2993) AND 
 	 Rel (sel)( , var__temp_h'2994, res ) ==((sel)( , var__temp_h2992, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'2994, other ) ==(sel)( , var__temp_h2992, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2994, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2994, other ) > (4)
 
VC_END(declare-const var_h_i2990 T10659)
(declare-const var_h2989 T10659)
(declare-const v Int)
(declare-const var_h_i2958 T10659)
(declare-const var_h2957 T10659)
(declare-const v Int)
(declare-const var_h_i2922 T10659)
(declare-const var_h2921 T10659)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2992 T10659)
(declare-const var__temp_v2993 Int)
(declare-const |var__temp_h'2994| T10659)
(declare-const var__temp_v_err2995 T10660)
(declare-const var_h2989 T10659)
(declare-const var_h2957 T10659)
(declare-const var_h2921 T10659)
(declare-const err T10673)
    (declare-const |5| Int)
  
solver 
 (declare-sort T10659)
(declare-fun sel (T10659 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2957 () T10659)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2994| () T10659)
(declare-fun var__temp_h2992 () T10659)
(declare-fun var__temp_v2993 () Int)
(declare-fun var_h2989 () T10659)
(declare-fun v () Int)
(assert (> (sel var_h2957 res) 4))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2992 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2992 other) (sel var_h2989 other)))
               (= (sel var__temp_h2992 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2994| res) var__temp_v2993)
                (= (sel |var__temp_h'2994| res) (+ (sel var__temp_h2992 res) 3))
                (= (sel |var__temp_h'2994| other) (sel var__temp_h2992 other))))
      (a!3 (and (= (sel |var__temp_h'2994| res) 10)
                (not (> (sel |var__temp_h'2994| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2992 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************819
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2990 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2990, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2990, other ) ==(sel)( , var_h2989, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2991:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2990 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2990 --->  Ty_heap  
 var_h2989 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2958 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h2996 --->  Ty_heap  
 var__temp_v2997 --->  Ty_int  
 var__temp_h'2998 --->  Ty_heap  
 var__temp_v_err2999 --->  error  
 var_h2989 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2957, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h2996, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h2996, other ) ==(sel)( , var_h2989, other ) => 
 	 Rel (sel)( , var__temp_h2996, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h2996, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2998, res ) ==(var__temp_v2997) AND 
 	 Rel (sel)( , var__temp_h'2998, res ) ==((sel)( , var__temp_h2996, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'2998, other ) ==(sel)( , var__temp_h2996, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'2998, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'2998, other ) > (4)
 
VC_END(declare-const var_h_i2990 T10676)
(declare-const var_h2989 T10676)
(declare-const v Int)
(declare-const var_h_i2958 T10676)
(declare-const var_h2957 T10676)
(declare-const v Int)
(declare-const var_h_i2922 T10676)
(declare-const var_h2921 T10676)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h2996 T10676)
(declare-const var__temp_v2997 Int)
(declare-const |var__temp_h'2998| T10676)
(declare-const var__temp_v_err2999 T10677)
(declare-const var_h2989 T10676)
(declare-const var_h2957 T10676)
(declare-const var_h2921 T10676)
(declare-const err T10690)
    (declare-const |5| Int)
  
solver 
 (declare-sort T10676)
(declare-fun sel (T10676 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2957 () T10676)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'2998| () T10676)
(declare-fun var__temp_h2996 () T10676)
(declare-fun var__temp_v2997 () Int)
(declare-fun var_h2989 () T10676)
(declare-fun v () Int)
(assert (> (sel var_h2957 res) 4))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h2996 res) v)
                    (= v |5|)
                    (= (sel var__temp_h2996 other) (sel var_h2989 other)))
               (= (sel var__temp_h2996 res) 7)))
      (a!2 (and (= (sel |var__temp_h'2998| res) var__temp_v2997)
                (= (sel |var__temp_h'2998| res) (+ (sel var__temp_h2996 res) 5))
                (= (sel |var__temp_h'2998| other) (sel var__temp_h2996 other))))
      (a!3 (and (= (sel |var__temp_h'2998| res) 10)
                (not (> (sel |var__temp_h'2998| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h2996 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************820
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2990 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2990, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2990, other ) ==(sel)( , var_h2989, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v2991:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i2990 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2990 --->  Ty_heap  
 var_h2989 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2958 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3000 --->  Ty_heap  
 var__temp_v3001 --->  Ty_int  
 var__temp_h'3002 --->  Ty_heap  
 var__temp_v_err3003 --->  error  
 var_h2989 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2957, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3000, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h3000, other ) ==(sel)( , var_h2989, other ) => 
 	 Rel (sel)( , var__temp_h3000, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h3000, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3002, res ) ==(var__temp_v3001) AND 
 	 Rel (sel)( , var__temp_h'3002, res ) ==((sel)( , var__temp_h3000, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'3002, other ) ==(sel)( , var__temp_h3000, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3002, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'3002, other ) > (4)
 
VC_END(declare-const var_h_i2990 T10693)
(declare-const var_h2989 T10693)
(declare-const v Int)
(declare-const var_h_i2958 T10693)
(declare-const var_h2957 T10693)
(declare-const v Int)
(declare-const var_h_i2922 T10693)
(declare-const var_h2921 T10693)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3000 T10693)
(declare-const var__temp_v3001 Int)
(declare-const |var__temp_h'3002| T10693)
(declare-const var__temp_v_err3003 T10694)
(declare-const var_h2989 T10693)
(declare-const var_h2957 T10693)
(declare-const var_h2921 T10693)
(declare-const err T10707)
    (declare-const |5| Int)
  
solver 
 (declare-sort T10693)
(declare-fun sel (T10693 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2957 () T10693)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'3002| () T10693)
(declare-fun var__temp_h3000 () T10693)
(declare-fun var__temp_v3001 () Int)
(declare-fun var_h2989 () T10693)
(declare-fun v () Int)
(assert (> (sel var_h2957 res) 4))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3000 res) v)
                    (= v |5|)
                    (= (sel var__temp_h3000 other) (sel var_h2989 other)))
               (= (sel var__temp_h3000 res) 5)))
      (a!2 (and (= (sel |var__temp_h'3002| res) var__temp_v3001)
                (= (sel |var__temp_h'3002| res) (+ (sel var__temp_h3000 res) 2))
                (= (sel |var__temp_h'3002| other) (sel var__temp_h3000 other))))
      (a!3 (and (= (sel |var__temp_h'3002| res) 10)
                (not (> (sel |var__temp_h'3002| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h3000 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************821
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v2991:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v2991:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --foo
 	 --c2
 	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2990 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2990, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2990, other ) ==(sel)( , var_h2989, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3004:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************822
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2990 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2990, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2990, other ) ==(sel)( , var_h2989, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3004:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2990 --->  Ty_heap  
 var_h2989 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2958 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3005 --->  Ty_heap  
 var__temp_v3006 --->  Ty_int  
 var__temp_h'3007 --->  Ty_heap  
 var__temp_v_err3008 --->  error  
 var_h2989 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2957, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3005, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h3005, other ) ==(sel)( , var_h2989, other ) => 
 	 Rel (sel)( , var__temp_h3005, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3005, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3007, res ) ==(var__temp_v3006) AND 
 	 Rel (sel)( , var__temp_h'3007, res ) ==((sel)( , var__temp_h3005, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'3007, other ) ==(sel)( , var__temp_h3005, other ) => 
 	 True
 
VC_END(declare-const var_h_i2990 T10710)
(declare-const var_h2989 T10710)
(declare-const v Int)
(declare-const var_h_i2958 T10710)
(declare-const var_h2957 T10710)
(declare-const v Int)
(declare-const var_h_i2922 T10710)
(declare-const var_h2921 T10710)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3005 T10710)
(declare-const var__temp_v3006 Int)
(declare-const |var__temp_h'3007| T10710)
(declare-const var__temp_v_err3008 T10711)
(declare-const var_h2989 T10710)
(declare-const var_h2957 T10710)
(declare-const var_h2921 T10710)
(declare-const err T10724)
    (declare-const |5| Int)
  
solver 
 (declare-sort T10710)
(declare-fun sel (T10710 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2957 () T10710)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h3005 () T10710)
(declare-fun |var__temp_h'3007| () T10710)
(declare-fun var__temp_v3006 () Int)
(declare-fun var_h2989 () T10710)
(declare-fun v () Int)
(assert (> (sel var_h2957 res) 4))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3005 res) v)
                    (= v |5|)
                    (= (sel var__temp_h3005 other) (sel var_h2989 other)))
               (= (sel var__temp_h3005 res) 7)))
      (a!2 (and (= (sel |var__temp_h'3007| res) var__temp_v3006)
                (= (sel |var__temp_h'3007| res) (+ (sel var__temp_h3005 res) 3))
                (= (sel |var__temp_h'3007| other) (sel var__temp_h3005 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h3005 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************823
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2990 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2990, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2990, other ) ==(sel)( , var_h2989, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3004:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2990 --->  Ty_heap  
 var_h2989 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2958 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3009 --->  Ty_heap  
 var__temp_v3010 --->  Ty_int  
 var__temp_h'3011 --->  Ty_heap  
 var__temp_v_err3012 --->  error  
 var_h2989 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2957, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3009, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h3009, other ) ==(sel)( , var_h2989, other ) => 
 	 Rel (sel)( , var__temp_h3009, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3009, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3011, res ) ==(var__temp_v3010) AND 
 	 Rel (sel)( , var__temp_h'3011, res ) ==((sel)( , var__temp_h3009, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'3011, other ) ==(sel)( , var__temp_h3009, other ) => 
 	 True
 
VC_END(declare-const var_h_i2990 T10727)
(declare-const var_h2989 T10727)
(declare-const v Int)
(declare-const var_h_i2958 T10727)
(declare-const var_h2957 T10727)
(declare-const v Int)
(declare-const var_h_i2922 T10727)
(declare-const var_h2921 T10727)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3009 T10727)
(declare-const var__temp_v3010 Int)
(declare-const |var__temp_h'3011| T10727)
(declare-const var__temp_v_err3012 T10728)
(declare-const var_h2989 T10727)
(declare-const var_h2957 T10727)
(declare-const var_h2921 T10727)
(declare-const err T10741)
    (declare-const |5| Int)
  
solver 
 (declare-sort T10727)
(declare-fun sel (T10727 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2957 () T10727)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h3009 () T10727)
(declare-fun |var__temp_h'3011| () T10727)
(declare-fun var__temp_v3010 () Int)
(declare-fun var_h2989 () T10727)
(declare-fun v () Int)
(assert (> (sel var_h2957 res) 4))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3009 res) v)
                    (= v |5|)
                    (= (sel var__temp_h3009 other) (sel var_h2989 other)))
               (= (sel var__temp_h3009 res) 7)))
      (a!2 (and (= (sel |var__temp_h'3011| res) var__temp_v3010)
                (= (sel |var__temp_h'3011| res) (+ (sel var__temp_h3009 res) 5))
                (= (sel |var__temp_h'3011| other) (sel var__temp_h3009 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h3009 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************824
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2990 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2990, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2990, other ) ==(sel)( , var_h2989, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3004:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2990 --->  Ty_heap  
 var_h2989 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2958 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3013 --->  Ty_heap  
 var__temp_v3014 --->  Ty_int  
 var__temp_h'3015 --->  Ty_heap  
 var__temp_v_err3016 --->  error  
 var_h2989 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2957, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3013, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h3013, other ) ==(sel)( , var_h2989, other ) => 
 	 Rel (sel)( , var__temp_h3013, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h3013, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3015, res ) ==(var__temp_v3014) AND 
 	 Rel (sel)( , var__temp_h'3015, res ) ==((sel)( , var__temp_h3013, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'3015, other ) ==(sel)( , var__temp_h3013, other ) => 
 	 True
 
VC_END(declare-const var_h_i2990 T10744)
(declare-const var_h2989 T10744)
(declare-const v Int)
(declare-const var_h_i2958 T10744)
(declare-const var_h2957 T10744)
(declare-const v Int)
(declare-const var_h_i2922 T10744)
(declare-const var_h2921 T10744)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3013 T10744)
(declare-const var__temp_v3014 Int)
(declare-const |var__temp_h'3015| T10744)
(declare-const var__temp_v_err3016 T10745)
(declare-const var_h2989 T10744)
(declare-const var_h2957 T10744)
(declare-const var_h2921 T10744)
(declare-const err T10758)
    (declare-const |5| Int)
  
solver 
 (declare-sort T10744)
(declare-fun sel (T10744 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2957 () T10744)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h3013 () T10744)
(declare-fun |var__temp_h'3015| () T10744)
(declare-fun var__temp_v3014 () Int)
(declare-fun var_h2989 () T10744)
(declare-fun v () Int)
(assert (> (sel var_h2957 res) 4))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3013 res) v)
                    (= v |5|)
                    (= (sel var__temp_h3013 other) (sel var_h2989 other)))
               (= (sel var__temp_h3013 res) 5)))
      (a!2 (and (= (sel |var__temp_h'3015| res) var__temp_v3014)
                (= (sel |var__temp_h'3015| res) (+ (sel var__temp_h3013 res) 2))
                (= (sel |var__temp_h'3015| other) (sel var__temp_h3013 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h3013 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************bar
PARTIAL PATH NEW
SUB 
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i3018 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3018 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3018, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3018, res ) ==((sel)( , var_h3017, res ) + (2))
 	 , (sel)( , var_h_i3018, other ) ==(sel)( , var_h3017, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3019:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3018 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************825
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3018 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3018, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3018, res ) ==((sel)( , var_h3017, res ) + (2))
 	 , (sel)( , var_h_i3018, other ) ==(sel)( , var_h3017, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3019:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3018 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3018 --->  Ty_heap  
 var_h3017 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2990 --->  Ty_heap  
 var_h2989 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2958 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3020 --->  Ty_heap  
 var__temp_v3021 --->  Ty_int  
 var__temp_h'3022 --->  Ty_heap  
 var__temp_v_err3023 --->  error  
 var_h3017 --->  Ty_heap  
 var_h2989 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h3017, res ) ==(5) AND 
 	 Rel (sel)( , var_h2957, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3020, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h3020, res ) ==((sel)( , var_h3017, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h3020, other ) ==(sel)( , var_h3017, other ) => 
 	 Rel (sel)( , var__temp_h3020, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3020, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3022, res ) ==(var__temp_v3021) AND 
 	 Rel (sel)( , var__temp_h'3022, res ) ==((sel)( , var__temp_h3020, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'3022, other ) ==(sel)( , var__temp_h3020, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3022, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'3022, other ) > (4)
 
VC_END(declare-const var_h_i3018 T10761)
(declare-const var_h3017 T10761)
(declare-const v Int)
(declare-const var_h_i2990 T10761)
(declare-const var_h2989 T10761)
(declare-const v Int)
(declare-const var_h_i2958 T10761)
(declare-const var_h2957 T10761)
(declare-const v Int)
(declare-const var_h_i2922 T10761)
(declare-const var_h2921 T10761)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3020 T10761)
(declare-const var__temp_v3021 Int)
(declare-const |var__temp_h'3022| T10761)
(declare-const var__temp_v_err3023 T10762)
(declare-const var_h3017 T10761)
(declare-const var_h2989 T10761)
(declare-const var_h2957 T10761)
(declare-const var_h2921 T10761)
(declare-const err T10775)

solver 
 (declare-sort T10761)
(declare-fun sel (T10761 Int) Int)
(declare-fun res () Int)
(declare-fun var_h3017 () T10761)
(declare-fun var_h2957 () T10761)
(declare-fun other () Int)
(declare-fun |var__temp_h'3022| () T10761)
(declare-fun var__temp_h3020 () T10761)
(declare-fun var__temp_v3021 () Int)
(declare-fun v () Int)
(assert (= (sel var_h3017 res) 5))
(assert (> (sel var_h2957 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h3020 res) v)
                (= (sel var__temp_h3020 res) (+ (sel var_h3017 res) 2))
                (= (sel var__temp_h3020 other) (sel var_h3017 other))))
      (a!2 (and (= (sel |var__temp_h'3022| res) var__temp_v3021)
                (= (sel |var__temp_h'3022| res) (+ (sel var__temp_h3020 res) 3))
                (= (sel |var__temp_h'3022| other) (sel var__temp_h3020 other))))
      (a!3 (and (= (sel |var__temp_h'3022| res) 10)
                (not (> (sel |var__temp_h'3022| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h3020 res) 7))
                (=> (= (sel var__temp_h3020 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************826
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3018 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3018, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3018, res ) ==((sel)( , var_h3017, res ) + (2))
 	 , (sel)( , var_h_i3018, other ) ==(sel)( , var_h3017, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3019:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3018 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3018 --->  Ty_heap  
 var_h3017 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2990 --->  Ty_heap  
 var_h2989 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2958 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3024 --->  Ty_heap  
 var__temp_v3025 --->  Ty_int  
 var__temp_h'3026 --->  Ty_heap  
 var__temp_v_err3027 --->  error  
 var_h3017 --->  Ty_heap  
 var_h2989 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h3017, res ) ==(5) AND 
 	 Rel (sel)( , var_h2957, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3024, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h3024, res ) ==((sel)( , var_h3017, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h3024, other ) ==(sel)( , var_h3017, other ) => 
 	 Rel (sel)( , var__temp_h3024, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3024, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3026, res ) ==(var__temp_v3025) AND 
 	 Rel (sel)( , var__temp_h'3026, res ) ==((sel)( , var__temp_h3024, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'3026, other ) ==(sel)( , var__temp_h3024, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3026, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'3026, other ) > (4)
 
VC_END(declare-const var_h_i3018 T10778)
(declare-const var_h3017 T10778)
(declare-const v Int)
(declare-const var_h_i2990 T10778)
(declare-const var_h2989 T10778)
(declare-const v Int)
(declare-const var_h_i2958 T10778)
(declare-const var_h2957 T10778)
(declare-const v Int)
(declare-const var_h_i2922 T10778)
(declare-const var_h2921 T10778)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3024 T10778)
(declare-const var__temp_v3025 Int)
(declare-const |var__temp_h'3026| T10778)
(declare-const var__temp_v_err3027 T10779)
(declare-const var_h3017 T10778)
(declare-const var_h2989 T10778)
(declare-const var_h2957 T10778)
(declare-const var_h2921 T10778)
(declare-const err T10792)

solver 
 (declare-sort T10778)
(declare-fun sel (T10778 Int) Int)
(declare-fun res () Int)
(declare-fun var_h3017 () T10778)
(declare-fun var_h2957 () T10778)
(declare-fun other () Int)
(declare-fun |var__temp_h'3026| () T10778)
(declare-fun var__temp_h3024 () T10778)
(declare-fun var__temp_v3025 () Int)
(declare-fun v () Int)
(assert (= (sel var_h3017 res) 5))
(assert (> (sel var_h2957 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h3024 res) v)
                (= (sel var__temp_h3024 res) (+ (sel var_h3017 res) 2))
                (= (sel var__temp_h3024 other) (sel var_h3017 other))))
      (a!2 (and (= (sel |var__temp_h'3026| res) var__temp_v3025)
                (= (sel |var__temp_h'3026| res) (+ (sel var__temp_h3024 res) 5))
                (= (sel |var__temp_h'3026| other) (sel var__temp_h3024 other))))
      (a!3 (and (= (sel |var__temp_h'3026| res) 10)
                (not (> (sel |var__temp_h'3026| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h3024 res) 7))
                (=> (= (sel var__temp_h3024 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************827
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v3019:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v3019:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbarfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3018 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3018, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3018, res ) ==((sel)( , var_h3017, res ) + (2))
 	 , (sel)( , var_h_i3018, other ) ==(sel)( , var_h3017, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3028:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************828
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3018 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3018, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3018, res ) ==((sel)( , var_h3017, res ) + (2))
 	 , (sel)( , var_h_i3018, other ) ==(sel)( , var_h3017, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3028:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3018 --->  Ty_heap  
 var_h3017 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2990 --->  Ty_heap  
 var_h2989 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2958 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3029 --->  Ty_heap  
 var__temp_v3030 --->  Ty_int  
 var__temp_h'3031 --->  Ty_heap  
 var__temp_v_err3032 --->  error  
 var_h3017 --->  Ty_heap  
 var_h2989 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h3017, res ) ==(5) AND 
 	 Rel (sel)( , var_h2957, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3029, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h3029, res ) ==((sel)( , var_h3017, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h3029, other ) ==(sel)( , var_h3017, other ) => 
 	 Rel (sel)( , var__temp_h3029, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3029, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3031, res ) ==(var__temp_v3030) AND 
 	 Rel (sel)( , var__temp_h'3031, res ) ==((sel)( , var__temp_h3029, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'3031, other ) ==(sel)( , var__temp_h3029, other ) => 
 	 True
 
VC_END(declare-const var_h_i3018 T10795)
(declare-const var_h3017 T10795)
(declare-const v Int)
(declare-const var_h_i2990 T10795)
(declare-const var_h2989 T10795)
(declare-const v Int)
(declare-const var_h_i2958 T10795)
(declare-const var_h2957 T10795)
(declare-const v Int)
(declare-const var_h_i2922 T10795)
(declare-const var_h2921 T10795)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3029 T10795)
(declare-const var__temp_v3030 Int)
(declare-const |var__temp_h'3031| T10795)
(declare-const var__temp_v_err3032 T10796)
(declare-const var_h3017 T10795)
(declare-const var_h2989 T10795)
(declare-const var_h2957 T10795)
(declare-const var_h2921 T10795)
(declare-const err T10809)

solver 
 (declare-sort T10795)
(declare-fun sel (T10795 Int) Int)
(declare-fun res () Int)
(declare-fun var_h3017 () T10795)
(declare-fun var_h2957 () T10795)
(declare-fun other () Int)
(declare-fun var__temp_h3029 () T10795)
(declare-fun |var__temp_h'3031| () T10795)
(declare-fun var__temp_v3030 () Int)
(declare-fun v () Int)
(assert (= (sel var_h3017 res) 5))
(assert (> (sel var_h2957 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h3029 res) v)
                (= (sel var__temp_h3029 res) (+ (sel var_h3017 res) 2))
                (= (sel var__temp_h3029 other) (sel var_h3017 other))))
      (a!2 (and (= (sel |var__temp_h'3031| res) var__temp_v3030)
                (= (sel |var__temp_h'3031| res) (+ (sel var__temp_h3029 res) 3))
                (= (sel |var__temp_h'3031| other) (sel var__temp_h3029 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h3029 res) 7))
                (=> (= (sel var__temp_h3029 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************baz
PARTIAL PATH NEW
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i3034 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3034 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3034, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3034, res ) ==((sel)( , var_h3033, res ) + (3))
 	 , (sel)( , var_h_i3034, other ) ==(sel)( , var_h3033, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3035:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3034 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************829
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3034 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3034, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3034, res ) ==((sel)( , var_h3033, res ) + (3))
 	 , (sel)( , var_h_i3034, other ) ==(sel)( , var_h3033, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3035:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3034 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3034 --->  Ty_heap  
 var_h3033 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i3018 --->  Ty_heap  
 var_h3017 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2990 --->  Ty_heap  
 var_h2989 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2958 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3036 --->  Ty_heap  
 var__temp_v3037 --->  Ty_int  
 var__temp_h'3038 --->  Ty_heap  
 var__temp_v_err3039 --->  error  
 var_h3033 --->  Ty_heap  
 var_h3017 --->  Ty_heap  
 var_h2989 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h3033, res ) ==(7) AND 
 	 Rel (sel)( , var_h3017, res ) ==(5) AND 
 	 Rel (sel)( , var_h2957, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3036, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h3036, res ) ==((sel)( , var_h3033, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h3036, other ) ==(sel)( , var_h3033, other ) => 
 	 Rel (sel)( , var__temp_h3036, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3036, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3038, res ) ==(var__temp_v3037) AND 
 	 Rel (sel)( , var__temp_h'3038, res ) ==((sel)( , var__temp_h3036, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'3038, other ) ==(sel)( , var__temp_h3036, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3038, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'3038, other ) > (4)
 
VC_END(declare-const var_h_i3034 T10812)
(declare-const var_h3033 T10812)
(declare-const v Int)
(declare-const var_h_i3018 T10812)
(declare-const var_h3017 T10812)
(declare-const v Int)
(declare-const var_h_i2990 T10812)
(declare-const var_h2989 T10812)
(declare-const v Int)
(declare-const var_h_i2958 T10812)
(declare-const var_h2957 T10812)
(declare-const v Int)
(declare-const var_h_i2922 T10812)
(declare-const var_h2921 T10812)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3036 T10812)
(declare-const var__temp_v3037 Int)
(declare-const |var__temp_h'3038| T10812)
(declare-const var__temp_v_err3039 T10813)
(declare-const var_h3033 T10812)
(declare-const var_h3017 T10812)
(declare-const var_h2989 T10812)
(declare-const var_h2957 T10812)
(declare-const var_h2921 T10812)
(declare-const err T10826)

solver 
 (declare-sort T10812)
(declare-fun sel (T10812 Int) Int)
(declare-fun res () Int)
(declare-fun var_h3033 () T10812)
(declare-fun var_h3017 () T10812)
(declare-fun var_h2957 () T10812)
(declare-fun other () Int)
(declare-fun |var__temp_h'3038| () T10812)
(declare-fun var__temp_h3036 () T10812)
(declare-fun var__temp_v3037 () Int)
(declare-fun v () Int)
(assert (= (sel var_h3033 res) 7))
(assert (= (sel var_h3017 res) 5))
(assert (> (sel var_h2957 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h3036 res) v)
                (= (sel var__temp_h3036 res) (+ (sel var_h3033 res) 3))
                (= (sel var__temp_h3036 other) (sel var_h3033 other))))
      (a!2 (and (= (sel |var__temp_h'3038| res) var__temp_v3037)
                (= (sel |var__temp_h'3038| res) (+ (sel var__temp_h3036 res) 5))
                (= (sel |var__temp_h'3038| other) (sel var__temp_h3036 other))))
      (a!3 (and (= (sel |var__temp_h'3038| res) 10)
                (not (> (sel |var__temp_h'3038| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h3036 res) 7))
                (=> (= (sel var__temp_h3036 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************830
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v3035:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v3035:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbazbarfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3034 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3034, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3034, res ) ==((sel)( , var_h3033, res ) + (3))
 	 , (sel)( , var_h_i3034, other ) ==(sel)( , var_h3033, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3040:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************831
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3034 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3034, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3034, res ) ==((sel)( , var_h3033, res ) + (3))
 	 , (sel)( , var_h_i3034, other ) ==(sel)( , var_h3033, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3040:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3034 --->  Ty_heap  
 var_h3033 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i3018 --->  Ty_heap  
 var_h3017 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2990 --->  Ty_heap  
 var_h2989 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2958 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3041 --->  Ty_heap  
 var__temp_v3042 --->  Ty_int  
 var__temp_h'3043 --->  Ty_heap  
 var__temp_v_err3044 --->  error  
 var_h3033 --->  Ty_heap  
 var_h3017 --->  Ty_heap  
 var_h2989 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h3033, res ) ==(7) AND 
 	 Rel (sel)( , var_h3017, res ) ==(5) AND 
 	 Rel (sel)( , var_h2957, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3041, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h3041, res ) ==((sel)( , var_h3033, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h3041, other ) ==(sel)( , var_h3033, other ) => 
 	 Rel (sel)( , var__temp_h3041, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3041, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3043, res ) ==(var__temp_v3042) AND 
 	 Rel (sel)( , var__temp_h'3043, res ) ==((sel)( , var__temp_h3041, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'3043, other ) ==(sel)( , var__temp_h3041, other ) => 
 	 True
 
VC_END(declare-const var_h_i3034 T10829)
(declare-const var_h3033 T10829)
(declare-const v Int)
(declare-const var_h_i3018 T10829)
(declare-const var_h3017 T10829)
(declare-const v Int)
(declare-const var_h_i2990 T10829)
(declare-const var_h2989 T10829)
(declare-const v Int)
(declare-const var_h_i2958 T10829)
(declare-const var_h2957 T10829)
(declare-const v Int)
(declare-const var_h_i2922 T10829)
(declare-const var_h2921 T10829)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3041 T10829)
(declare-const var__temp_v3042 Int)
(declare-const |var__temp_h'3043| T10829)
(declare-const var__temp_v_err3044 T10830)
(declare-const var_h3033 T10829)
(declare-const var_h3017 T10829)
(declare-const var_h2989 T10829)
(declare-const var_h2957 T10829)
(declare-const var_h2921 T10829)
(declare-const err T10843)

solver 
 (declare-sort T10829)
(declare-fun sel (T10829 Int) Int)
(declare-fun res () Int)
(declare-fun var_h3033 () T10829)
(declare-fun var_h3017 () T10829)
(declare-fun var_h2957 () T10829)
(declare-fun other () Int)
(declare-fun var__temp_h3041 () T10829)
(declare-fun |var__temp_h'3043| () T10829)
(declare-fun var__temp_v3042 () Int)
(declare-fun v () Int)
(assert (= (sel var_h3033 res) 7))
(assert (= (sel var_h3017 res) 5))
(assert (> (sel var_h2957 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h3041 res) v)
                (= (sel var__temp_h3041 res) (+ (sel var_h3033 res) 3))
                (= (sel var__temp_h3041 other) (sel var_h3033 other))))
      (a!2 (and (= (sel |var__temp_h'3043| res) var__temp_v3042)
                (= (sel |var__temp_h'3043| res) (+ (sel var__temp_h3041 res) 5))
                (= (sel |var__temp_h'3043| other) (sel var__temp_h3041 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h3041 res) 7))
                (=> (= (sel var__temp_h3041 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************832
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT baz
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3018 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3018, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3018, res ) ==((sel)( , var_h3017, res ) + (2))
 	 , (sel)( , var_h_i3018, other ) ==(sel)( , var_h3017, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3045:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************833
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3018 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3018, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3018, res ) ==((sel)( , var_h3017, res ) + (2))
 	 , (sel)( , var_h_i3018, other ) ==(sel)( , var_h3017, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3045:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3018 --->  Ty_heap  
 var_h3017 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2990 --->  Ty_heap  
 var_h2989 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2958 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3046 --->  Ty_heap  
 var__temp_v3047 --->  Ty_int  
 var__temp_h'3048 --->  Ty_heap  
 var__temp_v_err3049 --->  error  
 var_h3017 --->  Ty_heap  
 var_h2989 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h3017, res ) ==(5) AND 
 	 Rel (sel)( , var_h2957, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3046, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h3046, res ) ==((sel)( , var_h3017, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h3046, other ) ==(sel)( , var_h3017, other ) => 
 	 Rel (sel)( , var__temp_h3046, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3046, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3048, res ) ==(var__temp_v3047) AND 
 	 Rel (sel)( , var__temp_h'3048, res ) ==((sel)( , var__temp_h3046, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'3048, other ) ==(sel)( , var__temp_h3046, other ) => 
 	 True
 
VC_END(declare-const var_h_i3018 T10846)
(declare-const var_h3017 T10846)
(declare-const v Int)
(declare-const var_h_i2990 T10846)
(declare-const var_h2989 T10846)
(declare-const v Int)
(declare-const var_h_i2958 T10846)
(declare-const var_h2957 T10846)
(declare-const v Int)
(declare-const var_h_i2922 T10846)
(declare-const var_h2921 T10846)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3046 T10846)
(declare-const var__temp_v3047 Int)
(declare-const |var__temp_h'3048| T10846)
(declare-const var__temp_v_err3049 T10847)
(declare-const var_h3017 T10846)
(declare-const var_h2989 T10846)
(declare-const var_h2957 T10846)
(declare-const var_h2921 T10846)
(declare-const err T10860)

solver 
 (declare-sort T10846)
(declare-fun sel (T10846 Int) Int)
(declare-fun res () Int)
(declare-fun var_h3017 () T10846)
(declare-fun var_h2957 () T10846)
(declare-fun other () Int)
(declare-fun var__temp_h3046 () T10846)
(declare-fun |var__temp_h'3048| () T10846)
(declare-fun var__temp_v3047 () Int)
(declare-fun v () Int)
(assert (= (sel var_h3017 res) 5))
(assert (> (sel var_h2957 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h3046 res) v)
                (= (sel var__temp_h3046 res) (+ (sel var_h3017 res) 2))
                (= (sel var__temp_h3046 other) (sel var_h3017 other))))
      (a!2 (and (= (sel |var__temp_h'3048| res) var__temp_v3047)
                (= (sel |var__temp_h'3048| res) (+ (sel var__temp_h3046 res) 5))
                (= (sel |var__temp_h'3048| other) (sel var__temp_h3046 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h3046 res) 7))
                (=> (= (sel var__temp_h3046 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c5
PARTIAL PATH NEW
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i3051 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3051 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3051, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3051, res ) ==((sel)( , var_h3050, res ) + (5))
 	 , (sel)( , var_h_i3051, other ) ==(sel)( , var_h3050, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3052:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3051 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************834
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v3052:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v3052:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc5bazbarfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3051 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3051, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3051, res ) ==((sel)( , var_h3050, res ) + (5))
 	 , (sel)( , var_h_i3051, other ) ==(sel)( , var_h3050, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3053:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************835
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --c2
 	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3018 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3018, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3018, res ) ==((sel)( , var_h3017, res ) + (2))
 	 , (sel)( , var_h_i3018, other ) ==(sel)( , var_h3017, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3054:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************836
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --foo
 	 --c2
 	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2990 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2990, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2990, other ) ==(sel)( , var_h2989, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3055:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************837
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2990 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2990, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2990, other ) ==(sel)( , var_h2989, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3055:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2990 --->  Ty_heap  
 var_h2989 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2958 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3056 --->  Ty_heap  
 var__temp_v3057 --->  Ty_int  
 var__temp_h'3058 --->  Ty_heap  
 var__temp_v_err3059 --->  error  
 var_h2989 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2957, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3056, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h3056, other ) ==(sel)( , var_h2989, other ) => 
 	 Rel (sel)( , var__temp_h3056, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3056, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3058, res ) ==(var__temp_v3057) AND 
 	 Rel (sel)( , var__temp_h'3058, res ) ==((sel)( , var__temp_h3056, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'3058, other ) ==(sel)( , var__temp_h3056, other ) => 
 	 True
 
VC_END(declare-const var_h_i2990 T10863)
(declare-const var_h2989 T10863)
(declare-const v Int)
(declare-const var_h_i2958 T10863)
(declare-const var_h2957 T10863)
(declare-const v Int)
(declare-const var_h_i2922 T10863)
(declare-const var_h2921 T10863)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3056 T10863)
(declare-const var__temp_v3057 Int)
(declare-const |var__temp_h'3058| T10863)
(declare-const var__temp_v_err3059 T10864)
(declare-const var_h2989 T10863)
(declare-const var_h2957 T10863)
(declare-const var_h2921 T10863)
(declare-const err T10877)
    (declare-const |5| Int)
  
solver 
 (declare-sort T10863)
(declare-fun sel (T10863 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2957 () T10863)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h3056 () T10863)
(declare-fun |var__temp_h'3058| () T10863)
(declare-fun var__temp_v3057 () Int)
(declare-fun var_h2989 () T10863)
(declare-fun v () Int)
(assert (> (sel var_h2957 res) 4))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3056 res) v)
                    (= v |5|)
                    (= (sel var__temp_h3056 other) (sel var_h2989 other)))
               (= (sel var__temp_h3056 res) 7)))
      (a!2 (and (= (sel |var__temp_h'3058| res) var__temp_v3057)
                (= (sel |var__temp_h'3058| res) (+ (sel var__temp_h3056 res) 3))
                (= (sel |var__temp_h'3058| other) (sel var__temp_h3056 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h3056 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************838
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2990 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2990, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i2990, other ) ==(sel)( , var_h2989, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3055:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2990 --->  Ty_heap  
 var_h2989 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2958 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3060 --->  Ty_heap  
 var__temp_v3061 --->  Ty_int  
 var__temp_h'3062 --->  Ty_heap  
 var__temp_v_err3063 --->  error  
 var_h2989 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2957, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3060, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h3060, other ) ==(sel)( , var_h2989, other ) => 
 	 Rel (sel)( , var__temp_h3060, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3060, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3062, res ) ==(var__temp_v3061) AND 
 	 Rel (sel)( , var__temp_h'3062, res ) ==((sel)( , var__temp_h3060, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'3062, other ) ==(sel)( , var__temp_h3060, other ) => 
 	 True
 
VC_END(declare-const var_h_i2990 T10880)
(declare-const var_h2989 T10880)
(declare-const v Int)
(declare-const var_h_i2958 T10880)
(declare-const var_h2957 T10880)
(declare-const v Int)
(declare-const var_h_i2922 T10880)
(declare-const var_h2921 T10880)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3060 T10880)
(declare-const var__temp_v3061 Int)
(declare-const |var__temp_h'3062| T10880)
(declare-const var__temp_v_err3063 T10881)
(declare-const var_h2989 T10880)
(declare-const var_h2957 T10880)
(declare-const var_h2921 T10880)
(declare-const err T10894)
    (declare-const |5| Int)
  
solver 
 (declare-sort T10880)
(declare-fun sel (T10880 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2957 () T10880)
(declare-fun |5| () Int)
(declare-fun other () Int)
(declare-fun var__temp_h3060 () T10880)
(declare-fun |var__temp_h'3062| () T10880)
(declare-fun var__temp_v3061 () Int)
(declare-fun var_h2989 () T10880)
(declare-fun v () Int)
(assert (> (sel var_h2957 res) 4))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3060 res) v)
                    (= v |5|)
                    (= (sel var__temp_h3060 other) (sel var_h2989 other)))
               (= (sel var__temp_h3060 res) 7)))
      (a!2 (and (= (sel |var__temp_h'3062| res) var__temp_v3061)
                (= (sel |var__temp_h'3062| res) (+ (sel var__temp_h3060 res) 5))
                (= (sel |var__temp_h'3062| other) (sel var__temp_h3060 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h3060 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************839
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT bar
PARTIAL PATH
SUB 
 	 --c2
 	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2958 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2958, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2958, res ) ==((sel)( , var_h2957, res ) + (10))
 	 , (sel)( , var_h_i2958, other ) ==(sel)( , var_h2957, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3064:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************840
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2958 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2958, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2958, res ) ==((sel)( , var_h2957, res ) + (10))
 	 , (sel)( , var_h_i2958, other ) ==(sel)( , var_h2957, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3064:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2958 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3065 --->  Ty_heap  
 var__temp_v3066 --->  Ty_int  
 var__temp_h'3067 --->  Ty_heap  
 var__temp_v_err3068 --->  error  
 var_h2957 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2957, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3065, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h3065, res ) ==((sel)( , var_h2957, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h3065, other ) ==(sel)( , var_h2957, other ) => 
 	 Rel (sel)( , var__temp_h3065, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3065, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3067, res ) ==(var__temp_v3066) AND 
 	 Rel (sel)( , var__temp_h'3067, res ) ==((sel)( , var__temp_h3065, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'3067, other ) ==(sel)( , var__temp_h3065, other ) => 
 	 True
 
VC_END(declare-const var_h_i2958 T10897)
(declare-const var_h2957 T10897)
(declare-const v Int)
(declare-const var_h_i2922 T10897)
(declare-const var_h2921 T10897)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3065 T10897)
(declare-const var__temp_v3066 Int)
(declare-const |var__temp_h'3067| T10897)
(declare-const var__temp_v_err3068 T10898)
(declare-const var_h2957 T10897)
(declare-const var_h2921 T10897)
(declare-const err T10911)

solver 
 (declare-sort T10897)
(declare-fun sel (T10897 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2957 () T10897)
(declare-fun other () Int)
(declare-fun var__temp_h3065 () T10897)
(declare-fun |var__temp_h'3067| () T10897)
(declare-fun var__temp_v3066 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2957 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h3065 res) v)
                (= (sel var__temp_h3065 res) (+ (sel var_h2957 res) 10))
                (= (sel var__temp_h3065 other) (sel var_h2957 other))))
      (a!2 (and (= (sel |var__temp_h'3067| res) var__temp_v3066)
                (= (sel |var__temp_h'3067| res) (+ (sel var__temp_h3065 res) 3))
                (= (sel |var__temp_h'3067| other) (sel var__temp_h3065 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h3065 res) 7))
                (=> (= (sel var__temp_h3065 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************841
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2958 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2958, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2958, res ) ==((sel)( , var_h2957, res ) + (10))
 	 , (sel)( , var_h_i2958, other ) ==(sel)( , var_h2957, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3064:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2958 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3069 --->  Ty_heap  
 var__temp_v3070 --->  Ty_int  
 var__temp_h'3071 --->  Ty_heap  
 var__temp_v_err3072 --->  error  
 var_h2957 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2957, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3069, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h3069, res ) ==((sel)( , var_h2957, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h3069, other ) ==(sel)( , var_h2957, other ) => 
 	 Rel (sel)( , var__temp_h3069, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3069, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3071, res ) ==(var__temp_v3070) AND 
 	 Rel (sel)( , var__temp_h'3071, res ) ==((sel)( , var__temp_h3069, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'3071, other ) ==(sel)( , var__temp_h3069, other ) => 
 	 True
 
VC_END(declare-const var_h_i2958 T10914)
(declare-const var_h2957 T10914)
(declare-const v Int)
(declare-const var_h_i2922 T10914)
(declare-const var_h2921 T10914)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3069 T10914)
(declare-const var__temp_v3070 Int)
(declare-const |var__temp_h'3071| T10914)
(declare-const var__temp_v_err3072 T10915)
(declare-const var_h2957 T10914)
(declare-const var_h2921 T10914)
(declare-const err T10928)

solver 
 (declare-sort T10914)
(declare-fun sel (T10914 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2957 () T10914)
(declare-fun other () Int)
(declare-fun var__temp_h3069 () T10914)
(declare-fun |var__temp_h'3071| () T10914)
(declare-fun var__temp_v3070 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2957 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h3069 res) v)
                (= (sel var__temp_h3069 res) (+ (sel var_h2957 res) 10))
                (= (sel var__temp_h3069 other) (sel var_h2957 other))))
      (a!2 (and (= (sel |var__temp_h'3071| res) var__temp_v3070)
                (= (sel |var__temp_h'3071| res) (+ (sel var__temp_h3069 res) 5))
                (= (sel |var__temp_h'3071| other) (sel var__temp_h3069 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h3069 res) 7))
                (=> (= (sel var__temp_h3069 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************842
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2958 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2958, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i2958, res ) ==((sel)( , var_h2957, res ) + (10))
 	 , (sel)( , var_h_i2958, other ) ==(sel)( , var_h2957, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3064:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2958 --->  Ty_heap  
 var_h2957 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3073 --->  Ty_heap  
 var__temp_v3074 --->  Ty_int  
 var__temp_h'3075 --->  Ty_heap  
 var__temp_v_err3076 --->  error  
 var_h2957 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h2957, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3073, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h3073, res ) ==((sel)( , var_h2957, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h3073, other ) ==(sel)( , var_h2957, other ) => 
 	 Rel (sel)( , var__temp_h3073, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h3073, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3075, res ) ==(var__temp_v3074) AND 
 	 Rel (sel)( , var__temp_h'3075, res ) ==((sel)( , var__temp_h3073, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'3075, other ) ==(sel)( , var__temp_h3073, other ) => 
 	 True
 
VC_END(declare-const var_h_i2958 T10931)
(declare-const var_h2957 T10931)
(declare-const v Int)
(declare-const var_h_i2922 T10931)
(declare-const var_h2921 T10931)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3073 T10931)
(declare-const var__temp_v3074 Int)
(declare-const |var__temp_h'3075| T10931)
(declare-const var__temp_v_err3076 T10932)
(declare-const var_h2957 T10931)
(declare-const var_h2921 T10931)
(declare-const err T10945)

solver 
 (declare-sort T10931)
(declare-fun sel (T10931 Int) Int)
(declare-fun res () Int)
(declare-fun var_h2957 () T10931)
(declare-fun other () Int)
(declare-fun var__temp_h3073 () T10931)
(declare-fun |var__temp_h'3075| () T10931)
(declare-fun var__temp_v3074 () Int)
(declare-fun v () Int)
(assert (> (sel var_h2957 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h3073 res) v)
                (= (sel var__temp_h3073 res) (+ (sel var_h2957 res) 10))
                (= (sel var__temp_h3073 other) (sel var_h2957 other))))
      (a!2 (and (= (sel |var__temp_h'3075| res) var__temp_v3074)
                (= (sel |var__temp_h'3075| res) (+ (sel var__temp_h3073 res) 2))
                (= (sel |var__temp_h'3075| other) (sel var__temp_h3073 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h3073 res) 5))
                (=> (= (sel var__temp_h3073 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************843
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo
PARTIAL PATH
SUB 
 	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2922 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2922, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2922, other ) ==(sel)( , var_h2921, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3077:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
foo
bar
 *********************Enumeration Iteration*****************844
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2922 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2922, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2922, other ) ==(sel)( , var_h2921, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3077:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3078 --->  Ty_heap  
 var__temp_v3079 --->  Ty_int  
 var__temp_h'3080 --->  Ty_heap  
 var__temp_v_err3081 --->  error  
 var_h2921 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3078, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h3078, other ) ==(sel)( , var_h2921, other ) => 
 	 Rel (sel)( , var__temp_h3078, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3078, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3080, res ) ==(var__temp_v3079) AND 
 	 Rel (sel)( , var__temp_h'3080, res ) ==((sel)( , var__temp_h3078, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'3080, other ) ==(sel)( , var__temp_h3078, other ) => 
 	 True
 
VC_END(declare-const var_h_i2922 T10948)
(declare-const var_h2921 T10948)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3078 T10948)
(declare-const var__temp_v3079 Int)
(declare-const |var__temp_h'3080| T10948)
(declare-const var__temp_v_err3081 T10949)
(declare-const var_h2921 T10948)
(declare-const err T10962)
    (declare-const |20| Int)
  
solver 
 (declare-sort T10948)
(declare-fun |20| () Int)
(declare-fun sel (T10948 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h3078 () T10948)
(declare-fun |var__temp_h'3080| () T10948)
(declare-fun res () Int)
(declare-fun var__temp_v3079 () Int)
(declare-fun var_h2921 () T10948)
(declare-fun v () Int)
(assert true)
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3078 res) v)
                    (= v |20|)
                    (= (sel var__temp_h3078 other) (sel var_h2921 other)))
               (= (sel var__temp_h3078 res) 7)))
      (a!2 (and (= (sel |var__temp_h'3080| res) var__temp_v3079)
                (= (sel |var__temp_h'3080| res) (+ (sel var__temp_h3078 res) 3))
                (= (sel |var__temp_h'3080| other) (sel var__temp_h3078 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h3078 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************845
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2922 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2922, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2922, other ) ==(sel)( , var_h2921, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3077:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3082 --->  Ty_heap  
 var__temp_v3083 --->  Ty_int  
 var__temp_h'3084 --->  Ty_heap  
 var__temp_v_err3085 --->  error  
 var_h2921 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3082, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h3082, other ) ==(sel)( , var_h2921, other ) => 
 	 Rel (sel)( , var__temp_h3082, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3082, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3084, res ) ==(var__temp_v3083) AND 
 	 Rel (sel)( , var__temp_h'3084, res ) ==((sel)( , var__temp_h3082, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'3084, other ) ==(sel)( , var__temp_h3082, other ) => 
 	 True
 
VC_END(declare-const var_h_i2922 T10965)
(declare-const var_h2921 T10965)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3082 T10965)
(declare-const var__temp_v3083 Int)
(declare-const |var__temp_h'3084| T10965)
(declare-const var__temp_v_err3085 T10966)
(declare-const var_h2921 T10965)
(declare-const err T10979)
    (declare-const |20| Int)
  
solver 
 (declare-sort T10965)
(declare-fun |20| () Int)
(declare-fun sel (T10965 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h3082 () T10965)
(declare-fun |var__temp_h'3084| () T10965)
(declare-fun res () Int)
(declare-fun var__temp_v3083 () Int)
(declare-fun var_h2921 () T10965)
(declare-fun v () Int)
(assert true)
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3082 res) v)
                    (= v |20|)
                    (= (sel var__temp_h3082 other) (sel var_h2921 other)))
               (= (sel var__temp_h3082 res) 7)))
      (a!2 (and (= (sel |var__temp_h'3084| res) var__temp_v3083)
                (= (sel |var__temp_h'3084| res) (+ (sel var__temp_h3082 res) 5))
                (= (sel |var__temp_h'3084| other) (sel var__temp_h3082 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h3082 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************846
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2922 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2922, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2922, other ) ==(sel)( , var_h2921, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3077:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3086 --->  Ty_heap  
 var__temp_v3087 --->  Ty_int  
 var__temp_h'3088 --->  Ty_heap  
 var__temp_v_err3089 --->  error  
 var_h2921 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3086, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h3086, other ) ==(sel)( , var_h2921, other ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3088, res ) ==(var__temp_v3087) AND 
 	 Base var__temp_v3087 = 5 AND 
 	 Rel (sel)( , var__temp_h'3088, other ) ==(sel)( , var__temp_h3086, other ) => 
 	 True
 
VC_END(declare-const var_h_i2922 T10982)
(declare-const var_h2921 T10982)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3086 T10982)
(declare-const var__temp_v3087 Int)
(declare-const |var__temp_h'3088| T10982)
(declare-const var__temp_v_err3089 T10983)
(declare-const var_h2921 T10982)
(declare-const err T10996)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T10982)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun sel (T10982 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h3086 () T10982)
(declare-fun |var__temp_h'3088| () T10982)
(declare-fun var__temp_v3087 () Int)
(declare-fun res () Int)
(declare-fun var_h2921 () T10982)
(declare-fun v () Int)
(assert true)
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3086 res) v)
                    (= v |20|)
                    (= (sel var__temp_h3086 other) (sel var_h2921 other)))
               true))
      (a!2 (=> (and (= (sel |var__temp_h'3088| res) var__temp_v3087)
                    (= var__temp_v3087 |5|)
                    (= (sel |var__temp_h'3088| other)
                       (sel var__temp_h3086 other)))
               true)))
  (not (and a!1 (=> true a!2)))))

***************Selection Successful************foo
PARTIAL PATH NEW
SUB 
 	 --foo
 	 --foo'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i3091 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3091 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3091, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i3091, other ) ==(sel)( , var_h3090, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3092:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3091 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************847
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3091 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3091, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i3091, other ) ==(sel)( , var_h3090, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3092:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3091 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3091 --->  Ty_heap  
 var_h3090 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3093 --->  Ty_heap  
 var__temp_v3094 --->  Ty_int  
 var__temp_h'3095 --->  Ty_heap  
 var__temp_v_err3096 --->  error  
 var_h3090 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3093, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h3093, other ) ==(sel)( , var_h3090, other ) => 
 	 Rel (sel)( , var__temp_h3093, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3093, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3095, res ) ==(var__temp_v3094) AND 
 	 Rel (sel)( , var__temp_h'3095, res ) ==((sel)( , var__temp_h3093, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'3095, other ) ==(sel)( , var__temp_h3093, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3095, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'3095, other ) > (4)
 
VC_END(declare-const var_h_i3091 T10999)
(declare-const var_h3090 T10999)
(declare-const v Int)
(declare-const var_h_i2922 T10999)
(declare-const var_h2921 T10999)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3093 T10999)
(declare-const var__temp_v3094 Int)
(declare-const |var__temp_h'3095| T10999)
(declare-const var__temp_v_err3096 T11000)
(declare-const var_h3090 T10999)
(declare-const var_h2921 T10999)
(declare-const err T11013)
    (declare-const |5| Int)
  
solver 
 (declare-sort T10999)
(declare-fun |5| () Int)
(declare-fun sel (T10999 Int) Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'3095| () T10999)
(declare-fun res () Int)
(declare-fun var__temp_h3093 () T10999)
(declare-fun var__temp_v3094 () Int)
(declare-fun var_h3090 () T10999)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3093 res) v)
                    (= v |5|)
                    (= (sel var__temp_h3093 other) (sel var_h3090 other)))
               (= (sel var__temp_h3093 res) 7)))
      (a!2 (and (= (sel |var__temp_h'3095| res) var__temp_v3094)
                (= (sel |var__temp_h'3095| res) (+ (sel var__temp_h3093 res) 3))
                (= (sel |var__temp_h'3095| other) (sel var__temp_h3093 other))))
      (a!3 (and (= (sel |var__temp_h'3095| res) 10)
                (not (> (sel |var__temp_h'3095| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h3093 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************848
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3091 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3091, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i3091, other ) ==(sel)( , var_h3090, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3092:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3091 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3091 --->  Ty_heap  
 var_h3090 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3097 --->  Ty_heap  
 var__temp_v3098 --->  Ty_int  
 var__temp_h'3099 --->  Ty_heap  
 var__temp_v_err3100 --->  error  
 var_h3090 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3097, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h3097, other ) ==(sel)( , var_h3090, other ) => 
 	 Rel (sel)( , var__temp_h3097, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3097, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3099, res ) ==(var__temp_v3098) AND 
 	 Rel (sel)( , var__temp_h'3099, res ) ==((sel)( , var__temp_h3097, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'3099, other ) ==(sel)( , var__temp_h3097, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3099, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'3099, other ) > (4)
 
VC_END(declare-const var_h_i3091 T11016)
(declare-const var_h3090 T11016)
(declare-const v Int)
(declare-const var_h_i2922 T11016)
(declare-const var_h2921 T11016)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3097 T11016)
(declare-const var__temp_v3098 Int)
(declare-const |var__temp_h'3099| T11016)
(declare-const var__temp_v_err3100 T11017)
(declare-const var_h3090 T11016)
(declare-const var_h2921 T11016)
(declare-const err T11030)
    (declare-const |5| Int)
  
solver 
 (declare-sort T11016)
(declare-fun |5| () Int)
(declare-fun sel (T11016 Int) Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'3099| () T11016)
(declare-fun res () Int)
(declare-fun var__temp_h3097 () T11016)
(declare-fun var__temp_v3098 () Int)
(declare-fun var_h3090 () T11016)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3097 res) v)
                    (= v |5|)
                    (= (sel var__temp_h3097 other) (sel var_h3090 other)))
               (= (sel var__temp_h3097 res) 7)))
      (a!2 (and (= (sel |var__temp_h'3099| res) var__temp_v3098)
                (= (sel |var__temp_h'3099| res) (+ (sel var__temp_h3097 res) 5))
                (= (sel |var__temp_h'3099| other) (sel var__temp_h3097 other))))
      (a!3 (and (= (sel |var__temp_h'3099| res) 10)
                (not (> (sel |var__temp_h'3099| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h3097 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************849
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3091 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3091, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i3091, other ) ==(sel)( , var_h3090, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3092:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3091 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3091 --->  Ty_heap  
 var_h3090 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3101 --->  Ty_heap  
 var__temp_v3102 --->  Ty_int  
 var__temp_h'3103 --->  Ty_heap  
 var__temp_v_err3104 --->  error  
 var_h3090 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3101, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h3101, other ) ==(sel)( , var_h3090, other ) => 
 	 Rel (sel)( , var__temp_h3101, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h3101, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3103, res ) ==(var__temp_v3102) AND 
 	 Rel (sel)( , var__temp_h'3103, res ) ==((sel)( , var__temp_h3101, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'3103, other ) ==(sel)( , var__temp_h3101, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3103, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'3103, other ) > (4)
 
VC_END(declare-const var_h_i3091 T11033)
(declare-const var_h3090 T11033)
(declare-const v Int)
(declare-const var_h_i2922 T11033)
(declare-const var_h2921 T11033)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3101 T11033)
(declare-const var__temp_v3102 Int)
(declare-const |var__temp_h'3103| T11033)
(declare-const var__temp_v_err3104 T11034)
(declare-const var_h3090 T11033)
(declare-const var_h2921 T11033)
(declare-const err T11047)
    (declare-const |5| Int)
  
solver 
 (declare-sort T11033)
(declare-fun |5| () Int)
(declare-fun sel (T11033 Int) Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'3103| () T11033)
(declare-fun res () Int)
(declare-fun var__temp_h3101 () T11033)
(declare-fun var__temp_v3102 () Int)
(declare-fun var_h3090 () T11033)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3101 res) v)
                    (= v |5|)
                    (= (sel var__temp_h3101 other) (sel var_h3090 other)))
               (= (sel var__temp_h3101 res) 5)))
      (a!2 (and (= (sel |var__temp_h'3103| res) var__temp_v3102)
                (= (sel |var__temp_h'3103| res) (+ (sel var__temp_h3101 res) 2))
                (= (sel |var__temp_h'3103| other) (sel var__temp_h3101 other))))
      (a!3 (and (= (sel |var__temp_h'3103| res) 10)
                (not (> (sel |var__temp_h'3103| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h3101 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************850
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v3092:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v3092:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --foo
 	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3091 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3091, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i3091, other ) ==(sel)( , var_h3090, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3105:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************851
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3091 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3091, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i3091, other ) ==(sel)( , var_h3090, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3105:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3091 --->  Ty_heap  
 var_h3090 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3106 --->  Ty_heap  
 var__temp_v3107 --->  Ty_int  
 var__temp_h'3108 --->  Ty_heap  
 var__temp_v_err3109 --->  error  
 var_h3090 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3106, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h3106, other ) ==(sel)( , var_h3090, other ) => 
 	 Rel (sel)( , var__temp_h3106, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3106, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3108, res ) ==(var__temp_v3107) AND 
 	 Rel (sel)( , var__temp_h'3108, res ) ==((sel)( , var__temp_h3106, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'3108, other ) ==(sel)( , var__temp_h3106, other ) => 
 	 True
 
VC_END(declare-const var_h_i3091 T11050)
(declare-const var_h3090 T11050)
(declare-const v Int)
(declare-const var_h_i2922 T11050)
(declare-const var_h2921 T11050)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3106 T11050)
(declare-const var__temp_v3107 Int)
(declare-const |var__temp_h'3108| T11050)
(declare-const var__temp_v_err3109 T11051)
(declare-const var_h3090 T11050)
(declare-const var_h2921 T11050)
(declare-const err T11064)
    (declare-const |5| Int)
  
solver 
 (declare-sort T11050)
(declare-fun |5| () Int)
(declare-fun sel (T11050 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h3106 () T11050)
(declare-fun |var__temp_h'3108| () T11050)
(declare-fun res () Int)
(declare-fun var__temp_v3107 () Int)
(declare-fun var_h3090 () T11050)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3106 res) v)
                    (= v |5|)
                    (= (sel var__temp_h3106 other) (sel var_h3090 other)))
               (= (sel var__temp_h3106 res) 7)))
      (a!2 (and (= (sel |var__temp_h'3108| res) var__temp_v3107)
                (= (sel |var__temp_h'3108| res) (+ (sel var__temp_h3106 res) 3))
                (= (sel |var__temp_h'3108| other) (sel var__temp_h3106 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h3106 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************852
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3091 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3091, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i3091, other ) ==(sel)( , var_h3090, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3105:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3091 --->  Ty_heap  
 var_h3090 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3110 --->  Ty_heap  
 var__temp_v3111 --->  Ty_int  
 var__temp_h'3112 --->  Ty_heap  
 var__temp_v_err3113 --->  error  
 var_h3090 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3110, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h3110, other ) ==(sel)( , var_h3090, other ) => 
 	 Rel (sel)( , var__temp_h3110, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3110, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3112, res ) ==(var__temp_v3111) AND 
 	 Rel (sel)( , var__temp_h'3112, res ) ==((sel)( , var__temp_h3110, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'3112, other ) ==(sel)( , var__temp_h3110, other ) => 
 	 True
 
VC_END(declare-const var_h_i3091 T11067)
(declare-const var_h3090 T11067)
(declare-const v Int)
(declare-const var_h_i2922 T11067)
(declare-const var_h2921 T11067)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3110 T11067)
(declare-const var__temp_v3111 Int)
(declare-const |var__temp_h'3112| T11067)
(declare-const var__temp_v_err3113 T11068)
(declare-const var_h3090 T11067)
(declare-const var_h2921 T11067)
(declare-const err T11081)
    (declare-const |5| Int)
  
solver 
 (declare-sort T11067)
(declare-fun |5| () Int)
(declare-fun sel (T11067 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h3110 () T11067)
(declare-fun |var__temp_h'3112| () T11067)
(declare-fun res () Int)
(declare-fun var__temp_v3111 () Int)
(declare-fun var_h3090 () T11067)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3110 res) v)
                    (= v |5|)
                    (= (sel var__temp_h3110 other) (sel var_h3090 other)))
               (= (sel var__temp_h3110 res) 7)))
      (a!2 (and (= (sel |var__temp_h'3112| res) var__temp_v3111)
                (= (sel |var__temp_h'3112| res) (+ (sel var__temp_h3110 res) 5))
                (= (sel |var__temp_h'3112| other) (sel var__temp_h3110 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h3110 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************853
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3091 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3091, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i3091, other ) ==(sel)( , var_h3090, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3105:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3091 --->  Ty_heap  
 var_h3090 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3114 --->  Ty_heap  
 var__temp_v3115 --->  Ty_int  
 var__temp_h'3116 --->  Ty_heap  
 var__temp_v_err3117 --->  error  
 var_h3090 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3114, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h3114, other ) ==(sel)( , var_h3090, other ) => 
 	 Rel (sel)( , var__temp_h3114, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h3114, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3116, res ) ==(var__temp_v3115) AND 
 	 Rel (sel)( , var__temp_h'3116, res ) ==((sel)( , var__temp_h3114, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'3116, other ) ==(sel)( , var__temp_h3114, other ) => 
 	 True
 
VC_END(declare-const var_h_i3091 T11084)
(declare-const var_h3090 T11084)
(declare-const v Int)
(declare-const var_h_i2922 T11084)
(declare-const var_h2921 T11084)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3114 T11084)
(declare-const var__temp_v3115 Int)
(declare-const |var__temp_h'3116| T11084)
(declare-const var__temp_v_err3117 T11085)
(declare-const var_h3090 T11084)
(declare-const var_h2921 T11084)
(declare-const err T11098)
    (declare-const |5| Int)
  
solver 
 (declare-sort T11084)
(declare-fun |5| () Int)
(declare-fun sel (T11084 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h3114 () T11084)
(declare-fun |var__temp_h'3116| () T11084)
(declare-fun res () Int)
(declare-fun var__temp_v3115 () Int)
(declare-fun var_h3090 () T11084)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3114 res) v)
                    (= v |5|)
                    (= (sel var__temp_h3114 other) (sel var_h3090 other)))
               (= (sel var__temp_h3114 res) 5)))
      (a!2 (and (= (sel |var__temp_h'3116| res) var__temp_v3115)
                (= (sel |var__temp_h'3116| res) (+ (sel var__temp_h3114 res) 2))
                (= (sel |var__temp_h'3116| other) (sel var__temp_h3114 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h3114 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************bar
PARTIAL PATH NEW
SUB 
 	 --bar
 	 --foo
 	 --foo'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i3119 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3119 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3119, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3119, res ) ==((sel)( , var_h3118, res ) + (2))
 	 , (sel)( , var_h_i3119, other ) ==(sel)( , var_h3118, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3120:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3119 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************854
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3119 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3119, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3119, res ) ==((sel)( , var_h3118, res ) + (2))
 	 , (sel)( , var_h_i3119, other ) ==(sel)( , var_h3118, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3120:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3119 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3119 --->  Ty_heap  
 var_h3118 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i3091 --->  Ty_heap  
 var_h3090 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3121 --->  Ty_heap  
 var__temp_v3122 --->  Ty_int  
 var__temp_h'3123 --->  Ty_heap  
 var__temp_v_err3124 --->  error  
 var_h3118 --->  Ty_heap  
 var_h3090 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h3118, res ) ==(5) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3121, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h3121, res ) ==((sel)( , var_h3118, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h3121, other ) ==(sel)( , var_h3118, other ) => 
 	 Rel (sel)( , var__temp_h3121, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3121, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3123, res ) ==(var__temp_v3122) AND 
 	 Rel (sel)( , var__temp_h'3123, res ) ==((sel)( , var__temp_h3121, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'3123, other ) ==(sel)( , var__temp_h3121, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3123, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'3123, other ) > (4)
 
VC_END(declare-const var_h_i3119 T11101)
(declare-const var_h3118 T11101)
(declare-const v Int)
(declare-const var_h_i3091 T11101)
(declare-const var_h3090 T11101)
(declare-const v Int)
(declare-const var_h_i2922 T11101)
(declare-const var_h2921 T11101)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3121 T11101)
(declare-const var__temp_v3122 Int)
(declare-const |var__temp_h'3123| T11101)
(declare-const var__temp_v_err3124 T11102)
(declare-const var_h3118 T11101)
(declare-const var_h3090 T11101)
(declare-const var_h2921 T11101)
(declare-const err T11115)

solver 
 (declare-sort T11101)
(declare-fun sel (T11101 Int) Int)
(declare-fun res () Int)
(declare-fun var_h3118 () T11101)
(declare-fun other () Int)
(declare-fun |var__temp_h'3123| () T11101)
(declare-fun var__temp_h3121 () T11101)
(declare-fun var__temp_v3122 () Int)
(declare-fun v () Int)
(assert (= (sel var_h3118 res) 5))
(assert (let ((a!1 (and (= (sel var__temp_h3121 res) v)
                (= (sel var__temp_h3121 res) (+ (sel var_h3118 res) 2))
                (= (sel var__temp_h3121 other) (sel var_h3118 other))))
      (a!2 (and (= (sel |var__temp_h'3123| res) var__temp_v3122)
                (= (sel |var__temp_h'3123| res) (+ (sel var__temp_h3121 res) 3))
                (= (sel |var__temp_h'3123| other) (sel var__temp_h3121 other))))
      (a!3 (and (= (sel |var__temp_h'3123| res) 10)
                (not (> (sel |var__temp_h'3123| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h3121 res) 7))
                (=> (= (sel var__temp_h3121 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************855
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3119 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3119, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3119, res ) ==((sel)( , var_h3118, res ) + (2))
 	 , (sel)( , var_h_i3119, other ) ==(sel)( , var_h3118, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3120:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3119 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3119 --->  Ty_heap  
 var_h3118 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i3091 --->  Ty_heap  
 var_h3090 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3125 --->  Ty_heap  
 var__temp_v3126 --->  Ty_int  
 var__temp_h'3127 --->  Ty_heap  
 var__temp_v_err3128 --->  error  
 var_h3118 --->  Ty_heap  
 var_h3090 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h3118, res ) ==(5) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3125, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h3125, res ) ==((sel)( , var_h3118, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h3125, other ) ==(sel)( , var_h3118, other ) => 
 	 Rel (sel)( , var__temp_h3125, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3125, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3127, res ) ==(var__temp_v3126) AND 
 	 Rel (sel)( , var__temp_h'3127, res ) ==((sel)( , var__temp_h3125, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'3127, other ) ==(sel)( , var__temp_h3125, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3127, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'3127, other ) > (4)
 
VC_END(declare-const var_h_i3119 T11118)
(declare-const var_h3118 T11118)
(declare-const v Int)
(declare-const var_h_i3091 T11118)
(declare-const var_h3090 T11118)
(declare-const v Int)
(declare-const var_h_i2922 T11118)
(declare-const var_h2921 T11118)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3125 T11118)
(declare-const var__temp_v3126 Int)
(declare-const |var__temp_h'3127| T11118)
(declare-const var__temp_v_err3128 T11119)
(declare-const var_h3118 T11118)
(declare-const var_h3090 T11118)
(declare-const var_h2921 T11118)
(declare-const err T11132)

solver 
 (declare-sort T11118)
(declare-fun sel (T11118 Int) Int)
(declare-fun res () Int)
(declare-fun var_h3118 () T11118)
(declare-fun other () Int)
(declare-fun |var__temp_h'3127| () T11118)
(declare-fun var__temp_h3125 () T11118)
(declare-fun var__temp_v3126 () Int)
(declare-fun v () Int)
(assert (= (sel var_h3118 res) 5))
(assert (let ((a!1 (and (= (sel var__temp_h3125 res) v)
                (= (sel var__temp_h3125 res) (+ (sel var_h3118 res) 2))
                (= (sel var__temp_h3125 other) (sel var_h3118 other))))
      (a!2 (and (= (sel |var__temp_h'3127| res) var__temp_v3126)
                (= (sel |var__temp_h'3127| res) (+ (sel var__temp_h3125 res) 5))
                (= (sel |var__temp_h'3127| other) (sel var__temp_h3125 other))))
      (a!3 (and (= (sel |var__temp_h'3127| res) 10)
                (not (> (sel |var__temp_h'3127| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h3125 res) 7))
                (=> (= (sel var__temp_h3125 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************856
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v3120:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v3120:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbarfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3119 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3119, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3119, res ) ==((sel)( , var_h3118, res ) + (2))
 	 , (sel)( , var_h_i3119, other ) ==(sel)( , var_h3118, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3129:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************857
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3119 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3119, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3119, res ) ==((sel)( , var_h3118, res ) + (2))
 	 , (sel)( , var_h_i3119, other ) ==(sel)( , var_h3118, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3129:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3119 --->  Ty_heap  
 var_h3118 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i3091 --->  Ty_heap  
 var_h3090 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3130 --->  Ty_heap  
 var__temp_v3131 --->  Ty_int  
 var__temp_h'3132 --->  Ty_heap  
 var__temp_v_err3133 --->  error  
 var_h3118 --->  Ty_heap  
 var_h3090 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h3118, res ) ==(5) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3130, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h3130, res ) ==((sel)( , var_h3118, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h3130, other ) ==(sel)( , var_h3118, other ) => 
 	 Rel (sel)( , var__temp_h3130, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3130, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3132, res ) ==(var__temp_v3131) AND 
 	 Rel (sel)( , var__temp_h'3132, res ) ==((sel)( , var__temp_h3130, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'3132, other ) ==(sel)( , var__temp_h3130, other ) => 
 	 True
 
VC_END(declare-const var_h_i3119 T11135)
(declare-const var_h3118 T11135)
(declare-const v Int)
(declare-const var_h_i3091 T11135)
(declare-const var_h3090 T11135)
(declare-const v Int)
(declare-const var_h_i2922 T11135)
(declare-const var_h2921 T11135)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3130 T11135)
(declare-const var__temp_v3131 Int)
(declare-const |var__temp_h'3132| T11135)
(declare-const var__temp_v_err3133 T11136)
(declare-const var_h3118 T11135)
(declare-const var_h3090 T11135)
(declare-const var_h2921 T11135)
(declare-const err T11149)

solver 
 (declare-sort T11135)
(declare-fun sel (T11135 Int) Int)
(declare-fun res () Int)
(declare-fun var_h3118 () T11135)
(declare-fun other () Int)
(declare-fun var__temp_h3130 () T11135)
(declare-fun |var__temp_h'3132| () T11135)
(declare-fun var__temp_v3131 () Int)
(declare-fun v () Int)
(assert (= (sel var_h3118 res) 5))
(assert (let ((a!1 (and (= (sel var__temp_h3130 res) v)
                (= (sel var__temp_h3130 res) (+ (sel var_h3118 res) 2))
                (= (sel var__temp_h3130 other) (sel var_h3118 other))))
      (a!2 (and (= (sel |var__temp_h'3132| res) var__temp_v3131)
                (= (sel |var__temp_h'3132| res) (+ (sel var__temp_h3130 res) 3))
                (= (sel |var__temp_h'3132| other) (sel var__temp_h3130 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h3130 res) 7))
                (=> (= (sel var__temp_h3130 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************baz
PARTIAL PATH NEW
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --foo'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i3135 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3135 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3135, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3135, res ) ==((sel)( , var_h3134, res ) + (3))
 	 , (sel)( , var_h_i3135, other ) ==(sel)( , var_h3134, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3136:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3135 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************858
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3135 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3135, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3135, res ) ==((sel)( , var_h3134, res ) + (3))
 	 , (sel)( , var_h_i3135, other ) ==(sel)( , var_h3134, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3136:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3135 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3135 --->  Ty_heap  
 var_h3134 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i3119 --->  Ty_heap  
 var_h3118 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i3091 --->  Ty_heap  
 var_h3090 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3137 --->  Ty_heap  
 var__temp_v3138 --->  Ty_int  
 var__temp_h'3139 --->  Ty_heap  
 var__temp_v_err3140 --->  error  
 var_h3134 --->  Ty_heap  
 var_h3118 --->  Ty_heap  
 var_h3090 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h3134, res ) ==(7) AND 
 	 Rel (sel)( , var_h3118, res ) ==(5) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3137, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h3137, res ) ==((sel)( , var_h3134, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h3137, other ) ==(sel)( , var_h3134, other ) => 
 	 Rel (sel)( , var__temp_h3137, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3137, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3139, res ) ==(var__temp_v3138) AND 
 	 Rel (sel)( , var__temp_h'3139, res ) ==((sel)( , var__temp_h3137, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'3139, other ) ==(sel)( , var__temp_h3137, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3139, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'3139, other ) > (4)
 
VC_END(declare-const var_h_i3135 T11152)
(declare-const var_h3134 T11152)
(declare-const v Int)
(declare-const var_h_i3119 T11152)
(declare-const var_h3118 T11152)
(declare-const v Int)
(declare-const var_h_i3091 T11152)
(declare-const var_h3090 T11152)
(declare-const v Int)
(declare-const var_h_i2922 T11152)
(declare-const var_h2921 T11152)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3137 T11152)
(declare-const var__temp_v3138 Int)
(declare-const |var__temp_h'3139| T11152)
(declare-const var__temp_v_err3140 T11153)
(declare-const var_h3134 T11152)
(declare-const var_h3118 T11152)
(declare-const var_h3090 T11152)
(declare-const var_h2921 T11152)
(declare-const err T11166)

solver 
 (declare-sort T11152)
(declare-fun sel (T11152 Int) Int)
(declare-fun res () Int)
(declare-fun var_h3134 () T11152)
(declare-fun var_h3118 () T11152)
(declare-fun other () Int)
(declare-fun |var__temp_h'3139| () T11152)
(declare-fun var__temp_h3137 () T11152)
(declare-fun var__temp_v3138 () Int)
(declare-fun v () Int)
(assert (= (sel var_h3134 res) 7))
(assert (= (sel var_h3118 res) 5))
(assert (let ((a!1 (and (= (sel var__temp_h3137 res) v)
                (= (sel var__temp_h3137 res) (+ (sel var_h3134 res) 3))
                (= (sel var__temp_h3137 other) (sel var_h3134 other))))
      (a!2 (and (= (sel |var__temp_h'3139| res) var__temp_v3138)
                (= (sel |var__temp_h'3139| res) (+ (sel var__temp_h3137 res) 5))
                (= (sel |var__temp_h'3139| other) (sel var__temp_h3137 other))))
      (a!3 (and (= (sel |var__temp_h'3139| res) 10)
                (not (> (sel |var__temp_h'3139| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h3137 res) 7))
                (=> (= (sel var__temp_h3137 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************859
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v3136:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v3136:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbazbarfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --baz
 	 --bar
 	 --foo
 	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3135 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3135, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3135, res ) ==((sel)( , var_h3134, res ) + (3))
 	 , (sel)( , var_h_i3135, other ) ==(sel)( , var_h3134, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3141:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************860
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3135 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3135, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3135, res ) ==((sel)( , var_h3134, res ) + (3))
 	 , (sel)( , var_h_i3135, other ) ==(sel)( , var_h3134, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3141:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3135 --->  Ty_heap  
 var_h3134 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i3119 --->  Ty_heap  
 var_h3118 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i3091 --->  Ty_heap  
 var_h3090 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3142 --->  Ty_heap  
 var__temp_v3143 --->  Ty_int  
 var__temp_h'3144 --->  Ty_heap  
 var__temp_v_err3145 --->  error  
 var_h3134 --->  Ty_heap  
 var_h3118 --->  Ty_heap  
 var_h3090 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h3134, res ) ==(7) AND 
 	 Rel (sel)( , var_h3118, res ) ==(5) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3142, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h3142, res ) ==((sel)( , var_h3134, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h3142, other ) ==(sel)( , var_h3134, other ) => 
 	 Rel (sel)( , var__temp_h3142, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3142, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3144, res ) ==(var__temp_v3143) AND 
 	 Rel (sel)( , var__temp_h'3144, res ) ==((sel)( , var__temp_h3142, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'3144, other ) ==(sel)( , var__temp_h3142, other ) => 
 	 True
 
VC_END(declare-const var_h_i3135 T11169)
(declare-const var_h3134 T11169)
(declare-const v Int)
(declare-const var_h_i3119 T11169)
(declare-const var_h3118 T11169)
(declare-const v Int)
(declare-const var_h_i3091 T11169)
(declare-const var_h3090 T11169)
(declare-const v Int)
(declare-const var_h_i2922 T11169)
(declare-const var_h2921 T11169)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3142 T11169)
(declare-const var__temp_v3143 Int)
(declare-const |var__temp_h'3144| T11169)
(declare-const var__temp_v_err3145 T11170)
(declare-const var_h3134 T11169)
(declare-const var_h3118 T11169)
(declare-const var_h3090 T11169)
(declare-const var_h2921 T11169)
(declare-const err T11183)

solver 
 (declare-sort T11169)
(declare-fun sel (T11169 Int) Int)
(declare-fun res () Int)
(declare-fun var_h3134 () T11169)
(declare-fun var_h3118 () T11169)
(declare-fun other () Int)
(declare-fun var__temp_h3142 () T11169)
(declare-fun |var__temp_h'3144| () T11169)
(declare-fun var__temp_v3143 () Int)
(declare-fun v () Int)
(assert (= (sel var_h3134 res) 7))
(assert (= (sel var_h3118 res) 5))
(assert (let ((a!1 (and (= (sel var__temp_h3142 res) v)
                (= (sel var__temp_h3142 res) (+ (sel var_h3134 res) 3))
                (= (sel var__temp_h3142 other) (sel var_h3134 other))))
      (a!2 (and (= (sel |var__temp_h'3144| res) var__temp_v3143)
                (= (sel |var__temp_h'3144| res) (+ (sel var__temp_h3142 res) 5))
                (= (sel |var__temp_h'3144| other) (sel var__temp_h3142 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h3142 res) 7))
                (=> (= (sel var__temp_h3142 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************861
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT baz
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3119 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3119, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3119, res ) ==((sel)( , var_h3118, res ) + (2))
 	 , (sel)( , var_h_i3119, other ) ==(sel)( , var_h3118, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3146:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************862
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3119 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3119, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3119, res ) ==((sel)( , var_h3118, res ) + (2))
 	 , (sel)( , var_h_i3119, other ) ==(sel)( , var_h3118, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3146:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3119 --->  Ty_heap  
 var_h3118 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i3091 --->  Ty_heap  
 var_h3090 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3147 --->  Ty_heap  
 var__temp_v3148 --->  Ty_int  
 var__temp_h'3149 --->  Ty_heap  
 var__temp_v_err3150 --->  error  
 var_h3118 --->  Ty_heap  
 var_h3090 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h3118, res ) ==(5) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3147, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h3147, res ) ==((sel)( , var_h3118, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h3147, other ) ==(sel)( , var_h3118, other ) => 
 	 Rel (sel)( , var__temp_h3147, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3147, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3149, res ) ==(var__temp_v3148) AND 
 	 Rel (sel)( , var__temp_h'3149, res ) ==((sel)( , var__temp_h3147, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'3149, other ) ==(sel)( , var__temp_h3147, other ) => 
 	 True
 
VC_END(declare-const var_h_i3119 T11186)
(declare-const var_h3118 T11186)
(declare-const v Int)
(declare-const var_h_i3091 T11186)
(declare-const var_h3090 T11186)
(declare-const v Int)
(declare-const var_h_i2922 T11186)
(declare-const var_h2921 T11186)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3147 T11186)
(declare-const var__temp_v3148 Int)
(declare-const |var__temp_h'3149| T11186)
(declare-const var__temp_v_err3150 T11187)
(declare-const var_h3118 T11186)
(declare-const var_h3090 T11186)
(declare-const var_h2921 T11186)
(declare-const err T11200)

solver 
 (declare-sort T11186)
(declare-fun sel (T11186 Int) Int)
(declare-fun res () Int)
(declare-fun var_h3118 () T11186)
(declare-fun other () Int)
(declare-fun var__temp_h3147 () T11186)
(declare-fun |var__temp_h'3149| () T11186)
(declare-fun var__temp_v3148 () Int)
(declare-fun v () Int)
(assert (= (sel var_h3118 res) 5))
(assert (let ((a!1 (and (= (sel var__temp_h3147 res) v)
                (= (sel var__temp_h3147 res) (+ (sel var_h3118 res) 2))
                (= (sel var__temp_h3147 other) (sel var_h3118 other))))
      (a!2 (and (= (sel |var__temp_h'3149| res) var__temp_v3148)
                (= (sel |var__temp_h'3149| res) (+ (sel var__temp_h3147 res) 5))
                (= (sel |var__temp_h'3149| other) (sel var__temp_h3147 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h3147 res) 7))
                (=> (= (sel var__temp_h3147 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c5
PARTIAL PATH NEW
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --foo'
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i3152 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3152 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3152, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3152, res ) ==((sel)( , var_h3151, res ) + (5))
 	 , (sel)( , var_h_i3152, other ) ==(sel)( , var_h3151, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3153:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3152 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************863
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v3153:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v3153:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc5bazbarfooc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c5
 	 --bar
 	 --foo
 	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3152 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3152, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3152, res ) ==((sel)( , var_h3151, res ) + (5))
 	 , (sel)( , var_h_i3152, other ) ==(sel)( , var_h3151, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3154:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************864
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
 	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3119 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3119, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3119, res ) ==((sel)( , var_h3118, res ) + (2))
 	 , (sel)( , var_h_i3119, other ) ==(sel)( , var_h3118, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3155:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************865
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --foo
 	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3091 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3091, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i3091, other ) ==(sel)( , var_h3090, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3156:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************866
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3091 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3091, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i3091, other ) ==(sel)( , var_h3090, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3156:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3091 --->  Ty_heap  
 var_h3090 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3157 --->  Ty_heap  
 var__temp_v3158 --->  Ty_int  
 var__temp_h'3159 --->  Ty_heap  
 var__temp_v_err3160 --->  error  
 var_h3090 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3157, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h3157, other ) ==(sel)( , var_h3090, other ) => 
 	 Rel (sel)( , var__temp_h3157, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3157, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3159, res ) ==(var__temp_v3158) AND 
 	 Rel (sel)( , var__temp_h'3159, res ) ==((sel)( , var__temp_h3157, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'3159, other ) ==(sel)( , var__temp_h3157, other ) => 
 	 True
 
VC_END(declare-const var_h_i3091 T11203)
(declare-const var_h3090 T11203)
(declare-const v Int)
(declare-const var_h_i2922 T11203)
(declare-const var_h2921 T11203)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3157 T11203)
(declare-const var__temp_v3158 Int)
(declare-const |var__temp_h'3159| T11203)
(declare-const var__temp_v_err3160 T11204)
(declare-const var_h3090 T11203)
(declare-const var_h2921 T11203)
(declare-const err T11217)
    (declare-const |5| Int)
  
solver 
 (declare-sort T11203)
(declare-fun |5| () Int)
(declare-fun sel (T11203 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h3157 () T11203)
(declare-fun |var__temp_h'3159| () T11203)
(declare-fun res () Int)
(declare-fun var__temp_v3158 () Int)
(declare-fun var_h3090 () T11203)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3157 res) v)
                    (= v |5|)
                    (= (sel var__temp_h3157 other) (sel var_h3090 other)))
               (= (sel var__temp_h3157 res) 7)))
      (a!2 (and (= (sel |var__temp_h'3159| res) var__temp_v3158)
                (= (sel |var__temp_h'3159| res) (+ (sel var__temp_h3157 res) 3))
                (= (sel |var__temp_h'3159| other) (sel var__temp_h3157 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h3157 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************867
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3091 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3091, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i3091, other ) ==(sel)( , var_h3090, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3156:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3091 --->  Ty_heap  
 var_h3090 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3161 --->  Ty_heap  
 var__temp_v3162 --->  Ty_int  
 var__temp_h'3163 --->  Ty_heap  
 var__temp_v_err3164 --->  error  
 var_h3090 --->  Ty_heap  
 var_h2921 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3161, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h3161, other ) ==(sel)( , var_h3090, other ) => 
 	 Rel (sel)( , var__temp_h3161, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3161, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3163, res ) ==(var__temp_v3162) AND 
 	 Rel (sel)( , var__temp_h'3163, res ) ==((sel)( , var__temp_h3161, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'3163, other ) ==(sel)( , var__temp_h3161, other ) => 
 	 True
 
VC_END(declare-const var_h_i3091 T11220)
(declare-const var_h3090 T11220)
(declare-const v Int)
(declare-const var_h_i2922 T11220)
(declare-const var_h2921 T11220)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3161 T11220)
(declare-const var__temp_v3162 Int)
(declare-const |var__temp_h'3163| T11220)
(declare-const var__temp_v_err3164 T11221)
(declare-const var_h3090 T11220)
(declare-const var_h2921 T11220)
(declare-const err T11234)
    (declare-const |5| Int)
  
solver 
 (declare-sort T11220)
(declare-fun |5| () Int)
(declare-fun sel (T11220 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h3161 () T11220)
(declare-fun |var__temp_h'3163| () T11220)
(declare-fun res () Int)
(declare-fun var__temp_v3162 () Int)
(declare-fun var_h3090 () T11220)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3161 res) v)
                    (= v |5|)
                    (= (sel var__temp_h3161 other) (sel var_h3090 other)))
               (= (sel var__temp_h3161 res) 7)))
      (a!2 (and (= (sel |var__temp_h'3163| res) var__temp_v3162)
                (= (sel |var__temp_h'3163| res) (+ (sel var__temp_h3161 res) 5))
                (= (sel |var__temp_h'3163| other) (sel var__temp_h3161 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h3161 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************868
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT bar
PARTIAL PATH
SUB 
 	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2922 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2922, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2922, other ) ==(sel)( , var_h2921, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3165:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************869
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2922 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2922, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2922, other ) ==(sel)( , var_h2921, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3165:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3166 --->  Ty_heap  
 var__temp_v3167 --->  Ty_int  
 var__temp_h'3168 --->  Ty_heap  
 var__temp_v_err3169 --->  error  
 var_h2921 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3166, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h3166, other ) ==(sel)( , var_h2921, other ) => 
 	 Rel (sel)( , var__temp_h3166, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3166, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3168, res ) ==(var__temp_v3167) AND 
 	 Rel (sel)( , var__temp_h'3168, res ) ==((sel)( , var__temp_h3166, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'3168, other ) ==(sel)( , var__temp_h3166, other ) => 
 	 True
 
VC_END(declare-const var_h_i2922 T11237)
(declare-const var_h2921 T11237)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3166 T11237)
(declare-const var__temp_v3167 Int)
(declare-const |var__temp_h'3168| T11237)
(declare-const var__temp_v_err3169 T11238)
(declare-const var_h2921 T11237)
(declare-const err T11251)
    (declare-const |20| Int)
  
solver 
 (declare-sort T11237)
(declare-fun |20| () Int)
(declare-fun sel (T11237 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h3166 () T11237)
(declare-fun |var__temp_h'3168| () T11237)
(declare-fun res () Int)
(declare-fun var__temp_v3167 () Int)
(declare-fun var_h2921 () T11237)
(declare-fun v () Int)
(assert true)
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3166 res) v)
                    (= v |20|)
                    (= (sel var__temp_h3166 other) (sel var_h2921 other)))
               (= (sel var__temp_h3166 res) 7)))
      (a!2 (and (= (sel |var__temp_h'3168| res) var__temp_v3167)
                (= (sel |var__temp_h'3168| res) (+ (sel var__temp_h3166 res) 3))
                (= (sel |var__temp_h'3168| other) (sel var__temp_h3166 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h3166 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************870
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2922 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2922, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2922, other ) ==(sel)( , var_h2921, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3165:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3170 --->  Ty_heap  
 var__temp_v3171 --->  Ty_int  
 var__temp_h'3172 --->  Ty_heap  
 var__temp_v_err3173 --->  error  
 var_h2921 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3170, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h3170, other ) ==(sel)( , var_h2921, other ) => 
 	 Rel (sel)( , var__temp_h3170, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3170, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3172, res ) ==(var__temp_v3171) AND 
 	 Rel (sel)( , var__temp_h'3172, res ) ==((sel)( , var__temp_h3170, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'3172, other ) ==(sel)( , var__temp_h3170, other ) => 
 	 True
 
VC_END(declare-const var_h_i2922 T11254)
(declare-const var_h2921 T11254)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3170 T11254)
(declare-const var__temp_v3171 Int)
(declare-const |var__temp_h'3172| T11254)
(declare-const var__temp_v_err3173 T11255)
(declare-const var_h2921 T11254)
(declare-const err T11268)
    (declare-const |20| Int)
  
solver 
 (declare-sort T11254)
(declare-fun |20| () Int)
(declare-fun sel (T11254 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h3170 () T11254)
(declare-fun |var__temp_h'3172| () T11254)
(declare-fun res () Int)
(declare-fun var__temp_v3171 () Int)
(declare-fun var_h2921 () T11254)
(declare-fun v () Int)
(assert true)
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3170 res) v)
                    (= v |20|)
                    (= (sel var__temp_h3170 other) (sel var_h2921 other)))
               (= (sel var__temp_h3170 res) 7)))
      (a!2 (and (= (sel |var__temp_h'3172| res) var__temp_v3171)
                (= (sel |var__temp_h'3172| res) (+ (sel var__temp_h3170 res) 5))
                (= (sel |var__temp_h'3172| other) (sel var__temp_h3170 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h3170 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************871
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i2922 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i2922, res ) ==(v)
 	 , 
 Conj <c v = 20
 	 , (sel)( , var_h_i2922, other ) ==(sel)( , var_h2921, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3165:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i2922 --->  Ty_heap  
 var_h2921 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3174 --->  Ty_heap  
 var__temp_v3175 --->  Ty_int  
 var__temp_h'3176 --->  Ty_heap  
 var__temp_v_err3177 --->  error  
 var_h2921 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3174, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var__temp_h3174, other ) ==(sel)( , var_h2921, other ) => 
 	 Rel (sel)( , var__temp_h3174, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h3174, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3176, res ) ==(var__temp_v3175) AND 
 	 Rel (sel)( , var__temp_h'3176, res ) ==((sel)( , var__temp_h3174, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'3176, other ) ==(sel)( , var__temp_h3174, other ) => 
 	 True
 
VC_END(declare-const var_h_i2922 T11271)
(declare-const var_h2921 T11271)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3174 T11271)
(declare-const var__temp_v3175 Int)
(declare-const |var__temp_h'3176| T11271)
(declare-const var__temp_v_err3177 T11272)
(declare-const var_h2921 T11271)
(declare-const err T11285)
    (declare-const |20| Int)
  
solver 
 (declare-sort T11271)
(declare-fun |20| () Int)
(declare-fun sel (T11271 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h3174 () T11271)
(declare-fun |var__temp_h'3176| () T11271)
(declare-fun res () Int)
(declare-fun var__temp_v3175 () Int)
(declare-fun var_h2921 () T11271)
(declare-fun v () Int)
(assert true)
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3174 res) v)
                    (= v |20|)
                    (= (sel var__temp_h3174 other) (sel var_h2921 other)))
               (= (sel var__temp_h3174 res) 5)))
      (a!2 (and (= (sel |var__temp_h'3176| res) var__temp_v3175)
                (= (sel |var__temp_h'3176| res) (+ (sel var__temp_h3174 res) 2))
                (= (sel |var__temp_h'3176| other) (sel var__temp_h3174 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h3174 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************872
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo
PARTIAL PATH
SUB 
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {var_v3178:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
foo
bar
 *********************Enumeration Iteration*****************873
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {var_v3178:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3179 --->  Ty_heap  
 var__temp_v3180 --->  Ty_int  
 var__temp_h'3181 --->  Ty_heap  
 var__temp_v_err3182 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3179, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h3179, other ) ==(0) => 
 	 Rel (sel)( , var__temp_h3179, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3179, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3181, res ) ==(var__temp_v3180) AND 
 	 Rel (sel)( , var__temp_h'3181, res ) ==((sel)( , var__temp_h3179, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'3181, other ) ==(sel)( , var__temp_h3179, other ) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3179 T11288)
(declare-const var__temp_v3180 Int)
(declare-const |var__temp_h'3181| T11288)
(declare-const var__temp_v_err3182 T11289)
(declare-const err T11302)

solver 
 (declare-sort T11288)
(declare-fun sel (T11288 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h3179 () T11288)
(declare-fun |var__temp_h'3181| () T11288)
(declare-fun res () Int)
(declare-fun var__temp_v3180 () Int)
(assert true)
(assert (let ((a!1 (=> (and (= (sel var__temp_h3179 res) 0)
                    (= (sel var__temp_h3179 other) 0))
               (= (sel var__temp_h3179 res) 7)))
      (a!2 (and (= (sel |var__temp_h'3181| res) var__temp_v3180)
                (= (sel |var__temp_h'3181| res) (+ (sel var__temp_h3179 res) 3))
                (= (sel |var__temp_h'3181| other) (sel var__temp_h3179 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h3179 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************874
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {var_v3178:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3183 --->  Ty_heap  
 var__temp_v3184 --->  Ty_int  
 var__temp_h'3185 --->  Ty_heap  
 var__temp_v_err3186 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3183, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h3183, other ) ==(0) => 
 	 Rel (sel)( , var__temp_h3183, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3183, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3185, res ) ==(var__temp_v3184) AND 
 	 Rel (sel)( , var__temp_h'3185, res ) ==((sel)( , var__temp_h3183, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'3185, other ) ==(sel)( , var__temp_h3183, other ) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3183 T11305)
(declare-const var__temp_v3184 Int)
(declare-const |var__temp_h'3185| T11305)
(declare-const var__temp_v_err3186 T11306)
(declare-const err T11319)

solver 
 (declare-sort T11305)
(declare-fun sel (T11305 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h3183 () T11305)
(declare-fun |var__temp_h'3185| () T11305)
(declare-fun res () Int)
(declare-fun var__temp_v3184 () Int)
(assert true)
(assert (let ((a!1 (=> (and (= (sel var__temp_h3183 res) 0)
                    (= (sel var__temp_h3183 other) 0))
               (= (sel var__temp_h3183 res) 7)))
      (a!2 (and (= (sel |var__temp_h'3185| res) var__temp_v3184)
                (= (sel |var__temp_h'3185| res) (+ (sel var__temp_h3183 res) 5))
                (= (sel |var__temp_h'3185| other) (sel var__temp_h3183 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h3183 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************875
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {var_v3178:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3187 --->  Ty_heap  
 var__temp_v3188 --->  Ty_int  
 var__temp_h'3189 --->  Ty_heap  
 var__temp_v_err3190 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3187, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h3187, other ) ==(0) => 
 	 Rel (sel)( , var__temp_h3187, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h3187, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3189, res ) ==(var__temp_v3188) AND 
 	 Rel (sel)( , var__temp_h'3189, res ) ==((sel)( , var__temp_h3187, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'3189, other ) ==(sel)( , var__temp_h3187, other ) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3187 T11322)
(declare-const var__temp_v3188 Int)
(declare-const |var__temp_h'3189| T11322)
(declare-const var__temp_v_err3190 T11323)
(declare-const err T11336)

solver 
 (declare-sort T11322)
(declare-fun sel (T11322 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h3187 () T11322)
(declare-fun |var__temp_h'3189| () T11322)
(declare-fun res () Int)
(declare-fun var__temp_v3188 () Int)
(assert true)
(assert (let ((a!1 (=> (and (= (sel var__temp_h3187 res) 0)
                    (= (sel var__temp_h3187 other) 0))
               (> (sel var__temp_h3187 res) 4)))
      (a!2 (and (= (sel |var__temp_h'3189| res) var__temp_v3188)
                (= (sel |var__temp_h'3189| res)
                   (+ (sel var__temp_h3187 res) 10))
                (= (sel |var__temp_h'3189| other) (sel var__temp_h3187 other)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h3187 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************876
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {var_v3178:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3191 --->  Ty_heap  
 var__temp_v3192 --->  Ty_int  
 var__temp_h'3193 --->  Ty_heap  
 var__temp_v_err3194 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3191, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h3191, other ) ==(0) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3193, res ) ==(var__temp_v3192) AND 
 	 Base var__temp_v3192 = 5 AND 
 	 Rel (sel)( , var__temp_h'3193, other ) ==(sel)( , var__temp_h3191, other ) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3191 T11339)
(declare-const var__temp_v3192 Int)
(declare-const |var__temp_h'3193| T11339)
(declare-const var__temp_v_err3194 T11340)
(declare-const err T11353)
    (declare-const |5| Int)
  
solver 
 (declare-sort T11339)
(declare-fun |5| () Int)
(declare-fun sel (T11339 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h3191 () T11339)
(declare-fun |var__temp_h'3193| () T11339)
(declare-fun var__temp_v3192 () Int)
(declare-fun res () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3191 res) 0)
                    (= (sel var__temp_h3191 other) 0))
               true))
      (a!2 (=> (and (= (sel |var__temp_h'3193| res) var__temp_v3192)
                    (= var__temp_v3192 |5|)
                    (= (sel |var__temp_h'3193| other)
                       (sel var__temp_h3191 other)))
               true)))
  (not (and a!1 (=> true a!2)))))

***************Selection Successful************foo
PARTIAL PATH NEW
SUB 
 	 --foo
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i3196 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3196 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3196, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i3196, other ) ==(sel)( , var_h3195, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3197:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3196 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
bar
 *********************Enumeration Iteration*****************877
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3196 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3196, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i3196, other ) ==(sel)( , var_h3195, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3197:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3196 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3196 --->  Ty_heap  
 var_h3195 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3198 --->  Ty_heap  
 var__temp_v3199 --->  Ty_int  
 var__temp_h'3200 --->  Ty_heap  
 var__temp_v_err3201 --->  error  
 var_h3195 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3198, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h3198, other ) ==(sel)( , var_h3195, other ) => 
 	 Rel (sel)( , var__temp_h3198, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3198, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3200, res ) ==(var__temp_v3199) AND 
 	 Rel (sel)( , var__temp_h'3200, res ) ==((sel)( , var__temp_h3198, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'3200, other ) ==(sel)( , var__temp_h3198, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3200, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'3200, other ) > (4)
 
VC_END(declare-const var_h_i3196 T11356)
(declare-const var_h3195 T11356)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3198 T11356)
(declare-const var__temp_v3199 Int)
(declare-const |var__temp_h'3200| T11356)
(declare-const var__temp_v_err3201 T11357)
(declare-const var_h3195 T11356)
(declare-const err T11370)
    (declare-const |5| Int)
  
solver 
 (declare-sort T11356)
(declare-fun |5| () Int)
(declare-fun sel (T11356 Int) Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'3200| () T11356)
(declare-fun res () Int)
(declare-fun var__temp_h3198 () T11356)
(declare-fun var__temp_v3199 () Int)
(declare-fun var_h3195 () T11356)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3198 res) v)
                    (= v |5|)
                    (= (sel var__temp_h3198 other) (sel var_h3195 other)))
               (= (sel var__temp_h3198 res) 7)))
      (a!2 (and (= (sel |var__temp_h'3200| res) var__temp_v3199)
                (= (sel |var__temp_h'3200| res) (+ (sel var__temp_h3198 res) 3))
                (= (sel |var__temp_h'3200| other) (sel var__temp_h3198 other))))
      (a!3 (and (= (sel |var__temp_h'3200| res) 10)
                (not (> (sel |var__temp_h'3200| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h3198 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************878
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3196 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3196, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i3196, other ) ==(sel)( , var_h3195, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3197:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3196 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3196 --->  Ty_heap  
 var_h3195 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3202 --->  Ty_heap  
 var__temp_v3203 --->  Ty_int  
 var__temp_h'3204 --->  Ty_heap  
 var__temp_v_err3205 --->  error  
 var_h3195 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3202, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h3202, other ) ==(sel)( , var_h3195, other ) => 
 	 Rel (sel)( , var__temp_h3202, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3202, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3204, res ) ==(var__temp_v3203) AND 
 	 Rel (sel)( , var__temp_h'3204, res ) ==((sel)( , var__temp_h3202, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'3204, other ) ==(sel)( , var__temp_h3202, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3204, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'3204, other ) > (4)
 
VC_END(declare-const var_h_i3196 T11373)
(declare-const var_h3195 T11373)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3202 T11373)
(declare-const var__temp_v3203 Int)
(declare-const |var__temp_h'3204| T11373)
(declare-const var__temp_v_err3205 T11374)
(declare-const var_h3195 T11373)
(declare-const err T11387)
    (declare-const |5| Int)
  
solver 
 (declare-sort T11373)
(declare-fun |5| () Int)
(declare-fun sel (T11373 Int) Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'3204| () T11373)
(declare-fun res () Int)
(declare-fun var__temp_h3202 () T11373)
(declare-fun var__temp_v3203 () Int)
(declare-fun var_h3195 () T11373)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3202 res) v)
                    (= v |5|)
                    (= (sel var__temp_h3202 other) (sel var_h3195 other)))
               (= (sel var__temp_h3202 res) 7)))
      (a!2 (and (= (sel |var__temp_h'3204| res) var__temp_v3203)
                (= (sel |var__temp_h'3204| res) (+ (sel var__temp_h3202 res) 5))
                (= (sel |var__temp_h'3204| other) (sel var__temp_h3202 other))))
      (a!3 (and (= (sel |var__temp_h'3204| res) 10)
                (not (> (sel |var__temp_h'3204| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h3202 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************879
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3196 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3196, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i3196, other ) ==(sel)( , var_h3195, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3197:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3196 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3196 --->  Ty_heap  
 var_h3195 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3206 --->  Ty_heap  
 var__temp_v3207 --->  Ty_int  
 var__temp_h'3208 --->  Ty_heap  
 var__temp_v_err3209 --->  error  
 var_h3195 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3206, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h3206, other ) ==(sel)( , var_h3195, other ) => 
 	 Rel (sel)( , var__temp_h3206, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h3206, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3208, res ) ==(var__temp_v3207) AND 
 	 Rel (sel)( , var__temp_h'3208, res ) ==((sel)( , var__temp_h3206, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'3208, other ) ==(sel)( , var__temp_h3206, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3208, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'3208, other ) > (4)
 
VC_END(declare-const var_h_i3196 T11390)
(declare-const var_h3195 T11390)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3206 T11390)
(declare-const var__temp_v3207 Int)
(declare-const |var__temp_h'3208| T11390)
(declare-const var__temp_v_err3209 T11391)
(declare-const var_h3195 T11390)
(declare-const err T11404)
    (declare-const |5| Int)
  
solver 
 (declare-sort T11390)
(declare-fun |5| () Int)
(declare-fun sel (T11390 Int) Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'3208| () T11390)
(declare-fun res () Int)
(declare-fun var__temp_h3206 () T11390)
(declare-fun var__temp_v3207 () Int)
(declare-fun var_h3195 () T11390)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3206 res) v)
                    (= v |5|)
                    (= (sel var__temp_h3206 other) (sel var_h3195 other)))
               (> (sel var__temp_h3206 res) 4)))
      (a!2 (and (= (sel |var__temp_h'3208| res) var__temp_v3207)
                (= (sel |var__temp_h'3208| res)
                   (+ (sel var__temp_h3206 res) 10))
                (= (sel |var__temp_h'3208| other) (sel var__temp_h3206 other))))
      (a!3 (and (= (sel |var__temp_h'3208| res) 10)
                (not (> (sel |var__temp_h'3208| other) 4)))))
(let ((a!4 (and a!1 (=> (> (sel var__temp_h3206 res) 4) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************880
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3196 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3196, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i3196, other ) ==(sel)( , var_h3195, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3197:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3196 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3196 --->  Ty_heap  
 var_h3195 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3210 --->  Ty_heap  
 var__temp_v3211 --->  Ty_int  
 var__temp_h'3212 --->  Ty_heap  
 var__temp_v_err3213 --->  error  
 var_h3195 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3210, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h3210, other ) ==(sel)( , var_h3195, other ) => 
 	 Rel (sel)( , var__temp_h3210, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h3210, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3212, res ) ==(var__temp_v3211) AND 
 	 Rel (sel)( , var__temp_h'3212, res ) ==((sel)( , var__temp_h3210, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'3212, other ) ==(sel)( , var__temp_h3210, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3212, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'3212, other ) > (4)
 
VC_END(declare-const var_h_i3196 T11407)
(declare-const var_h3195 T11407)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3210 T11407)
(declare-const var__temp_v3211 Int)
(declare-const |var__temp_h'3212| T11407)
(declare-const var__temp_v_err3213 T11408)
(declare-const var_h3195 T11407)
(declare-const err T11421)
    (declare-const |5| Int)
  
solver 
 (declare-sort T11407)
(declare-fun |5| () Int)
(declare-fun sel (T11407 Int) Int)
(declare-fun other () Int)
(declare-fun |var__temp_h'3212| () T11407)
(declare-fun res () Int)
(declare-fun var__temp_h3210 () T11407)
(declare-fun var__temp_v3211 () Int)
(declare-fun var_h3195 () T11407)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3210 res) v)
                    (= v |5|)
                    (= (sel var__temp_h3210 other) (sel var_h3195 other)))
               (= (sel var__temp_h3210 res) 5)))
      (a!2 (and (= (sel |var__temp_h'3212| res) var__temp_v3211)
                (= (sel |var__temp_h'3212| res) (+ (sel var__temp_h3210 res) 2))
                (= (sel |var__temp_h'3212| other) (sel var__temp_h3210 other))))
      (a!3 (and (= (sel |var__temp_h'3212| res) 10)
                (not (> (sel |var__temp_h'3212| other) 4)))))
(let ((a!4 (and a!1 (=> (= (sel var__temp_h3210 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************881
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v3197:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v3197:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfoofoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --foo
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3196 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3196, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i3196, other ) ==(sel)( , var_h3195, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3214:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
bar
 *********************Enumeration Iteration*****************882
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3196 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3196, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i3196, other ) ==(sel)( , var_h3195, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3214:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3196 --->  Ty_heap  
 var_h3195 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3215 --->  Ty_heap  
 var__temp_v3216 --->  Ty_int  
 var__temp_h'3217 --->  Ty_heap  
 var__temp_v_err3218 --->  error  
 var_h3195 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3215, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h3215, other ) ==(sel)( , var_h3195, other ) => 
 	 Rel (sel)( , var__temp_h3215, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3215, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3217, res ) ==(var__temp_v3216) AND 
 	 Rel (sel)( , var__temp_h'3217, res ) ==((sel)( , var__temp_h3215, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'3217, other ) ==(sel)( , var__temp_h3215, other ) => 
 	 True
 
VC_END(declare-const var_h_i3196 T11424)
(declare-const var_h3195 T11424)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3215 T11424)
(declare-const var__temp_v3216 Int)
(declare-const |var__temp_h'3217| T11424)
(declare-const var__temp_v_err3218 T11425)
(declare-const var_h3195 T11424)
(declare-const err T11438)
    (declare-const |5| Int)
  
solver 
 (declare-sort T11424)
(declare-fun |5| () Int)
(declare-fun sel (T11424 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h3215 () T11424)
(declare-fun |var__temp_h'3217| () T11424)
(declare-fun res () Int)
(declare-fun var__temp_v3216 () Int)
(declare-fun var_h3195 () T11424)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3215 res) v)
                    (= v |5|)
                    (= (sel var__temp_h3215 other) (sel var_h3195 other)))
               (= (sel var__temp_h3215 res) 7)))
      (a!2 (and (= (sel |var__temp_h'3217| res) var__temp_v3216)
                (= (sel |var__temp_h'3217| res) (+ (sel var__temp_h3215 res) 3))
                (= (sel |var__temp_h'3217| other) (sel var__temp_h3215 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h3215 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************883
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3196 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3196, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i3196, other ) ==(sel)( , var_h3195, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3214:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3196 --->  Ty_heap  
 var_h3195 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3219 --->  Ty_heap  
 var__temp_v3220 --->  Ty_int  
 var__temp_h'3221 --->  Ty_heap  
 var__temp_v_err3222 --->  error  
 var_h3195 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3219, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h3219, other ) ==(sel)( , var_h3195, other ) => 
 	 Rel (sel)( , var__temp_h3219, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3219, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3221, res ) ==(var__temp_v3220) AND 
 	 Rel (sel)( , var__temp_h'3221, res ) ==((sel)( , var__temp_h3219, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'3221, other ) ==(sel)( , var__temp_h3219, other ) => 
 	 True
 
VC_END(declare-const var_h_i3196 T11441)
(declare-const var_h3195 T11441)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3219 T11441)
(declare-const var__temp_v3220 Int)
(declare-const |var__temp_h'3221| T11441)
(declare-const var__temp_v_err3222 T11442)
(declare-const var_h3195 T11441)
(declare-const err T11455)
    (declare-const |5| Int)
  
solver 
 (declare-sort T11441)
(declare-fun |5| () Int)
(declare-fun sel (T11441 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h3219 () T11441)
(declare-fun |var__temp_h'3221| () T11441)
(declare-fun res () Int)
(declare-fun var__temp_v3220 () Int)
(declare-fun var_h3195 () T11441)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3219 res) v)
                    (= v |5|)
                    (= (sel var__temp_h3219 other) (sel var_h3195 other)))
               (= (sel var__temp_h3219 res) 7)))
      (a!2 (and (= (sel |var__temp_h'3221| res) var__temp_v3220)
                (= (sel |var__temp_h'3221| res) (+ (sel var__temp_h3219 res) 5))
                (= (sel |var__temp_h'3221| other) (sel var__temp_h3219 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h3219 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************884
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3196 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3196, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i3196, other ) ==(sel)( , var_h3195, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3214:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3196 --->  Ty_heap  
 var_h3195 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3223 --->  Ty_heap  
 var__temp_v3224 --->  Ty_int  
 var__temp_h'3225 --->  Ty_heap  
 var__temp_v_err3226 --->  error  
 var_h3195 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3223, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h3223, other ) ==(sel)( , var_h3195, other ) => 
 	 Rel (sel)( , var__temp_h3223, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h3223, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3225, res ) ==(var__temp_v3224) AND 
 	 Rel (sel)( , var__temp_h'3225, res ) ==((sel)( , var__temp_h3223, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'3225, other ) ==(sel)( , var__temp_h3223, other ) => 
 	 True
 
VC_END(declare-const var_h_i3196 T11458)
(declare-const var_h3195 T11458)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3223 T11458)
(declare-const var__temp_v3224 Int)
(declare-const |var__temp_h'3225| T11458)
(declare-const var__temp_v_err3226 T11459)
(declare-const var_h3195 T11458)
(declare-const err T11472)
    (declare-const |5| Int)
  
solver 
 (declare-sort T11458)
(declare-fun |5| () Int)
(declare-fun sel (T11458 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h3223 () T11458)
(declare-fun |var__temp_h'3225| () T11458)
(declare-fun res () Int)
(declare-fun var__temp_v3224 () Int)
(declare-fun var_h3195 () T11458)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3223 res) v)
                    (= v |5|)
                    (= (sel var__temp_h3223 other) (sel var_h3195 other)))
               (> (sel var__temp_h3223 res) 4)))
      (a!2 (and (= (sel |var__temp_h'3225| res) var__temp_v3224)
                (= (sel |var__temp_h'3225| res)
                   (+ (sel var__temp_h3223 res) 10))
                (= (sel |var__temp_h'3225| other) (sel var__temp_h3223 other)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h3223 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c2
PARTIAL PATH NEW
SUB 
 	 --c2
 	 --foo
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i3228 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3228 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3228, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3228, res ) ==((sel)( , var_h3227, res ) + (10))
 	 , (sel)( , var_h_i3228, other ) ==(sel)( , var_h3227, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3229:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3228 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************885
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3228 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3228, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3228, res ) ==((sel)( , var_h3227, res ) + (10))
 	 , (sel)( , var_h_i3228, other ) ==(sel)( , var_h3227, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3229:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3228 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3228 --->  Ty_heap  
 var_h3227 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i3196 --->  Ty_heap  
 var_h3195 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3230 --->  Ty_heap  
 var__temp_v3231 --->  Ty_int  
 var__temp_h'3232 --->  Ty_heap  
 var__temp_v_err3233 --->  error  
 var_h3227 --->  Ty_heap  
 var_h3195 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h3227, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3230, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h3230, res ) ==((sel)( , var_h3227, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h3230, other ) ==(sel)( , var_h3227, other ) => 
 	 Rel (sel)( , var__temp_h3230, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3230, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3232, res ) ==(var__temp_v3231) AND 
 	 Rel (sel)( , var__temp_h'3232, res ) ==((sel)( , var__temp_h3230, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'3232, other ) ==(sel)( , var__temp_h3230, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3232, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'3232, other ) > (4)
 
VC_END(declare-const var_h_i3228 T11475)
(declare-const var_h3227 T11475)
(declare-const v Int)
(declare-const var_h_i3196 T11475)
(declare-const var_h3195 T11475)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3230 T11475)
(declare-const var__temp_v3231 Int)
(declare-const |var__temp_h'3232| T11475)
(declare-const var__temp_v_err3233 T11476)
(declare-const var_h3227 T11475)
(declare-const var_h3195 T11475)
(declare-const err T11489)

solver 
 (declare-sort T11475)
(declare-fun sel (T11475 Int) Int)
(declare-fun res () Int)
(declare-fun var_h3227 () T11475)
(declare-fun other () Int)
(declare-fun |var__temp_h'3232| () T11475)
(declare-fun var__temp_h3230 () T11475)
(declare-fun var__temp_v3231 () Int)
(declare-fun v () Int)
(assert (> (sel var_h3227 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h3230 res) v)
                (= (sel var__temp_h3230 res) (+ (sel var_h3227 res) 10))
                (= (sel var__temp_h3230 other) (sel var_h3227 other))))
      (a!2 (and (= (sel |var__temp_h'3232| res) var__temp_v3231)
                (= (sel |var__temp_h'3232| res) (+ (sel var__temp_h3230 res) 3))
                (= (sel |var__temp_h'3232| other) (sel var__temp_h3230 other))))
      (a!3 (and (= (sel |var__temp_h'3232| res) 10)
                (not (> (sel |var__temp_h'3232| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h3230 res) 7))
                (=> (= (sel var__temp_h3230 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************886
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3228 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3228, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3228, res ) ==((sel)( , var_h3227, res ) + (10))
 	 , (sel)( , var_h_i3228, other ) ==(sel)( , var_h3227, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3229:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3228 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3228 --->  Ty_heap  
 var_h3227 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i3196 --->  Ty_heap  
 var_h3195 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3234 --->  Ty_heap  
 var__temp_v3235 --->  Ty_int  
 var__temp_h'3236 --->  Ty_heap  
 var__temp_v_err3237 --->  error  
 var_h3227 --->  Ty_heap  
 var_h3195 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h3227, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3234, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h3234, res ) ==((sel)( , var_h3227, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h3234, other ) ==(sel)( , var_h3227, other ) => 
 	 Rel (sel)( , var__temp_h3234, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3234, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3236, res ) ==(var__temp_v3235) AND 
 	 Rel (sel)( , var__temp_h'3236, res ) ==((sel)( , var__temp_h3234, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'3236, other ) ==(sel)( , var__temp_h3234, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3236, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'3236, other ) > (4)
 
VC_END(declare-const var_h_i3228 T11492)
(declare-const var_h3227 T11492)
(declare-const v Int)
(declare-const var_h_i3196 T11492)
(declare-const var_h3195 T11492)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3234 T11492)
(declare-const var__temp_v3235 Int)
(declare-const |var__temp_h'3236| T11492)
(declare-const var__temp_v_err3237 T11493)
(declare-const var_h3227 T11492)
(declare-const var_h3195 T11492)
(declare-const err T11506)

solver 
 (declare-sort T11492)
(declare-fun sel (T11492 Int) Int)
(declare-fun res () Int)
(declare-fun var_h3227 () T11492)
(declare-fun other () Int)
(declare-fun |var__temp_h'3236| () T11492)
(declare-fun var__temp_h3234 () T11492)
(declare-fun var__temp_v3235 () Int)
(declare-fun v () Int)
(assert (> (sel var_h3227 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h3234 res) v)
                (= (sel var__temp_h3234 res) (+ (sel var_h3227 res) 10))
                (= (sel var__temp_h3234 other) (sel var_h3227 other))))
      (a!2 (and (= (sel |var__temp_h'3236| res) var__temp_v3235)
                (= (sel |var__temp_h'3236| res) (+ (sel var__temp_h3234 res) 5))
                (= (sel |var__temp_h'3236| other) (sel var__temp_h3234 other))))
      (a!3 (and (= (sel |var__temp_h'3236| res) 10)
                (not (> (sel |var__temp_h'3236| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h3234 res) 7))
                (=> (= (sel var__temp_h3234 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************887
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3228 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3228, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3228, res ) ==((sel)( , var_h3227, res ) + (10))
 	 , (sel)( , var_h_i3228, other ) ==(sel)( , var_h3227, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3229:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3228 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3228 --->  Ty_heap  
 var_h3227 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i3196 --->  Ty_heap  
 var_h3195 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3238 --->  Ty_heap  
 var__temp_v3239 --->  Ty_int  
 var__temp_h'3240 --->  Ty_heap  
 var__temp_v_err3241 --->  error  
 var_h3227 --->  Ty_heap  
 var_h3195 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h3227, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3238, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h3238, res ) ==((sel)( , var_h3227, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h3238, other ) ==(sel)( , var_h3227, other ) => 
 	 Rel (sel)( , var__temp_h3238, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h3238, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3240, res ) ==(var__temp_v3239) AND 
 	 Rel (sel)( , var__temp_h'3240, res ) ==((sel)( , var__temp_h3238, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'3240, other ) ==(sel)( , var__temp_h3238, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3240, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'3240, other ) > (4)
 
VC_END(declare-const var_h_i3228 T11509)
(declare-const var_h3227 T11509)
(declare-const v Int)
(declare-const var_h_i3196 T11509)
(declare-const var_h3195 T11509)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3238 T11509)
(declare-const var__temp_v3239 Int)
(declare-const |var__temp_h'3240| T11509)
(declare-const var__temp_v_err3241 T11510)
(declare-const var_h3227 T11509)
(declare-const var_h3195 T11509)
(declare-const err T11523)

solver 
 (declare-sort T11509)
(declare-fun sel (T11509 Int) Int)
(declare-fun res () Int)
(declare-fun var_h3227 () T11509)
(declare-fun other () Int)
(declare-fun |var__temp_h'3240| () T11509)
(declare-fun var__temp_h3238 () T11509)
(declare-fun var__temp_v3239 () Int)
(declare-fun v () Int)
(assert (> (sel var_h3227 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h3238 res) v)
                (= (sel var__temp_h3238 res) (+ (sel var_h3227 res) 10))
                (= (sel var__temp_h3238 other) (sel var_h3227 other))))
      (a!2 (and (= (sel |var__temp_h'3240| res) var__temp_v3239)
                (= (sel |var__temp_h'3240| res) (+ (sel var__temp_h3238 res) 2))
                (= (sel |var__temp_h'3240| other) (sel var__temp_h3238 other))))
      (a!3 (and (= (sel |var__temp_h'3240| res) 10)
                (not (> (sel |var__temp_h'3240| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h3238 res) 5))
                (=> (= (sel var__temp_h3238 res) 5) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************888
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v3229:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v3229:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2foofoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c2
 	 --foo
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3228 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3228, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3228, res ) ==((sel)( , var_h3227, res ) + (10))
 	 , (sel)( , var_h_i3228, other ) ==(sel)( , var_h3227, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3242:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************889
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3228 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3228, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3228, res ) ==((sel)( , var_h3227, res ) + (10))
 	 , (sel)( , var_h_i3228, other ) ==(sel)( , var_h3227, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3242:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3228 --->  Ty_heap  
 var_h3227 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i3196 --->  Ty_heap  
 var_h3195 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3243 --->  Ty_heap  
 var__temp_v3244 --->  Ty_int  
 var__temp_h'3245 --->  Ty_heap  
 var__temp_v_err3246 --->  error  
 var_h3227 --->  Ty_heap  
 var_h3195 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h3227, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3243, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h3243, res ) ==((sel)( , var_h3227, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h3243, other ) ==(sel)( , var_h3227, other ) => 
 	 Rel (sel)( , var__temp_h3243, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3243, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3245, res ) ==(var__temp_v3244) AND 
 	 Rel (sel)( , var__temp_h'3245, res ) ==((sel)( , var__temp_h3243, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'3245, other ) ==(sel)( , var__temp_h3243, other ) => 
 	 True
 
VC_END(declare-const var_h_i3228 T11526)
(declare-const var_h3227 T11526)
(declare-const v Int)
(declare-const var_h_i3196 T11526)
(declare-const var_h3195 T11526)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3243 T11526)
(declare-const var__temp_v3244 Int)
(declare-const |var__temp_h'3245| T11526)
(declare-const var__temp_v_err3246 T11527)
(declare-const var_h3227 T11526)
(declare-const var_h3195 T11526)
(declare-const err T11540)

solver 
 (declare-sort T11526)
(declare-fun sel (T11526 Int) Int)
(declare-fun res () Int)
(declare-fun var_h3227 () T11526)
(declare-fun other () Int)
(declare-fun var__temp_h3243 () T11526)
(declare-fun |var__temp_h'3245| () T11526)
(declare-fun var__temp_v3244 () Int)
(declare-fun v () Int)
(assert (> (sel var_h3227 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h3243 res) v)
                (= (sel var__temp_h3243 res) (+ (sel var_h3227 res) 10))
                (= (sel var__temp_h3243 other) (sel var_h3227 other))))
      (a!2 (and (= (sel |var__temp_h'3245| res) var__temp_v3244)
                (= (sel |var__temp_h'3245| res) (+ (sel var__temp_h3243 res) 3))
                (= (sel |var__temp_h'3245| other) (sel var__temp_h3243 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h3243 res) 7))
                (=> (= (sel var__temp_h3243 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************890
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3228 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3228, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3228, res ) ==((sel)( , var_h3227, res ) + (10))
 	 , (sel)( , var_h_i3228, other ) ==(sel)( , var_h3227, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3242:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3228 --->  Ty_heap  
 var_h3227 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i3196 --->  Ty_heap  
 var_h3195 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3247 --->  Ty_heap  
 var__temp_v3248 --->  Ty_int  
 var__temp_h'3249 --->  Ty_heap  
 var__temp_v_err3250 --->  error  
 var_h3227 --->  Ty_heap  
 var_h3195 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h3227, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3247, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h3247, res ) ==((sel)( , var_h3227, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h3247, other ) ==(sel)( , var_h3227, other ) => 
 	 Rel (sel)( , var__temp_h3247, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3247, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3249, res ) ==(var__temp_v3248) AND 
 	 Rel (sel)( , var__temp_h'3249, res ) ==((sel)( , var__temp_h3247, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'3249, other ) ==(sel)( , var__temp_h3247, other ) => 
 	 True
 
VC_END(declare-const var_h_i3228 T11543)
(declare-const var_h3227 T11543)
(declare-const v Int)
(declare-const var_h_i3196 T11543)
(declare-const var_h3195 T11543)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3247 T11543)
(declare-const var__temp_v3248 Int)
(declare-const |var__temp_h'3249| T11543)
(declare-const var__temp_v_err3250 T11544)
(declare-const var_h3227 T11543)
(declare-const var_h3195 T11543)
(declare-const err T11557)

solver 
 (declare-sort T11543)
(declare-fun sel (T11543 Int) Int)
(declare-fun res () Int)
(declare-fun var_h3227 () T11543)
(declare-fun other () Int)
(declare-fun var__temp_h3247 () T11543)
(declare-fun |var__temp_h'3249| () T11543)
(declare-fun var__temp_v3248 () Int)
(declare-fun v () Int)
(assert (> (sel var_h3227 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h3247 res) v)
                (= (sel var__temp_h3247 res) (+ (sel var_h3227 res) 10))
                (= (sel var__temp_h3247 other) (sel var_h3227 other))))
      (a!2 (and (= (sel |var__temp_h'3249| res) var__temp_v3248)
                (= (sel |var__temp_h'3249| res) (+ (sel var__temp_h3247 res) 5))
                (= (sel |var__temp_h'3249| other) (sel var__temp_h3247 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h3247 res) 7))
                (=> (= (sel var__temp_h3247 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************891
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3228 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3228, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3228, res ) ==((sel)( , var_h3227, res ) + (10))
 	 , (sel)( , var_h_i3228, other ) ==(sel)( , var_h3227, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3242:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3228 --->  Ty_heap  
 var_h3227 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i3196 --->  Ty_heap  
 var_h3195 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3251 --->  Ty_heap  
 var__temp_v3252 --->  Ty_int  
 var__temp_h'3253 --->  Ty_heap  
 var__temp_v_err3254 --->  error  
 var_h3227 --->  Ty_heap  
 var_h3195 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h3227, res ) > (4) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3251, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h3251, res ) ==((sel)( , var_h3227, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h3251, other ) ==(sel)( , var_h3227, other ) => 
 	 Rel (sel)( , var__temp_h3251, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h3251, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3253, res ) ==(var__temp_v3252) AND 
 	 Rel (sel)( , var__temp_h'3253, res ) ==((sel)( , var__temp_h3251, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'3253, other ) ==(sel)( , var__temp_h3251, other ) => 
 	 True
 
VC_END(declare-const var_h_i3228 T11560)
(declare-const var_h3227 T11560)
(declare-const v Int)
(declare-const var_h_i3196 T11560)
(declare-const var_h3195 T11560)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3251 T11560)
(declare-const var__temp_v3252 Int)
(declare-const |var__temp_h'3253| T11560)
(declare-const var__temp_v_err3254 T11561)
(declare-const var_h3227 T11560)
(declare-const var_h3195 T11560)
(declare-const err T11574)

solver 
 (declare-sort T11560)
(declare-fun sel (T11560 Int) Int)
(declare-fun res () Int)
(declare-fun var_h3227 () T11560)
(declare-fun other () Int)
(declare-fun var__temp_h3251 () T11560)
(declare-fun |var__temp_h'3253| () T11560)
(declare-fun var__temp_v3252 () Int)
(declare-fun v () Int)
(assert (> (sel var_h3227 res) 4))
(assert (let ((a!1 (and (= (sel var__temp_h3251 res) v)
                (= (sel var__temp_h3251 res) (+ (sel var_h3227 res) 10))
                (= (sel var__temp_h3251 other) (sel var_h3227 other))))
      (a!2 (and (= (sel |var__temp_h'3253| res) var__temp_v3252)
                (= (sel |var__temp_h'3253| res) (+ (sel var__temp_h3251 res) 2))
                (= (sel |var__temp_h'3253| other) (sel var__temp_h3251 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h3251 res) 5))
                (=> (= (sel var__temp_h3251 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************892
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 
 	 --foo
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3196 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3196, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i3196, other ) ==(sel)( , var_h3195, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3255:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
bar
 *********************Enumeration Iteration*****************893
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3196 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3196, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i3196, other ) ==(sel)( , var_h3195, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3255:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3196 --->  Ty_heap  
 var_h3195 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3256 --->  Ty_heap  
 var__temp_v3257 --->  Ty_int  
 var__temp_h'3258 --->  Ty_heap  
 var__temp_v_err3259 --->  error  
 var_h3195 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3256, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h3256, other ) ==(sel)( , var_h3195, other ) => 
 	 Rel (sel)( , var__temp_h3256, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3256, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3258, res ) ==(var__temp_v3257) AND 
 	 Rel (sel)( , var__temp_h'3258, res ) ==((sel)( , var__temp_h3256, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'3258, other ) ==(sel)( , var__temp_h3256, other ) => 
 	 True
 
VC_END(declare-const var_h_i3196 T11577)
(declare-const var_h3195 T11577)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3256 T11577)
(declare-const var__temp_v3257 Int)
(declare-const |var__temp_h'3258| T11577)
(declare-const var__temp_v_err3259 T11578)
(declare-const var_h3195 T11577)
(declare-const err T11591)
    (declare-const |5| Int)
  
solver 
 (declare-sort T11577)
(declare-fun |5| () Int)
(declare-fun sel (T11577 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h3256 () T11577)
(declare-fun |var__temp_h'3258| () T11577)
(declare-fun res () Int)
(declare-fun var__temp_v3257 () Int)
(declare-fun var_h3195 () T11577)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3256 res) v)
                    (= v |5|)
                    (= (sel var__temp_h3256 other) (sel var_h3195 other)))
               (= (sel var__temp_h3256 res) 7)))
      (a!2 (and (= (sel |var__temp_h'3258| res) var__temp_v3257)
                (= (sel |var__temp_h'3258| res) (+ (sel var__temp_h3256 res) 3))
                (= (sel |var__temp_h'3258| other) (sel var__temp_h3256 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h3256 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************894
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3196 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3196, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i3196, other ) ==(sel)( , var_h3195, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3255:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3196 --->  Ty_heap  
 var_h3195 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3260 --->  Ty_heap  
 var__temp_v3261 --->  Ty_int  
 var__temp_h'3262 --->  Ty_heap  
 var__temp_v_err3263 --->  error  
 var_h3195 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3260, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h3260, other ) ==(sel)( , var_h3195, other ) => 
 	 Rel (sel)( , var__temp_h3260, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3260, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3262, res ) ==(var__temp_v3261) AND 
 	 Rel (sel)( , var__temp_h'3262, res ) ==((sel)( , var__temp_h3260, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'3262, other ) ==(sel)( , var__temp_h3260, other ) => 
 	 True
 
VC_END(declare-const var_h_i3196 T11594)
(declare-const var_h3195 T11594)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3260 T11594)
(declare-const var__temp_v3261 Int)
(declare-const |var__temp_h'3262| T11594)
(declare-const var__temp_v_err3263 T11595)
(declare-const var_h3195 T11594)
(declare-const err T11608)
    (declare-const |5| Int)
  
solver 
 (declare-sort T11594)
(declare-fun |5| () Int)
(declare-fun sel (T11594 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h3260 () T11594)
(declare-fun |var__temp_h'3262| () T11594)
(declare-fun res () Int)
(declare-fun var__temp_v3261 () Int)
(declare-fun var_h3195 () T11594)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3260 res) v)
                    (= v |5|)
                    (= (sel var__temp_h3260 other) (sel var_h3195 other)))
               (= (sel var__temp_h3260 res) 7)))
      (a!2 (and (= (sel |var__temp_h'3262| res) var__temp_v3261)
                (= (sel |var__temp_h'3262| res) (+ (sel var__temp_h3260 res) 5))
                (= (sel |var__temp_h'3262| other) (sel var__temp_h3260 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h3260 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************895
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3196 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3196, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i3196, other ) ==(sel)( , var_h3195, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3255:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3196 --->  Ty_heap  
 var_h3195 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3264 --->  Ty_heap  
 var__temp_v3265 --->  Ty_int  
 var__temp_h'3266 --->  Ty_heap  
 var__temp_v_err3267 --->  error  
 var_h3195 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3264, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h3264, other ) ==(sel)( , var_h3195, other ) => 
 	 Rel (sel)( , var__temp_h3264, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h3264, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3266, res ) ==(var__temp_v3265) AND 
 	 Rel (sel)( , var__temp_h'3266, res ) ==((sel)( , var__temp_h3264, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'3266, other ) ==(sel)( , var__temp_h3264, other ) => 
 	 True
 
VC_END(declare-const var_h_i3196 T11611)
(declare-const var_h3195 T11611)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3264 T11611)
(declare-const var__temp_v3265 Int)
(declare-const |var__temp_h'3266| T11611)
(declare-const var__temp_v_err3267 T11612)
(declare-const var_h3195 T11611)
(declare-const err T11625)
    (declare-const |5| Int)
  
solver 
 (declare-sort T11611)
(declare-fun |5| () Int)
(declare-fun sel (T11611 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h3264 () T11611)
(declare-fun |var__temp_h'3266| () T11611)
(declare-fun res () Int)
(declare-fun var__temp_v3265 () Int)
(declare-fun var_h3195 () T11611)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3264 res) v)
                    (= v |5|)
                    (= (sel var__temp_h3264 other) (sel var_h3195 other)))
               (= (sel var__temp_h3264 res) 5)))
      (a!2 (and (= (sel |var__temp_h'3266| res) var__temp_v3265)
                (= (sel |var__temp_h'3266| res) (+ (sel var__temp_h3264 res) 2))
                (= (sel |var__temp_h'3266| other) (sel var__temp_h3264 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h3264 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************bar
PARTIAL PATH NEW
SUB 
 	 --bar
 	 --foo
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i3269 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3269 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3269, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3269, res ) ==((sel)( , var_h3268, res ) + (2))
 	 , (sel)( , var_h_i3269, other ) ==(sel)( , var_h3268, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3270:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3269 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************896
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3269 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3269, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3269, res ) ==((sel)( , var_h3268, res ) + (2))
 	 , (sel)( , var_h_i3269, other ) ==(sel)( , var_h3268, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3270:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3269 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3269 --->  Ty_heap  
 var_h3268 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i3196 --->  Ty_heap  
 var_h3195 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3271 --->  Ty_heap  
 var__temp_v3272 --->  Ty_int  
 var__temp_h'3273 --->  Ty_heap  
 var__temp_v_err3274 --->  error  
 var_h3268 --->  Ty_heap  
 var_h3195 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h3268, res ) ==(5) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3271, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h3271, res ) ==((sel)( , var_h3268, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h3271, other ) ==(sel)( , var_h3268, other ) => 
 	 Rel (sel)( , var__temp_h3271, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3271, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3273, res ) ==(var__temp_v3272) AND 
 	 Rel (sel)( , var__temp_h'3273, res ) ==((sel)( , var__temp_h3271, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'3273, other ) ==(sel)( , var__temp_h3271, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3273, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'3273, other ) > (4)
 
VC_END(declare-const var_h_i3269 T11628)
(declare-const var_h3268 T11628)
(declare-const v Int)
(declare-const var_h_i3196 T11628)
(declare-const var_h3195 T11628)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3271 T11628)
(declare-const var__temp_v3272 Int)
(declare-const |var__temp_h'3273| T11628)
(declare-const var__temp_v_err3274 T11629)
(declare-const var_h3268 T11628)
(declare-const var_h3195 T11628)
(declare-const err T11642)

solver 
 (declare-sort T11628)
(declare-fun sel (T11628 Int) Int)
(declare-fun res () Int)
(declare-fun var_h3268 () T11628)
(declare-fun other () Int)
(declare-fun |var__temp_h'3273| () T11628)
(declare-fun var__temp_h3271 () T11628)
(declare-fun var__temp_v3272 () Int)
(declare-fun v () Int)
(assert (= (sel var_h3268 res) 5))
(assert (let ((a!1 (and (= (sel var__temp_h3271 res) v)
                (= (sel var__temp_h3271 res) (+ (sel var_h3268 res) 2))
                (= (sel var__temp_h3271 other) (sel var_h3268 other))))
      (a!2 (and (= (sel |var__temp_h'3273| res) var__temp_v3272)
                (= (sel |var__temp_h'3273| res) (+ (sel var__temp_h3271 res) 3))
                (= (sel |var__temp_h'3273| other) (sel var__temp_h3271 other))))
      (a!3 (and (= (sel |var__temp_h'3273| res) 10)
                (not (> (sel |var__temp_h'3273| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h3271 res) 7))
                (=> (= (sel var__temp_h3271 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************897
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3269 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3269, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3269, res ) ==((sel)( , var_h3268, res ) + (2))
 	 , (sel)( , var_h_i3269, other ) ==(sel)( , var_h3268, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3270:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3269 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3269 --->  Ty_heap  
 var_h3268 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i3196 --->  Ty_heap  
 var_h3195 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3275 --->  Ty_heap  
 var__temp_v3276 --->  Ty_int  
 var__temp_h'3277 --->  Ty_heap  
 var__temp_v_err3278 --->  error  
 var_h3268 --->  Ty_heap  
 var_h3195 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h3268, res ) ==(5) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3275, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h3275, res ) ==((sel)( , var_h3268, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h3275, other ) ==(sel)( , var_h3268, other ) => 
 	 Rel (sel)( , var__temp_h3275, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3275, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3277, res ) ==(var__temp_v3276) AND 
 	 Rel (sel)( , var__temp_h'3277, res ) ==((sel)( , var__temp_h3275, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'3277, other ) ==(sel)( , var__temp_h3275, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3277, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'3277, other ) > (4)
 
VC_END(declare-const var_h_i3269 T11645)
(declare-const var_h3268 T11645)
(declare-const v Int)
(declare-const var_h_i3196 T11645)
(declare-const var_h3195 T11645)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3275 T11645)
(declare-const var__temp_v3276 Int)
(declare-const |var__temp_h'3277| T11645)
(declare-const var__temp_v_err3278 T11646)
(declare-const var_h3268 T11645)
(declare-const var_h3195 T11645)
(declare-const err T11659)

solver 
 (declare-sort T11645)
(declare-fun sel (T11645 Int) Int)
(declare-fun res () Int)
(declare-fun var_h3268 () T11645)
(declare-fun other () Int)
(declare-fun |var__temp_h'3277| () T11645)
(declare-fun var__temp_h3275 () T11645)
(declare-fun var__temp_v3276 () Int)
(declare-fun v () Int)
(assert (= (sel var_h3268 res) 5))
(assert (let ((a!1 (and (= (sel var__temp_h3275 res) v)
                (= (sel var__temp_h3275 res) (+ (sel var_h3268 res) 2))
                (= (sel var__temp_h3275 other) (sel var_h3268 other))))
      (a!2 (and (= (sel |var__temp_h'3277| res) var__temp_v3276)
                (= (sel |var__temp_h'3277| res) (+ (sel var__temp_h3275 res) 5))
                (= (sel |var__temp_h'3277| other) (sel var__temp_h3275 other))))
      (a!3 (and (= (sel |var__temp_h'3277| res) 10)
                (not (> (sel |var__temp_h'3277| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h3275 res) 7))
                (=> (= (sel var__temp_h3275 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************898
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v3270:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v3270:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbarc2foofoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3269 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3269, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3269, res ) ==((sel)( , var_h3268, res ) + (2))
 	 , (sel)( , var_h_i3269, other ) ==(sel)( , var_h3268, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3279:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************899
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3269 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3269, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3269, res ) ==((sel)( , var_h3268, res ) + (2))
 	 , (sel)( , var_h_i3269, other ) ==(sel)( , var_h3268, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3279:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3269 --->  Ty_heap  
 var_h3268 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i3196 --->  Ty_heap  
 var_h3195 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3280 --->  Ty_heap  
 var__temp_v3281 --->  Ty_int  
 var__temp_h'3282 --->  Ty_heap  
 var__temp_v_err3283 --->  error  
 var_h3268 --->  Ty_heap  
 var_h3195 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h3268, res ) ==(5) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3280, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h3280, res ) ==((sel)( , var_h3268, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h3280, other ) ==(sel)( , var_h3268, other ) => 
 	 Rel (sel)( , var__temp_h3280, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3280, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3282, res ) ==(var__temp_v3281) AND 
 	 Rel (sel)( , var__temp_h'3282, res ) ==((sel)( , var__temp_h3280, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'3282, other ) ==(sel)( , var__temp_h3280, other ) => 
 	 True
 
VC_END(declare-const var_h_i3269 T11662)
(declare-const var_h3268 T11662)
(declare-const v Int)
(declare-const var_h_i3196 T11662)
(declare-const var_h3195 T11662)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3280 T11662)
(declare-const var__temp_v3281 Int)
(declare-const |var__temp_h'3282| T11662)
(declare-const var__temp_v_err3283 T11663)
(declare-const var_h3268 T11662)
(declare-const var_h3195 T11662)
(declare-const err T11676)

solver 
 (declare-sort T11662)
(declare-fun sel (T11662 Int) Int)
(declare-fun res () Int)
(declare-fun var_h3268 () T11662)
(declare-fun other () Int)
(declare-fun var__temp_h3280 () T11662)
(declare-fun |var__temp_h'3282| () T11662)
(declare-fun var__temp_v3281 () Int)
(declare-fun v () Int)
(assert (= (sel var_h3268 res) 5))
(assert (let ((a!1 (and (= (sel var__temp_h3280 res) v)
                (= (sel var__temp_h3280 res) (+ (sel var_h3268 res) 2))
                (= (sel var__temp_h3280 other) (sel var_h3268 other))))
      (a!2 (and (= (sel |var__temp_h'3282| res) var__temp_v3281)
                (= (sel |var__temp_h'3282| res) (+ (sel var__temp_h3280 res) 3))
                (= (sel |var__temp_h'3282| other) (sel var__temp_h3280 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h3280 res) 7))
                (=> (= (sel var__temp_h3280 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************baz
PARTIAL PATH NEW
SUB 
 	 --baz
 	 --bar
 	 --foo
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i3285 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3285 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3285, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3285, res ) ==((sel)( , var_h3284, res ) + (3))
 	 , (sel)( , var_h_i3285, other ) ==(sel)( , var_h3284, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3286:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3285 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************900
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3285 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3285, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3285, res ) ==((sel)( , var_h3284, res ) + (3))
 	 , (sel)( , var_h_i3285, other ) ==(sel)( , var_h3284, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3286:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3285 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3285 --->  Ty_heap  
 var_h3284 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i3269 --->  Ty_heap  
 var_h3268 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i3196 --->  Ty_heap  
 var_h3195 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3287 --->  Ty_heap  
 var__temp_v3288 --->  Ty_int  
 var__temp_h'3289 --->  Ty_heap  
 var__temp_v_err3290 --->  error  
 var_h3284 --->  Ty_heap  
 var_h3268 --->  Ty_heap  
 var_h3195 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h3284, res ) ==(7) AND 
 	 Rel (sel)( , var_h3268, res ) ==(5) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3287, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h3287, res ) ==((sel)( , var_h3284, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h3287, other ) ==(sel)( , var_h3284, other ) => 
 	 Rel (sel)( , var__temp_h3287, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3287, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3289, res ) ==(var__temp_v3288) AND 
 	 Rel (sel)( , var__temp_h'3289, res ) ==((sel)( , var__temp_h3287, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'3289, other ) ==(sel)( , var__temp_h3287, other ) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3289, res ) ==(10) AND 
 	 Rel (sel)( , var__temp_h'3289, other ) > (4)
 
VC_END(declare-const var_h_i3285 T11679)
(declare-const var_h3284 T11679)
(declare-const v Int)
(declare-const var_h_i3269 T11679)
(declare-const var_h3268 T11679)
(declare-const v Int)
(declare-const var_h_i3196 T11679)
(declare-const var_h3195 T11679)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3287 T11679)
(declare-const var__temp_v3288 Int)
(declare-const |var__temp_h'3289| T11679)
(declare-const var__temp_v_err3290 T11680)
(declare-const var_h3284 T11679)
(declare-const var_h3268 T11679)
(declare-const var_h3195 T11679)
(declare-const err T11693)

solver 
 (declare-sort T11679)
(declare-fun sel (T11679 Int) Int)
(declare-fun res () Int)
(declare-fun var_h3284 () T11679)
(declare-fun var_h3268 () T11679)
(declare-fun other () Int)
(declare-fun |var__temp_h'3289| () T11679)
(declare-fun var__temp_h3287 () T11679)
(declare-fun var__temp_v3288 () Int)
(declare-fun v () Int)
(assert (= (sel var_h3284 res) 7))
(assert (= (sel var_h3268 res) 5))
(assert (let ((a!1 (and (= (sel var__temp_h3287 res) v)
                (= (sel var__temp_h3287 res) (+ (sel var_h3284 res) 3))
                (= (sel var__temp_h3287 other) (sel var_h3284 other))))
      (a!2 (and (= (sel |var__temp_h'3289| res) var__temp_v3288)
                (= (sel |var__temp_h'3289| res) (+ (sel var__temp_h3287 res) 5))
                (= (sel |var__temp_h'3289| other) (sel var__temp_h3287 other))))
      (a!3 (and (= (sel |var__temp_h'3289| res) 10)
                (not (> (sel |var__temp_h'3289| other) 4)))))
(let ((a!4 (and (=> a!1 (= (sel var__temp_h3287 res) 7))
                (=> (= (sel var__temp_h3287 res) 7) (=> a!2 a!3)))))
  (not a!4))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************901
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v3286:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v3286:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsbazbarc2foofoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --baz
 	 --bar
 	 --foo
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3285 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3285, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3285, res ) ==((sel)( , var_h3284, res ) + (3))
 	 , (sel)( , var_h_i3285, other ) ==(sel)( , var_h3284, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3291:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************902
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3285 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3285, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3285, res ) ==((sel)( , var_h3284, res ) + (3))
 	 , (sel)( , var_h_i3285, other ) ==(sel)( , var_h3284, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3291:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3285 --->  Ty_heap  
 var_h3284 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i3269 --->  Ty_heap  
 var_h3268 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i3196 --->  Ty_heap  
 var_h3195 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3292 --->  Ty_heap  
 var__temp_v3293 --->  Ty_int  
 var__temp_h'3294 --->  Ty_heap  
 var__temp_v_err3295 --->  error  
 var_h3284 --->  Ty_heap  
 var_h3268 --->  Ty_heap  
 var_h3195 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h3284, res ) ==(7) AND 
 	 Rel (sel)( , var_h3268, res ) ==(5) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3292, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h3292, res ) ==((sel)( , var_h3284, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h3292, other ) ==(sel)( , var_h3284, other ) => 
 	 Rel (sel)( , var__temp_h3292, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3292, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3294, res ) ==(var__temp_v3293) AND 
 	 Rel (sel)( , var__temp_h'3294, res ) ==((sel)( , var__temp_h3292, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'3294, other ) ==(sel)( , var__temp_h3292, other ) => 
 	 True
 
VC_END(declare-const var_h_i3285 T11696)
(declare-const var_h3284 T11696)
(declare-const v Int)
(declare-const var_h_i3269 T11696)
(declare-const var_h3268 T11696)
(declare-const v Int)
(declare-const var_h_i3196 T11696)
(declare-const var_h3195 T11696)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3292 T11696)
(declare-const var__temp_v3293 Int)
(declare-const |var__temp_h'3294| T11696)
(declare-const var__temp_v_err3295 T11697)
(declare-const var_h3284 T11696)
(declare-const var_h3268 T11696)
(declare-const var_h3195 T11696)
(declare-const err T11710)

solver 
 (declare-sort T11696)
(declare-fun sel (T11696 Int) Int)
(declare-fun res () Int)
(declare-fun var_h3284 () T11696)
(declare-fun var_h3268 () T11696)
(declare-fun other () Int)
(declare-fun var__temp_h3292 () T11696)
(declare-fun |var__temp_h'3294| () T11696)
(declare-fun var__temp_v3293 () Int)
(declare-fun v () Int)
(assert (= (sel var_h3284 res) 7))
(assert (= (sel var_h3268 res) 5))
(assert (let ((a!1 (and (= (sel var__temp_h3292 res) v)
                (= (sel var__temp_h3292 res) (+ (sel var_h3284 res) 3))
                (= (sel var__temp_h3292 other) (sel var_h3284 other))))
      (a!2 (and (= (sel |var__temp_h'3294| res) var__temp_v3293)
                (= (sel |var__temp_h'3294| res) (+ (sel var__temp_h3292 res) 5))
                (= (sel |var__temp_h'3294| other) (sel var__temp_h3292 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h3292 res) 7))
                (=> (= (sel var__temp_h3292 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************903
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT baz
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3269 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3269, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3269, res ) ==((sel)( , var_h3268, res ) + (2))
 	 , (sel)( , var_h_i3269, other ) ==(sel)( , var_h3268, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3296:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c5
 *********************Enumeration Iteration*****************904
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3269 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3269, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3269, res ) ==((sel)( , var_h3268, res ) + (2))
 	 , (sel)( , var_h_i3269, other ) ==(sel)( , var_h3268, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3296:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3269 --->  Ty_heap  
 var_h3268 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i3196 --->  Ty_heap  
 var_h3195 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3297 --->  Ty_heap  
 var__temp_v3298 --->  Ty_int  
 var__temp_h'3299 --->  Ty_heap  
 var__temp_v_err3300 --->  error  
 var_h3268 --->  Ty_heap  
 var_h3195 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h3268, res ) ==(5) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3297, res ) ==(v) AND 
 	 Rel (sel)( , var__temp_h3297, res ) ==((sel)( , var_h3268, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h3297, other ) ==(sel)( , var_h3268, other ) => 
 	 Rel (sel)( , var__temp_h3297, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3297, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3299, res ) ==(var__temp_v3298) AND 
 	 Rel (sel)( , var__temp_h'3299, res ) ==((sel)( , var__temp_h3297, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'3299, other ) ==(sel)( , var__temp_h3297, other ) => 
 	 True
 
VC_END(declare-const var_h_i3269 T11713)
(declare-const var_h3268 T11713)
(declare-const v Int)
(declare-const var_h_i3196 T11713)
(declare-const var_h3195 T11713)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3297 T11713)
(declare-const var__temp_v3298 Int)
(declare-const |var__temp_h'3299| T11713)
(declare-const var__temp_v_err3300 T11714)
(declare-const var_h3268 T11713)
(declare-const var_h3195 T11713)
(declare-const err T11727)

solver 
 (declare-sort T11713)
(declare-fun sel (T11713 Int) Int)
(declare-fun res () Int)
(declare-fun var_h3268 () T11713)
(declare-fun other () Int)
(declare-fun var__temp_h3297 () T11713)
(declare-fun |var__temp_h'3299| () T11713)
(declare-fun var__temp_v3298 () Int)
(declare-fun v () Int)
(assert (= (sel var_h3268 res) 5))
(assert (let ((a!1 (and (= (sel var__temp_h3297 res) v)
                (= (sel var__temp_h3297 res) (+ (sel var_h3268 res) 2))
                (= (sel var__temp_h3297 other) (sel var_h3268 other))))
      (a!2 (and (= (sel |var__temp_h'3299| res) var__temp_v3298)
                (= (sel |var__temp_h'3299| res) (+ (sel var__temp_h3297 res) 5))
                (= (sel |var__temp_h'3299| other) (sel var__temp_h3297 other)))))
(let ((a!3 (and (=> a!1 (= (sel var__temp_h3297 res) 7))
                (=> (= (sel var__temp_h3297 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Successful************c5
PARTIAL PATH NEW
SUB 
 	 --c5
 	 --bar
 	 --foo
Found e1 in (x <- e1 in e2), Synthesizing now e2 
post_substituted Forall 
 	 
 Key =var_h_i3302 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3302 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3302, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3302, res ) ==((sel)( , var_h3301, res ) + (5))
 	 , (sel)( , var_h_i3302, other ) ==(sel)( , var_h3301, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3303:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i3302 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(10)
 	 , Not (sel)( , h', other ) > (4) >c  } 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************905
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v3303:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v3303:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc5bazbarc2foofoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 
 	 --c5
 	 --bar
 	 --foo
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3302 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3302, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3302, res ) ==((sel)( , var_h3301, res ) + (5))
 	 , (sel)( , var_h_i3302, other ) ==(sel)( , var_h3301, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3304:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************906
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --bar
 	 --foo
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3269 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3269, res ) ==(v)
 	 , 
 Conj <c (sel)( , var_h_i3269, res ) ==((sel)( , var_h3268, res ) + (2))
 	 , (sel)( , var_h_i3269, other ) ==(sel)( , var_h3268, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3305:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
 *********************Enumeration Iteration*****************907
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c5
PARTIAL PATH
SUB 
 	 --foo
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3196 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3196, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i3196, other ) ==(sel)( , var_h3195, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3306:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
 *********************Enumeration Iteration*****************908
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3196 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3196, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i3196, other ) ==(sel)( , var_h3195, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3306:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3196 --->  Ty_heap  
 var_h3195 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3307 --->  Ty_heap  
 var__temp_v3308 --->  Ty_int  
 var__temp_h'3309 --->  Ty_heap  
 var__temp_v_err3310 --->  error  
 var_h3195 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3307, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h3307, other ) ==(sel)( , var_h3195, other ) => 
 	 Rel (sel)( , var__temp_h3307, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3307, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3309, res ) ==(var__temp_v3308) AND 
 	 Rel (sel)( , var__temp_h'3309, res ) ==((sel)( , var__temp_h3307, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'3309, other ) ==(sel)( , var__temp_h3307, other ) => 
 	 True
 
VC_END(declare-const var_h_i3196 T11730)
(declare-const var_h3195 T11730)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3307 T11730)
(declare-const var__temp_v3308 Int)
(declare-const |var__temp_h'3309| T11730)
(declare-const var__temp_v_err3310 T11731)
(declare-const var_h3195 T11730)
(declare-const err T11744)
    (declare-const |5| Int)
  
solver 
 (declare-sort T11730)
(declare-fun |5| () Int)
(declare-fun sel (T11730 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h3307 () T11730)
(declare-fun |var__temp_h'3309| () T11730)
(declare-fun res () Int)
(declare-fun var__temp_v3308 () Int)
(declare-fun var_h3195 () T11730)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3307 res) v)
                    (= v |5|)
                    (= (sel var__temp_h3307 other) (sel var_h3195 other)))
               (= (sel var__temp_h3307 res) 7)))
      (a!2 (and (= (sel |var__temp_h'3309| res) var__temp_v3308)
                (= (sel |var__temp_h'3309| res) (+ (sel var__temp_h3307 res) 3))
                (= (sel |var__temp_h'3309| other) (sel var__temp_h3307 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h3307 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************909
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i3196 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i3196, res ) ==(v)
 	 , 
 Conj <c v = 5
 	 , (sel)( , var_h_i3196, other ) ==(sel)( , var_h3195, other ) >c  >c  } 
 } 
 
                                                RET :  Base {var_v3306:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i3196 --->  Ty_heap  
 var_h3195 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3311 --->  Ty_heap  
 var__temp_v3312 --->  Ty_int  
 var__temp_h'3313 --->  Ty_heap  
 var__temp_v_err3314 --->  error  
 var_h3195 --->  Ty_heap 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3311, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var__temp_h3311, other ) ==(sel)( , var_h3195, other ) => 
 	 Rel (sel)( , var__temp_h3311, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3311, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3313, res ) ==(var__temp_v3312) AND 
 	 Rel (sel)( , var__temp_h'3313, res ) ==((sel)( , var__temp_h3311, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'3313, other ) ==(sel)( , var__temp_h3311, other ) => 
 	 True
 
VC_END(declare-const var_h_i3196 T11747)
(declare-const var_h3195 T11747)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3311 T11747)
(declare-const var__temp_v3312 Int)
(declare-const |var__temp_h'3313| T11747)
(declare-const var__temp_v_err3314 T11748)
(declare-const var_h3195 T11747)
(declare-const err T11761)
    (declare-const |5| Int)
  
solver 
 (declare-sort T11747)
(declare-fun |5| () Int)
(declare-fun sel (T11747 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h3311 () T11747)
(declare-fun |var__temp_h'3313| () T11747)
(declare-fun res () Int)
(declare-fun var__temp_v3312 () Int)
(declare-fun var_h3195 () T11747)
(declare-fun v () Int)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h3311 res) v)
                    (= v |5|)
                    (= (sel var__temp_h3311 other) (sel var_h3195 other)))
               (= (sel var__temp_h3311 res) 7)))
      (a!2 (and (= (sel |var__temp_h'3313| res) var__temp_v3312)
                (= (sel |var__temp_h'3313| res) (+ (sel var__temp_h3311 res) 5))
                (= (sel |var__temp_h'3313| other) (sel var__temp_h3311 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h3311 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************910
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT bar
PARTIAL PATH
SUB 
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {var_v3315:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz
c5
c2
bar
 *********************Enumeration Iteration*****************911
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {var_v3315:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (3))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3316 --->  Ty_heap  
 var__temp_v3317 --->  Ty_int  
 var__temp_h'3318 --->  Ty_heap  
 var__temp_v_err3319 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3316, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h3316, other ) ==(0) => 
 	 Rel (sel)( , var__temp_h3316, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3316, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3318, res ) ==(var__temp_v3317) AND 
 	 Rel (sel)( , var__temp_h'3318, res ) ==((sel)( , var__temp_h3316, res ) + (3)) AND 
 	 Rel (sel)( , var__temp_h'3318, other ) ==(sel)( , var__temp_h3316, other ) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3316 T11764)
(declare-const var__temp_v3317 Int)
(declare-const |var__temp_h'3318| T11764)
(declare-const var__temp_v_err3319 T11765)
(declare-const err T11778)

solver 
 (declare-sort T11764)
(declare-fun sel (T11764 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h3316 () T11764)
(declare-fun |var__temp_h'3318| () T11764)
(declare-fun res () Int)
(declare-fun var__temp_v3317 () Int)
(assert true)
(assert (let ((a!1 (=> (and (= (sel var__temp_h3316 res) 0)
                    (= (sel var__temp_h3316 other) 0))
               (= (sel var__temp_h3316 res) 7)))
      (a!2 (and (= (sel |var__temp_h'3318| res) var__temp_v3317)
                (= (sel |var__temp_h'3318| res) (+ (sel var__temp_h3316 res) 3))
                (= (sel |var__temp_h'3318| other) (sel var__temp_h3316 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h3316 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************912
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {var_v3315:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (5))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3320 --->  Ty_heap  
 var__temp_v3321 --->  Ty_int  
 var__temp_h'3322 --->  Ty_heap  
 var__temp_v_err3323 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3320, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h3320, other ) ==(0) => 
 	 Rel (sel)( , var__temp_h3320, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h3320, res ) ==(7) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3322, res ) ==(var__temp_v3321) AND 
 	 Rel (sel)( , var__temp_h'3322, res ) ==((sel)( , var__temp_h3320, res ) + (5)) AND 
 	 Rel (sel)( , var__temp_h'3322, other ) ==(sel)( , var__temp_h3320, other ) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3320 T11781)
(declare-const var__temp_v3321 Int)
(declare-const |var__temp_h'3322| T11781)
(declare-const var__temp_v_err3323 T11782)
(declare-const err T11795)

solver 
 (declare-sort T11781)
(declare-fun sel (T11781 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h3320 () T11781)
(declare-fun |var__temp_h'3322| () T11781)
(declare-fun res () Int)
(declare-fun var__temp_v3321 () Int)
(assert true)
(assert (let ((a!1 (=> (and (= (sel var__temp_h3320 res) 0)
                    (= (sel var__temp_h3320 other) 0))
               (= (sel var__temp_h3320 res) 7)))
      (a!2 (and (= (sel |var__temp_h'3322| res) var__temp_v3321)
                (= (sel |var__temp_h'3322| res) (+ (sel var__temp_h3320 res) 5))
                (= (sel |var__temp_h'3322| other) (sel var__temp_h3320 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h3320 res) 7) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************913
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {var_v3315:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (10))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3324 --->  Ty_heap  
 var__temp_v3325 --->  Ty_int  
 var__temp_h'3326 --->  Ty_heap  
 var__temp_v_err3327 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3324, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h3324, other ) ==(0) => 
 	 Rel (sel)( , var__temp_h3324, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h3324, res ) > (4) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3326, res ) ==(var__temp_v3325) AND 
 	 Rel (sel)( , var__temp_h'3326, res ) ==((sel)( , var__temp_h3324, res ) + (10)) AND 
 	 Rel (sel)( , var__temp_h'3326, other ) ==(sel)( , var__temp_h3324, other ) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3324 T11798)
(declare-const var__temp_v3325 Int)
(declare-const |var__temp_h'3326| T11798)
(declare-const var__temp_v_err3327 T11799)
(declare-const err T11812)

solver 
 (declare-sort T11798)
(declare-fun sel (T11798 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h3324 () T11798)
(declare-fun |var__temp_h'3326| () T11798)
(declare-fun res () Int)
(declare-fun var__temp_v3325 () Int)
(assert true)
(assert (let ((a!1 (=> (and (= (sel var__temp_h3324 res) 0)
                    (= (sel var__temp_h3324 other) 0))
               (> (sel var__temp_h3324 res) 4)))
      (a!2 (and (= (sel |var__temp_h'3326| res) var__temp_v3325)
                (= (sel |var__temp_h'3326| res)
                   (+ (sel var__temp_h3324 res) 10))
                (= (sel |var__temp_h'3326| other) (sel var__temp_h3324 other)))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h3324 res) 4) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************914
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ 
 Conj <c (sel)( , h, res ) ==(0)
 	 , (sel)( , h, other ) ==(0) >c  } 
 } 
 
                                                RET :  Base {var_v3315:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , 
 Conj <c (sel)( , h', res ) ==((sel)( , h, res ) + (2))
 	 , (sel)( , h', other ) ==(sel)( , h, other ) >c  >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 other --->  Ty_int  
 res --->  Ty_int  
 var__temp_h3328 --->  Ty_heap  
 var__temp_v3329 --->  Ty_int  
 var__temp_h'3330 --->  Ty_heap  
 var__temp_v_err3331 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h3328, res ) ==(0) AND 
 	 Rel (sel)( , var__temp_h3328, other ) ==(0) => 
 	 Rel (sel)( , var__temp_h3328, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h3328, res ) ==(5) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'3330, res ) ==(var__temp_v3329) AND 
 	 Rel (sel)( , var__temp_h'3330, res ) ==((sel)( , var__temp_h3328, res ) + (2)) AND 
 	 Rel (sel)( , var__temp_h'3330, other ) ==(sel)( , var__temp_h3328, other ) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const baz Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const other Int)
(declare-const res Int)
(declare-const var__temp_h3328 T11815)
(declare-const var__temp_v3329 Int)
(declare-const |var__temp_h'3330| T11815)
(declare-const var__temp_v_err3331 T11816)
(declare-const err T11829)

solver 
 (declare-sort T11815)
(declare-fun sel (T11815 Int) Int)
(declare-fun other () Int)
(declare-fun var__temp_h3328 () T11815)
(declare-fun |var__temp_h'3330| () T11815)
(declare-fun res () Int)
(declare-fun var__temp_v3329 () Int)
(assert true)
(assert (let ((a!1 (=> (and (= (sel var__temp_h3328 res) 0)
                    (= (sel var__temp_h3328 other) 0))
               (= (sel var__temp_h3328 res) 5)))
      (a!2 (and (= (sel |var__temp_h'3330| res) var__temp_v3329)
                (= (sel |var__temp_h'3330| res) (+ (sel var__temp_h3328 res) 2))
                (= (sel |var__temp_h'3330| other) (sel var__temp_h3328 other)))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h3328 res) 5) (=> a!2 true)))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************915
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo
ENUM ::bar::c2::c5::baz::c5::baz::c5::c5::c5::baz::c5::baz::bar::c5::baz::bar::c5::baz::bar::c5::baz::c2::c5::baz::bar::c2::c5::baz::foo::c2::c5::baz::bar::c5::baz::c5::baz::c5::c5::c5::baz::c5::baz::bar::c5::baz::bar::c5::baz::foo::c5::baz::bar::c5::baz::c5::baz::c5::c5::c5::baz::c5::baz::bar::c5::baz::bar::c5::baz::foo::c5::baz::bar::foo::c5::baz::c2::c5::baz::bar::foo::c2::c5::baz::foo'::c2::c5::baz::bar::c2::c5::baz::c5::baz::c5::c5::c5::baz::c5::baz::bar::c5::baz::bar::c5::baz::bar::c5::baz::c2::c5::baz::bar::c2::c5::baz::foo::c2::c5::baz::bar::c5::baz::c5::baz::c5::c5::c5::baz::c5::baz::bar::c5::baz::bar::c5::baz::foo::c5::baz::bar::c5::baz::c5::baz::c5::c5::c5::baz::c5::baz::bar::c5::baz::bar::c5::baz::foo::c5::baz::bar::foo::c5::baz::c2::c5::baz::bar::foo::c2::c5::baz::foo'::c2::c5::baz::bar::foo::foo'::c2::c5::baz::c2'::c5::baz::bar::c2::c2'::c5::baz::c5::baz::c5::c5::c5::baz::c5::baz::bar::c5::baz::bar::c5::baz::bar::c5::baz::c2::c5::baz::bar::c2::c5::baz::bar::c2::c5::baz::c2'::c5::baz::bar::c2::c2'::c5::baz::foo::c2::c2'::c5::baz::bar::c5::baz::c5::baz::c5::c5::c5::baz::c5::baz::bar::c5::baz::bar::c5::baz::foo::c5::baz::bar::c5::baz::c5::baz::c5::c5::c5::baz::c5::baz::bar::c5::baz::bar::c5::baz::foo::c5::baz::bar::foo::c5::baz::c2::c5::baz::bar::c2::c5::baz::c5::baz::c5::c5::c5::baz::c5::baz::bar::c5::baz::bar::c5::baz::bar::c5::baz::c2::c5::baz::bar::c2::c5::baz::foo::c2::c5::baz::bar::foo::c2::c5::baz::c2'::c5::baz::bar::foo::c2::c2'::c5::baz::foo'::c2::c2'::c5::baz::bar::foo::foo'::c2::c2'::c5::baz::c4::c5::baz::bar::c2::c5::baz::c5::baz::c5::c5::c5::baz::c5::baz::bar::c5::baz::bar::c5::baz::bar::c5::baz::c2::c5::baz::bar::c2::c5::baz::foo::c2::c5::baz::bar::c5::baz::c5::baz::c5::c5::c5::baz::c5::baz::bar::c5::baz::bar::c5::baz::foo::c5::baz::bar::c5::baz::c5::baz::c5::c5::c5::baz::c5::baz::bar::c5::baz::bar::c5::baz::foo::c5::baz::bar::foo::c5::baz::c2::c5::baz::bar::foo::c2::c5::baz::foo'::c2::c5::baz::bar::c2::c5::baz::c5::baz::c5::c5::c5::baz::c5::baz::bar::c5::baz::bar::c5::baz::bar::c5::baz::c2::c5::baz::bar::c2::c5::baz::foo::c2::c5::baz::bar::c5::baz::c5::baz::c5::c5::c5::baz::c5::baz::bar::c5::baz::bar::c5::baz::foo::c5::baz::bar::c5::baz::c5::baz::c5::c5::c5::baz::c5::baz::bar::c5::baz::bar::c5::baz::foo::c5::baz::bar::foo::c5::baz::c2::c5::baz::bar::foo::c2::c5::baz::foo'::c2::c5::baz::bar::foo::foo'::c2::c5::baz::c2'::c5::baz::bar::c2::c2'::c5::baz::c5::baz::c5::c5::c5::baz::c5::baz::bar::c5::baz::bar::c5::baz::bar::c5::baz::c2::c5::baz::bar::c2::c5::baz::bar::c2::c5::baz::c2'::c5::baz::bar::c2::c2'::c5::baz::foo::c2::c2'::c5::baz::bar::c5::baz::c5::baz::c5::c5::c5::baz::c5::baz::bar::c5::baz::bar::c5::baz::foo::c5::baz::bar::c5::baz::c5::baz::c5::c5::c5::baz::c5::baz::bar::c5::baz::bar::c5::baz::foo::c5::baz::bar::foo::c5::baz::c2::c5::baz::bar::c2::c5::baz::c5::baz::c5::c5::c5::baz::c5::baz::bar::c5::baz::bar::c5::baz::bar::c5::baz::c2::c5::baz::bar::c2::c5::baz::foo::c2::c5::baz::bar::foo::c2::c5::baz::c2'::c5::baz::bar::foo::c2::c2'::c5::baz::foo'::c2::c2'::c5::baz::bar::foo::foo'::c2::c2'::c5::baz::c4::c5::baz::bar::foo::foo'::c2::c2'::c4::c5::baz::c3'::bar::foo::foo'::c2::c2'::c4::c5::baz::c3'
SUB Synthesis returned witout result