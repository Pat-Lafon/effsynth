
 specfile :: synth_tests/eff12_1.spec

res : int;




bar : State  {\(h : heap). sel (h, res) == 5} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == sel (h, res) + 2};

foo : State  {\(h : heap). not (sel (h, res) > 3)} 
	v : { v : int |  [v=5]} 
	{\(h : heap), (v : int), (h' : heap). sel (h', res) == v /\ [v=5]};


baz : State  {\(h : heap). sel (h, res) == 7} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == sel (h, res) + 3};


foo' : State  {\(h : heap). true} 
	v : { v : int |  [v=20]} 
	{\(h : heap), (v : int), (h' : heap). sel (h', res) == v /\ [v=20]};


c2 : State  {\(h : heap). sel (h, res) > 4} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == sel (h, res) + 10};
test : State  {\(h : heap). sel (h, res) == 6} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == sel (h, res) + 5};



c2' : State  {\(h : heap). not (sel (h, res) > 20)} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == sel (h, res)};


c4 : State  {\(h : heap). not (sel (h, res) > 30)} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == sel (h, res) + 6};


c5 : State  {\(h : heap). sel (h, res) == 7} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == sel (h, res) + 5};

baz'' : State  {\(h : heap). sel (h, res) == 7} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == sel (h, res) + 4};


baz''' : State  {\(h : heap). sel (h, res) == 7} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == sel (h, res) + 4};


baz' : State  {\(h : heap). sel (h, res) == 7} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == sel (h, res) + 4};


c3' : State  {\(h : heap). not (sel (h, res) > 8)} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == sel (h, res) + 3};



goal : State  {\(h : heap). sel (h, res) == 0} 
		v : { v : int | true} 
		{\(h : heap), (v : int), (h' : heap). 
		sel (h', res) == 10};


var: res
whitespace colon
whitespace var: int
semicolon
var: bar
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 5
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 2
rcurly
semicolon
var: foo
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace notwhitespace lparen
var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace lessthanopwhitespace int: 3
rparen
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace lbrace
var: v
equalopint: 5
rbrace
rcurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace conjwhitespace lbrace
var: v
equalopint: 5
rbrace
rcurly
semicolon
var: baz
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 7
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 3
rcurly
semicolon
var: foo'
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace truercurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace lbrace
var: v
equalopint: 20
rbrace
rcurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: v
whitespace conjwhitespace lbrace
var: v
equalopint: 20
rbrace
rcurly
semicolon
var: c2
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace lessthanopwhitespace int: 4
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 10
rcurly
semicolon
var: test
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 6
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 5
rcurly
semicolon
var: c2'
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace notwhitespace lparen
var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace lessthanopwhitespace int: 20
rparen
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
rcurly
semicolon
var: c4
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace notwhitespace lparen
var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace lessthanopwhitespace int: 30
rparen
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 6
rcurly
semicolon
var: c5
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 7
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 5
rcurly
semicolon
var: baz''
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 7
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 4
rcurly
semicolon
var: baz'''
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 7
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 4
rcurly
semicolon
var: baz'
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 7
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 4
rcurly
semicolon
var: c3'
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace notwhitespace lparen
var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace lessthanopwhitespace int: 8
rparen
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace pluswhitespace int: 3
rcurly
semicolon
var: goal
whitespace colon
whitespace var: State
whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
dotwhitespace var: sel
whitespace lparen
var: h
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 0
rcurly
whitespace whitespace var: v
whitespace colon
whitespace lcurly
whitespace var: v
whitespace colon
whitespace var: int
whitespace pipe
whitespace truercurly
whitespace whitespace lcurly
lambdalparen
var: h
whitespace colon
whitespace var: heap
rparen
comma
whitespace lparen
var: v
whitespace colon
whitespace var: int
rparen
comma
whitespace lparen
var: h'
whitespace colon
whitespace var: heap
rparen
dotwhitespace whitespace var: sel
whitespace lparen
var: h'
comma
whitespace var: res
rparen
whitespace equalopwhitespace int: 10
rcurly
semicolon
RelSpec {  SRs ;  PRs ;  TSs  
 Assume false
 name res : 
 params :
 Type Base {var_v0:Ty_int | true} 
 Assume false
 name bar : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 ) 
 Assume false
 name foo : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (3) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 ) 
 Assume false
 name baz : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 ) 
 Assume false
 name foo' : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 20} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 ) 
 Assume false
 name c2 : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 ) 
 Assume false
 name test : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 ) 
 Assume false
 name c2' : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) } 
 } 
 ) 
 Assume false
 name c4 : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (30) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (6)) } 
 } 
 ) 
 Assume false
 name c5 : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 ) 
 Assume false
 name baz'' : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 ) 
 Assume false
 name baz''' : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 ) 
 Assume false
 name baz' : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 ) 
 Assume false
 name c3' : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (8) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 ) 
 Assume false
 name goal : 
 params :
 Type MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 );  Formulas  }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
c3'
baz'
baz'''
baz''
c5
c4
c2'
test
c2
foo'
baz
foo
bar
 *********************Enumeration Iteration*****************0
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (8) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1 --->  Ty_heap  
 var__temp_v2 --->  Ty_int  
 var__temp_h'3 --->  Ty_heap  
 var__temp_v_err4 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h1, res ) > (8) AND 
 	 Rel (sel)( , var__temp_h1, res ) > (8) => 
 	 Rel (sel)( , var__temp_h'3, res ) ==((sel)( , var__temp_h1, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'3, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1 T0)
(declare-const var__temp_v2 Int)
(declare-const |var__temp_h'3| T0)
(declare-const var__temp_v_err4 T1)
(declare-const err T14)

solver 
 (declare-sort T0)
(declare-fun sel (T0 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'3| () T0)
(declare-fun var__temp_h1 () T0)
(assert true)
(assert (let ((a!1 (=> (= (sel var__temp_h1 res) 0) (not (> (sel var__temp_h1 res) 8))))
      (a!2 (=> (= (sel |var__temp_h'3| res) (+ (sel var__temp_h1 res) 3))
               (= (sel |var__temp_h'3| res) 10))))
(let ((a!3 (=> (not (> (sel var__temp_h1 res) 8)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************c3'
 *********************Enumeration Iteration*****************1
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h5 --->  Ty_heap  
 var__temp_v6 --->  Ty_int  
 var__temp_h'7 --->  Ty_heap  
 var__temp_v_err8 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h5, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h5, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h5, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'7, res ) ==((sel)( , var__temp_h5, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'7, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h5 T17)
(declare-const var__temp_v6 Int)
(declare-const |var__temp_h'7| T17)
(declare-const var__temp_v_err8 T18)
(declare-const err T31)

solver 
 (declare-sort T17)
(declare-fun sel (T17 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'7| () T17)
(declare-fun var__temp_h5 () T17)
(assert true)
(assert (let ((a!1 (=> (= (sel |var__temp_h'7| res) (+ (sel var__temp_h5 res) 4))
               (= (sel |var__temp_h'7| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h5 res) 0) (= (sel var__temp_h5 res) 7))
                (=> (= (sel var__temp_h5 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************2
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h9 --->  Ty_heap  
 var__temp_v10 --->  Ty_int  
 var__temp_h'11 --->  Ty_heap  
 var__temp_v_err12 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h9, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h9, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h9, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'11, res ) ==((sel)( , var__temp_h9, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'11, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h9 T34)
(declare-const var__temp_v10 Int)
(declare-const |var__temp_h'11| T34)
(declare-const var__temp_v_err12 T35)
(declare-const err T48)

solver 
 (declare-sort T34)
(declare-fun sel (T34 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'11| () T34)
(declare-fun var__temp_h9 () T34)
(assert true)
(assert (let ((a!1 (=> (= (sel |var__temp_h'11| res) (+ (sel var__temp_h9 res) 4))
               (= (sel |var__temp_h'11| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h9 res) 0) (= (sel var__temp_h9 res) 7))
                (=> (= (sel var__temp_h9 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************3
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h13 --->  Ty_heap  
 var__temp_v14 --->  Ty_int  
 var__temp_h'15 --->  Ty_heap  
 var__temp_v_err16 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h13, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h13, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h13, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'15, res ) ==((sel)( , var__temp_h13, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'15, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h13 T51)
(declare-const var__temp_v14 Int)
(declare-const |var__temp_h'15| T51)
(declare-const var__temp_v_err16 T52)
(declare-const err T65)

solver 
 (declare-sort T51)
(declare-fun sel (T51 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'15| () T51)
(declare-fun var__temp_h13 () T51)
(assert true)
(assert (let ((a!1 (=> (= (sel |var__temp_h'15| res) (+ (sel var__temp_h13 res) 4))
               (= (sel |var__temp_h'15| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h13 res) 0) (= (sel var__temp_h13 res) 7))
                (=> (= (sel var__temp_h13 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************4
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h17 --->  Ty_heap  
 var__temp_v18 --->  Ty_int  
 var__temp_h'19 --->  Ty_heap  
 var__temp_v_err20 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h17, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h17, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h17, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'19, res ) ==((sel)( , var__temp_h17, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'19, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h17 T68)
(declare-const var__temp_v18 Int)
(declare-const |var__temp_h'19| T68)
(declare-const var__temp_v_err20 T69)
(declare-const err T82)

solver 
 (declare-sort T68)
(declare-fun sel (T68 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'19| () T68)
(declare-fun var__temp_h17 () T68)
(assert true)
(assert (let ((a!1 (=> (= (sel |var__temp_h'19| res) (+ (sel var__temp_h17 res) 5))
               (= (sel |var__temp_h'19| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h17 res) 0) (= (sel var__temp_h17 res) 7))
                (=> (= (sel var__temp_h17 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************5
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (30) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (6)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (6)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h21 --->  Ty_heap  
 var__temp_v22 --->  Ty_int  
 var__temp_h'23 --->  Ty_heap  
 var__temp_v_err24 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h21, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h21, res ) > (30) AND 
 	 Rel (sel)( , var__temp_h21, res ) > (30) => 
 	 Rel (sel)( , var__temp_h'23, res ) ==((sel)( , var__temp_h21, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h'23, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h21 T85)
(declare-const var__temp_v22 Int)
(declare-const |var__temp_h'23| T85)
(declare-const var__temp_v_err24 T86)
(declare-const err T99)

solver 
 (declare-sort T85)
(declare-fun sel (T85 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'23| () T85)
(declare-fun var__temp_h21 () T85)
(assert true)
(assert (let ((a!1 (=> (= (sel var__temp_h21 res) 0)
               (not (> (sel var__temp_h21 res) 30))))
      (a!2 (=> (= (sel |var__temp_h'23| res) (+ (sel var__temp_h21 res) 6))
               (= (sel |var__temp_h'23| res) 10))))
(let ((a!3 (=> (not (> (sel var__temp_h21 res) 30)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************6
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h25 --->  Ty_heap  
 var__temp_v26 --->  Ty_int  
 var__temp_h'27 --->  Ty_heap  
 var__temp_v_err28 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h25, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h25, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h25, res ) > (20) => 
 	 Rel (sel)( , var__temp_h'27, res ) ==(sel)( , var__temp_h25, res ) => 
 	 Rel (sel)( , var__temp_h'27, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h25 T102)
(declare-const var__temp_v26 Int)
(declare-const |var__temp_h'27| T102)
(declare-const var__temp_v_err28 T103)
(declare-const err T116)

solver 
 (declare-sort T102)
(declare-fun sel (T102 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'27| () T102)
(declare-fun var__temp_h25 () T102)
(assert true)
(assert (let ((a!1 (=> (= (sel var__temp_h25 res) 0)
               (not (> (sel var__temp_h25 res) 20))))
      (a!2 (=> (not (> (sel var__temp_h25 res) 20))
               (=> (= (sel |var__temp_h'27| res) (sel var__temp_h25 res))
                   (= (sel |var__temp_h'27| res) 10)))))
  (not (and a!1 a!2))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************7
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h29 --->  Ty_heap  
 var__temp_v30 --->  Ty_int  
 var__temp_h'31 --->  Ty_heap  
 var__temp_v_err32 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h29, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h29, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h29, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'31, res ) ==((sel)( , var__temp_h29, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'31, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h29 T119)
(declare-const var__temp_v30 Int)
(declare-const |var__temp_h'31| T119)
(declare-const var__temp_v_err32 T120)
(declare-const err T133)

solver 
 (declare-sort T119)
(declare-fun sel (T119 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'31| () T119)
(declare-fun var__temp_h29 () T119)
(assert true)
(assert (let ((a!1 (=> (= (sel |var__temp_h'31| res) (+ (sel var__temp_h29 res) 5))
               (= (sel |var__temp_h'31| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h29 res) 0) (= (sel var__temp_h29 res) 6))
                (=> (= (sel var__temp_h29 res) 6) a!1))))
  (not a!2))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************8
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h33 --->  Ty_heap  
 var__temp_v34 --->  Ty_int  
 var__temp_h'35 --->  Ty_heap  
 var__temp_v_err36 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h33, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h33, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h33, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'35, res ) ==((sel)( , var__temp_h33, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h'35, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h33 T136)
(declare-const var__temp_v34 Int)
(declare-const |var__temp_h'35| T136)
(declare-const var__temp_v_err36 T137)
(declare-const err T150)

solver 
 (declare-sort T136)
(declare-fun sel (T136 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'35| () T136)
(declare-fun var__temp_h33 () T136)
(assert true)
(assert (let ((a!1 (=> (= (sel |var__temp_h'35| res) (+ (sel var__temp_h33 res) 10))
               (= (sel |var__temp_h'35| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h33 res) 0) (> (sel var__temp_h33 res) 4))
                (=> (> (sel var__temp_h33 res) 4) a!1))))
  (not a!2))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************9
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 20} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h37 --->  Ty_heap  
 var__temp_v38 --->  Ty_int  
 var__temp_h'39 --->  Ty_heap  
 var__temp_v_err40 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h37, res ) ==(0) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'39, res ) ==(var__temp_v38) AND 
 	 Base var__temp_v38 = 20 => 
 	 Rel (sel)( , var__temp_h'39, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h37 T153)
(declare-const var__temp_v38 Int)
(declare-const |var__temp_h'39| T153)
(declare-const var__temp_v_err40 T154)
(declare-const err T167)
    (declare-const |20| Int)
  
solver 
 (declare-sort T153)
(declare-fun |20| () Int)
(declare-fun sel (T153 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'39| () T153)
(declare-fun var__temp_v38 () Int)
(declare-fun var__temp_h37 () T153)
(assert true)
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel |var__temp_h'39| res) var__temp_v38)
                    (= var__temp_v38 |20|))
               (= (sel |var__temp_h'39| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h37 res) 0) true) (=> true a!1))))
  (not a!2))))

***************Selection Failed************foo'
 *********************Enumeration Iteration*****************10
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h41 --->  Ty_heap  
 var__temp_v42 --->  Ty_int  
 var__temp_h'43 --->  Ty_heap  
 var__temp_v_err44 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h41, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h41, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h41, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'43, res ) ==((sel)( , var__temp_h41, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'43, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h41 T170)
(declare-const var__temp_v42 Int)
(declare-const |var__temp_h'43| T170)
(declare-const var__temp_v_err44 T171)
(declare-const err T184)

solver 
 (declare-sort T170)
(declare-fun sel (T170 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'43| () T170)
(declare-fun var__temp_h41 () T170)
(assert true)
(assert (let ((a!1 (=> (= (sel |var__temp_h'43| res) (+ (sel var__temp_h41 res) 3))
               (= (sel |var__temp_h'43| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h41 res) 0) (= (sel var__temp_h41 res) 7))
                (=> (= (sel var__temp_h41 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************11
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (3) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h45 --->  Ty_heap  
 var__temp_v46 --->  Ty_int  
 var__temp_h'47 --->  Ty_heap  
 var__temp_v_err48 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h45, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h45, res ) > (3) AND 
 	 Rel (sel)( , var__temp_h45, res ) > (3) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'47, res ) ==(var__temp_v46) AND 
 	 Base var__temp_v46 = 5 => 
 	 Rel (sel)( , var__temp_h'47, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h45 T187)
(declare-const var__temp_v46 Int)
(declare-const |var__temp_h'47| T187)
(declare-const var__temp_v_err48 T188)
(declare-const err T201)
    (declare-const |5| Int)
  
solver 
 (declare-sort T187)
(declare-fun |5| () Int)
(declare-fun sel (T187 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'47| () T187)
(declare-fun var__temp_v46 () Int)
(declare-fun var__temp_h45 () T187)
(assert true)
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h45 res) 0)
               (not (> (sel var__temp_h45 res) 3))))
      (a!2 (=> (and (= (sel |var__temp_h'47| res) var__temp_v46)
                    (= var__temp_v46 |5|))
               (= (sel |var__temp_h'47| res) 10))))
(let ((a!3 (=> (not (> (sel var__temp_h45 res) 3)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************12
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h49 --->  Ty_heap  
 var__temp_v50 --->  Ty_int  
 var__temp_h'51 --->  Ty_heap  
 var__temp_v_err52 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h49, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h49, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h49, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'51, res ) ==((sel)( , var__temp_h49, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'51, res ) ==(10)
 
VC_END(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h49 T204)
(declare-const var__temp_v50 Int)
(declare-const |var__temp_h'51| T204)
(declare-const var__temp_v_err52 T205)
(declare-const err T218)

solver 
 (declare-sort T204)
(declare-fun sel (T204 Int) Int)
(declare-fun res () Int)
(declare-fun |var__temp_h'51| () T204)
(declare-fun var__temp_h49 () T204)
(assert true)
(assert (let ((a!1 (=> (= (sel |var__temp_h'51| res) (+ (sel var__temp_h49 res) 2))
               (= (sel |var__temp_h'51| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h49 res) 0) (= (sel var__temp_h49 res) 5))
                (=> (= (sel var__temp_h49 res) 5) a!1))))
  (not a!2))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************13
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {v:Ty_int | true}
isynthesizeConstApp
Spec Base {v:Ty_int | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Terms
esynthesizeBind
PARTIAL PATH
SUB 
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {var_v53:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
c3'
baz'
baz'''
baz''
c5
c4
c2'
test
c2
foo'
baz
foo
bar
 *********************Enumeration Iteration*****************14
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (8) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(0) } 
 } 
 
                                                RET :  Base {var_v53:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h54 --->  Ty_heap  
 var__temp_v55 --->  Ty_int  
 var__temp_h'56 --->  Ty_heap  
 var__temp_v_err57 --->  error 
 	 ANTE True 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h54, res ) ==(0) => 
 	 Rel (sel)( , var__temp_h54, res ) > (8) AND 
 	 Rel (sel)( , var__temp_h54, res ) > (8) => 
 	 Rel (sel)( , var__temp_h'56, res ) ==((sel)( , var__temp_h54, res ) + (3)) => 
 	 True
 
VC_END(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h54 T221)
(declare-const var__temp_v55 Int)
(declare-const |var__temp_h'56| T221)
(declare-const var__temp_v_err57 T222)
(declare-const err T235)

solver 
 (declare-sort T221)
(declare-fun sel (T221 Int) Int)
(declare-fun res () Int)
(declare-fun var__temp_h54 () T221)
(declare-fun |var__temp_h'56| () T221)
(assert true)
(assert (let ((a!1 (=> (= (sel var__temp_h54 res) 0)
               (not (> (sel var__temp_h54 res) 8))))
      (a!2 (=> (= (sel |var__temp_h'56| res) (+ (sel var__temp_h54 res) 3))
               true)))
(let ((a!3 (=> (not (> (sel var__temp_h54 res) 8)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Successful************c3'
PARTIAL PATH NEW
NEW 	 --c3'
post_substituted Forall 
 	 
 Key =var_h_i59 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i59 Value = Ty_heap{ (sel)( , var_h_i59, res ) ==((sel)( , var_h58, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v60:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i59 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
c4
c2'
test
c2
foo'
baz
foo
bar
 *********************Enumeration Iteration*****************15
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i59 Value = Ty_heap{ (sel)( , var_h_i59, res ) ==((sel)( , var_h58, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v60:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i59 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h61 --->  Ty_heap  
 var__temp_v62 --->  Ty_int  
 var__temp_h'63 --->  Ty_heap  
 var__temp_v_err64 --->  error  
 var_h58 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h61, res ) ==((sel)( , var_h58, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h61, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h61, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'63, res ) ==((sel)( , var__temp_h61, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'63, res ) ==(10)
 
VC_END(declare-const var_h_i59 T238)
(declare-const var_h58 T238)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h61 T238)
(declare-const var__temp_v62 Int)
(declare-const |var__temp_h'63| T238)
(declare-const var__temp_v_err64 T239)
(declare-const var_h58 T238)
(declare-const err T252)

solver 
 (declare-sort T238)
(declare-fun sel (T238 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T238)
(declare-fun |var__temp_h'63| () T238)
(declare-fun var__temp_h61 () T238)
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h61 res) (+ (sel var_h58 res) 3))
               (= (sel var__temp_h61 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'63| res) (+ (sel var__temp_h61 res) 4))
               (= (sel |var__temp_h'63| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h61 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************16
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i59 Value = Ty_heap{ (sel)( , var_h_i59, res ) ==((sel)( , var_h58, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v60:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i59 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h65 --->  Ty_heap  
 var__temp_v66 --->  Ty_int  
 var__temp_h'67 --->  Ty_heap  
 var__temp_v_err68 --->  error  
 var_h58 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h65, res ) ==((sel)( , var_h58, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h65, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h65, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'67, res ) ==((sel)( , var__temp_h65, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'67, res ) ==(10)
 
VC_END(declare-const var_h_i59 T255)
(declare-const var_h58 T255)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h65 T255)
(declare-const var__temp_v66 Int)
(declare-const |var__temp_h'67| T255)
(declare-const var__temp_v_err68 T256)
(declare-const var_h58 T255)
(declare-const err T269)

solver 
 (declare-sort T255)
(declare-fun sel (T255 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T255)
(declare-fun |var__temp_h'67| () T255)
(declare-fun var__temp_h65 () T255)
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h65 res) (+ (sel var_h58 res) 3))
               (= (sel var__temp_h65 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'67| res) (+ (sel var__temp_h65 res) 4))
               (= (sel |var__temp_h'67| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h65 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************17
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i59 Value = Ty_heap{ (sel)( , var_h_i59, res ) ==((sel)( , var_h58, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v60:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i59 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h69 --->  Ty_heap  
 var__temp_v70 --->  Ty_int  
 var__temp_h'71 --->  Ty_heap  
 var__temp_v_err72 --->  error  
 var_h58 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h69, res ) ==((sel)( , var_h58, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h69, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h69, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'71, res ) ==((sel)( , var__temp_h69, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'71, res ) ==(10)
 
VC_END(declare-const var_h_i59 T272)
(declare-const var_h58 T272)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h69 T272)
(declare-const var__temp_v70 Int)
(declare-const |var__temp_h'71| T272)
(declare-const var__temp_v_err72 T273)
(declare-const var_h58 T272)
(declare-const err T286)

solver 
 (declare-sort T272)
(declare-fun sel (T272 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T272)
(declare-fun |var__temp_h'71| () T272)
(declare-fun var__temp_h69 () T272)
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h69 res) (+ (sel var_h58 res) 3))
               (= (sel var__temp_h69 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'71| res) (+ (sel var__temp_h69 res) 4))
               (= (sel |var__temp_h'71| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h69 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************18
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i59 Value = Ty_heap{ (sel)( , var_h_i59, res ) ==((sel)( , var_h58, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v60:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i59 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h73 --->  Ty_heap  
 var__temp_v74 --->  Ty_int  
 var__temp_h'75 --->  Ty_heap  
 var__temp_v_err76 --->  error  
 var_h58 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h73, res ) ==((sel)( , var_h58, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h73, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h73, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'75, res ) ==((sel)( , var__temp_h73, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'75, res ) ==(10)
 
VC_END(declare-const var_h_i59 T289)
(declare-const var_h58 T289)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h73 T289)
(declare-const var__temp_v74 Int)
(declare-const |var__temp_h'75| T289)
(declare-const var__temp_v_err76 T290)
(declare-const var_h58 T289)
(declare-const err T303)

solver 
 (declare-sort T289)
(declare-fun sel (T289 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T289)
(declare-fun |var__temp_h'75| () T289)
(declare-fun var__temp_h73 () T289)
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h73 res) (+ (sel var_h58 res) 3))
               (= (sel var__temp_h73 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'75| res) (+ (sel var__temp_h73 res) 5))
               (= (sel |var__temp_h'75| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h73 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************19
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (30) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (6)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i59 Value = Ty_heap{ (sel)( , var_h_i59, res ) ==((sel)( , var_h58, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v60:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i59 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (6)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h77 --->  Ty_heap  
 var__temp_v78 --->  Ty_int  
 var__temp_h'79 --->  Ty_heap  
 var__temp_v_err80 --->  error  
 var_h58 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h77, res ) ==((sel)( , var_h58, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h77, res ) > (30) AND 
 	 Rel (sel)( , var__temp_h77, res ) > (30) => 
 	 Rel (sel)( , var__temp_h'79, res ) ==((sel)( , var__temp_h77, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h'79, res ) ==(10)
 
VC_END(declare-const var_h_i59 T306)
(declare-const var_h58 T306)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h77 T306)
(declare-const var__temp_v78 Int)
(declare-const |var__temp_h'79| T306)
(declare-const var__temp_v_err80 T307)
(declare-const var_h58 T306)
(declare-const err T320)

solver 
 (declare-sort T306)
(declare-fun sel (T306 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T306)
(declare-fun |var__temp_h'79| () T306)
(declare-fun var__temp_h77 () T306)
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h77 res) (+ (sel var_h58 res) 3))
               (not (> (sel var__temp_h77 res) 30))))
      (a!2 (=> (= (sel |var__temp_h'79| res) (+ (sel var__temp_h77 res) 6))
               (= (sel |var__temp_h'79| res) 10))))
(let ((a!3 (=> (not (> (sel var__temp_h77 res) 30)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************c4
 *********************Enumeration Iteration*****************20
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i59 Value = Ty_heap{ (sel)( , var_h_i59, res ) ==((sel)( , var_h58, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v60:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i59 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h81 --->  Ty_heap  
 var__temp_v82 --->  Ty_int  
 var__temp_h'83 --->  Ty_heap  
 var__temp_v_err84 --->  error  
 var_h58 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h81, res ) ==((sel)( , var_h58, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h81, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h81, res ) > (20) => 
 	 Rel (sel)( , var__temp_h'83, res ) ==(sel)( , var__temp_h81, res ) => 
 	 Rel (sel)( , var__temp_h'83, res ) ==(10)
 
VC_END(declare-const var_h_i59 T323)
(declare-const var_h58 T323)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h81 T323)
(declare-const var__temp_v82 Int)
(declare-const |var__temp_h'83| T323)
(declare-const var__temp_v_err84 T324)
(declare-const var_h58 T323)
(declare-const err T337)

solver 
 (declare-sort T323)
(declare-fun sel (T323 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T323)
(declare-fun |var__temp_h'83| () T323)
(declare-fun var__temp_h81 () T323)
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h81 res) (+ (sel var_h58 res) 3))
               (not (> (sel var__temp_h81 res) 20))))
      (a!2 (=> (not (> (sel var__temp_h81 res) 20))
               (=> (= (sel |var__temp_h'83| res) (sel var__temp_h81 res))
                   (= (sel |var__temp_h'83| res) 10)))))
  (not (and a!1 a!2))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************21
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i59 Value = Ty_heap{ (sel)( , var_h_i59, res ) ==((sel)( , var_h58, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v60:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i59 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h85 --->  Ty_heap  
 var__temp_v86 --->  Ty_int  
 var__temp_h'87 --->  Ty_heap  
 var__temp_v_err88 --->  error  
 var_h58 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h85, res ) ==((sel)( , var_h58, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h85, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h85, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'87, res ) ==((sel)( , var__temp_h85, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'87, res ) ==(10)
 
VC_END(declare-const var_h_i59 T340)
(declare-const var_h58 T340)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h85 T340)
(declare-const var__temp_v86 Int)
(declare-const |var__temp_h'87| T340)
(declare-const var__temp_v_err88 T341)
(declare-const var_h58 T340)
(declare-const err T354)

solver 
 (declare-sort T340)
(declare-fun sel (T340 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T340)
(declare-fun |var__temp_h'87| () T340)
(declare-fun var__temp_h85 () T340)
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h85 res) (+ (sel var_h58 res) 3))
               (= (sel var__temp_h85 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'87| res) (+ (sel var__temp_h85 res) 5))
               (= (sel |var__temp_h'87| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h85 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************22
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i59 Value = Ty_heap{ (sel)( , var_h_i59, res ) ==((sel)( , var_h58, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v60:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i59 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h89 --->  Ty_heap  
 var__temp_v90 --->  Ty_int  
 var__temp_h'91 --->  Ty_heap  
 var__temp_v_err92 --->  error  
 var_h58 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h89, res ) ==((sel)( , var_h58, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h89, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h89, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'91, res ) ==((sel)( , var__temp_h89, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h'91, res ) ==(10)
 
VC_END(declare-const var_h_i59 T357)
(declare-const var_h58 T357)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h89 T357)
(declare-const var__temp_v90 Int)
(declare-const |var__temp_h'91| T357)
(declare-const var__temp_v_err92 T358)
(declare-const var_h58 T357)
(declare-const err T371)

solver 
 (declare-sort T357)
(declare-fun sel (T357 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T357)
(declare-fun |var__temp_h'91| () T357)
(declare-fun var__temp_h89 () T357)
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h89 res) (+ (sel var_h58 res) 3))
               (> (sel var__temp_h89 res) 4)))
      (a!2 (=> (= (sel |var__temp_h'91| res) (+ (sel var__temp_h89 res) 10))
               (= (sel |var__temp_h'91| res) 10))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h89 res) 4) a!2))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************23
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 20} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i59 Value = Ty_heap{ (sel)( , var_h_i59, res ) ==((sel)( , var_h58, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v60:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i59 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h93 --->  Ty_heap  
 var__temp_v94 --->  Ty_int  
 var__temp_h'95 --->  Ty_heap  
 var__temp_v_err96 --->  error  
 var_h58 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h93, res ) ==((sel)( , var_h58, res ) + (3)) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'95, res ) ==(var__temp_v94) AND 
 	 Base var__temp_v94 = 20 => 
 	 Rel (sel)( , var__temp_h'95, res ) ==(10)
 
VC_END(declare-const var_h_i59 T374)
(declare-const var_h58 T374)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h93 T374)
(declare-const var__temp_v94 Int)
(declare-const |var__temp_h'95| T374)
(declare-const var__temp_v_err96 T375)
(declare-const var_h58 T374)
(declare-const err T388)
    (declare-const |20| Int)
  
solver 
 (declare-sort T374)
(declare-fun sel (T374 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T374)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'95| () T374)
(declare-fun var__temp_v94 () Int)
(declare-fun var__temp_h93 () T374)
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (= (sel var__temp_h93 res) (+ (sel var_h58 res) 3)) true))
      (a!2 (=> (and (= (sel |var__temp_h'95| res) var__temp_v94)
                    (= var__temp_v94 |20|))
               (= (sel |var__temp_h'95| res) 10))))
  (not (and a!1 (=> true a!2)))))

***************Selection Failed************foo'
 *********************Enumeration Iteration*****************24
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i59 Value = Ty_heap{ (sel)( , var_h_i59, res ) ==((sel)( , var_h58, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v60:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i59 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h97 --->  Ty_heap  
 var__temp_v98 --->  Ty_int  
 var__temp_h'99 --->  Ty_heap  
 var__temp_v_err100 --->  error  
 var_h58 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h97, res ) ==((sel)( , var_h58, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h97, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h97, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'99, res ) ==((sel)( , var__temp_h97, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'99, res ) ==(10)
 
VC_END(declare-const var_h_i59 T391)
(declare-const var_h58 T391)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h97 T391)
(declare-const var__temp_v98 Int)
(declare-const |var__temp_h'99| T391)
(declare-const var__temp_v_err100 T392)
(declare-const var_h58 T391)
(declare-const err T405)

solver 
 (declare-sort T391)
(declare-fun sel (T391 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T391)
(declare-fun |var__temp_h'99| () T391)
(declare-fun var__temp_h97 () T391)
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h97 res) (+ (sel var_h58 res) 3))
               (= (sel var__temp_h97 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'99| res) (+ (sel var__temp_h97 res) 3))
               (= (sel |var__temp_h'99| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h97 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************25
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (3) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i59 Value = Ty_heap{ (sel)( , var_h_i59, res ) ==((sel)( , var_h58, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v60:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i59 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h101 --->  Ty_heap  
 var__temp_v102 --->  Ty_int  
 var__temp_h'103 --->  Ty_heap  
 var__temp_v_err104 --->  error  
 var_h58 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h101, res ) ==((sel)( , var_h58, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h101, res ) > (3) AND 
 	 Rel (sel)( , var__temp_h101, res ) > (3) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'103, res ) ==(var__temp_v102) AND 
 	 Base var__temp_v102 = 5 => 
 	 Rel (sel)( , var__temp_h'103, res ) ==(10)
 
VC_END(declare-const var_h_i59 T408)
(declare-const var_h58 T408)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h101 T408)
(declare-const var__temp_v102 Int)
(declare-const |var__temp_h'103| T408)
(declare-const var__temp_v_err104 T409)
(declare-const var_h58 T408)
(declare-const err T422)
    (declare-const |5| Int)
  
solver 
 (declare-sort T408)
(declare-fun sel (T408 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T408)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'103| () T408)
(declare-fun var__temp_v102 () Int)
(declare-fun var__temp_h101 () T408)
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h101 res) (+ (sel var_h58 res) 3))
               (not (> (sel var__temp_h101 res) 3))))
      (a!2 (=> (and (= (sel |var__temp_h'103| res) var__temp_v102)
                    (= var__temp_v102 |5|))
               (= (sel |var__temp_h'103| res) 10))))
(let ((a!3 (=> (not (> (sel var__temp_h101 res) 3)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************26
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i59 Value = Ty_heap{ (sel)( , var_h_i59, res ) ==((sel)( , var_h58, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v60:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i59 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h105 --->  Ty_heap  
 var__temp_v106 --->  Ty_int  
 var__temp_h'107 --->  Ty_heap  
 var__temp_v_err108 --->  error  
 var_h58 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h105, res ) ==((sel)( , var_h58, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h105, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h105, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'107, res ) ==((sel)( , var__temp_h105, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'107, res ) ==(10)
 
VC_END(declare-const var_h_i59 T425)
(declare-const var_h58 T425)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h105 T425)
(declare-const var__temp_v106 Int)
(declare-const |var__temp_h'107| T425)
(declare-const var__temp_v_err108 T426)
(declare-const var_h58 T425)
(declare-const err T439)

solver 
 (declare-sort T425)
(declare-fun sel (T425 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T425)
(declare-fun |var__temp_h'107| () T425)
(declare-fun var__temp_h105 () T425)
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h105 res) (+ (sel var_h58 res) 3))
               (= (sel var__temp_h105 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'107| res) (+ (sel var__temp_h105 res) 2))
               (= (sel |var__temp_h'107| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h105 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************27
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v60:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v60:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i59 Value = Ty_heap{ (sel)( , var_h_i59, res ) ==((sel)( , var_h58, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v109:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
c4
c2'
test
c2
foo'
baz
foo
bar
 *********************Enumeration Iteration*****************28
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i59 Value = Ty_heap{ (sel)( , var_h_i59, res ) ==((sel)( , var_h58, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v109:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h110 --->  Ty_heap  
 var__temp_v111 --->  Ty_int  
 var__temp_h'112 --->  Ty_heap  
 var__temp_v_err113 --->  error  
 var_h58 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h110, res ) ==((sel)( , var_h58, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h110, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h110, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'112, res ) ==((sel)( , var__temp_h110, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i59 T442)
(declare-const var_h58 T442)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h110 T442)
(declare-const var__temp_v111 Int)
(declare-const |var__temp_h'112| T442)
(declare-const var__temp_v_err113 T443)
(declare-const var_h58 T442)
(declare-const err T456)

solver 
 (declare-sort T442)
(declare-fun sel (T442 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T442)
(declare-fun var__temp_h110 () T442)
(declare-fun |var__temp_h'112| () T442)
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h110 res) (+ (sel var_h58 res) 3))
               (= (sel var__temp_h110 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'112| res) (+ (sel var__temp_h110 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h110 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************29
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i59 Value = Ty_heap{ (sel)( , var_h_i59, res ) ==((sel)( , var_h58, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v109:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h114 --->  Ty_heap  
 var__temp_v115 --->  Ty_int  
 var__temp_h'116 --->  Ty_heap  
 var__temp_v_err117 --->  error  
 var_h58 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h114, res ) ==((sel)( , var_h58, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h114, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h114, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'116, res ) ==((sel)( , var__temp_h114, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i59 T459)
(declare-const var_h58 T459)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h114 T459)
(declare-const var__temp_v115 Int)
(declare-const |var__temp_h'116| T459)
(declare-const var__temp_v_err117 T460)
(declare-const var_h58 T459)
(declare-const err T473)

solver 
 (declare-sort T459)
(declare-fun sel (T459 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T459)
(declare-fun var__temp_h114 () T459)
(declare-fun |var__temp_h'116| () T459)
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h114 res) (+ (sel var_h58 res) 3))
               (= (sel var__temp_h114 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'116| res) (+ (sel var__temp_h114 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h114 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************30
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i59 Value = Ty_heap{ (sel)( , var_h_i59, res ) ==((sel)( , var_h58, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v109:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h118 --->  Ty_heap  
 var__temp_v119 --->  Ty_int  
 var__temp_h'120 --->  Ty_heap  
 var__temp_v_err121 --->  error  
 var_h58 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h118, res ) ==((sel)( , var_h58, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h118, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h118, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'120, res ) ==((sel)( , var__temp_h118, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i59 T476)
(declare-const var_h58 T476)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h118 T476)
(declare-const var__temp_v119 Int)
(declare-const |var__temp_h'120| T476)
(declare-const var__temp_v_err121 T477)
(declare-const var_h58 T476)
(declare-const err T490)

solver 
 (declare-sort T476)
(declare-fun sel (T476 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T476)
(declare-fun var__temp_h118 () T476)
(declare-fun |var__temp_h'120| () T476)
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h118 res) (+ (sel var_h58 res) 3))
               (= (sel var__temp_h118 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'120| res) (+ (sel var__temp_h118 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h118 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************31
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i59 Value = Ty_heap{ (sel)( , var_h_i59, res ) ==((sel)( , var_h58, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v109:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h122 --->  Ty_heap  
 var__temp_v123 --->  Ty_int  
 var__temp_h'124 --->  Ty_heap  
 var__temp_v_err125 --->  error  
 var_h58 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h122, res ) ==((sel)( , var_h58, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h122, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h122, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'124, res ) ==((sel)( , var__temp_h122, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i59 T493)
(declare-const var_h58 T493)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h122 T493)
(declare-const var__temp_v123 Int)
(declare-const |var__temp_h'124| T493)
(declare-const var__temp_v_err125 T494)
(declare-const var_h58 T493)
(declare-const err T507)

solver 
 (declare-sort T493)
(declare-fun sel (T493 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T493)
(declare-fun var__temp_h122 () T493)
(declare-fun |var__temp_h'124| () T493)
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h122 res) (+ (sel var_h58 res) 3))
               (= (sel var__temp_h122 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'124| res) (+ (sel var__temp_h122 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h122 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************32
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (30) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (6)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i59 Value = Ty_heap{ (sel)( , var_h_i59, res ) ==((sel)( , var_h58, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v109:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (6)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h126 --->  Ty_heap  
 var__temp_v127 --->  Ty_int  
 var__temp_h'128 --->  Ty_heap  
 var__temp_v_err129 --->  error  
 var_h58 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h126, res ) ==((sel)( , var_h58, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h126, res ) > (30) AND 
 	 Rel (sel)( , var__temp_h126, res ) > (30) => 
 	 Rel (sel)( , var__temp_h'128, res ) ==((sel)( , var__temp_h126, res ) + (6)) => 
 	 True
 
VC_END(declare-const var_h_i59 T510)
(declare-const var_h58 T510)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h126 T510)
(declare-const var__temp_v127 Int)
(declare-const |var__temp_h'128| T510)
(declare-const var__temp_v_err129 T511)
(declare-const var_h58 T510)
(declare-const err T524)

solver 
 (declare-sort T510)
(declare-fun sel (T510 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T510)
(declare-fun var__temp_h126 () T510)
(declare-fun |var__temp_h'128| () T510)
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h126 res) (+ (sel var_h58 res) 3))
               (not (> (sel var__temp_h126 res) 30))))
      (a!2 (=> (= (sel |var__temp_h'128| res) (+ (sel var__temp_h126 res) 6))
               true)))
(let ((a!3 (=> (not (> (sel var__temp_h126 res) 30)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Successful************c4
PARTIAL PATH NEW
NEW 	 --c3'	 --c4
post_substituted Forall 
 	 
 Key =var_h_i131 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v132:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i131 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
c2'
test
c2
foo'
baz
foo
bar
 *********************Enumeration Iteration*****************33
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v132:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i131 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h133 --->  Ty_heap  
 var__temp_v134 --->  Ty_int  
 var__temp_h'135 --->  Ty_heap  
 var__temp_v_err136 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h133, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h133, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h133, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'135, res ) ==((sel)( , var__temp_h133, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'135, res ) ==(10)
 
VC_END(declare-const var_h_i131 T527)
(declare-const var_h130 T527)
(declare-const v Int)
(declare-const var_h_i59 T527)
(declare-const var_h58 T527)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h133 T527)
(declare-const var__temp_v134 Int)
(declare-const |var__temp_h'135| T527)
(declare-const var__temp_v_err136 T528)
(declare-const var_h130 T527)
(declare-const var_h58 T527)
(declare-const err T541)

solver 
 (declare-sort T527)
(declare-fun sel (T527 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T527)
(declare-fun var_h130 () T527)
(declare-fun |var__temp_h'135| () T527)
(declare-fun var__temp_h133 () T527)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h133 res) (+ (sel var_h130 res) 6))
               (= (sel var__temp_h133 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'135| res) (+ (sel var__temp_h133 res) 4))
               (= (sel |var__temp_h'135| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h133 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************34
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v132:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i131 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h137 --->  Ty_heap  
 var__temp_v138 --->  Ty_int  
 var__temp_h'139 --->  Ty_heap  
 var__temp_v_err140 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h137, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h137, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h137, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'139, res ) ==((sel)( , var__temp_h137, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'139, res ) ==(10)
 
VC_END(declare-const var_h_i131 T544)
(declare-const var_h130 T544)
(declare-const v Int)
(declare-const var_h_i59 T544)
(declare-const var_h58 T544)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h137 T544)
(declare-const var__temp_v138 Int)
(declare-const |var__temp_h'139| T544)
(declare-const var__temp_v_err140 T545)
(declare-const var_h130 T544)
(declare-const var_h58 T544)
(declare-const err T558)

solver 
 (declare-sort T544)
(declare-fun sel (T544 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T544)
(declare-fun var_h130 () T544)
(declare-fun |var__temp_h'139| () T544)
(declare-fun var__temp_h137 () T544)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h137 res) (+ (sel var_h130 res) 6))
               (= (sel var__temp_h137 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'139| res) (+ (sel var__temp_h137 res) 4))
               (= (sel |var__temp_h'139| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h137 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************35
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v132:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i131 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h141 --->  Ty_heap  
 var__temp_v142 --->  Ty_int  
 var__temp_h'143 --->  Ty_heap  
 var__temp_v_err144 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h141, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h141, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h141, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'143, res ) ==((sel)( , var__temp_h141, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'143, res ) ==(10)
 
VC_END(declare-const var_h_i131 T561)
(declare-const var_h130 T561)
(declare-const v Int)
(declare-const var_h_i59 T561)
(declare-const var_h58 T561)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h141 T561)
(declare-const var__temp_v142 Int)
(declare-const |var__temp_h'143| T561)
(declare-const var__temp_v_err144 T562)
(declare-const var_h130 T561)
(declare-const var_h58 T561)
(declare-const err T575)

solver 
 (declare-sort T561)
(declare-fun sel (T561 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T561)
(declare-fun var_h130 () T561)
(declare-fun |var__temp_h'143| () T561)
(declare-fun var__temp_h141 () T561)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h141 res) (+ (sel var_h130 res) 6))
               (= (sel var__temp_h141 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'143| res) (+ (sel var__temp_h141 res) 4))
               (= (sel |var__temp_h'143| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h141 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************36
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v132:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i131 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h145 --->  Ty_heap  
 var__temp_v146 --->  Ty_int  
 var__temp_h'147 --->  Ty_heap  
 var__temp_v_err148 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h145, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h145, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h145, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'147, res ) ==((sel)( , var__temp_h145, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'147, res ) ==(10)
 
VC_END(declare-const var_h_i131 T578)
(declare-const var_h130 T578)
(declare-const v Int)
(declare-const var_h_i59 T578)
(declare-const var_h58 T578)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h145 T578)
(declare-const var__temp_v146 Int)
(declare-const |var__temp_h'147| T578)
(declare-const var__temp_v_err148 T579)
(declare-const var_h130 T578)
(declare-const var_h58 T578)
(declare-const err T592)

solver 
 (declare-sort T578)
(declare-fun sel (T578 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T578)
(declare-fun var_h130 () T578)
(declare-fun |var__temp_h'147| () T578)
(declare-fun var__temp_h145 () T578)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h145 res) (+ (sel var_h130 res) 6))
               (= (sel var__temp_h145 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'147| res) (+ (sel var__temp_h145 res) 5))
               (= (sel |var__temp_h'147| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h145 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************37
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v132:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i131 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h149 --->  Ty_heap  
 var__temp_v150 --->  Ty_int  
 var__temp_h'151 --->  Ty_heap  
 var__temp_v_err152 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h149, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h149, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h149, res ) > (20) => 
 	 Rel (sel)( , var__temp_h'151, res ) ==(sel)( , var__temp_h149, res ) => 
 	 Rel (sel)( , var__temp_h'151, res ) ==(10)
 
VC_END(declare-const var_h_i131 T595)
(declare-const var_h130 T595)
(declare-const v Int)
(declare-const var_h_i59 T595)
(declare-const var_h58 T595)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h149 T595)
(declare-const var__temp_v150 Int)
(declare-const |var__temp_h'151| T595)
(declare-const var__temp_v_err152 T596)
(declare-const var_h130 T595)
(declare-const var_h58 T595)
(declare-const err T609)

solver 
 (declare-sort T595)
(declare-fun sel (T595 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T595)
(declare-fun var_h130 () T595)
(declare-fun |var__temp_h'151| () T595)
(declare-fun var__temp_h149 () T595)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h149 res) (+ (sel var_h130 res) 6))
               (not (> (sel var__temp_h149 res) 20))))
      (a!2 (=> (not (> (sel var__temp_h149 res) 20))
               (=> (= (sel |var__temp_h'151| res) (sel var__temp_h149 res))
                   (= (sel |var__temp_h'151| res) 10)))))
  (not (and a!1 a!2))))

***************Selection Failed************c2'
 *********************Enumeration Iteration*****************38
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v132:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i131 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h153 --->  Ty_heap  
 var__temp_v154 --->  Ty_int  
 var__temp_h'155 --->  Ty_heap  
 var__temp_v_err156 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h153, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h153, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h153, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'155, res ) ==((sel)( , var__temp_h153, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'155, res ) ==(10)
 
VC_END(declare-const var_h_i131 T612)
(declare-const var_h130 T612)
(declare-const v Int)
(declare-const var_h_i59 T612)
(declare-const var_h58 T612)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h153 T612)
(declare-const var__temp_v154 Int)
(declare-const |var__temp_h'155| T612)
(declare-const var__temp_v_err156 T613)
(declare-const var_h130 T612)
(declare-const var_h58 T612)
(declare-const err T626)

solver 
 (declare-sort T612)
(declare-fun sel (T612 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T612)
(declare-fun var_h130 () T612)
(declare-fun |var__temp_h'155| () T612)
(declare-fun var__temp_h153 () T612)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h153 res) (+ (sel var_h130 res) 6))
               (= (sel var__temp_h153 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'155| res) (+ (sel var__temp_h153 res) 5))
               (= (sel |var__temp_h'155| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h153 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************39
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v132:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i131 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h157 --->  Ty_heap  
 var__temp_v158 --->  Ty_int  
 var__temp_h'159 --->  Ty_heap  
 var__temp_v_err160 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h157, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h157, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h157, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'159, res ) ==((sel)( , var__temp_h157, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h'159, res ) ==(10)
 
VC_END(declare-const var_h_i131 T629)
(declare-const var_h130 T629)
(declare-const v Int)
(declare-const var_h_i59 T629)
(declare-const var_h58 T629)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h157 T629)
(declare-const var__temp_v158 Int)
(declare-const |var__temp_h'159| T629)
(declare-const var__temp_v_err160 T630)
(declare-const var_h130 T629)
(declare-const var_h58 T629)
(declare-const err T643)

solver 
 (declare-sort T629)
(declare-fun sel (T629 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T629)
(declare-fun var_h130 () T629)
(declare-fun |var__temp_h'159| () T629)
(declare-fun var__temp_h157 () T629)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h157 res) (+ (sel var_h130 res) 6))
               (> (sel var__temp_h157 res) 4)))
      (a!2 (=> (= (sel |var__temp_h'159| res) (+ (sel var__temp_h157 res) 10))
               (= (sel |var__temp_h'159| res) 10))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h157 res) 4) a!2))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************40
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 20} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v132:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i131 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h161 --->  Ty_heap  
 var__temp_v162 --->  Ty_int  
 var__temp_h'163 --->  Ty_heap  
 var__temp_v_err164 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h161, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'163, res ) ==(var__temp_v162) AND 
 	 Base var__temp_v162 = 20 => 
 	 Rel (sel)( , var__temp_h'163, res ) ==(10)
 
VC_END(declare-const var_h_i131 T646)
(declare-const var_h130 T646)
(declare-const v Int)
(declare-const var_h_i59 T646)
(declare-const var_h58 T646)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h161 T646)
(declare-const var__temp_v162 Int)
(declare-const |var__temp_h'163| T646)
(declare-const var__temp_v_err164 T647)
(declare-const var_h130 T646)
(declare-const var_h58 T646)
(declare-const err T660)
    (declare-const |20| Int)
  
solver 
 (declare-sort T646)
(declare-fun sel (T646 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T646)
(declare-fun var_h130 () T646)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'163| () T646)
(declare-fun var__temp_v162 () Int)
(declare-fun var__temp_h161 () T646)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (= (sel var__temp_h161 res) (+ (sel var_h130 res) 6)) true))
      (a!2 (=> (and (= (sel |var__temp_h'163| res) var__temp_v162)
                    (= var__temp_v162 |20|))
               (= (sel |var__temp_h'163| res) 10))))
  (not (and a!1 (=> true a!2)))))

***************Selection Failed************foo'
 *********************Enumeration Iteration*****************41
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v132:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i131 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h165 --->  Ty_heap  
 var__temp_v166 --->  Ty_int  
 var__temp_h'167 --->  Ty_heap  
 var__temp_v_err168 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h165, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h165, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h165, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'167, res ) ==((sel)( , var__temp_h165, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'167, res ) ==(10)
 
VC_END(declare-const var_h_i131 T663)
(declare-const var_h130 T663)
(declare-const v Int)
(declare-const var_h_i59 T663)
(declare-const var_h58 T663)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h165 T663)
(declare-const var__temp_v166 Int)
(declare-const |var__temp_h'167| T663)
(declare-const var__temp_v_err168 T664)
(declare-const var_h130 T663)
(declare-const var_h58 T663)
(declare-const err T677)

solver 
 (declare-sort T663)
(declare-fun sel (T663 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T663)
(declare-fun var_h130 () T663)
(declare-fun |var__temp_h'167| () T663)
(declare-fun var__temp_h165 () T663)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h165 res) (+ (sel var_h130 res) 6))
               (= (sel var__temp_h165 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'167| res) (+ (sel var__temp_h165 res) 3))
               (= (sel |var__temp_h'167| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h165 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************42
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (3) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v132:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i131 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h169 --->  Ty_heap  
 var__temp_v170 --->  Ty_int  
 var__temp_h'171 --->  Ty_heap  
 var__temp_v_err172 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h169, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h169, res ) > (3) AND 
 	 Rel (sel)( , var__temp_h169, res ) > (3) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'171, res ) ==(var__temp_v170) AND 
 	 Base var__temp_v170 = 5 => 
 	 Rel (sel)( , var__temp_h'171, res ) ==(10)
 
VC_END(declare-const var_h_i131 T680)
(declare-const var_h130 T680)
(declare-const v Int)
(declare-const var_h_i59 T680)
(declare-const var_h58 T680)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h169 T680)
(declare-const var__temp_v170 Int)
(declare-const |var__temp_h'171| T680)
(declare-const var__temp_v_err172 T681)
(declare-const var_h130 T680)
(declare-const var_h58 T680)
(declare-const err T694)
    (declare-const |5| Int)
  
solver 
 (declare-sort T680)
(declare-fun sel (T680 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T680)
(declare-fun var_h130 () T680)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'171| () T680)
(declare-fun var__temp_v170 () Int)
(declare-fun var__temp_h169 () T680)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h169 res) (+ (sel var_h130 res) 6))
               (not (> (sel var__temp_h169 res) 3))))
      (a!2 (=> (and (= (sel |var__temp_h'171| res) var__temp_v170)
                    (= var__temp_v170 |5|))
               (= (sel |var__temp_h'171| res) 10))))
(let ((a!3 (=> (not (> (sel var__temp_h169 res) 3)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************43
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v132:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i131 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h173 --->  Ty_heap  
 var__temp_v174 --->  Ty_int  
 var__temp_h'175 --->  Ty_heap  
 var__temp_v_err176 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h173, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h173, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h173, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'175, res ) ==((sel)( , var__temp_h173, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'175, res ) ==(10)
 
VC_END(declare-const var_h_i131 T697)
(declare-const var_h130 T697)
(declare-const v Int)
(declare-const var_h_i59 T697)
(declare-const var_h58 T697)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h173 T697)
(declare-const var__temp_v174 Int)
(declare-const |var__temp_h'175| T697)
(declare-const var__temp_v_err176 T698)
(declare-const var_h130 T697)
(declare-const var_h58 T697)
(declare-const err T711)

solver 
 (declare-sort T697)
(declare-fun sel (T697 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T697)
(declare-fun var_h130 () T697)
(declare-fun |var__temp_h'175| () T697)
(declare-fun var__temp_h173 () T697)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h173 res) (+ (sel var_h130 res) 6))
               (= (sel var__temp_h173 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'175| res) (+ (sel var__temp_h173 res) 2))
               (= (sel |var__temp_h'175| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h173 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************44
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v132:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v132:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v177:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
c2'
test
c2
foo'
baz
foo
bar
 *********************Enumeration Iteration*****************45
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v177:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h178 --->  Ty_heap  
 var__temp_v179 --->  Ty_int  
 var__temp_h'180 --->  Ty_heap  
 var__temp_v_err181 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h178, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h178, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h178, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'180, res ) ==((sel)( , var__temp_h178, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i131 T714)
(declare-const var_h130 T714)
(declare-const v Int)
(declare-const var_h_i59 T714)
(declare-const var_h58 T714)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h178 T714)
(declare-const var__temp_v179 Int)
(declare-const |var__temp_h'180| T714)
(declare-const var__temp_v_err181 T715)
(declare-const var_h130 T714)
(declare-const var_h58 T714)
(declare-const err T728)

solver 
 (declare-sort T714)
(declare-fun sel (T714 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T714)
(declare-fun var_h130 () T714)
(declare-fun var__temp_h178 () T714)
(declare-fun |var__temp_h'180| () T714)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h178 res) (+ (sel var_h130 res) 6))
               (= (sel var__temp_h178 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'180| res) (+ (sel var__temp_h178 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h178 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************46
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v177:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h182 --->  Ty_heap  
 var__temp_v183 --->  Ty_int  
 var__temp_h'184 --->  Ty_heap  
 var__temp_v_err185 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h182, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h182, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h182, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'184, res ) ==((sel)( , var__temp_h182, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i131 T731)
(declare-const var_h130 T731)
(declare-const v Int)
(declare-const var_h_i59 T731)
(declare-const var_h58 T731)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h182 T731)
(declare-const var__temp_v183 Int)
(declare-const |var__temp_h'184| T731)
(declare-const var__temp_v_err185 T732)
(declare-const var_h130 T731)
(declare-const var_h58 T731)
(declare-const err T745)

solver 
 (declare-sort T731)
(declare-fun sel (T731 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T731)
(declare-fun var_h130 () T731)
(declare-fun var__temp_h182 () T731)
(declare-fun |var__temp_h'184| () T731)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h182 res) (+ (sel var_h130 res) 6))
               (= (sel var__temp_h182 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'184| res) (+ (sel var__temp_h182 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h182 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************47
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v177:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h186 --->  Ty_heap  
 var__temp_v187 --->  Ty_int  
 var__temp_h'188 --->  Ty_heap  
 var__temp_v_err189 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h186, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h186, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h186, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'188, res ) ==((sel)( , var__temp_h186, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i131 T748)
(declare-const var_h130 T748)
(declare-const v Int)
(declare-const var_h_i59 T748)
(declare-const var_h58 T748)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h186 T748)
(declare-const var__temp_v187 Int)
(declare-const |var__temp_h'188| T748)
(declare-const var__temp_v_err189 T749)
(declare-const var_h130 T748)
(declare-const var_h58 T748)
(declare-const err T762)

solver 
 (declare-sort T748)
(declare-fun sel (T748 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T748)
(declare-fun var_h130 () T748)
(declare-fun var__temp_h186 () T748)
(declare-fun |var__temp_h'188| () T748)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h186 res) (+ (sel var_h130 res) 6))
               (= (sel var__temp_h186 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'188| res) (+ (sel var__temp_h186 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h186 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************48
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v177:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h190 --->  Ty_heap  
 var__temp_v191 --->  Ty_int  
 var__temp_h'192 --->  Ty_heap  
 var__temp_v_err193 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h190, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h190, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h190, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'192, res ) ==((sel)( , var__temp_h190, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i131 T765)
(declare-const var_h130 T765)
(declare-const v Int)
(declare-const var_h_i59 T765)
(declare-const var_h58 T765)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h190 T765)
(declare-const var__temp_v191 Int)
(declare-const |var__temp_h'192| T765)
(declare-const var__temp_v_err193 T766)
(declare-const var_h130 T765)
(declare-const var_h58 T765)
(declare-const err T779)

solver 
 (declare-sort T765)
(declare-fun sel (T765 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T765)
(declare-fun var_h130 () T765)
(declare-fun var__temp_h190 () T765)
(declare-fun |var__temp_h'192| () T765)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h190 res) (+ (sel var_h130 res) 6))
               (= (sel var__temp_h190 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'192| res) (+ (sel var__temp_h190 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h190 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************49
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v177:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h194 --->  Ty_heap  
 var__temp_v195 --->  Ty_int  
 var__temp_h'196 --->  Ty_heap  
 var__temp_v_err197 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h194, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h194, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h194, res ) > (20) => 
 	 Rel (sel)( , var__temp_h'196, res ) ==(sel)( , var__temp_h194, res ) => 
 	 True
 
VC_END(declare-const var_h_i131 T782)
(declare-const var_h130 T782)
(declare-const v Int)
(declare-const var_h_i59 T782)
(declare-const var_h58 T782)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h194 T782)
(declare-const var__temp_v195 Int)
(declare-const |var__temp_h'196| T782)
(declare-const var__temp_v_err197 T783)
(declare-const var_h130 T782)
(declare-const var_h58 T782)
(declare-const err T796)

solver 
 (declare-sort T782)
(declare-fun sel (T782 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T782)
(declare-fun var_h130 () T782)
(declare-fun var__temp_h194 () T782)
(declare-fun |var__temp_h'196| () T782)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h194 res) (+ (sel var_h130 res) 6))
               (not (> (sel var__temp_h194 res) 20))))
      (a!2 (=> (not (> (sel var__temp_h194 res) 20))
               (=> (= (sel |var__temp_h'196| res) (sel var__temp_h194 res))
                   true))))
  (not (and a!1 a!2))))

***************Selection Successful************c2'
PARTIAL PATH NEW
NEW 	 --c3'	 --c4	 --c2'
post_substituted Forall 
 	 
 Key =var_h_i199 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v200:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i199 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
c2
foo'
baz
foo
bar
 *********************Enumeration Iteration*****************50
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v200:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i199 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h201 --->  Ty_heap  
 var__temp_v202 --->  Ty_int  
 var__temp_h'203 --->  Ty_heap  
 var__temp_v_err204 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h201, res ) ==(sel)( , var_h198, res ) => 
 	 Rel (sel)( , var__temp_h201, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h201, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'203, res ) ==((sel)( , var__temp_h201, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'203, res ) ==(10)
 
VC_END(declare-const var_h_i199 T799)
(declare-const var_h198 T799)
(declare-const v Int)
(declare-const var_h_i131 T799)
(declare-const var_h130 T799)
(declare-const v Int)
(declare-const var_h_i59 T799)
(declare-const var_h58 T799)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h201 T799)
(declare-const var__temp_v202 Int)
(declare-const |var__temp_h'203| T799)
(declare-const var__temp_v_err204 T800)
(declare-const var_h198 T799)
(declare-const var_h130 T799)
(declare-const var_h58 T799)
(declare-const err T813)

solver 
 (declare-sort T799)
(declare-fun sel (T799 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T799)
(declare-fun var_h198 () T799)
(declare-fun var_h58 () T799)
(declare-fun |var__temp_h'203| () T799)
(declare-fun var__temp_h201 () T799)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'203| res) (+ (sel var__temp_h201 res) 4))
               (= (sel |var__temp_h'203| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h201 res) (sel var_h198 res))
                    (= (sel var__temp_h201 res) 7))
                (=> (= (sel var__temp_h201 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************51
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v200:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i199 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h205 --->  Ty_heap  
 var__temp_v206 --->  Ty_int  
 var__temp_h'207 --->  Ty_heap  
 var__temp_v_err208 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h205, res ) ==(sel)( , var_h198, res ) => 
 	 Rel (sel)( , var__temp_h205, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h205, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'207, res ) ==((sel)( , var__temp_h205, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'207, res ) ==(10)
 
VC_END(declare-const var_h_i199 T816)
(declare-const var_h198 T816)
(declare-const v Int)
(declare-const var_h_i131 T816)
(declare-const var_h130 T816)
(declare-const v Int)
(declare-const var_h_i59 T816)
(declare-const var_h58 T816)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h205 T816)
(declare-const var__temp_v206 Int)
(declare-const |var__temp_h'207| T816)
(declare-const var__temp_v_err208 T817)
(declare-const var_h198 T816)
(declare-const var_h130 T816)
(declare-const var_h58 T816)
(declare-const err T830)

solver 
 (declare-sort T816)
(declare-fun sel (T816 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T816)
(declare-fun var_h198 () T816)
(declare-fun var_h58 () T816)
(declare-fun |var__temp_h'207| () T816)
(declare-fun var__temp_h205 () T816)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'207| res) (+ (sel var__temp_h205 res) 4))
               (= (sel |var__temp_h'207| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h205 res) (sel var_h198 res))
                    (= (sel var__temp_h205 res) 7))
                (=> (= (sel var__temp_h205 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************52
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v200:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i199 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h209 --->  Ty_heap  
 var__temp_v210 --->  Ty_int  
 var__temp_h'211 --->  Ty_heap  
 var__temp_v_err212 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h209, res ) ==(sel)( , var_h198, res ) => 
 	 Rel (sel)( , var__temp_h209, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h209, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'211, res ) ==((sel)( , var__temp_h209, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'211, res ) ==(10)
 
VC_END(declare-const var_h_i199 T833)
(declare-const var_h198 T833)
(declare-const v Int)
(declare-const var_h_i131 T833)
(declare-const var_h130 T833)
(declare-const v Int)
(declare-const var_h_i59 T833)
(declare-const var_h58 T833)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h209 T833)
(declare-const var__temp_v210 Int)
(declare-const |var__temp_h'211| T833)
(declare-const var__temp_v_err212 T834)
(declare-const var_h198 T833)
(declare-const var_h130 T833)
(declare-const var_h58 T833)
(declare-const err T847)

solver 
 (declare-sort T833)
(declare-fun sel (T833 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T833)
(declare-fun var_h198 () T833)
(declare-fun var_h58 () T833)
(declare-fun |var__temp_h'211| () T833)
(declare-fun var__temp_h209 () T833)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'211| res) (+ (sel var__temp_h209 res) 4))
               (= (sel |var__temp_h'211| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h209 res) (sel var_h198 res))
                    (= (sel var__temp_h209 res) 7))
                (=> (= (sel var__temp_h209 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************53
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v200:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i199 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h213 --->  Ty_heap  
 var__temp_v214 --->  Ty_int  
 var__temp_h'215 --->  Ty_heap  
 var__temp_v_err216 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h213, res ) ==(sel)( , var_h198, res ) => 
 	 Rel (sel)( , var__temp_h213, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h213, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'215, res ) ==((sel)( , var__temp_h213, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'215, res ) ==(10)
 
VC_END(declare-const var_h_i199 T850)
(declare-const var_h198 T850)
(declare-const v Int)
(declare-const var_h_i131 T850)
(declare-const var_h130 T850)
(declare-const v Int)
(declare-const var_h_i59 T850)
(declare-const var_h58 T850)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h213 T850)
(declare-const var__temp_v214 Int)
(declare-const |var__temp_h'215| T850)
(declare-const var__temp_v_err216 T851)
(declare-const var_h198 T850)
(declare-const var_h130 T850)
(declare-const var_h58 T850)
(declare-const err T864)

solver 
 (declare-sort T850)
(declare-fun sel (T850 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T850)
(declare-fun var_h198 () T850)
(declare-fun var_h58 () T850)
(declare-fun |var__temp_h'215| () T850)
(declare-fun var__temp_h213 () T850)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'215| res) (+ (sel var__temp_h213 res) 5))
               (= (sel |var__temp_h'215| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h213 res) (sel var_h198 res))
                    (= (sel var__temp_h213 res) 7))
                (=> (= (sel var__temp_h213 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************54
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v200:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i199 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h217 --->  Ty_heap  
 var__temp_v218 --->  Ty_int  
 var__temp_h'219 --->  Ty_heap  
 var__temp_v_err220 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h217, res ) ==(sel)( , var_h198, res ) => 
 	 Rel (sel)( , var__temp_h217, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h217, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'219, res ) ==((sel)( , var__temp_h217, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'219, res ) ==(10)
 
VC_END(declare-const var_h_i199 T867)
(declare-const var_h198 T867)
(declare-const v Int)
(declare-const var_h_i131 T867)
(declare-const var_h130 T867)
(declare-const v Int)
(declare-const var_h_i59 T867)
(declare-const var_h58 T867)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h217 T867)
(declare-const var__temp_v218 Int)
(declare-const |var__temp_h'219| T867)
(declare-const var__temp_v_err220 T868)
(declare-const var_h198 T867)
(declare-const var_h130 T867)
(declare-const var_h58 T867)
(declare-const err T881)

solver 
 (declare-sort T867)
(declare-fun sel (T867 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T867)
(declare-fun var_h198 () T867)
(declare-fun var_h58 () T867)
(declare-fun |var__temp_h'219| () T867)
(declare-fun var__temp_h217 () T867)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'219| res) (+ (sel var__temp_h217 res) 5))
               (= (sel |var__temp_h'219| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h217 res) (sel var_h198 res))
                    (= (sel var__temp_h217 res) 6))
                (=> (= (sel var__temp_h217 res) 6) a!1))))
  (not a!2))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************55
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v200:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i199 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h221 --->  Ty_heap  
 var__temp_v222 --->  Ty_int  
 var__temp_h'223 --->  Ty_heap  
 var__temp_v_err224 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h221, res ) ==(sel)( , var_h198, res ) => 
 	 Rel (sel)( , var__temp_h221, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h221, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'223, res ) ==((sel)( , var__temp_h221, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h'223, res ) ==(10)
 
VC_END(declare-const var_h_i199 T884)
(declare-const var_h198 T884)
(declare-const v Int)
(declare-const var_h_i131 T884)
(declare-const var_h130 T884)
(declare-const v Int)
(declare-const var_h_i59 T884)
(declare-const var_h58 T884)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h221 T884)
(declare-const var__temp_v222 Int)
(declare-const |var__temp_h'223| T884)
(declare-const var__temp_v_err224 T885)
(declare-const var_h198 T884)
(declare-const var_h130 T884)
(declare-const var_h58 T884)
(declare-const err T898)

solver 
 (declare-sort T884)
(declare-fun sel (T884 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T884)
(declare-fun var_h198 () T884)
(declare-fun var_h58 () T884)
(declare-fun |var__temp_h'223| () T884)
(declare-fun var__temp_h221 () T884)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'223| res) (+ (sel var__temp_h221 res) 10))
               (= (sel |var__temp_h'223| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h221 res) (sel var_h198 res))
                    (> (sel var__temp_h221 res) 4))
                (=> (> (sel var__temp_h221 res) 4) a!1))))
  (not a!2))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************56
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 20} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v200:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i199 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h225 --->  Ty_heap  
 var__temp_v226 --->  Ty_int  
 var__temp_h'227 --->  Ty_heap  
 var__temp_v_err228 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h225, res ) ==(sel)( , var_h198, res ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'227, res ) ==(var__temp_v226) AND 
 	 Base var__temp_v226 = 20 => 
 	 Rel (sel)( , var__temp_h'227, res ) ==(10)
 
VC_END(declare-const var_h_i199 T901)
(declare-const var_h198 T901)
(declare-const v Int)
(declare-const var_h_i131 T901)
(declare-const var_h130 T901)
(declare-const v Int)
(declare-const var_h_i59 T901)
(declare-const var_h58 T901)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h225 T901)
(declare-const var__temp_v226 Int)
(declare-const |var__temp_h'227| T901)
(declare-const var__temp_v_err228 T902)
(declare-const var_h198 T901)
(declare-const var_h130 T901)
(declare-const var_h58 T901)
(declare-const err T915)
    (declare-const |20| Int)
  
solver 
 (declare-sort T901)
(declare-fun sel (T901 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T901)
(declare-fun var_h198 () T901)
(declare-fun var_h58 () T901)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'227| () T901)
(declare-fun var__temp_v226 () Int)
(declare-fun var__temp_h225 () T901)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel |var__temp_h'227| res) var__temp_v226)
                    (= var__temp_v226 |20|))
               (= (sel |var__temp_h'227| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h225 res) (sel var_h198 res)) true)
                (=> true a!1))))
  (not a!2))))

***************Selection Failed************foo'
 *********************Enumeration Iteration*****************57
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v200:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i199 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h229 --->  Ty_heap  
 var__temp_v230 --->  Ty_int  
 var__temp_h'231 --->  Ty_heap  
 var__temp_v_err232 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h229, res ) ==(sel)( , var_h198, res ) => 
 	 Rel (sel)( , var__temp_h229, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h229, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'231, res ) ==((sel)( , var__temp_h229, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'231, res ) ==(10)
 
VC_END(declare-const var_h_i199 T918)
(declare-const var_h198 T918)
(declare-const v Int)
(declare-const var_h_i131 T918)
(declare-const var_h130 T918)
(declare-const v Int)
(declare-const var_h_i59 T918)
(declare-const var_h58 T918)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h229 T918)
(declare-const var__temp_v230 Int)
(declare-const |var__temp_h'231| T918)
(declare-const var__temp_v_err232 T919)
(declare-const var_h198 T918)
(declare-const var_h130 T918)
(declare-const var_h58 T918)
(declare-const err T932)

solver 
 (declare-sort T918)
(declare-fun sel (T918 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T918)
(declare-fun var_h198 () T918)
(declare-fun var_h58 () T918)
(declare-fun |var__temp_h'231| () T918)
(declare-fun var__temp_h229 () T918)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'231| res) (+ (sel var__temp_h229 res) 3))
               (= (sel |var__temp_h'231| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h229 res) (sel var_h198 res))
                    (= (sel var__temp_h229 res) 7))
                (=> (= (sel var__temp_h229 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************58
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (3) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v200:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i199 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h233 --->  Ty_heap  
 var__temp_v234 --->  Ty_int  
 var__temp_h'235 --->  Ty_heap  
 var__temp_v_err236 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h233, res ) ==(sel)( , var_h198, res ) => 
 	 Rel (sel)( , var__temp_h233, res ) > (3) AND 
 	 Rel (sel)( , var__temp_h233, res ) > (3) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'235, res ) ==(var__temp_v234) AND 
 	 Base var__temp_v234 = 5 => 
 	 Rel (sel)( , var__temp_h'235, res ) ==(10)
 
VC_END(declare-const var_h_i199 T935)
(declare-const var_h198 T935)
(declare-const v Int)
(declare-const var_h_i131 T935)
(declare-const var_h130 T935)
(declare-const v Int)
(declare-const var_h_i59 T935)
(declare-const var_h58 T935)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h233 T935)
(declare-const var__temp_v234 Int)
(declare-const |var__temp_h'235| T935)
(declare-const var__temp_v_err236 T936)
(declare-const var_h198 T935)
(declare-const var_h130 T935)
(declare-const var_h58 T935)
(declare-const err T949)
    (declare-const |5| Int)
  
solver 
 (declare-sort T935)
(declare-fun sel (T935 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T935)
(declare-fun var_h198 () T935)
(declare-fun var_h58 () T935)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'235| () T935)
(declare-fun var__temp_v234 () Int)
(declare-fun var__temp_h233 () T935)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h233 res) (sel var_h198 res))
               (not (> (sel var__temp_h233 res) 3))))
      (a!2 (=> (and (= (sel |var__temp_h'235| res) var__temp_v234)
                    (= var__temp_v234 |5|))
               (= (sel |var__temp_h'235| res) 10))))
(let ((a!3 (=> (not (> (sel var__temp_h233 res) 3)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************59
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v200:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i199 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h237 --->  Ty_heap  
 var__temp_v238 --->  Ty_int  
 var__temp_h'239 --->  Ty_heap  
 var__temp_v_err240 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h237, res ) ==(sel)( , var_h198, res ) => 
 	 Rel (sel)( , var__temp_h237, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h237, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'239, res ) ==((sel)( , var__temp_h237, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'239, res ) ==(10)
 
VC_END(declare-const var_h_i199 T952)
(declare-const var_h198 T952)
(declare-const v Int)
(declare-const var_h_i131 T952)
(declare-const var_h130 T952)
(declare-const v Int)
(declare-const var_h_i59 T952)
(declare-const var_h58 T952)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h237 T952)
(declare-const var__temp_v238 Int)
(declare-const |var__temp_h'239| T952)
(declare-const var__temp_v_err240 T953)
(declare-const var_h198 T952)
(declare-const var_h130 T952)
(declare-const var_h58 T952)
(declare-const err T966)

solver 
 (declare-sort T952)
(declare-fun sel (T952 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T952)
(declare-fun var_h198 () T952)
(declare-fun var_h58 () T952)
(declare-fun |var__temp_h'239| () T952)
(declare-fun var__temp_h237 () T952)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'239| res) (+ (sel var__temp_h237 res) 2))
               (= (sel |var__temp_h'239| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h237 res) (sel var_h198 res))
                    (= (sel var__temp_h237 res) 5))
                (=> (= (sel var__temp_h237 res) 5) a!1))))
  (not a!2))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************60
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v200:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v200:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --c4	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v241:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
c2
foo'
baz
foo
bar
 *********************Enumeration Iteration*****************61
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v241:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h242 --->  Ty_heap  
 var__temp_v243 --->  Ty_int  
 var__temp_h'244 --->  Ty_heap  
 var__temp_v_err245 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h242, res ) ==(sel)( , var_h198, res ) => 
 	 Rel (sel)( , var__temp_h242, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h242, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'244, res ) ==((sel)( , var__temp_h242, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i199 T969)
(declare-const var_h198 T969)
(declare-const v Int)
(declare-const var_h_i131 T969)
(declare-const var_h130 T969)
(declare-const v Int)
(declare-const var_h_i59 T969)
(declare-const var_h58 T969)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h242 T969)
(declare-const var__temp_v243 Int)
(declare-const |var__temp_h'244| T969)
(declare-const var__temp_v_err245 T970)
(declare-const var_h198 T969)
(declare-const var_h130 T969)
(declare-const var_h58 T969)
(declare-const err T983)

solver 
 (declare-sort T969)
(declare-fun sel (T969 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T969)
(declare-fun var_h198 () T969)
(declare-fun var_h58 () T969)
(declare-fun var__temp_h242 () T969)
(declare-fun |var__temp_h'244| () T969)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'244| res) (+ (sel var__temp_h242 res) 4))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h242 res) (sel var_h198 res))
                    (= (sel var__temp_h242 res) 7))
                (=> (= (sel var__temp_h242 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************62
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v241:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h246 --->  Ty_heap  
 var__temp_v247 --->  Ty_int  
 var__temp_h'248 --->  Ty_heap  
 var__temp_v_err249 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h246, res ) ==(sel)( , var_h198, res ) => 
 	 Rel (sel)( , var__temp_h246, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h246, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'248, res ) ==((sel)( , var__temp_h246, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i199 T986)
(declare-const var_h198 T986)
(declare-const v Int)
(declare-const var_h_i131 T986)
(declare-const var_h130 T986)
(declare-const v Int)
(declare-const var_h_i59 T986)
(declare-const var_h58 T986)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h246 T986)
(declare-const var__temp_v247 Int)
(declare-const |var__temp_h'248| T986)
(declare-const var__temp_v_err249 T987)
(declare-const var_h198 T986)
(declare-const var_h130 T986)
(declare-const var_h58 T986)
(declare-const err T1000)

solver 
 (declare-sort T986)
(declare-fun sel (T986 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T986)
(declare-fun var_h198 () T986)
(declare-fun var_h58 () T986)
(declare-fun var__temp_h246 () T986)
(declare-fun |var__temp_h'248| () T986)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'248| res) (+ (sel var__temp_h246 res) 4))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h246 res) (sel var_h198 res))
                    (= (sel var__temp_h246 res) 7))
                (=> (= (sel var__temp_h246 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************63
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v241:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h250 --->  Ty_heap  
 var__temp_v251 --->  Ty_int  
 var__temp_h'252 --->  Ty_heap  
 var__temp_v_err253 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h250, res ) ==(sel)( , var_h198, res ) => 
 	 Rel (sel)( , var__temp_h250, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h250, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'252, res ) ==((sel)( , var__temp_h250, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i199 T1003)
(declare-const var_h198 T1003)
(declare-const v Int)
(declare-const var_h_i131 T1003)
(declare-const var_h130 T1003)
(declare-const v Int)
(declare-const var_h_i59 T1003)
(declare-const var_h58 T1003)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h250 T1003)
(declare-const var__temp_v251 Int)
(declare-const |var__temp_h'252| T1003)
(declare-const var__temp_v_err253 T1004)
(declare-const var_h198 T1003)
(declare-const var_h130 T1003)
(declare-const var_h58 T1003)
(declare-const err T1017)

solver 
 (declare-sort T1003)
(declare-fun sel (T1003 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T1003)
(declare-fun var_h198 () T1003)
(declare-fun var_h58 () T1003)
(declare-fun var__temp_h250 () T1003)
(declare-fun |var__temp_h'252| () T1003)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'252| res) (+ (sel var__temp_h250 res) 4))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h250 res) (sel var_h198 res))
                    (= (sel var__temp_h250 res) 7))
                (=> (= (sel var__temp_h250 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************64
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v241:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h254 --->  Ty_heap  
 var__temp_v255 --->  Ty_int  
 var__temp_h'256 --->  Ty_heap  
 var__temp_v_err257 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h254, res ) ==(sel)( , var_h198, res ) => 
 	 Rel (sel)( , var__temp_h254, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h254, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'256, res ) ==((sel)( , var__temp_h254, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i199 T1020)
(declare-const var_h198 T1020)
(declare-const v Int)
(declare-const var_h_i131 T1020)
(declare-const var_h130 T1020)
(declare-const v Int)
(declare-const var_h_i59 T1020)
(declare-const var_h58 T1020)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h254 T1020)
(declare-const var__temp_v255 Int)
(declare-const |var__temp_h'256| T1020)
(declare-const var__temp_v_err257 T1021)
(declare-const var_h198 T1020)
(declare-const var_h130 T1020)
(declare-const var_h58 T1020)
(declare-const err T1034)

solver 
 (declare-sort T1020)
(declare-fun sel (T1020 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T1020)
(declare-fun var_h198 () T1020)
(declare-fun var_h58 () T1020)
(declare-fun var__temp_h254 () T1020)
(declare-fun |var__temp_h'256| () T1020)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'256| res) (+ (sel var__temp_h254 res) 5))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h254 res) (sel var_h198 res))
                    (= (sel var__temp_h254 res) 7))
                (=> (= (sel var__temp_h254 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************65
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v241:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h258 --->  Ty_heap  
 var__temp_v259 --->  Ty_int  
 var__temp_h'260 --->  Ty_heap  
 var__temp_v_err261 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h258, res ) ==(sel)( , var_h198, res ) => 
 	 Rel (sel)( , var__temp_h258, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h258, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'260, res ) ==((sel)( , var__temp_h258, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i199 T1037)
(declare-const var_h198 T1037)
(declare-const v Int)
(declare-const var_h_i131 T1037)
(declare-const var_h130 T1037)
(declare-const v Int)
(declare-const var_h_i59 T1037)
(declare-const var_h58 T1037)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h258 T1037)
(declare-const var__temp_v259 Int)
(declare-const |var__temp_h'260| T1037)
(declare-const var__temp_v_err261 T1038)
(declare-const var_h198 T1037)
(declare-const var_h130 T1037)
(declare-const var_h58 T1037)
(declare-const err T1051)

solver 
 (declare-sort T1037)
(declare-fun sel (T1037 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T1037)
(declare-fun var_h198 () T1037)
(declare-fun var_h58 () T1037)
(declare-fun var__temp_h258 () T1037)
(declare-fun |var__temp_h'260| () T1037)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'260| res) (+ (sel var__temp_h258 res) 5))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h258 res) (sel var_h198 res))
                    (= (sel var__temp_h258 res) 6))
                (=> (= (sel var__temp_h258 res) 6) a!1))))
  (not a!2))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************66
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v241:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h262 --->  Ty_heap  
 var__temp_v263 --->  Ty_int  
 var__temp_h'264 --->  Ty_heap  
 var__temp_v_err265 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h262, res ) ==(sel)( , var_h198, res ) => 
 	 Rel (sel)( , var__temp_h262, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h262, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'264, res ) ==((sel)( , var__temp_h262, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i199 T1054)
(declare-const var_h198 T1054)
(declare-const v Int)
(declare-const var_h_i131 T1054)
(declare-const var_h130 T1054)
(declare-const v Int)
(declare-const var_h_i59 T1054)
(declare-const var_h58 T1054)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h262 T1054)
(declare-const var__temp_v263 Int)
(declare-const |var__temp_h'264| T1054)
(declare-const var__temp_v_err265 T1055)
(declare-const var_h198 T1054)
(declare-const var_h130 T1054)
(declare-const var_h58 T1054)
(declare-const err T1068)

solver 
 (declare-sort T1054)
(declare-fun sel (T1054 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T1054)
(declare-fun var_h198 () T1054)
(declare-fun var_h58 () T1054)
(declare-fun var__temp_h262 () T1054)
(declare-fun |var__temp_h'264| () T1054)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'264| res) (+ (sel var__temp_h262 res) 10))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h262 res) (sel var_h198 res))
                    (> (sel var__temp_h262 res) 4))
                (=> (> (sel var__temp_h262 res) 4) a!1))))
  (not a!2))))

***************Selection Successful************c2
PARTIAL PATH NEW
NEW 	 --c3'	 --c4	 --c2'	 --c2
post_substituted Forall 
 	 
 Key =var_h_i267 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i267 Value = Ty_heap{ (sel)( , var_h_i267, res ) ==((sel)( , var_h266, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v268:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i267 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
foo'
baz
foo
bar
 *********************Enumeration Iteration*****************67
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i267 Value = Ty_heap{ (sel)( , var_h_i267, res ) ==((sel)( , var_h266, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v268:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i267 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h269 --->  Ty_heap  
 var__temp_v270 --->  Ty_int  
 var__temp_h'271 --->  Ty_heap  
 var__temp_v_err272 --->  error  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h269, res ) ==((sel)( , var_h266, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h269, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h269, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'271, res ) ==((sel)( , var__temp_h269, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'271, res ) ==(10)
 
VC_END(declare-const var_h_i267 T1071)
(declare-const var_h266 T1071)
(declare-const v Int)
(declare-const var_h_i199 T1071)
(declare-const var_h198 T1071)
(declare-const v Int)
(declare-const var_h_i131 T1071)
(declare-const var_h130 T1071)
(declare-const v Int)
(declare-const var_h_i59 T1071)
(declare-const var_h58 T1071)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h269 T1071)
(declare-const var__temp_v270 Int)
(declare-const |var__temp_h'271| T1071)
(declare-const var__temp_v_err272 T1072)
(declare-const var_h266 T1071)
(declare-const var_h198 T1071)
(declare-const var_h130 T1071)
(declare-const var_h58 T1071)
(declare-const err T1085)

solver 
 (declare-sort T1071)
(declare-fun sel (T1071 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1071)
(declare-fun var_h266 () T1071)
(declare-fun var_h130 () T1071)
(declare-fun var_h58 () T1071)
(declare-fun |var__temp_h'271| () T1071)
(declare-fun var__temp_h269 () T1071)
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h269 res) (+ (sel var_h266 res) 10))
               (= (sel var__temp_h269 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'271| res) (+ (sel var__temp_h269 res) 4))
               (= (sel |var__temp_h'271| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h269 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************68
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i267 Value = Ty_heap{ (sel)( , var_h_i267, res ) ==((sel)( , var_h266, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v268:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i267 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h273 --->  Ty_heap  
 var__temp_v274 --->  Ty_int  
 var__temp_h'275 --->  Ty_heap  
 var__temp_v_err276 --->  error  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h273, res ) ==((sel)( , var_h266, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h273, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h273, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'275, res ) ==((sel)( , var__temp_h273, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'275, res ) ==(10)
 
VC_END(declare-const var_h_i267 T1088)
(declare-const var_h266 T1088)
(declare-const v Int)
(declare-const var_h_i199 T1088)
(declare-const var_h198 T1088)
(declare-const v Int)
(declare-const var_h_i131 T1088)
(declare-const var_h130 T1088)
(declare-const v Int)
(declare-const var_h_i59 T1088)
(declare-const var_h58 T1088)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h273 T1088)
(declare-const var__temp_v274 Int)
(declare-const |var__temp_h'275| T1088)
(declare-const var__temp_v_err276 T1089)
(declare-const var_h266 T1088)
(declare-const var_h198 T1088)
(declare-const var_h130 T1088)
(declare-const var_h58 T1088)
(declare-const err T1102)

solver 
 (declare-sort T1088)
(declare-fun sel (T1088 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1088)
(declare-fun var_h266 () T1088)
(declare-fun var_h130 () T1088)
(declare-fun var_h58 () T1088)
(declare-fun |var__temp_h'275| () T1088)
(declare-fun var__temp_h273 () T1088)
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h273 res) (+ (sel var_h266 res) 10))
               (= (sel var__temp_h273 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'275| res) (+ (sel var__temp_h273 res) 4))
               (= (sel |var__temp_h'275| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h273 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************69
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i267 Value = Ty_heap{ (sel)( , var_h_i267, res ) ==((sel)( , var_h266, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v268:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i267 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h277 --->  Ty_heap  
 var__temp_v278 --->  Ty_int  
 var__temp_h'279 --->  Ty_heap  
 var__temp_v_err280 --->  error  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h277, res ) ==((sel)( , var_h266, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h277, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h277, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'279, res ) ==((sel)( , var__temp_h277, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'279, res ) ==(10)
 
VC_END(declare-const var_h_i267 T1105)
(declare-const var_h266 T1105)
(declare-const v Int)
(declare-const var_h_i199 T1105)
(declare-const var_h198 T1105)
(declare-const v Int)
(declare-const var_h_i131 T1105)
(declare-const var_h130 T1105)
(declare-const v Int)
(declare-const var_h_i59 T1105)
(declare-const var_h58 T1105)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h277 T1105)
(declare-const var__temp_v278 Int)
(declare-const |var__temp_h'279| T1105)
(declare-const var__temp_v_err280 T1106)
(declare-const var_h266 T1105)
(declare-const var_h198 T1105)
(declare-const var_h130 T1105)
(declare-const var_h58 T1105)
(declare-const err T1119)

solver 
 (declare-sort T1105)
(declare-fun sel (T1105 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1105)
(declare-fun var_h266 () T1105)
(declare-fun var_h130 () T1105)
(declare-fun var_h58 () T1105)
(declare-fun |var__temp_h'279| () T1105)
(declare-fun var__temp_h277 () T1105)
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h277 res) (+ (sel var_h266 res) 10))
               (= (sel var__temp_h277 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'279| res) (+ (sel var__temp_h277 res) 4))
               (= (sel |var__temp_h'279| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h277 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************70
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i267 Value = Ty_heap{ (sel)( , var_h_i267, res ) ==((sel)( , var_h266, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v268:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i267 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h281 --->  Ty_heap  
 var__temp_v282 --->  Ty_int  
 var__temp_h'283 --->  Ty_heap  
 var__temp_v_err284 --->  error  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h281, res ) ==((sel)( , var_h266, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h281, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h281, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'283, res ) ==((sel)( , var__temp_h281, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'283, res ) ==(10)
 
VC_END(declare-const var_h_i267 T1122)
(declare-const var_h266 T1122)
(declare-const v Int)
(declare-const var_h_i199 T1122)
(declare-const var_h198 T1122)
(declare-const v Int)
(declare-const var_h_i131 T1122)
(declare-const var_h130 T1122)
(declare-const v Int)
(declare-const var_h_i59 T1122)
(declare-const var_h58 T1122)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h281 T1122)
(declare-const var__temp_v282 Int)
(declare-const |var__temp_h'283| T1122)
(declare-const var__temp_v_err284 T1123)
(declare-const var_h266 T1122)
(declare-const var_h198 T1122)
(declare-const var_h130 T1122)
(declare-const var_h58 T1122)
(declare-const err T1136)

solver 
 (declare-sort T1122)
(declare-fun sel (T1122 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1122)
(declare-fun var_h266 () T1122)
(declare-fun var_h130 () T1122)
(declare-fun var_h58 () T1122)
(declare-fun |var__temp_h'283| () T1122)
(declare-fun var__temp_h281 () T1122)
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h281 res) (+ (sel var_h266 res) 10))
               (= (sel var__temp_h281 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'283| res) (+ (sel var__temp_h281 res) 5))
               (= (sel |var__temp_h'283| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h281 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************71
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i267 Value = Ty_heap{ (sel)( , var_h_i267, res ) ==((sel)( , var_h266, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v268:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i267 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h285 --->  Ty_heap  
 var__temp_v286 --->  Ty_int  
 var__temp_h'287 --->  Ty_heap  
 var__temp_v_err288 --->  error  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h285, res ) ==((sel)( , var_h266, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h285, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h285, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'287, res ) ==((sel)( , var__temp_h285, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'287, res ) ==(10)
 
VC_END(declare-const var_h_i267 T1139)
(declare-const var_h266 T1139)
(declare-const v Int)
(declare-const var_h_i199 T1139)
(declare-const var_h198 T1139)
(declare-const v Int)
(declare-const var_h_i131 T1139)
(declare-const var_h130 T1139)
(declare-const v Int)
(declare-const var_h_i59 T1139)
(declare-const var_h58 T1139)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h285 T1139)
(declare-const var__temp_v286 Int)
(declare-const |var__temp_h'287| T1139)
(declare-const var__temp_v_err288 T1140)
(declare-const var_h266 T1139)
(declare-const var_h198 T1139)
(declare-const var_h130 T1139)
(declare-const var_h58 T1139)
(declare-const err T1153)

solver 
 (declare-sort T1139)
(declare-fun sel (T1139 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1139)
(declare-fun var_h266 () T1139)
(declare-fun var_h130 () T1139)
(declare-fun var_h58 () T1139)
(declare-fun |var__temp_h'287| () T1139)
(declare-fun var__temp_h285 () T1139)
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h285 res) (+ (sel var_h266 res) 10))
               (= (sel var__temp_h285 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'287| res) (+ (sel var__temp_h285 res) 5))
               (= (sel |var__temp_h'287| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h285 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************72
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 20} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i267 Value = Ty_heap{ (sel)( , var_h_i267, res ) ==((sel)( , var_h266, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v268:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i267 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h289 --->  Ty_heap  
 var__temp_v290 --->  Ty_int  
 var__temp_h'291 --->  Ty_heap  
 var__temp_v_err292 --->  error  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h289, res ) ==((sel)( , var_h266, res ) + (10)) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'291, res ) ==(var__temp_v290) AND 
 	 Base var__temp_v290 = 20 => 
 	 Rel (sel)( , var__temp_h'291, res ) ==(10)
 
VC_END(declare-const var_h_i267 T1156)
(declare-const var_h266 T1156)
(declare-const v Int)
(declare-const var_h_i199 T1156)
(declare-const var_h198 T1156)
(declare-const v Int)
(declare-const var_h_i131 T1156)
(declare-const var_h130 T1156)
(declare-const v Int)
(declare-const var_h_i59 T1156)
(declare-const var_h58 T1156)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h289 T1156)
(declare-const var__temp_v290 Int)
(declare-const |var__temp_h'291| T1156)
(declare-const var__temp_v_err292 T1157)
(declare-const var_h266 T1156)
(declare-const var_h198 T1156)
(declare-const var_h130 T1156)
(declare-const var_h58 T1156)
(declare-const err T1170)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1156)
(declare-fun sel (T1156 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1156)
(declare-fun var_h266 () T1156)
(declare-fun var_h130 () T1156)
(declare-fun var_h58 () T1156)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'291| () T1156)
(declare-fun var__temp_v290 () Int)
(declare-fun var__temp_h289 () T1156)
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (= (sel var__temp_h289 res) (+ (sel var_h266 res) 10)) true))
      (a!2 (=> (and (= (sel |var__temp_h'291| res) var__temp_v290)
                    (= var__temp_v290 |20|))
               (= (sel |var__temp_h'291| res) 10))))
  (not (and a!1 (=> true a!2)))))

***************Selection Failed************foo'
 *********************Enumeration Iteration*****************73
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i267 Value = Ty_heap{ (sel)( , var_h_i267, res ) ==((sel)( , var_h266, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v268:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i267 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h293 --->  Ty_heap  
 var__temp_v294 --->  Ty_int  
 var__temp_h'295 --->  Ty_heap  
 var__temp_v_err296 --->  error  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h293, res ) ==((sel)( , var_h266, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h293, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h293, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'295, res ) ==((sel)( , var__temp_h293, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'295, res ) ==(10)
 
VC_END(declare-const var_h_i267 T1173)
(declare-const var_h266 T1173)
(declare-const v Int)
(declare-const var_h_i199 T1173)
(declare-const var_h198 T1173)
(declare-const v Int)
(declare-const var_h_i131 T1173)
(declare-const var_h130 T1173)
(declare-const v Int)
(declare-const var_h_i59 T1173)
(declare-const var_h58 T1173)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h293 T1173)
(declare-const var__temp_v294 Int)
(declare-const |var__temp_h'295| T1173)
(declare-const var__temp_v_err296 T1174)
(declare-const var_h266 T1173)
(declare-const var_h198 T1173)
(declare-const var_h130 T1173)
(declare-const var_h58 T1173)
(declare-const err T1187)

solver 
 (declare-sort T1173)
(declare-fun sel (T1173 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1173)
(declare-fun var_h266 () T1173)
(declare-fun var_h130 () T1173)
(declare-fun var_h58 () T1173)
(declare-fun |var__temp_h'295| () T1173)
(declare-fun var__temp_h293 () T1173)
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h293 res) (+ (sel var_h266 res) 10))
               (= (sel var__temp_h293 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'295| res) (+ (sel var__temp_h293 res) 3))
               (= (sel |var__temp_h'295| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h293 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************74
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (3) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i267 Value = Ty_heap{ (sel)( , var_h_i267, res ) ==((sel)( , var_h266, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v268:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i267 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h297 --->  Ty_heap  
 var__temp_v298 --->  Ty_int  
 var__temp_h'299 --->  Ty_heap  
 var__temp_v_err300 --->  error  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h297, res ) ==((sel)( , var_h266, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h297, res ) > (3) AND 
 	 Rel (sel)( , var__temp_h297, res ) > (3) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'299, res ) ==(var__temp_v298) AND 
 	 Base var__temp_v298 = 5 => 
 	 Rel (sel)( , var__temp_h'299, res ) ==(10)
 
VC_END(declare-const var_h_i267 T1190)
(declare-const var_h266 T1190)
(declare-const v Int)
(declare-const var_h_i199 T1190)
(declare-const var_h198 T1190)
(declare-const v Int)
(declare-const var_h_i131 T1190)
(declare-const var_h130 T1190)
(declare-const v Int)
(declare-const var_h_i59 T1190)
(declare-const var_h58 T1190)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h297 T1190)
(declare-const var__temp_v298 Int)
(declare-const |var__temp_h'299| T1190)
(declare-const var__temp_v_err300 T1191)
(declare-const var_h266 T1190)
(declare-const var_h198 T1190)
(declare-const var_h130 T1190)
(declare-const var_h58 T1190)
(declare-const err T1204)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1190)
(declare-fun sel (T1190 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1190)
(declare-fun var_h266 () T1190)
(declare-fun var_h130 () T1190)
(declare-fun var_h58 () T1190)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'299| () T1190)
(declare-fun var__temp_v298 () Int)
(declare-fun var__temp_h297 () T1190)
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h297 res) (+ (sel var_h266 res) 10))
               (not (> (sel var__temp_h297 res) 3))))
      (a!2 (=> (and (= (sel |var__temp_h'299| res) var__temp_v298)
                    (= var__temp_v298 |5|))
               (= (sel |var__temp_h'299| res) 10))))
(let ((a!3 (=> (not (> (sel var__temp_h297 res) 3)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************75
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i267 Value = Ty_heap{ (sel)( , var_h_i267, res ) ==((sel)( , var_h266, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v268:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i267 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h301 --->  Ty_heap  
 var__temp_v302 --->  Ty_int  
 var__temp_h'303 --->  Ty_heap  
 var__temp_v_err304 --->  error  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h301, res ) ==((sel)( , var_h266, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h301, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h301, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'303, res ) ==((sel)( , var__temp_h301, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'303, res ) ==(10)
 
VC_END(declare-const var_h_i267 T1207)
(declare-const var_h266 T1207)
(declare-const v Int)
(declare-const var_h_i199 T1207)
(declare-const var_h198 T1207)
(declare-const v Int)
(declare-const var_h_i131 T1207)
(declare-const var_h130 T1207)
(declare-const v Int)
(declare-const var_h_i59 T1207)
(declare-const var_h58 T1207)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h301 T1207)
(declare-const var__temp_v302 Int)
(declare-const |var__temp_h'303| T1207)
(declare-const var__temp_v_err304 T1208)
(declare-const var_h266 T1207)
(declare-const var_h198 T1207)
(declare-const var_h130 T1207)
(declare-const var_h58 T1207)
(declare-const err T1221)

solver 
 (declare-sort T1207)
(declare-fun sel (T1207 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1207)
(declare-fun var_h266 () T1207)
(declare-fun var_h130 () T1207)
(declare-fun var_h58 () T1207)
(declare-fun |var__temp_h'303| () T1207)
(declare-fun var__temp_h301 () T1207)
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h301 res) (+ (sel var_h266 res) 10))
               (= (sel var__temp_h301 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'303| res) (+ (sel var__temp_h301 res) 2))
               (= (sel |var__temp_h'303| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h301 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************76
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v268:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v268:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --c4	 --c2'	 --c2
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i267 Value = Ty_heap{ (sel)( , var_h_i267, res ) ==((sel)( , var_h266, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v305:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
foo'
baz
foo
bar
 *********************Enumeration Iteration*****************77
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i267 Value = Ty_heap{ (sel)( , var_h_i267, res ) ==((sel)( , var_h266, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v305:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h306 --->  Ty_heap  
 var__temp_v307 --->  Ty_int  
 var__temp_h'308 --->  Ty_heap  
 var__temp_v_err309 --->  error  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h306, res ) ==((sel)( , var_h266, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h306, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h306, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'308, res ) ==((sel)( , var__temp_h306, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i267 T1224)
(declare-const var_h266 T1224)
(declare-const v Int)
(declare-const var_h_i199 T1224)
(declare-const var_h198 T1224)
(declare-const v Int)
(declare-const var_h_i131 T1224)
(declare-const var_h130 T1224)
(declare-const v Int)
(declare-const var_h_i59 T1224)
(declare-const var_h58 T1224)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h306 T1224)
(declare-const var__temp_v307 Int)
(declare-const |var__temp_h'308| T1224)
(declare-const var__temp_v_err309 T1225)
(declare-const var_h266 T1224)
(declare-const var_h198 T1224)
(declare-const var_h130 T1224)
(declare-const var_h58 T1224)
(declare-const err T1238)

solver 
 (declare-sort T1224)
(declare-fun sel (T1224 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1224)
(declare-fun var_h266 () T1224)
(declare-fun var_h130 () T1224)
(declare-fun var_h58 () T1224)
(declare-fun var__temp_h306 () T1224)
(declare-fun |var__temp_h'308| () T1224)
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h306 res) (+ (sel var_h266 res) 10))
               (= (sel var__temp_h306 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'308| res) (+ (sel var__temp_h306 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h306 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************78
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i267 Value = Ty_heap{ (sel)( , var_h_i267, res ) ==((sel)( , var_h266, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v305:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h310 --->  Ty_heap  
 var__temp_v311 --->  Ty_int  
 var__temp_h'312 --->  Ty_heap  
 var__temp_v_err313 --->  error  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h310, res ) ==((sel)( , var_h266, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h310, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h310, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'312, res ) ==((sel)( , var__temp_h310, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i267 T1241)
(declare-const var_h266 T1241)
(declare-const v Int)
(declare-const var_h_i199 T1241)
(declare-const var_h198 T1241)
(declare-const v Int)
(declare-const var_h_i131 T1241)
(declare-const var_h130 T1241)
(declare-const v Int)
(declare-const var_h_i59 T1241)
(declare-const var_h58 T1241)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h310 T1241)
(declare-const var__temp_v311 Int)
(declare-const |var__temp_h'312| T1241)
(declare-const var__temp_v_err313 T1242)
(declare-const var_h266 T1241)
(declare-const var_h198 T1241)
(declare-const var_h130 T1241)
(declare-const var_h58 T1241)
(declare-const err T1255)

solver 
 (declare-sort T1241)
(declare-fun sel (T1241 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1241)
(declare-fun var_h266 () T1241)
(declare-fun var_h130 () T1241)
(declare-fun var_h58 () T1241)
(declare-fun var__temp_h310 () T1241)
(declare-fun |var__temp_h'312| () T1241)
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h310 res) (+ (sel var_h266 res) 10))
               (= (sel var__temp_h310 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'312| res) (+ (sel var__temp_h310 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h310 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************79
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i267 Value = Ty_heap{ (sel)( , var_h_i267, res ) ==((sel)( , var_h266, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v305:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h314 --->  Ty_heap  
 var__temp_v315 --->  Ty_int  
 var__temp_h'316 --->  Ty_heap  
 var__temp_v_err317 --->  error  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h314, res ) ==((sel)( , var_h266, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h314, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h314, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'316, res ) ==((sel)( , var__temp_h314, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i267 T1258)
(declare-const var_h266 T1258)
(declare-const v Int)
(declare-const var_h_i199 T1258)
(declare-const var_h198 T1258)
(declare-const v Int)
(declare-const var_h_i131 T1258)
(declare-const var_h130 T1258)
(declare-const v Int)
(declare-const var_h_i59 T1258)
(declare-const var_h58 T1258)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h314 T1258)
(declare-const var__temp_v315 Int)
(declare-const |var__temp_h'316| T1258)
(declare-const var__temp_v_err317 T1259)
(declare-const var_h266 T1258)
(declare-const var_h198 T1258)
(declare-const var_h130 T1258)
(declare-const var_h58 T1258)
(declare-const err T1272)

solver 
 (declare-sort T1258)
(declare-fun sel (T1258 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1258)
(declare-fun var_h266 () T1258)
(declare-fun var_h130 () T1258)
(declare-fun var_h58 () T1258)
(declare-fun var__temp_h314 () T1258)
(declare-fun |var__temp_h'316| () T1258)
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h314 res) (+ (sel var_h266 res) 10))
               (= (sel var__temp_h314 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'316| res) (+ (sel var__temp_h314 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h314 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************80
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i267 Value = Ty_heap{ (sel)( , var_h_i267, res ) ==((sel)( , var_h266, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v305:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h318 --->  Ty_heap  
 var__temp_v319 --->  Ty_int  
 var__temp_h'320 --->  Ty_heap  
 var__temp_v_err321 --->  error  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h318, res ) ==((sel)( , var_h266, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h318, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h318, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'320, res ) ==((sel)( , var__temp_h318, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i267 T1275)
(declare-const var_h266 T1275)
(declare-const v Int)
(declare-const var_h_i199 T1275)
(declare-const var_h198 T1275)
(declare-const v Int)
(declare-const var_h_i131 T1275)
(declare-const var_h130 T1275)
(declare-const v Int)
(declare-const var_h_i59 T1275)
(declare-const var_h58 T1275)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h318 T1275)
(declare-const var__temp_v319 Int)
(declare-const |var__temp_h'320| T1275)
(declare-const var__temp_v_err321 T1276)
(declare-const var_h266 T1275)
(declare-const var_h198 T1275)
(declare-const var_h130 T1275)
(declare-const var_h58 T1275)
(declare-const err T1289)

solver 
 (declare-sort T1275)
(declare-fun sel (T1275 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1275)
(declare-fun var_h266 () T1275)
(declare-fun var_h130 () T1275)
(declare-fun var_h58 () T1275)
(declare-fun var__temp_h318 () T1275)
(declare-fun |var__temp_h'320| () T1275)
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h318 res) (+ (sel var_h266 res) 10))
               (= (sel var__temp_h318 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'320| res) (+ (sel var__temp_h318 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h318 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************81
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i267 Value = Ty_heap{ (sel)( , var_h_i267, res ) ==((sel)( , var_h266, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v305:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h322 --->  Ty_heap  
 var__temp_v323 --->  Ty_int  
 var__temp_h'324 --->  Ty_heap  
 var__temp_v_err325 --->  error  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h322, res ) ==((sel)( , var_h266, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h322, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h322, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'324, res ) ==((sel)( , var__temp_h322, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i267 T1292)
(declare-const var_h266 T1292)
(declare-const v Int)
(declare-const var_h_i199 T1292)
(declare-const var_h198 T1292)
(declare-const v Int)
(declare-const var_h_i131 T1292)
(declare-const var_h130 T1292)
(declare-const v Int)
(declare-const var_h_i59 T1292)
(declare-const var_h58 T1292)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h322 T1292)
(declare-const var__temp_v323 Int)
(declare-const |var__temp_h'324| T1292)
(declare-const var__temp_v_err325 T1293)
(declare-const var_h266 T1292)
(declare-const var_h198 T1292)
(declare-const var_h130 T1292)
(declare-const var_h58 T1292)
(declare-const err T1306)

solver 
 (declare-sort T1292)
(declare-fun sel (T1292 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1292)
(declare-fun var_h266 () T1292)
(declare-fun var_h130 () T1292)
(declare-fun var_h58 () T1292)
(declare-fun var__temp_h322 () T1292)
(declare-fun |var__temp_h'324| () T1292)
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h322 res) (+ (sel var_h266 res) 10))
               (= (sel var__temp_h322 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'324| res) (+ (sel var__temp_h322 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h322 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************82
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 20} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i267 Value = Ty_heap{ (sel)( , var_h_i267, res ) ==((sel)( , var_h266, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v305:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h326 --->  Ty_heap  
 var__temp_v327 --->  Ty_int  
 var__temp_h'328 --->  Ty_heap  
 var__temp_v_err329 --->  error  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h326, res ) ==((sel)( , var_h266, res ) + (10)) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'328, res ) ==(var__temp_v327) AND 
 	 Base var__temp_v327 = 20 => 
 	 True
 
VC_END(declare-const var_h_i267 T1309)
(declare-const var_h266 T1309)
(declare-const v Int)
(declare-const var_h_i199 T1309)
(declare-const var_h198 T1309)
(declare-const v Int)
(declare-const var_h_i131 T1309)
(declare-const var_h130 T1309)
(declare-const v Int)
(declare-const var_h_i59 T1309)
(declare-const var_h58 T1309)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h326 T1309)
(declare-const var__temp_v327 Int)
(declare-const |var__temp_h'328| T1309)
(declare-const var__temp_v_err329 T1310)
(declare-const var_h266 T1309)
(declare-const var_h198 T1309)
(declare-const var_h130 T1309)
(declare-const var_h58 T1309)
(declare-const err T1323)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1309)
(declare-fun sel (T1309 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1309)
(declare-fun var_h266 () T1309)
(declare-fun var_h130 () T1309)
(declare-fun var_h58 () T1309)
(declare-fun |20| () Int)
(declare-fun var__temp_v327 () Int)
(declare-fun |var__temp_h'328| () T1309)
(declare-fun var__temp_h326 () T1309)
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (= (sel var__temp_h326 res) (+ (sel var_h266 res) 10)) true))
      (a!2 (=> (and (= (sel |var__temp_h'328| res) var__temp_v327)
                    (= var__temp_v327 |20|))
               true)))
  (not (and a!1 (=> true a!2)))))

***************Selection Successful************foo'
PARTIAL PATH NEW
NEW 	 --c3'	 --c4	 --c2'	 --c2	 --foo'
post_substituted Forall 
 	 
 Key =var_h_i331 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v332:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i331 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
baz
foo
bar
 *********************Enumeration Iteration*****************83
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v332:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i331 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h333 --->  Ty_heap  
 var__temp_v334 --->  Ty_int  
 var__temp_h'335 --->  Ty_heap  
 var__temp_v_err336 --->  error  
 var_h330 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) ==((sel)( , var_h266, res ) + (10)) AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h333, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h333, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h333, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'335, res ) ==((sel)( , var__temp_h333, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'335, res ) ==(10)
 
VC_END(declare-const var_h_i331 T1326)
(declare-const var_h330 T1326)
(declare-const v Int)
(declare-const var_h_i267 T1326)
(declare-const var_h266 T1326)
(declare-const v Int)
(declare-const var_h_i199 T1326)
(declare-const var_h198 T1326)
(declare-const v Int)
(declare-const var_h_i131 T1326)
(declare-const var_h130 T1326)
(declare-const v Int)
(declare-const var_h_i59 T1326)
(declare-const var_h58 T1326)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h333 T1326)
(declare-const var__temp_v334 Int)
(declare-const |var__temp_h'335| T1326)
(declare-const var__temp_v_err336 T1327)
(declare-const var_h330 T1326)
(declare-const var_h266 T1326)
(declare-const var_h198 T1326)
(declare-const var_h130 T1326)
(declare-const var_h58 T1326)
(declare-const err T1340)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1326)
(declare-fun sel (T1326 Int) Int)
(declare-fun res () Int)
(declare-fun var_h266 () T1326)
(declare-fun var_h330 () T1326)
(declare-fun var_h198 () T1326)
(declare-fun var_h130 () T1326)
(declare-fun var_h58 () T1326)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'335| () T1326)
(declare-fun var__temp_h333 () T1326)
(declare-fun v () Int)
(assert (= (sel var_h330 res) (+ (sel var_h266 res) 10)))
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h333 res) v) (= v |20|))
               (= (sel var__temp_h333 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'335| res) (+ (sel var__temp_h333 res) 4))
               (= (sel |var__temp_h'335| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h333 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************84
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v332:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i331 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h337 --->  Ty_heap  
 var__temp_v338 --->  Ty_int  
 var__temp_h'339 --->  Ty_heap  
 var__temp_v_err340 --->  error  
 var_h330 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) ==((sel)( , var_h266, res ) + (10)) AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h337, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h337, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h337, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'339, res ) ==((sel)( , var__temp_h337, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'339, res ) ==(10)
 
VC_END(declare-const var_h_i331 T1343)
(declare-const var_h330 T1343)
(declare-const v Int)
(declare-const var_h_i267 T1343)
(declare-const var_h266 T1343)
(declare-const v Int)
(declare-const var_h_i199 T1343)
(declare-const var_h198 T1343)
(declare-const v Int)
(declare-const var_h_i131 T1343)
(declare-const var_h130 T1343)
(declare-const v Int)
(declare-const var_h_i59 T1343)
(declare-const var_h58 T1343)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h337 T1343)
(declare-const var__temp_v338 Int)
(declare-const |var__temp_h'339| T1343)
(declare-const var__temp_v_err340 T1344)
(declare-const var_h330 T1343)
(declare-const var_h266 T1343)
(declare-const var_h198 T1343)
(declare-const var_h130 T1343)
(declare-const var_h58 T1343)
(declare-const err T1357)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1343)
(declare-fun sel (T1343 Int) Int)
(declare-fun res () Int)
(declare-fun var_h266 () T1343)
(declare-fun var_h330 () T1343)
(declare-fun var_h198 () T1343)
(declare-fun var_h130 () T1343)
(declare-fun var_h58 () T1343)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'339| () T1343)
(declare-fun var__temp_h337 () T1343)
(declare-fun v () Int)
(assert (= (sel var_h330 res) (+ (sel var_h266 res) 10)))
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h337 res) v) (= v |20|))
               (= (sel var__temp_h337 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'339| res) (+ (sel var__temp_h337 res) 4))
               (= (sel |var__temp_h'339| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h337 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************85
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v332:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i331 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h341 --->  Ty_heap  
 var__temp_v342 --->  Ty_int  
 var__temp_h'343 --->  Ty_heap  
 var__temp_v_err344 --->  error  
 var_h330 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) ==((sel)( , var_h266, res ) + (10)) AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h341, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h341, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h341, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'343, res ) ==((sel)( , var__temp_h341, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'343, res ) ==(10)
 
VC_END(declare-const var_h_i331 T1360)
(declare-const var_h330 T1360)
(declare-const v Int)
(declare-const var_h_i267 T1360)
(declare-const var_h266 T1360)
(declare-const v Int)
(declare-const var_h_i199 T1360)
(declare-const var_h198 T1360)
(declare-const v Int)
(declare-const var_h_i131 T1360)
(declare-const var_h130 T1360)
(declare-const v Int)
(declare-const var_h_i59 T1360)
(declare-const var_h58 T1360)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h341 T1360)
(declare-const var__temp_v342 Int)
(declare-const |var__temp_h'343| T1360)
(declare-const var__temp_v_err344 T1361)
(declare-const var_h330 T1360)
(declare-const var_h266 T1360)
(declare-const var_h198 T1360)
(declare-const var_h130 T1360)
(declare-const var_h58 T1360)
(declare-const err T1374)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1360)
(declare-fun sel (T1360 Int) Int)
(declare-fun res () Int)
(declare-fun var_h266 () T1360)
(declare-fun var_h330 () T1360)
(declare-fun var_h198 () T1360)
(declare-fun var_h130 () T1360)
(declare-fun var_h58 () T1360)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'343| () T1360)
(declare-fun var__temp_h341 () T1360)
(declare-fun v () Int)
(assert (= (sel var_h330 res) (+ (sel var_h266 res) 10)))
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h341 res) v) (= v |20|))
               (= (sel var__temp_h341 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'343| res) (+ (sel var__temp_h341 res) 4))
               (= (sel |var__temp_h'343| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h341 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************86
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v332:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i331 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h345 --->  Ty_heap  
 var__temp_v346 --->  Ty_int  
 var__temp_h'347 --->  Ty_heap  
 var__temp_v_err348 --->  error  
 var_h330 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) ==((sel)( , var_h266, res ) + (10)) AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h345, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h345, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h345, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'347, res ) ==((sel)( , var__temp_h345, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'347, res ) ==(10)
 
VC_END(declare-const var_h_i331 T1377)
(declare-const var_h330 T1377)
(declare-const v Int)
(declare-const var_h_i267 T1377)
(declare-const var_h266 T1377)
(declare-const v Int)
(declare-const var_h_i199 T1377)
(declare-const var_h198 T1377)
(declare-const v Int)
(declare-const var_h_i131 T1377)
(declare-const var_h130 T1377)
(declare-const v Int)
(declare-const var_h_i59 T1377)
(declare-const var_h58 T1377)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h345 T1377)
(declare-const var__temp_v346 Int)
(declare-const |var__temp_h'347| T1377)
(declare-const var__temp_v_err348 T1378)
(declare-const var_h330 T1377)
(declare-const var_h266 T1377)
(declare-const var_h198 T1377)
(declare-const var_h130 T1377)
(declare-const var_h58 T1377)
(declare-const err T1391)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1377)
(declare-fun sel (T1377 Int) Int)
(declare-fun res () Int)
(declare-fun var_h266 () T1377)
(declare-fun var_h330 () T1377)
(declare-fun var_h198 () T1377)
(declare-fun var_h130 () T1377)
(declare-fun var_h58 () T1377)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'347| () T1377)
(declare-fun var__temp_h345 () T1377)
(declare-fun v () Int)
(assert (= (sel var_h330 res) (+ (sel var_h266 res) 10)))
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h345 res) v) (= v |20|))
               (= (sel var__temp_h345 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'347| res) (+ (sel var__temp_h345 res) 5))
               (= (sel |var__temp_h'347| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h345 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************87
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v332:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i331 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h349 --->  Ty_heap  
 var__temp_v350 --->  Ty_int  
 var__temp_h'351 --->  Ty_heap  
 var__temp_v_err352 --->  error  
 var_h330 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) ==((sel)( , var_h266, res ) + (10)) AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h349, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h349, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h349, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'351, res ) ==((sel)( , var__temp_h349, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'351, res ) ==(10)
 
VC_END(declare-const var_h_i331 T1394)
(declare-const var_h330 T1394)
(declare-const v Int)
(declare-const var_h_i267 T1394)
(declare-const var_h266 T1394)
(declare-const v Int)
(declare-const var_h_i199 T1394)
(declare-const var_h198 T1394)
(declare-const v Int)
(declare-const var_h_i131 T1394)
(declare-const var_h130 T1394)
(declare-const v Int)
(declare-const var_h_i59 T1394)
(declare-const var_h58 T1394)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h349 T1394)
(declare-const var__temp_v350 Int)
(declare-const |var__temp_h'351| T1394)
(declare-const var__temp_v_err352 T1395)
(declare-const var_h330 T1394)
(declare-const var_h266 T1394)
(declare-const var_h198 T1394)
(declare-const var_h130 T1394)
(declare-const var_h58 T1394)
(declare-const err T1408)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1394)
(declare-fun sel (T1394 Int) Int)
(declare-fun res () Int)
(declare-fun var_h266 () T1394)
(declare-fun var_h330 () T1394)
(declare-fun var_h198 () T1394)
(declare-fun var_h130 () T1394)
(declare-fun var_h58 () T1394)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'351| () T1394)
(declare-fun var__temp_h349 () T1394)
(declare-fun v () Int)
(assert (= (sel var_h330 res) (+ (sel var_h266 res) 10)))
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h349 res) v) (= v |20|))
               (= (sel var__temp_h349 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'351| res) (+ (sel var__temp_h349 res) 5))
               (= (sel |var__temp_h'351| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h349 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************88
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v332:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i331 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h353 --->  Ty_heap  
 var__temp_v354 --->  Ty_int  
 var__temp_h'355 --->  Ty_heap  
 var__temp_v_err356 --->  error  
 var_h330 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) ==((sel)( , var_h266, res ) + (10)) AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h353, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h353, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h353, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'355, res ) ==((sel)( , var__temp_h353, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'355, res ) ==(10)
 
VC_END(declare-const var_h_i331 T1411)
(declare-const var_h330 T1411)
(declare-const v Int)
(declare-const var_h_i267 T1411)
(declare-const var_h266 T1411)
(declare-const v Int)
(declare-const var_h_i199 T1411)
(declare-const var_h198 T1411)
(declare-const v Int)
(declare-const var_h_i131 T1411)
(declare-const var_h130 T1411)
(declare-const v Int)
(declare-const var_h_i59 T1411)
(declare-const var_h58 T1411)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h353 T1411)
(declare-const var__temp_v354 Int)
(declare-const |var__temp_h'355| T1411)
(declare-const var__temp_v_err356 T1412)
(declare-const var_h330 T1411)
(declare-const var_h266 T1411)
(declare-const var_h198 T1411)
(declare-const var_h130 T1411)
(declare-const var_h58 T1411)
(declare-const err T1425)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1411)
(declare-fun sel (T1411 Int) Int)
(declare-fun res () Int)
(declare-fun var_h266 () T1411)
(declare-fun var_h330 () T1411)
(declare-fun var_h198 () T1411)
(declare-fun var_h130 () T1411)
(declare-fun var_h58 () T1411)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'355| () T1411)
(declare-fun var__temp_h353 () T1411)
(declare-fun v () Int)
(assert (= (sel var_h330 res) (+ (sel var_h266 res) 10)))
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h353 res) v) (= v |20|))
               (= (sel var__temp_h353 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'355| res) (+ (sel var__temp_h353 res) 3))
               (= (sel |var__temp_h'355| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h353 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************89
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (3) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v332:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i331 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h357 --->  Ty_heap  
 var__temp_v358 --->  Ty_int  
 var__temp_h'359 --->  Ty_heap  
 var__temp_v_err360 --->  error  
 var_h330 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) ==((sel)( , var_h266, res ) + (10)) AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h357, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h357, res ) > (3) AND 
 	 Rel (sel)( , var__temp_h357, res ) > (3) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'359, res ) ==(var__temp_v358) AND 
 	 Base var__temp_v358 = 5 => 
 	 Rel (sel)( , var__temp_h'359, res ) ==(10)
 
VC_END(declare-const var_h_i331 T1428)
(declare-const var_h330 T1428)
(declare-const v Int)
(declare-const var_h_i267 T1428)
(declare-const var_h266 T1428)
(declare-const v Int)
(declare-const var_h_i199 T1428)
(declare-const var_h198 T1428)
(declare-const v Int)
(declare-const var_h_i131 T1428)
(declare-const var_h130 T1428)
(declare-const v Int)
(declare-const var_h_i59 T1428)
(declare-const var_h58 T1428)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h357 T1428)
(declare-const var__temp_v358 Int)
(declare-const |var__temp_h'359| T1428)
(declare-const var__temp_v_err360 T1429)
(declare-const var_h330 T1428)
(declare-const var_h266 T1428)
(declare-const var_h198 T1428)
(declare-const var_h130 T1428)
(declare-const var_h58 T1428)
(declare-const err T1442)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T1428)
(declare-fun sel (T1428 Int) Int)
(declare-fun res () Int)
(declare-fun var_h266 () T1428)
(declare-fun var_h330 () T1428)
(declare-fun var_h198 () T1428)
(declare-fun var_h130 () T1428)
(declare-fun var_h58 () T1428)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'359| () T1428)
(declare-fun var__temp_v358 () Int)
(declare-fun var__temp_h357 () T1428)
(declare-fun v () Int)
(assert (= (sel var_h330 res) (+ (sel var_h266 res) 10)))
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h357 res) v) (= v |20|))
               (not (> (sel var__temp_h357 res) 3))))
      (a!2 (=> (and (= (sel |var__temp_h'359| res) var__temp_v358)
                    (= var__temp_v358 |5|))
               (= (sel |var__temp_h'359| res) 10))))
(let ((a!3 (=> (not (> (sel var__temp_h357 res) 3)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************90
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v332:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i331 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h361 --->  Ty_heap  
 var__temp_v362 --->  Ty_int  
 var__temp_h'363 --->  Ty_heap  
 var__temp_v_err364 --->  error  
 var_h330 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) ==((sel)( , var_h266, res ) + (10)) AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h361, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h361, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h361, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'363, res ) ==((sel)( , var__temp_h361, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'363, res ) ==(10)
 
VC_END(declare-const var_h_i331 T1445)
(declare-const var_h330 T1445)
(declare-const v Int)
(declare-const var_h_i267 T1445)
(declare-const var_h266 T1445)
(declare-const v Int)
(declare-const var_h_i199 T1445)
(declare-const var_h198 T1445)
(declare-const v Int)
(declare-const var_h_i131 T1445)
(declare-const var_h130 T1445)
(declare-const v Int)
(declare-const var_h_i59 T1445)
(declare-const var_h58 T1445)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h361 T1445)
(declare-const var__temp_v362 Int)
(declare-const |var__temp_h'363| T1445)
(declare-const var__temp_v_err364 T1446)
(declare-const var_h330 T1445)
(declare-const var_h266 T1445)
(declare-const var_h198 T1445)
(declare-const var_h130 T1445)
(declare-const var_h58 T1445)
(declare-const err T1459)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1445)
(declare-fun sel (T1445 Int) Int)
(declare-fun res () Int)
(declare-fun var_h266 () T1445)
(declare-fun var_h330 () T1445)
(declare-fun var_h198 () T1445)
(declare-fun var_h130 () T1445)
(declare-fun var_h58 () T1445)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'363| () T1445)
(declare-fun var__temp_h361 () T1445)
(declare-fun v () Int)
(assert (= (sel var_h330 res) (+ (sel var_h266 res) 10)))
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h361 res) v) (= v |20|))
               (= (sel var__temp_h361 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'363| res) (+ (sel var__temp_h361 res) 2))
               (= (sel |var__temp_h'363| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h361 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************91
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v332:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v332:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfoo'c2c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --c4	 --c2'	 --c2	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v365:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
baz
foo
bar
 *********************Enumeration Iteration*****************92
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v365:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h366 --->  Ty_heap  
 var__temp_v367 --->  Ty_int  
 var__temp_h'368 --->  Ty_heap  
 var__temp_v_err369 --->  error  
 var_h330 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) ==((sel)( , var_h266, res ) + (10)) AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h366, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h366, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h366, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'368, res ) ==((sel)( , var__temp_h366, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i331 T1462)
(declare-const var_h330 T1462)
(declare-const v Int)
(declare-const var_h_i267 T1462)
(declare-const var_h266 T1462)
(declare-const v Int)
(declare-const var_h_i199 T1462)
(declare-const var_h198 T1462)
(declare-const v Int)
(declare-const var_h_i131 T1462)
(declare-const var_h130 T1462)
(declare-const v Int)
(declare-const var_h_i59 T1462)
(declare-const var_h58 T1462)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h366 T1462)
(declare-const var__temp_v367 Int)
(declare-const |var__temp_h'368| T1462)
(declare-const var__temp_v_err369 T1463)
(declare-const var_h330 T1462)
(declare-const var_h266 T1462)
(declare-const var_h198 T1462)
(declare-const var_h130 T1462)
(declare-const var_h58 T1462)
(declare-const err T1476)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1462)
(declare-fun sel (T1462 Int) Int)
(declare-fun res () Int)
(declare-fun var_h266 () T1462)
(declare-fun var_h330 () T1462)
(declare-fun var_h198 () T1462)
(declare-fun var_h130 () T1462)
(declare-fun var_h58 () T1462)
(declare-fun |20| () Int)
(declare-fun var__temp_h366 () T1462)
(declare-fun |var__temp_h'368| () T1462)
(declare-fun v () Int)
(assert (= (sel var_h330 res) (+ (sel var_h266 res) 10)))
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h366 res) v) (= v |20|))
               (= (sel var__temp_h366 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'368| res) (+ (sel var__temp_h366 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h366 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************93
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v365:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h370 --->  Ty_heap  
 var__temp_v371 --->  Ty_int  
 var__temp_h'372 --->  Ty_heap  
 var__temp_v_err373 --->  error  
 var_h330 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) ==((sel)( , var_h266, res ) + (10)) AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h370, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h370, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h370, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'372, res ) ==((sel)( , var__temp_h370, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i331 T1479)
(declare-const var_h330 T1479)
(declare-const v Int)
(declare-const var_h_i267 T1479)
(declare-const var_h266 T1479)
(declare-const v Int)
(declare-const var_h_i199 T1479)
(declare-const var_h198 T1479)
(declare-const v Int)
(declare-const var_h_i131 T1479)
(declare-const var_h130 T1479)
(declare-const v Int)
(declare-const var_h_i59 T1479)
(declare-const var_h58 T1479)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h370 T1479)
(declare-const var__temp_v371 Int)
(declare-const |var__temp_h'372| T1479)
(declare-const var__temp_v_err373 T1480)
(declare-const var_h330 T1479)
(declare-const var_h266 T1479)
(declare-const var_h198 T1479)
(declare-const var_h130 T1479)
(declare-const var_h58 T1479)
(declare-const err T1493)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1479)
(declare-fun sel (T1479 Int) Int)
(declare-fun res () Int)
(declare-fun var_h266 () T1479)
(declare-fun var_h330 () T1479)
(declare-fun var_h198 () T1479)
(declare-fun var_h130 () T1479)
(declare-fun var_h58 () T1479)
(declare-fun |20| () Int)
(declare-fun var__temp_h370 () T1479)
(declare-fun |var__temp_h'372| () T1479)
(declare-fun v () Int)
(assert (= (sel var_h330 res) (+ (sel var_h266 res) 10)))
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h370 res) v) (= v |20|))
               (= (sel var__temp_h370 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'372| res) (+ (sel var__temp_h370 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h370 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************94
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v365:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h374 --->  Ty_heap  
 var__temp_v375 --->  Ty_int  
 var__temp_h'376 --->  Ty_heap  
 var__temp_v_err377 --->  error  
 var_h330 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) ==((sel)( , var_h266, res ) + (10)) AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h374, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h374, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h374, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'376, res ) ==((sel)( , var__temp_h374, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i331 T1496)
(declare-const var_h330 T1496)
(declare-const v Int)
(declare-const var_h_i267 T1496)
(declare-const var_h266 T1496)
(declare-const v Int)
(declare-const var_h_i199 T1496)
(declare-const var_h198 T1496)
(declare-const v Int)
(declare-const var_h_i131 T1496)
(declare-const var_h130 T1496)
(declare-const v Int)
(declare-const var_h_i59 T1496)
(declare-const var_h58 T1496)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h374 T1496)
(declare-const var__temp_v375 Int)
(declare-const |var__temp_h'376| T1496)
(declare-const var__temp_v_err377 T1497)
(declare-const var_h330 T1496)
(declare-const var_h266 T1496)
(declare-const var_h198 T1496)
(declare-const var_h130 T1496)
(declare-const var_h58 T1496)
(declare-const err T1510)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1496)
(declare-fun sel (T1496 Int) Int)
(declare-fun res () Int)
(declare-fun var_h266 () T1496)
(declare-fun var_h330 () T1496)
(declare-fun var_h198 () T1496)
(declare-fun var_h130 () T1496)
(declare-fun var_h58 () T1496)
(declare-fun |20| () Int)
(declare-fun var__temp_h374 () T1496)
(declare-fun |var__temp_h'376| () T1496)
(declare-fun v () Int)
(assert (= (sel var_h330 res) (+ (sel var_h266 res) 10)))
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h374 res) v) (= v |20|))
               (= (sel var__temp_h374 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'376| res) (+ (sel var__temp_h374 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h374 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************95
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v365:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h378 --->  Ty_heap  
 var__temp_v379 --->  Ty_int  
 var__temp_h'380 --->  Ty_heap  
 var__temp_v_err381 --->  error  
 var_h330 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) ==((sel)( , var_h266, res ) + (10)) AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h378, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h378, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h378, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'380, res ) ==((sel)( , var__temp_h378, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i331 T1513)
(declare-const var_h330 T1513)
(declare-const v Int)
(declare-const var_h_i267 T1513)
(declare-const var_h266 T1513)
(declare-const v Int)
(declare-const var_h_i199 T1513)
(declare-const var_h198 T1513)
(declare-const v Int)
(declare-const var_h_i131 T1513)
(declare-const var_h130 T1513)
(declare-const v Int)
(declare-const var_h_i59 T1513)
(declare-const var_h58 T1513)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h378 T1513)
(declare-const var__temp_v379 Int)
(declare-const |var__temp_h'380| T1513)
(declare-const var__temp_v_err381 T1514)
(declare-const var_h330 T1513)
(declare-const var_h266 T1513)
(declare-const var_h198 T1513)
(declare-const var_h130 T1513)
(declare-const var_h58 T1513)
(declare-const err T1527)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1513)
(declare-fun sel (T1513 Int) Int)
(declare-fun res () Int)
(declare-fun var_h266 () T1513)
(declare-fun var_h330 () T1513)
(declare-fun var_h198 () T1513)
(declare-fun var_h130 () T1513)
(declare-fun var_h58 () T1513)
(declare-fun |20| () Int)
(declare-fun var__temp_h378 () T1513)
(declare-fun |var__temp_h'380| () T1513)
(declare-fun v () Int)
(assert (= (sel var_h330 res) (+ (sel var_h266 res) 10)))
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h378 res) v) (= v |20|))
               (= (sel var__temp_h378 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'380| res) (+ (sel var__temp_h378 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h378 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************96
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v365:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h382 --->  Ty_heap  
 var__temp_v383 --->  Ty_int  
 var__temp_h'384 --->  Ty_heap  
 var__temp_v_err385 --->  error  
 var_h330 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) ==((sel)( , var_h266, res ) + (10)) AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h382, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h382, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h382, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'384, res ) ==((sel)( , var__temp_h382, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i331 T1530)
(declare-const var_h330 T1530)
(declare-const v Int)
(declare-const var_h_i267 T1530)
(declare-const var_h266 T1530)
(declare-const v Int)
(declare-const var_h_i199 T1530)
(declare-const var_h198 T1530)
(declare-const v Int)
(declare-const var_h_i131 T1530)
(declare-const var_h130 T1530)
(declare-const v Int)
(declare-const var_h_i59 T1530)
(declare-const var_h58 T1530)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h382 T1530)
(declare-const var__temp_v383 Int)
(declare-const |var__temp_h'384| T1530)
(declare-const var__temp_v_err385 T1531)
(declare-const var_h330 T1530)
(declare-const var_h266 T1530)
(declare-const var_h198 T1530)
(declare-const var_h130 T1530)
(declare-const var_h58 T1530)
(declare-const err T1544)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1530)
(declare-fun sel (T1530 Int) Int)
(declare-fun res () Int)
(declare-fun var_h266 () T1530)
(declare-fun var_h330 () T1530)
(declare-fun var_h198 () T1530)
(declare-fun var_h130 () T1530)
(declare-fun var_h58 () T1530)
(declare-fun |20| () Int)
(declare-fun var__temp_h382 () T1530)
(declare-fun |var__temp_h'384| () T1530)
(declare-fun v () Int)
(assert (= (sel var_h330 res) (+ (sel var_h266 res) 10)))
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h382 res) v) (= v |20|))
               (= (sel var__temp_h382 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'384| res) (+ (sel var__temp_h382 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h382 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************97
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v365:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h386 --->  Ty_heap  
 var__temp_v387 --->  Ty_int  
 var__temp_h'388 --->  Ty_heap  
 var__temp_v_err389 --->  error  
 var_h330 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) ==((sel)( , var_h266, res ) + (10)) AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h386, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h386, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h386, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'388, res ) ==((sel)( , var__temp_h386, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i331 T1547)
(declare-const var_h330 T1547)
(declare-const v Int)
(declare-const var_h_i267 T1547)
(declare-const var_h266 T1547)
(declare-const v Int)
(declare-const var_h_i199 T1547)
(declare-const var_h198 T1547)
(declare-const v Int)
(declare-const var_h_i131 T1547)
(declare-const var_h130 T1547)
(declare-const v Int)
(declare-const var_h_i59 T1547)
(declare-const var_h58 T1547)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h386 T1547)
(declare-const var__temp_v387 Int)
(declare-const |var__temp_h'388| T1547)
(declare-const var__temp_v_err389 T1548)
(declare-const var_h330 T1547)
(declare-const var_h266 T1547)
(declare-const var_h198 T1547)
(declare-const var_h130 T1547)
(declare-const var_h58 T1547)
(declare-const err T1561)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1547)
(declare-fun sel (T1547 Int) Int)
(declare-fun res () Int)
(declare-fun var_h266 () T1547)
(declare-fun var_h330 () T1547)
(declare-fun var_h198 () T1547)
(declare-fun var_h130 () T1547)
(declare-fun var_h58 () T1547)
(declare-fun |20| () Int)
(declare-fun var__temp_h386 () T1547)
(declare-fun |var__temp_h'388| () T1547)
(declare-fun v () Int)
(assert (= (sel var_h330 res) (+ (sel var_h266 res) 10)))
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h386 res) v) (= v |20|))
               (= (sel var__temp_h386 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'388| res) (+ (sel var__temp_h386 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h386 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************98
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (3) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v365:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h390 --->  Ty_heap  
 var__temp_v391 --->  Ty_int  
 var__temp_h'392 --->  Ty_heap  
 var__temp_v_err393 --->  error  
 var_h330 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) ==((sel)( , var_h266, res ) + (10)) AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h390, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h390, res ) > (3) AND 
 	 Rel (sel)( , var__temp_h390, res ) > (3) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'392, res ) ==(var__temp_v391) AND 
 	 Base var__temp_v391 = 5 => 
 	 True
 
VC_END(declare-const var_h_i331 T1564)
(declare-const var_h330 T1564)
(declare-const v Int)
(declare-const var_h_i267 T1564)
(declare-const var_h266 T1564)
(declare-const v Int)
(declare-const var_h_i199 T1564)
(declare-const var_h198 T1564)
(declare-const v Int)
(declare-const var_h_i131 T1564)
(declare-const var_h130 T1564)
(declare-const v Int)
(declare-const var_h_i59 T1564)
(declare-const var_h58 T1564)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h390 T1564)
(declare-const var__temp_v391 Int)
(declare-const |var__temp_h'392| T1564)
(declare-const var__temp_v_err393 T1565)
(declare-const var_h330 T1564)
(declare-const var_h266 T1564)
(declare-const var_h198 T1564)
(declare-const var_h130 T1564)
(declare-const var_h58 T1564)
(declare-const err T1578)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T1564)
(declare-fun sel (T1564 Int) Int)
(declare-fun res () Int)
(declare-fun var_h266 () T1564)
(declare-fun var_h330 () T1564)
(declare-fun var_h198 () T1564)
(declare-fun var_h130 () T1564)
(declare-fun var_h58 () T1564)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_v391 () Int)
(declare-fun |var__temp_h'392| () T1564)
(declare-fun var__temp_h390 () T1564)
(declare-fun v () Int)
(assert (= (sel var_h330 res) (+ (sel var_h266 res) 10)))
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h390 res) v) (= v |20|))
               (not (> (sel var__temp_h390 res) 3))))
      (a!2 (=> (and (= (sel |var__temp_h'392| res) var__temp_v391)
                    (= var__temp_v391 |5|))
               true)))
(let ((a!3 (=> (not (> (sel var__temp_h390 res) 3)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************99
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i331 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i331, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v365:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i331 --->  Ty_heap  
 var_h330 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h394 --->  Ty_heap  
 var__temp_v395 --->  Ty_int  
 var__temp_h'396 --->  Ty_heap  
 var__temp_v_err397 --->  error  
 var_h330 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h330, res ) ==((sel)( , var_h266, res ) + (10)) AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h394, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h394, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h394, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'396, res ) ==((sel)( , var__temp_h394, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i331 T1581)
(declare-const var_h330 T1581)
(declare-const v Int)
(declare-const var_h_i267 T1581)
(declare-const var_h266 T1581)
(declare-const v Int)
(declare-const var_h_i199 T1581)
(declare-const var_h198 T1581)
(declare-const v Int)
(declare-const var_h_i131 T1581)
(declare-const var_h130 T1581)
(declare-const v Int)
(declare-const var_h_i59 T1581)
(declare-const var_h58 T1581)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h394 T1581)
(declare-const var__temp_v395 Int)
(declare-const |var__temp_h'396| T1581)
(declare-const var__temp_v_err397 T1582)
(declare-const var_h330 T1581)
(declare-const var_h266 T1581)
(declare-const var_h198 T1581)
(declare-const var_h130 T1581)
(declare-const var_h58 T1581)
(declare-const err T1595)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1581)
(declare-fun sel (T1581 Int) Int)
(declare-fun res () Int)
(declare-fun var_h266 () T1581)
(declare-fun var_h330 () T1581)
(declare-fun var_h198 () T1581)
(declare-fun var_h130 () T1581)
(declare-fun var_h58 () T1581)
(declare-fun |20| () Int)
(declare-fun var__temp_h394 () T1581)
(declare-fun |var__temp_h'396| () T1581)
(declare-fun v () Int)
(assert (= (sel var_h330 res) (+ (sel var_h266 res) 10)))
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h394 res) v) (= v |20|))
               (= (sel var__temp_h394 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'396| res) (+ (sel var__temp_h394 res) 2))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h394 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************100
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo'
PARTIAL PATH
SUB 	 --c3'	 --c4	 --c2'	 --c2
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i267 Value = Ty_heap{ (sel)( , var_h_i267, res ) ==((sel)( , var_h266, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v398:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
baz
foo
bar
 *********************Enumeration Iteration*****************101
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i267 Value = Ty_heap{ (sel)( , var_h_i267, res ) ==((sel)( , var_h266, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v398:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h399 --->  Ty_heap  
 var__temp_v400 --->  Ty_int  
 var__temp_h'401 --->  Ty_heap  
 var__temp_v_err402 --->  error  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h399, res ) ==((sel)( , var_h266, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h399, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h399, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'401, res ) ==((sel)( , var__temp_h399, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i267 T1598)
(declare-const var_h266 T1598)
(declare-const v Int)
(declare-const var_h_i199 T1598)
(declare-const var_h198 T1598)
(declare-const v Int)
(declare-const var_h_i131 T1598)
(declare-const var_h130 T1598)
(declare-const v Int)
(declare-const var_h_i59 T1598)
(declare-const var_h58 T1598)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h399 T1598)
(declare-const var__temp_v400 Int)
(declare-const |var__temp_h'401| T1598)
(declare-const var__temp_v_err402 T1599)
(declare-const var_h266 T1598)
(declare-const var_h198 T1598)
(declare-const var_h130 T1598)
(declare-const var_h58 T1598)
(declare-const err T1612)

solver 
 (declare-sort T1598)
(declare-fun sel (T1598 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1598)
(declare-fun var_h266 () T1598)
(declare-fun var_h130 () T1598)
(declare-fun var_h58 () T1598)
(declare-fun var__temp_h399 () T1598)
(declare-fun |var__temp_h'401| () T1598)
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h399 res) (+ (sel var_h266 res) 10))
               (= (sel var__temp_h399 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'401| res) (+ (sel var__temp_h399 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h399 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************102
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i267 Value = Ty_heap{ (sel)( , var_h_i267, res ) ==((sel)( , var_h266, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v398:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h403 --->  Ty_heap  
 var__temp_v404 --->  Ty_int  
 var__temp_h'405 --->  Ty_heap  
 var__temp_v_err406 --->  error  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h403, res ) ==((sel)( , var_h266, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h403, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h403, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'405, res ) ==((sel)( , var__temp_h403, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i267 T1615)
(declare-const var_h266 T1615)
(declare-const v Int)
(declare-const var_h_i199 T1615)
(declare-const var_h198 T1615)
(declare-const v Int)
(declare-const var_h_i131 T1615)
(declare-const var_h130 T1615)
(declare-const v Int)
(declare-const var_h_i59 T1615)
(declare-const var_h58 T1615)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h403 T1615)
(declare-const var__temp_v404 Int)
(declare-const |var__temp_h'405| T1615)
(declare-const var__temp_v_err406 T1616)
(declare-const var_h266 T1615)
(declare-const var_h198 T1615)
(declare-const var_h130 T1615)
(declare-const var_h58 T1615)
(declare-const err T1629)

solver 
 (declare-sort T1615)
(declare-fun sel (T1615 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1615)
(declare-fun var_h266 () T1615)
(declare-fun var_h130 () T1615)
(declare-fun var_h58 () T1615)
(declare-fun var__temp_h403 () T1615)
(declare-fun |var__temp_h'405| () T1615)
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h403 res) (+ (sel var_h266 res) 10))
               (= (sel var__temp_h403 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'405| res) (+ (sel var__temp_h403 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h403 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************103
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i267 Value = Ty_heap{ (sel)( , var_h_i267, res ) ==((sel)( , var_h266, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v398:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h407 --->  Ty_heap  
 var__temp_v408 --->  Ty_int  
 var__temp_h'409 --->  Ty_heap  
 var__temp_v_err410 --->  error  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h407, res ) ==((sel)( , var_h266, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h407, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h407, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'409, res ) ==((sel)( , var__temp_h407, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i267 T1632)
(declare-const var_h266 T1632)
(declare-const v Int)
(declare-const var_h_i199 T1632)
(declare-const var_h198 T1632)
(declare-const v Int)
(declare-const var_h_i131 T1632)
(declare-const var_h130 T1632)
(declare-const v Int)
(declare-const var_h_i59 T1632)
(declare-const var_h58 T1632)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h407 T1632)
(declare-const var__temp_v408 Int)
(declare-const |var__temp_h'409| T1632)
(declare-const var__temp_v_err410 T1633)
(declare-const var_h266 T1632)
(declare-const var_h198 T1632)
(declare-const var_h130 T1632)
(declare-const var_h58 T1632)
(declare-const err T1646)

solver 
 (declare-sort T1632)
(declare-fun sel (T1632 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1632)
(declare-fun var_h266 () T1632)
(declare-fun var_h130 () T1632)
(declare-fun var_h58 () T1632)
(declare-fun var__temp_h407 () T1632)
(declare-fun |var__temp_h'409| () T1632)
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h407 res) (+ (sel var_h266 res) 10))
               (= (sel var__temp_h407 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'409| res) (+ (sel var__temp_h407 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h407 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************104
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i267 Value = Ty_heap{ (sel)( , var_h_i267, res ) ==((sel)( , var_h266, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v398:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h411 --->  Ty_heap  
 var__temp_v412 --->  Ty_int  
 var__temp_h'413 --->  Ty_heap  
 var__temp_v_err414 --->  error  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h411, res ) ==((sel)( , var_h266, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h411, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h411, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'413, res ) ==((sel)( , var__temp_h411, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i267 T1649)
(declare-const var_h266 T1649)
(declare-const v Int)
(declare-const var_h_i199 T1649)
(declare-const var_h198 T1649)
(declare-const v Int)
(declare-const var_h_i131 T1649)
(declare-const var_h130 T1649)
(declare-const v Int)
(declare-const var_h_i59 T1649)
(declare-const var_h58 T1649)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h411 T1649)
(declare-const var__temp_v412 Int)
(declare-const |var__temp_h'413| T1649)
(declare-const var__temp_v_err414 T1650)
(declare-const var_h266 T1649)
(declare-const var_h198 T1649)
(declare-const var_h130 T1649)
(declare-const var_h58 T1649)
(declare-const err T1663)

solver 
 (declare-sort T1649)
(declare-fun sel (T1649 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1649)
(declare-fun var_h266 () T1649)
(declare-fun var_h130 () T1649)
(declare-fun var_h58 () T1649)
(declare-fun var__temp_h411 () T1649)
(declare-fun |var__temp_h'413| () T1649)
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h411 res) (+ (sel var_h266 res) 10))
               (= (sel var__temp_h411 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'413| res) (+ (sel var__temp_h411 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h411 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************105
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i267 Value = Ty_heap{ (sel)( , var_h_i267, res ) ==((sel)( , var_h266, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v398:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h415 --->  Ty_heap  
 var__temp_v416 --->  Ty_int  
 var__temp_h'417 --->  Ty_heap  
 var__temp_v_err418 --->  error  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h415, res ) ==((sel)( , var_h266, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h415, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h415, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'417, res ) ==((sel)( , var__temp_h415, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i267 T1666)
(declare-const var_h266 T1666)
(declare-const v Int)
(declare-const var_h_i199 T1666)
(declare-const var_h198 T1666)
(declare-const v Int)
(declare-const var_h_i131 T1666)
(declare-const var_h130 T1666)
(declare-const v Int)
(declare-const var_h_i59 T1666)
(declare-const var_h58 T1666)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h415 T1666)
(declare-const var__temp_v416 Int)
(declare-const |var__temp_h'417| T1666)
(declare-const var__temp_v_err418 T1667)
(declare-const var_h266 T1666)
(declare-const var_h198 T1666)
(declare-const var_h130 T1666)
(declare-const var_h58 T1666)
(declare-const err T1680)

solver 
 (declare-sort T1666)
(declare-fun sel (T1666 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1666)
(declare-fun var_h266 () T1666)
(declare-fun var_h130 () T1666)
(declare-fun var_h58 () T1666)
(declare-fun var__temp_h415 () T1666)
(declare-fun |var__temp_h'417| () T1666)
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h415 res) (+ (sel var_h266 res) 10))
               (= (sel var__temp_h415 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'417| res) (+ (sel var__temp_h415 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h415 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************106
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i267 Value = Ty_heap{ (sel)( , var_h_i267, res ) ==((sel)( , var_h266, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v398:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h419 --->  Ty_heap  
 var__temp_v420 --->  Ty_int  
 var__temp_h'421 --->  Ty_heap  
 var__temp_v_err422 --->  error  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h419, res ) ==((sel)( , var_h266, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h419, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h419, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'421, res ) ==((sel)( , var__temp_h419, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i267 T1683)
(declare-const var_h266 T1683)
(declare-const v Int)
(declare-const var_h_i199 T1683)
(declare-const var_h198 T1683)
(declare-const v Int)
(declare-const var_h_i131 T1683)
(declare-const var_h130 T1683)
(declare-const v Int)
(declare-const var_h_i59 T1683)
(declare-const var_h58 T1683)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h419 T1683)
(declare-const var__temp_v420 Int)
(declare-const |var__temp_h'421| T1683)
(declare-const var__temp_v_err422 T1684)
(declare-const var_h266 T1683)
(declare-const var_h198 T1683)
(declare-const var_h130 T1683)
(declare-const var_h58 T1683)
(declare-const err T1697)

solver 
 (declare-sort T1683)
(declare-fun sel (T1683 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1683)
(declare-fun var_h266 () T1683)
(declare-fun var_h130 () T1683)
(declare-fun var_h58 () T1683)
(declare-fun var__temp_h419 () T1683)
(declare-fun |var__temp_h'421| () T1683)
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h419 res) (+ (sel var_h266 res) 10))
               (= (sel var__temp_h419 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'421| res) (+ (sel var__temp_h419 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h419 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************107
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (3) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i267 Value = Ty_heap{ (sel)( , var_h_i267, res ) ==((sel)( , var_h266, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v398:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h423 --->  Ty_heap  
 var__temp_v424 --->  Ty_int  
 var__temp_h'425 --->  Ty_heap  
 var__temp_v_err426 --->  error  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h423, res ) ==((sel)( , var_h266, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h423, res ) > (3) AND 
 	 Rel (sel)( , var__temp_h423, res ) > (3) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'425, res ) ==(var__temp_v424) AND 
 	 Base var__temp_v424 = 5 => 
 	 True
 
VC_END(declare-const var_h_i267 T1700)
(declare-const var_h266 T1700)
(declare-const v Int)
(declare-const var_h_i199 T1700)
(declare-const var_h198 T1700)
(declare-const v Int)
(declare-const var_h_i131 T1700)
(declare-const var_h130 T1700)
(declare-const v Int)
(declare-const var_h_i59 T1700)
(declare-const var_h58 T1700)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h423 T1700)
(declare-const var__temp_v424 Int)
(declare-const |var__temp_h'425| T1700)
(declare-const var__temp_v_err426 T1701)
(declare-const var_h266 T1700)
(declare-const var_h198 T1700)
(declare-const var_h130 T1700)
(declare-const var_h58 T1700)
(declare-const err T1714)
    (declare-const |5| Int)
  
solver 
 (declare-sort T1700)
(declare-fun sel (T1700 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1700)
(declare-fun var_h266 () T1700)
(declare-fun var_h130 () T1700)
(declare-fun var_h58 () T1700)
(declare-fun |5| () Int)
(declare-fun var__temp_v424 () Int)
(declare-fun |var__temp_h'425| () T1700)
(declare-fun var__temp_h423 () T1700)
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h423 res) (+ (sel var_h266 res) 10))
               (not (> (sel var__temp_h423 res) 3))))
      (a!2 (=> (and (= (sel |var__temp_h'425| res) var__temp_v424)
                    (= var__temp_v424 |5|))
               true)))
(let ((a!3 (=> (not (> (sel var__temp_h423 res) 3)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************108
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i267 Value = Ty_heap{ (sel)( , var_h_i267, res ) ==((sel)( , var_h266, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v398:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i267 --->  Ty_heap  
 var_h266 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h427 --->  Ty_heap  
 var__temp_v428 --->  Ty_int  
 var__temp_h'429 --->  Ty_heap  
 var__temp_v_err430 --->  error  
 var_h266 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h266, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h427, res ) ==((sel)( , var_h266, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h427, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h427, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'429, res ) ==((sel)( , var__temp_h427, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i267 T1717)
(declare-const var_h266 T1717)
(declare-const v Int)
(declare-const var_h_i199 T1717)
(declare-const var_h198 T1717)
(declare-const v Int)
(declare-const var_h_i131 T1717)
(declare-const var_h130 T1717)
(declare-const v Int)
(declare-const var_h_i59 T1717)
(declare-const var_h58 T1717)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h427 T1717)
(declare-const var__temp_v428 Int)
(declare-const |var__temp_h'429| T1717)
(declare-const var__temp_v_err430 T1718)
(declare-const var_h266 T1717)
(declare-const var_h198 T1717)
(declare-const var_h130 T1717)
(declare-const var_h58 T1717)
(declare-const err T1731)

solver 
 (declare-sort T1717)
(declare-fun sel (T1717 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1717)
(declare-fun var_h266 () T1717)
(declare-fun var_h130 () T1717)
(declare-fun var_h58 () T1717)
(declare-fun var__temp_h427 () T1717)
(declare-fun |var__temp_h'429| () T1717)
(assert (= (sel var_h266 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h427 res) (+ (sel var_h266 res) 10))
               (= (sel var__temp_h427 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'429| res) (+ (sel var__temp_h427 res) 2))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h427 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************109
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo'
PARTIAL PATH
SUB 	 --c3'	 --c4	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v431:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
foo'
baz
foo
bar
 *********************Enumeration Iteration*****************110
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v431:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h432 --->  Ty_heap  
 var__temp_v433 --->  Ty_int  
 var__temp_h'434 --->  Ty_heap  
 var__temp_v_err435 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h432, res ) ==(sel)( , var_h198, res ) => 
 	 Rel (sel)( , var__temp_h432, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h432, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'434, res ) ==((sel)( , var__temp_h432, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i199 T1734)
(declare-const var_h198 T1734)
(declare-const v Int)
(declare-const var_h_i131 T1734)
(declare-const var_h130 T1734)
(declare-const v Int)
(declare-const var_h_i59 T1734)
(declare-const var_h58 T1734)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h432 T1734)
(declare-const var__temp_v433 Int)
(declare-const |var__temp_h'434| T1734)
(declare-const var__temp_v_err435 T1735)
(declare-const var_h198 T1734)
(declare-const var_h130 T1734)
(declare-const var_h58 T1734)
(declare-const err T1748)

solver 
 (declare-sort T1734)
(declare-fun sel (T1734 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T1734)
(declare-fun var_h198 () T1734)
(declare-fun var_h58 () T1734)
(declare-fun var__temp_h432 () T1734)
(declare-fun |var__temp_h'434| () T1734)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'434| res) (+ (sel var__temp_h432 res) 4))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h432 res) (sel var_h198 res))
                    (= (sel var__temp_h432 res) 7))
                (=> (= (sel var__temp_h432 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************111
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v431:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h436 --->  Ty_heap  
 var__temp_v437 --->  Ty_int  
 var__temp_h'438 --->  Ty_heap  
 var__temp_v_err439 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h436, res ) ==(sel)( , var_h198, res ) => 
 	 Rel (sel)( , var__temp_h436, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h436, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'438, res ) ==((sel)( , var__temp_h436, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i199 T1751)
(declare-const var_h198 T1751)
(declare-const v Int)
(declare-const var_h_i131 T1751)
(declare-const var_h130 T1751)
(declare-const v Int)
(declare-const var_h_i59 T1751)
(declare-const var_h58 T1751)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h436 T1751)
(declare-const var__temp_v437 Int)
(declare-const |var__temp_h'438| T1751)
(declare-const var__temp_v_err439 T1752)
(declare-const var_h198 T1751)
(declare-const var_h130 T1751)
(declare-const var_h58 T1751)
(declare-const err T1765)

solver 
 (declare-sort T1751)
(declare-fun sel (T1751 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T1751)
(declare-fun var_h198 () T1751)
(declare-fun var_h58 () T1751)
(declare-fun var__temp_h436 () T1751)
(declare-fun |var__temp_h'438| () T1751)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'438| res) (+ (sel var__temp_h436 res) 4))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h436 res) (sel var_h198 res))
                    (= (sel var__temp_h436 res) 7))
                (=> (= (sel var__temp_h436 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************112
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v431:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h440 --->  Ty_heap  
 var__temp_v441 --->  Ty_int  
 var__temp_h'442 --->  Ty_heap  
 var__temp_v_err443 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h440, res ) ==(sel)( , var_h198, res ) => 
 	 Rel (sel)( , var__temp_h440, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h440, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'442, res ) ==((sel)( , var__temp_h440, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i199 T1768)
(declare-const var_h198 T1768)
(declare-const v Int)
(declare-const var_h_i131 T1768)
(declare-const var_h130 T1768)
(declare-const v Int)
(declare-const var_h_i59 T1768)
(declare-const var_h58 T1768)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h440 T1768)
(declare-const var__temp_v441 Int)
(declare-const |var__temp_h'442| T1768)
(declare-const var__temp_v_err443 T1769)
(declare-const var_h198 T1768)
(declare-const var_h130 T1768)
(declare-const var_h58 T1768)
(declare-const err T1782)

solver 
 (declare-sort T1768)
(declare-fun sel (T1768 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T1768)
(declare-fun var_h198 () T1768)
(declare-fun var_h58 () T1768)
(declare-fun var__temp_h440 () T1768)
(declare-fun |var__temp_h'442| () T1768)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'442| res) (+ (sel var__temp_h440 res) 4))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h440 res) (sel var_h198 res))
                    (= (sel var__temp_h440 res) 7))
                (=> (= (sel var__temp_h440 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************113
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v431:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h444 --->  Ty_heap  
 var__temp_v445 --->  Ty_int  
 var__temp_h'446 --->  Ty_heap  
 var__temp_v_err447 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h444, res ) ==(sel)( , var_h198, res ) => 
 	 Rel (sel)( , var__temp_h444, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h444, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'446, res ) ==((sel)( , var__temp_h444, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i199 T1785)
(declare-const var_h198 T1785)
(declare-const v Int)
(declare-const var_h_i131 T1785)
(declare-const var_h130 T1785)
(declare-const v Int)
(declare-const var_h_i59 T1785)
(declare-const var_h58 T1785)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h444 T1785)
(declare-const var__temp_v445 Int)
(declare-const |var__temp_h'446| T1785)
(declare-const var__temp_v_err447 T1786)
(declare-const var_h198 T1785)
(declare-const var_h130 T1785)
(declare-const var_h58 T1785)
(declare-const err T1799)

solver 
 (declare-sort T1785)
(declare-fun sel (T1785 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T1785)
(declare-fun var_h198 () T1785)
(declare-fun var_h58 () T1785)
(declare-fun var__temp_h444 () T1785)
(declare-fun |var__temp_h'446| () T1785)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'446| res) (+ (sel var__temp_h444 res) 5))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h444 res) (sel var_h198 res))
                    (= (sel var__temp_h444 res) 7))
                (=> (= (sel var__temp_h444 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************114
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v431:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h448 --->  Ty_heap  
 var__temp_v449 --->  Ty_int  
 var__temp_h'450 --->  Ty_heap  
 var__temp_v_err451 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h448, res ) ==(sel)( , var_h198, res ) => 
 	 Rel (sel)( , var__temp_h448, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h448, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'450, res ) ==((sel)( , var__temp_h448, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i199 T1802)
(declare-const var_h198 T1802)
(declare-const v Int)
(declare-const var_h_i131 T1802)
(declare-const var_h130 T1802)
(declare-const v Int)
(declare-const var_h_i59 T1802)
(declare-const var_h58 T1802)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h448 T1802)
(declare-const var__temp_v449 Int)
(declare-const |var__temp_h'450| T1802)
(declare-const var__temp_v_err451 T1803)
(declare-const var_h198 T1802)
(declare-const var_h130 T1802)
(declare-const var_h58 T1802)
(declare-const err T1816)

solver 
 (declare-sort T1802)
(declare-fun sel (T1802 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T1802)
(declare-fun var_h198 () T1802)
(declare-fun var_h58 () T1802)
(declare-fun var__temp_h448 () T1802)
(declare-fun |var__temp_h'450| () T1802)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'450| res) (+ (sel var__temp_h448 res) 5))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h448 res) (sel var_h198 res))
                    (= (sel var__temp_h448 res) 6))
                (=> (= (sel var__temp_h448 res) 6) a!1))))
  (not a!2))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************115
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 20} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v431:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h452 --->  Ty_heap  
 var__temp_v453 --->  Ty_int  
 var__temp_h'454 --->  Ty_heap  
 var__temp_v_err455 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h452, res ) ==(sel)( , var_h198, res ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'454, res ) ==(var__temp_v453) AND 
 	 Base var__temp_v453 = 20 => 
 	 True
 
VC_END(declare-const var_h_i199 T1819)
(declare-const var_h198 T1819)
(declare-const v Int)
(declare-const var_h_i131 T1819)
(declare-const var_h130 T1819)
(declare-const v Int)
(declare-const var_h_i59 T1819)
(declare-const var_h58 T1819)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h452 T1819)
(declare-const var__temp_v453 Int)
(declare-const |var__temp_h'454| T1819)
(declare-const var__temp_v_err455 T1820)
(declare-const var_h198 T1819)
(declare-const var_h130 T1819)
(declare-const var_h58 T1819)
(declare-const err T1833)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1819)
(declare-fun sel (T1819 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T1819)
(declare-fun var_h198 () T1819)
(declare-fun var_h58 () T1819)
(declare-fun |20| () Int)
(declare-fun var__temp_v453 () Int)
(declare-fun |var__temp_h'454| () T1819)
(declare-fun var__temp_h452 () T1819)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel |var__temp_h'454| res) var__temp_v453)
                    (= var__temp_v453 |20|))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h452 res) (sel var_h198 res)) true)
                (=> true a!1))))
  (not a!2))))

***************Selection Successful************foo'
PARTIAL PATH NEW
NEW 	 --c3'	 --c4	 --c2'	 --foo'
post_substituted Forall 
 	 
 Key =var_h_i457 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i457 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i457, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v458:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i457 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
baz
foo
bar
 *********************Enumeration Iteration*****************116
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i457 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i457, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v458:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i457 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i457 --->  Ty_heap  
 var_h456 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h459 --->  Ty_heap  
 var__temp_v460 --->  Ty_int  
 var__temp_h'461 --->  Ty_heap  
 var__temp_v_err462 --->  error  
 var_h456 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h456, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h459, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h459, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h459, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'461, res ) ==((sel)( , var__temp_h459, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'461, res ) ==(10)
 
VC_END(declare-const var_h_i457 T1836)
(declare-const var_h456 T1836)
(declare-const v Int)
(declare-const var_h_i199 T1836)
(declare-const var_h198 T1836)
(declare-const v Int)
(declare-const var_h_i131 T1836)
(declare-const var_h130 T1836)
(declare-const v Int)
(declare-const var_h_i59 T1836)
(declare-const var_h58 T1836)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h459 T1836)
(declare-const var__temp_v460 Int)
(declare-const |var__temp_h'461| T1836)
(declare-const var__temp_v_err462 T1837)
(declare-const var_h456 T1836)
(declare-const var_h198 T1836)
(declare-const var_h130 T1836)
(declare-const var_h58 T1836)
(declare-const err T1850)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1836)
(declare-fun sel (T1836 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1836)
(declare-fun var_h456 () T1836)
(declare-fun var_h130 () T1836)
(declare-fun var_h58 () T1836)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'461| () T1836)
(declare-fun var__temp_h459 () T1836)
(declare-fun v () Int)
(assert (= (sel var_h456 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h459 res) v) (= v |20|))
               (= (sel var__temp_h459 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'461| res) (+ (sel var__temp_h459 res) 4))
               (= (sel |var__temp_h'461| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h459 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************117
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i457 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i457, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v458:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i457 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i457 --->  Ty_heap  
 var_h456 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h463 --->  Ty_heap  
 var__temp_v464 --->  Ty_int  
 var__temp_h'465 --->  Ty_heap  
 var__temp_v_err466 --->  error  
 var_h456 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h456, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h463, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h463, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h463, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'465, res ) ==((sel)( , var__temp_h463, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'465, res ) ==(10)
 
VC_END(declare-const var_h_i457 T1853)
(declare-const var_h456 T1853)
(declare-const v Int)
(declare-const var_h_i199 T1853)
(declare-const var_h198 T1853)
(declare-const v Int)
(declare-const var_h_i131 T1853)
(declare-const var_h130 T1853)
(declare-const v Int)
(declare-const var_h_i59 T1853)
(declare-const var_h58 T1853)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h463 T1853)
(declare-const var__temp_v464 Int)
(declare-const |var__temp_h'465| T1853)
(declare-const var__temp_v_err466 T1854)
(declare-const var_h456 T1853)
(declare-const var_h198 T1853)
(declare-const var_h130 T1853)
(declare-const var_h58 T1853)
(declare-const err T1867)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1853)
(declare-fun sel (T1853 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1853)
(declare-fun var_h456 () T1853)
(declare-fun var_h130 () T1853)
(declare-fun var_h58 () T1853)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'465| () T1853)
(declare-fun var__temp_h463 () T1853)
(declare-fun v () Int)
(assert (= (sel var_h456 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h463 res) v) (= v |20|))
               (= (sel var__temp_h463 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'465| res) (+ (sel var__temp_h463 res) 4))
               (= (sel |var__temp_h'465| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h463 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************118
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i457 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i457, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v458:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i457 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i457 --->  Ty_heap  
 var_h456 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h467 --->  Ty_heap  
 var__temp_v468 --->  Ty_int  
 var__temp_h'469 --->  Ty_heap  
 var__temp_v_err470 --->  error  
 var_h456 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h456, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h467, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h467, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h467, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'469, res ) ==((sel)( , var__temp_h467, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'469, res ) ==(10)
 
VC_END(declare-const var_h_i457 T1870)
(declare-const var_h456 T1870)
(declare-const v Int)
(declare-const var_h_i199 T1870)
(declare-const var_h198 T1870)
(declare-const v Int)
(declare-const var_h_i131 T1870)
(declare-const var_h130 T1870)
(declare-const v Int)
(declare-const var_h_i59 T1870)
(declare-const var_h58 T1870)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h467 T1870)
(declare-const var__temp_v468 Int)
(declare-const |var__temp_h'469| T1870)
(declare-const var__temp_v_err470 T1871)
(declare-const var_h456 T1870)
(declare-const var_h198 T1870)
(declare-const var_h130 T1870)
(declare-const var_h58 T1870)
(declare-const err T1884)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1870)
(declare-fun sel (T1870 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1870)
(declare-fun var_h456 () T1870)
(declare-fun var_h130 () T1870)
(declare-fun var_h58 () T1870)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'469| () T1870)
(declare-fun var__temp_h467 () T1870)
(declare-fun v () Int)
(assert (= (sel var_h456 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h467 res) v) (= v |20|))
               (= (sel var__temp_h467 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'469| res) (+ (sel var__temp_h467 res) 4))
               (= (sel |var__temp_h'469| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h467 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************119
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i457 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i457, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v458:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i457 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i457 --->  Ty_heap  
 var_h456 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h471 --->  Ty_heap  
 var__temp_v472 --->  Ty_int  
 var__temp_h'473 --->  Ty_heap  
 var__temp_v_err474 --->  error  
 var_h456 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h456, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h471, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h471, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h471, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'473, res ) ==((sel)( , var__temp_h471, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'473, res ) ==(10)
 
VC_END(declare-const var_h_i457 T1887)
(declare-const var_h456 T1887)
(declare-const v Int)
(declare-const var_h_i199 T1887)
(declare-const var_h198 T1887)
(declare-const v Int)
(declare-const var_h_i131 T1887)
(declare-const var_h130 T1887)
(declare-const v Int)
(declare-const var_h_i59 T1887)
(declare-const var_h58 T1887)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h471 T1887)
(declare-const var__temp_v472 Int)
(declare-const |var__temp_h'473| T1887)
(declare-const var__temp_v_err474 T1888)
(declare-const var_h456 T1887)
(declare-const var_h198 T1887)
(declare-const var_h130 T1887)
(declare-const var_h58 T1887)
(declare-const err T1901)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1887)
(declare-fun sel (T1887 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1887)
(declare-fun var_h456 () T1887)
(declare-fun var_h130 () T1887)
(declare-fun var_h58 () T1887)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'473| () T1887)
(declare-fun var__temp_h471 () T1887)
(declare-fun v () Int)
(assert (= (sel var_h456 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h471 res) v) (= v |20|))
               (= (sel var__temp_h471 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'473| res) (+ (sel var__temp_h471 res) 5))
               (= (sel |var__temp_h'473| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h471 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************120
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i457 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i457, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v458:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i457 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i457 --->  Ty_heap  
 var_h456 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h475 --->  Ty_heap  
 var__temp_v476 --->  Ty_int  
 var__temp_h'477 --->  Ty_heap  
 var__temp_v_err478 --->  error  
 var_h456 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h456, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h475, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h475, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h475, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'477, res ) ==((sel)( , var__temp_h475, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'477, res ) ==(10)
 
VC_END(declare-const var_h_i457 T1904)
(declare-const var_h456 T1904)
(declare-const v Int)
(declare-const var_h_i199 T1904)
(declare-const var_h198 T1904)
(declare-const v Int)
(declare-const var_h_i131 T1904)
(declare-const var_h130 T1904)
(declare-const v Int)
(declare-const var_h_i59 T1904)
(declare-const var_h58 T1904)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h475 T1904)
(declare-const var__temp_v476 Int)
(declare-const |var__temp_h'477| T1904)
(declare-const var__temp_v_err478 T1905)
(declare-const var_h456 T1904)
(declare-const var_h198 T1904)
(declare-const var_h130 T1904)
(declare-const var_h58 T1904)
(declare-const err T1918)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1904)
(declare-fun sel (T1904 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1904)
(declare-fun var_h456 () T1904)
(declare-fun var_h130 () T1904)
(declare-fun var_h58 () T1904)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'477| () T1904)
(declare-fun var__temp_h475 () T1904)
(declare-fun v () Int)
(assert (= (sel var_h456 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h475 res) v) (= v |20|))
               (= (sel var__temp_h475 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'477| res) (+ (sel var__temp_h475 res) 5))
               (= (sel |var__temp_h'477| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h475 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************121
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i457 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i457, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v458:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i457 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i457 --->  Ty_heap  
 var_h456 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h479 --->  Ty_heap  
 var__temp_v480 --->  Ty_int  
 var__temp_h'481 --->  Ty_heap  
 var__temp_v_err482 --->  error  
 var_h456 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h456, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h479, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h479, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h479, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'481, res ) ==((sel)( , var__temp_h479, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'481, res ) ==(10)
 
VC_END(declare-const var_h_i457 T1921)
(declare-const var_h456 T1921)
(declare-const v Int)
(declare-const var_h_i199 T1921)
(declare-const var_h198 T1921)
(declare-const v Int)
(declare-const var_h_i131 T1921)
(declare-const var_h130 T1921)
(declare-const v Int)
(declare-const var_h_i59 T1921)
(declare-const var_h58 T1921)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h479 T1921)
(declare-const var__temp_v480 Int)
(declare-const |var__temp_h'481| T1921)
(declare-const var__temp_v_err482 T1922)
(declare-const var_h456 T1921)
(declare-const var_h198 T1921)
(declare-const var_h130 T1921)
(declare-const var_h58 T1921)
(declare-const err T1935)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1921)
(declare-fun sel (T1921 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1921)
(declare-fun var_h456 () T1921)
(declare-fun var_h130 () T1921)
(declare-fun var_h58 () T1921)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'481| () T1921)
(declare-fun var__temp_h479 () T1921)
(declare-fun v () Int)
(assert (= (sel var_h456 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h479 res) v) (= v |20|))
               (= (sel var__temp_h479 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'481| res) (+ (sel var__temp_h479 res) 3))
               (= (sel |var__temp_h'481| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h479 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************122
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (3) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i457 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i457, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v458:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i457 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i457 --->  Ty_heap  
 var_h456 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h483 --->  Ty_heap  
 var__temp_v484 --->  Ty_int  
 var__temp_h'485 --->  Ty_heap  
 var__temp_v_err486 --->  error  
 var_h456 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h456, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h483, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h483, res ) > (3) AND 
 	 Rel (sel)( , var__temp_h483, res ) > (3) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'485, res ) ==(var__temp_v484) AND 
 	 Base var__temp_v484 = 5 => 
 	 Rel (sel)( , var__temp_h'485, res ) ==(10)
 
VC_END(declare-const var_h_i457 T1938)
(declare-const var_h456 T1938)
(declare-const v Int)
(declare-const var_h_i199 T1938)
(declare-const var_h198 T1938)
(declare-const v Int)
(declare-const var_h_i131 T1938)
(declare-const var_h130 T1938)
(declare-const v Int)
(declare-const var_h_i59 T1938)
(declare-const var_h58 T1938)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h483 T1938)
(declare-const var__temp_v484 Int)
(declare-const |var__temp_h'485| T1938)
(declare-const var__temp_v_err486 T1939)
(declare-const var_h456 T1938)
(declare-const var_h198 T1938)
(declare-const var_h130 T1938)
(declare-const var_h58 T1938)
(declare-const err T1952)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T1938)
(declare-fun sel (T1938 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1938)
(declare-fun var_h456 () T1938)
(declare-fun var_h130 () T1938)
(declare-fun var_h58 () T1938)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'485| () T1938)
(declare-fun var__temp_v484 () Int)
(declare-fun var__temp_h483 () T1938)
(declare-fun v () Int)
(assert (= (sel var_h456 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h483 res) v) (= v |20|))
               (not (> (sel var__temp_h483 res) 3))))
      (a!2 (=> (and (= (sel |var__temp_h'485| res) var__temp_v484)
                    (= var__temp_v484 |5|))
               (= (sel |var__temp_h'485| res) 10))))
(let ((a!3 (=> (not (> (sel var__temp_h483 res) 3)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************123
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i457 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i457, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v458:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i457 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i457 --->  Ty_heap  
 var_h456 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h487 --->  Ty_heap  
 var__temp_v488 --->  Ty_int  
 var__temp_h'489 --->  Ty_heap  
 var__temp_v_err490 --->  error  
 var_h456 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h456, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h487, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h487, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h487, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'489, res ) ==((sel)( , var__temp_h487, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'489, res ) ==(10)
 
VC_END(declare-const var_h_i457 T1955)
(declare-const var_h456 T1955)
(declare-const v Int)
(declare-const var_h_i199 T1955)
(declare-const var_h198 T1955)
(declare-const v Int)
(declare-const var_h_i131 T1955)
(declare-const var_h130 T1955)
(declare-const v Int)
(declare-const var_h_i59 T1955)
(declare-const var_h58 T1955)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h487 T1955)
(declare-const var__temp_v488 Int)
(declare-const |var__temp_h'489| T1955)
(declare-const var__temp_v_err490 T1956)
(declare-const var_h456 T1955)
(declare-const var_h198 T1955)
(declare-const var_h130 T1955)
(declare-const var_h58 T1955)
(declare-const err T1969)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1955)
(declare-fun sel (T1955 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1955)
(declare-fun var_h456 () T1955)
(declare-fun var_h130 () T1955)
(declare-fun var_h58 () T1955)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'489| () T1955)
(declare-fun var__temp_h487 () T1955)
(declare-fun v () Int)
(assert (= (sel var_h456 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h487 res) v) (= v |20|))
               (= (sel var__temp_h487 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'489| res) (+ (sel var__temp_h487 res) 2))
               (= (sel |var__temp_h'489| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h487 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************124
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v458:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v458:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfoo'c2c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --c4	 --c2'	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i457 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i457, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v491:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
baz
foo
bar
 *********************Enumeration Iteration*****************125
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i457 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i457, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v491:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i457 --->  Ty_heap  
 var_h456 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h492 --->  Ty_heap  
 var__temp_v493 --->  Ty_int  
 var__temp_h'494 --->  Ty_heap  
 var__temp_v_err495 --->  error  
 var_h456 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h456, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h492, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h492, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h492, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'494, res ) ==((sel)( , var__temp_h492, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i457 T1972)
(declare-const var_h456 T1972)
(declare-const v Int)
(declare-const var_h_i199 T1972)
(declare-const var_h198 T1972)
(declare-const v Int)
(declare-const var_h_i131 T1972)
(declare-const var_h130 T1972)
(declare-const v Int)
(declare-const var_h_i59 T1972)
(declare-const var_h58 T1972)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h492 T1972)
(declare-const var__temp_v493 Int)
(declare-const |var__temp_h'494| T1972)
(declare-const var__temp_v_err495 T1973)
(declare-const var_h456 T1972)
(declare-const var_h198 T1972)
(declare-const var_h130 T1972)
(declare-const var_h58 T1972)
(declare-const err T1986)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1972)
(declare-fun sel (T1972 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1972)
(declare-fun var_h456 () T1972)
(declare-fun var_h130 () T1972)
(declare-fun var_h58 () T1972)
(declare-fun |20| () Int)
(declare-fun var__temp_h492 () T1972)
(declare-fun |var__temp_h'494| () T1972)
(declare-fun v () Int)
(assert (= (sel var_h456 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h492 res) v) (= v |20|))
               (= (sel var__temp_h492 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'494| res) (+ (sel var__temp_h492 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h492 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************126
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i457 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i457, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v491:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i457 --->  Ty_heap  
 var_h456 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h496 --->  Ty_heap  
 var__temp_v497 --->  Ty_int  
 var__temp_h'498 --->  Ty_heap  
 var__temp_v_err499 --->  error  
 var_h456 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h456, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h496, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h496, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h496, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'498, res ) ==((sel)( , var__temp_h496, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i457 T1989)
(declare-const var_h456 T1989)
(declare-const v Int)
(declare-const var_h_i199 T1989)
(declare-const var_h198 T1989)
(declare-const v Int)
(declare-const var_h_i131 T1989)
(declare-const var_h130 T1989)
(declare-const v Int)
(declare-const var_h_i59 T1989)
(declare-const var_h58 T1989)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h496 T1989)
(declare-const var__temp_v497 Int)
(declare-const |var__temp_h'498| T1989)
(declare-const var__temp_v_err499 T1990)
(declare-const var_h456 T1989)
(declare-const var_h198 T1989)
(declare-const var_h130 T1989)
(declare-const var_h58 T1989)
(declare-const err T2003)
    (declare-const |20| Int)
  
solver 
 (declare-sort T1989)
(declare-fun sel (T1989 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T1989)
(declare-fun var_h456 () T1989)
(declare-fun var_h130 () T1989)
(declare-fun var_h58 () T1989)
(declare-fun |20| () Int)
(declare-fun var__temp_h496 () T1989)
(declare-fun |var__temp_h'498| () T1989)
(declare-fun v () Int)
(assert (= (sel var_h456 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h496 res) v) (= v |20|))
               (= (sel var__temp_h496 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'498| res) (+ (sel var__temp_h496 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h496 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************127
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i457 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i457, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v491:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i457 --->  Ty_heap  
 var_h456 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h500 --->  Ty_heap  
 var__temp_v501 --->  Ty_int  
 var__temp_h'502 --->  Ty_heap  
 var__temp_v_err503 --->  error  
 var_h456 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h456, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h500, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h500, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h500, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'502, res ) ==((sel)( , var__temp_h500, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i457 T2006)
(declare-const var_h456 T2006)
(declare-const v Int)
(declare-const var_h_i199 T2006)
(declare-const var_h198 T2006)
(declare-const v Int)
(declare-const var_h_i131 T2006)
(declare-const var_h130 T2006)
(declare-const v Int)
(declare-const var_h_i59 T2006)
(declare-const var_h58 T2006)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h500 T2006)
(declare-const var__temp_v501 Int)
(declare-const |var__temp_h'502| T2006)
(declare-const var__temp_v_err503 T2007)
(declare-const var_h456 T2006)
(declare-const var_h198 T2006)
(declare-const var_h130 T2006)
(declare-const var_h58 T2006)
(declare-const err T2020)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2006)
(declare-fun sel (T2006 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T2006)
(declare-fun var_h456 () T2006)
(declare-fun var_h130 () T2006)
(declare-fun var_h58 () T2006)
(declare-fun |20| () Int)
(declare-fun var__temp_h500 () T2006)
(declare-fun |var__temp_h'502| () T2006)
(declare-fun v () Int)
(assert (= (sel var_h456 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h500 res) v) (= v |20|))
               (= (sel var__temp_h500 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'502| res) (+ (sel var__temp_h500 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h500 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************128
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i457 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i457, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v491:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i457 --->  Ty_heap  
 var_h456 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h504 --->  Ty_heap  
 var__temp_v505 --->  Ty_int  
 var__temp_h'506 --->  Ty_heap  
 var__temp_v_err507 --->  error  
 var_h456 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h456, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h504, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h504, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h504, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'506, res ) ==((sel)( , var__temp_h504, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i457 T2023)
(declare-const var_h456 T2023)
(declare-const v Int)
(declare-const var_h_i199 T2023)
(declare-const var_h198 T2023)
(declare-const v Int)
(declare-const var_h_i131 T2023)
(declare-const var_h130 T2023)
(declare-const v Int)
(declare-const var_h_i59 T2023)
(declare-const var_h58 T2023)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h504 T2023)
(declare-const var__temp_v505 Int)
(declare-const |var__temp_h'506| T2023)
(declare-const var__temp_v_err507 T2024)
(declare-const var_h456 T2023)
(declare-const var_h198 T2023)
(declare-const var_h130 T2023)
(declare-const var_h58 T2023)
(declare-const err T2037)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2023)
(declare-fun sel (T2023 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T2023)
(declare-fun var_h456 () T2023)
(declare-fun var_h130 () T2023)
(declare-fun var_h58 () T2023)
(declare-fun |20| () Int)
(declare-fun var__temp_h504 () T2023)
(declare-fun |var__temp_h'506| () T2023)
(declare-fun v () Int)
(assert (= (sel var_h456 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h504 res) v) (= v |20|))
               (= (sel var__temp_h504 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'506| res) (+ (sel var__temp_h504 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h504 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************129
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i457 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i457, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v491:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i457 --->  Ty_heap  
 var_h456 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h508 --->  Ty_heap  
 var__temp_v509 --->  Ty_int  
 var__temp_h'510 --->  Ty_heap  
 var__temp_v_err511 --->  error  
 var_h456 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h456, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h508, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h508, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h508, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'510, res ) ==((sel)( , var__temp_h508, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i457 T2040)
(declare-const var_h456 T2040)
(declare-const v Int)
(declare-const var_h_i199 T2040)
(declare-const var_h198 T2040)
(declare-const v Int)
(declare-const var_h_i131 T2040)
(declare-const var_h130 T2040)
(declare-const v Int)
(declare-const var_h_i59 T2040)
(declare-const var_h58 T2040)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h508 T2040)
(declare-const var__temp_v509 Int)
(declare-const |var__temp_h'510| T2040)
(declare-const var__temp_v_err511 T2041)
(declare-const var_h456 T2040)
(declare-const var_h198 T2040)
(declare-const var_h130 T2040)
(declare-const var_h58 T2040)
(declare-const err T2054)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2040)
(declare-fun sel (T2040 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T2040)
(declare-fun var_h456 () T2040)
(declare-fun var_h130 () T2040)
(declare-fun var_h58 () T2040)
(declare-fun |20| () Int)
(declare-fun var__temp_h508 () T2040)
(declare-fun |var__temp_h'510| () T2040)
(declare-fun v () Int)
(assert (= (sel var_h456 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h508 res) v) (= v |20|))
               (= (sel var__temp_h508 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'510| res) (+ (sel var__temp_h508 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h508 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************130
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i457 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i457, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v491:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i457 --->  Ty_heap  
 var_h456 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h512 --->  Ty_heap  
 var__temp_v513 --->  Ty_int  
 var__temp_h'514 --->  Ty_heap  
 var__temp_v_err515 --->  error  
 var_h456 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h456, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h512, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h512, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h512, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'514, res ) ==((sel)( , var__temp_h512, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i457 T2057)
(declare-const var_h456 T2057)
(declare-const v Int)
(declare-const var_h_i199 T2057)
(declare-const var_h198 T2057)
(declare-const v Int)
(declare-const var_h_i131 T2057)
(declare-const var_h130 T2057)
(declare-const v Int)
(declare-const var_h_i59 T2057)
(declare-const var_h58 T2057)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h512 T2057)
(declare-const var__temp_v513 Int)
(declare-const |var__temp_h'514| T2057)
(declare-const var__temp_v_err515 T2058)
(declare-const var_h456 T2057)
(declare-const var_h198 T2057)
(declare-const var_h130 T2057)
(declare-const var_h58 T2057)
(declare-const err T2071)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2057)
(declare-fun sel (T2057 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T2057)
(declare-fun var_h456 () T2057)
(declare-fun var_h130 () T2057)
(declare-fun var_h58 () T2057)
(declare-fun |20| () Int)
(declare-fun var__temp_h512 () T2057)
(declare-fun |var__temp_h'514| () T2057)
(declare-fun v () Int)
(assert (= (sel var_h456 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h512 res) v) (= v |20|))
               (= (sel var__temp_h512 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'514| res) (+ (sel var__temp_h512 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h512 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************131
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (3) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i457 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i457, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v491:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i457 --->  Ty_heap  
 var_h456 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h516 --->  Ty_heap  
 var__temp_v517 --->  Ty_int  
 var__temp_h'518 --->  Ty_heap  
 var__temp_v_err519 --->  error  
 var_h456 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h456, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h516, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h516, res ) > (3) AND 
 	 Rel (sel)( , var__temp_h516, res ) > (3) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'518, res ) ==(var__temp_v517) AND 
 	 Base var__temp_v517 = 5 => 
 	 True
 
VC_END(declare-const var_h_i457 T2074)
(declare-const var_h456 T2074)
(declare-const v Int)
(declare-const var_h_i199 T2074)
(declare-const var_h198 T2074)
(declare-const v Int)
(declare-const var_h_i131 T2074)
(declare-const var_h130 T2074)
(declare-const v Int)
(declare-const var_h_i59 T2074)
(declare-const var_h58 T2074)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h516 T2074)
(declare-const var__temp_v517 Int)
(declare-const |var__temp_h'518| T2074)
(declare-const var__temp_v_err519 T2075)
(declare-const var_h456 T2074)
(declare-const var_h198 T2074)
(declare-const var_h130 T2074)
(declare-const var_h58 T2074)
(declare-const err T2088)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T2074)
(declare-fun sel (T2074 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T2074)
(declare-fun var_h456 () T2074)
(declare-fun var_h130 () T2074)
(declare-fun var_h58 () T2074)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_v517 () Int)
(declare-fun |var__temp_h'518| () T2074)
(declare-fun var__temp_h516 () T2074)
(declare-fun v () Int)
(assert (= (sel var_h456 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h516 res) v) (= v |20|))
               (not (> (sel var__temp_h516 res) 3))))
      (a!2 (=> (and (= (sel |var__temp_h'518| res) var__temp_v517)
                    (= var__temp_v517 |5|))
               true)))
(let ((a!3 (=> (not (> (sel var__temp_h516 res) 3)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************132
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i457 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i457, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v491:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i457 --->  Ty_heap  
 var_h456 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h520 --->  Ty_heap  
 var__temp_v521 --->  Ty_int  
 var__temp_h'522 --->  Ty_heap  
 var__temp_v_err523 --->  error  
 var_h456 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h456, res ) ==(sel)( , var_h198, res ) AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h520, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h520, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h520, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'522, res ) ==((sel)( , var__temp_h520, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i457 T2091)
(declare-const var_h456 T2091)
(declare-const v Int)
(declare-const var_h_i199 T2091)
(declare-const var_h198 T2091)
(declare-const v Int)
(declare-const var_h_i131 T2091)
(declare-const var_h130 T2091)
(declare-const v Int)
(declare-const var_h_i59 T2091)
(declare-const var_h58 T2091)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h520 T2091)
(declare-const var__temp_v521 Int)
(declare-const |var__temp_h'522| T2091)
(declare-const var__temp_v_err523 T2092)
(declare-const var_h456 T2091)
(declare-const var_h198 T2091)
(declare-const var_h130 T2091)
(declare-const var_h58 T2091)
(declare-const err T2105)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2091)
(declare-fun sel (T2091 Int) Int)
(declare-fun res () Int)
(declare-fun var_h198 () T2091)
(declare-fun var_h456 () T2091)
(declare-fun var_h130 () T2091)
(declare-fun var_h58 () T2091)
(declare-fun |20| () Int)
(declare-fun var__temp_h520 () T2091)
(declare-fun |var__temp_h'522| () T2091)
(declare-fun v () Int)
(assert (= (sel var_h456 res) (sel var_h198 res)))
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h520 res) v) (= v |20|))
               (= (sel var__temp_h520 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'522| res) (+ (sel var__temp_h520 res) 2))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h520 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************133
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo'
PARTIAL PATH
SUB 	 --c3'	 --c4	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v524:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
baz
foo
bar
 *********************Enumeration Iteration*****************134
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v524:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h525 --->  Ty_heap  
 var__temp_v526 --->  Ty_int  
 var__temp_h'527 --->  Ty_heap  
 var__temp_v_err528 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h525, res ) ==(sel)( , var_h198, res ) => 
 	 Rel (sel)( , var__temp_h525, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h525, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'527, res ) ==((sel)( , var__temp_h525, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i199 T2108)
(declare-const var_h198 T2108)
(declare-const v Int)
(declare-const var_h_i131 T2108)
(declare-const var_h130 T2108)
(declare-const v Int)
(declare-const var_h_i59 T2108)
(declare-const var_h58 T2108)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h525 T2108)
(declare-const var__temp_v526 Int)
(declare-const |var__temp_h'527| T2108)
(declare-const var__temp_v_err528 T2109)
(declare-const var_h198 T2108)
(declare-const var_h130 T2108)
(declare-const var_h58 T2108)
(declare-const err T2122)

solver 
 (declare-sort T2108)
(declare-fun sel (T2108 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2108)
(declare-fun var_h198 () T2108)
(declare-fun var_h58 () T2108)
(declare-fun var__temp_h525 () T2108)
(declare-fun |var__temp_h'527| () T2108)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'527| res) (+ (sel var__temp_h525 res) 4))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h525 res) (sel var_h198 res))
                    (= (sel var__temp_h525 res) 7))
                (=> (= (sel var__temp_h525 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************135
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v524:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h529 --->  Ty_heap  
 var__temp_v530 --->  Ty_int  
 var__temp_h'531 --->  Ty_heap  
 var__temp_v_err532 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h529, res ) ==(sel)( , var_h198, res ) => 
 	 Rel (sel)( , var__temp_h529, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h529, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'531, res ) ==((sel)( , var__temp_h529, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i199 T2125)
(declare-const var_h198 T2125)
(declare-const v Int)
(declare-const var_h_i131 T2125)
(declare-const var_h130 T2125)
(declare-const v Int)
(declare-const var_h_i59 T2125)
(declare-const var_h58 T2125)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h529 T2125)
(declare-const var__temp_v530 Int)
(declare-const |var__temp_h'531| T2125)
(declare-const var__temp_v_err532 T2126)
(declare-const var_h198 T2125)
(declare-const var_h130 T2125)
(declare-const var_h58 T2125)
(declare-const err T2139)

solver 
 (declare-sort T2125)
(declare-fun sel (T2125 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2125)
(declare-fun var_h198 () T2125)
(declare-fun var_h58 () T2125)
(declare-fun var__temp_h529 () T2125)
(declare-fun |var__temp_h'531| () T2125)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'531| res) (+ (sel var__temp_h529 res) 4))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h529 res) (sel var_h198 res))
                    (= (sel var__temp_h529 res) 7))
                (=> (= (sel var__temp_h529 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************136
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v524:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h533 --->  Ty_heap  
 var__temp_v534 --->  Ty_int  
 var__temp_h'535 --->  Ty_heap  
 var__temp_v_err536 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h533, res ) ==(sel)( , var_h198, res ) => 
 	 Rel (sel)( , var__temp_h533, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h533, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'535, res ) ==((sel)( , var__temp_h533, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i199 T2142)
(declare-const var_h198 T2142)
(declare-const v Int)
(declare-const var_h_i131 T2142)
(declare-const var_h130 T2142)
(declare-const v Int)
(declare-const var_h_i59 T2142)
(declare-const var_h58 T2142)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h533 T2142)
(declare-const var__temp_v534 Int)
(declare-const |var__temp_h'535| T2142)
(declare-const var__temp_v_err536 T2143)
(declare-const var_h198 T2142)
(declare-const var_h130 T2142)
(declare-const var_h58 T2142)
(declare-const err T2156)

solver 
 (declare-sort T2142)
(declare-fun sel (T2142 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2142)
(declare-fun var_h198 () T2142)
(declare-fun var_h58 () T2142)
(declare-fun var__temp_h533 () T2142)
(declare-fun |var__temp_h'535| () T2142)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'535| res) (+ (sel var__temp_h533 res) 4))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h533 res) (sel var_h198 res))
                    (= (sel var__temp_h533 res) 7))
                (=> (= (sel var__temp_h533 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************137
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v524:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h537 --->  Ty_heap  
 var__temp_v538 --->  Ty_int  
 var__temp_h'539 --->  Ty_heap  
 var__temp_v_err540 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h537, res ) ==(sel)( , var_h198, res ) => 
 	 Rel (sel)( , var__temp_h537, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h537, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'539, res ) ==((sel)( , var__temp_h537, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i199 T2159)
(declare-const var_h198 T2159)
(declare-const v Int)
(declare-const var_h_i131 T2159)
(declare-const var_h130 T2159)
(declare-const v Int)
(declare-const var_h_i59 T2159)
(declare-const var_h58 T2159)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h537 T2159)
(declare-const var__temp_v538 Int)
(declare-const |var__temp_h'539| T2159)
(declare-const var__temp_v_err540 T2160)
(declare-const var_h198 T2159)
(declare-const var_h130 T2159)
(declare-const var_h58 T2159)
(declare-const err T2173)

solver 
 (declare-sort T2159)
(declare-fun sel (T2159 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2159)
(declare-fun var_h198 () T2159)
(declare-fun var_h58 () T2159)
(declare-fun var__temp_h537 () T2159)
(declare-fun |var__temp_h'539| () T2159)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'539| res) (+ (sel var__temp_h537 res) 5))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h537 res) (sel var_h198 res))
                    (= (sel var__temp_h537 res) 7))
                (=> (= (sel var__temp_h537 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************138
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v524:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h541 --->  Ty_heap  
 var__temp_v542 --->  Ty_int  
 var__temp_h'543 --->  Ty_heap  
 var__temp_v_err544 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h541, res ) ==(sel)( , var_h198, res ) => 
 	 Rel (sel)( , var__temp_h541, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h541, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'543, res ) ==((sel)( , var__temp_h541, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i199 T2176)
(declare-const var_h198 T2176)
(declare-const v Int)
(declare-const var_h_i131 T2176)
(declare-const var_h130 T2176)
(declare-const v Int)
(declare-const var_h_i59 T2176)
(declare-const var_h58 T2176)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h541 T2176)
(declare-const var__temp_v542 Int)
(declare-const |var__temp_h'543| T2176)
(declare-const var__temp_v_err544 T2177)
(declare-const var_h198 T2176)
(declare-const var_h130 T2176)
(declare-const var_h58 T2176)
(declare-const err T2190)

solver 
 (declare-sort T2176)
(declare-fun sel (T2176 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2176)
(declare-fun var_h198 () T2176)
(declare-fun var_h58 () T2176)
(declare-fun var__temp_h541 () T2176)
(declare-fun |var__temp_h'543| () T2176)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'543| res) (+ (sel var__temp_h541 res) 5))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h541 res) (sel var_h198 res))
                    (= (sel var__temp_h541 res) 6))
                (=> (= (sel var__temp_h541 res) 6) a!1))))
  (not a!2))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************139
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v524:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h545 --->  Ty_heap  
 var__temp_v546 --->  Ty_int  
 var__temp_h'547 --->  Ty_heap  
 var__temp_v_err548 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h545, res ) ==(sel)( , var_h198, res ) => 
 	 Rel (sel)( , var__temp_h545, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h545, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'547, res ) ==((sel)( , var__temp_h545, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i199 T2193)
(declare-const var_h198 T2193)
(declare-const v Int)
(declare-const var_h_i131 T2193)
(declare-const var_h130 T2193)
(declare-const v Int)
(declare-const var_h_i59 T2193)
(declare-const var_h58 T2193)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h545 T2193)
(declare-const var__temp_v546 Int)
(declare-const |var__temp_h'547| T2193)
(declare-const var__temp_v_err548 T2194)
(declare-const var_h198 T2193)
(declare-const var_h130 T2193)
(declare-const var_h58 T2193)
(declare-const err T2207)

solver 
 (declare-sort T2193)
(declare-fun sel (T2193 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2193)
(declare-fun var_h198 () T2193)
(declare-fun var_h58 () T2193)
(declare-fun var__temp_h545 () T2193)
(declare-fun |var__temp_h'547| () T2193)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'547| res) (+ (sel var__temp_h545 res) 3))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h545 res) (sel var_h198 res))
                    (= (sel var__temp_h545 res) 7))
                (=> (= (sel var__temp_h545 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************140
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (3) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v524:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h549 --->  Ty_heap  
 var__temp_v550 --->  Ty_int  
 var__temp_h'551 --->  Ty_heap  
 var__temp_v_err552 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h549, res ) ==(sel)( , var_h198, res ) => 
 	 Rel (sel)( , var__temp_h549, res ) > (3) AND 
 	 Rel (sel)( , var__temp_h549, res ) > (3) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'551, res ) ==(var__temp_v550) AND 
 	 Base var__temp_v550 = 5 => 
 	 True
 
VC_END(declare-const var_h_i199 T2210)
(declare-const var_h198 T2210)
(declare-const v Int)
(declare-const var_h_i131 T2210)
(declare-const var_h130 T2210)
(declare-const v Int)
(declare-const var_h_i59 T2210)
(declare-const var_h58 T2210)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h549 T2210)
(declare-const var__temp_v550 Int)
(declare-const |var__temp_h'551| T2210)
(declare-const var__temp_v_err552 T2211)
(declare-const var_h198 T2210)
(declare-const var_h130 T2210)
(declare-const var_h58 T2210)
(declare-const err T2224)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2210)
(declare-fun sel (T2210 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2210)
(declare-fun var_h198 () T2210)
(declare-fun var_h58 () T2210)
(declare-fun |5| () Int)
(declare-fun var__temp_v550 () Int)
(declare-fun |var__temp_h'551| () T2210)
(declare-fun var__temp_h549 () T2210)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h549 res) (sel var_h198 res))
               (not (> (sel var__temp_h549 res) 3))))
      (a!2 (=> (and (= (sel |var__temp_h'551| res) var__temp_v550)
                    (= var__temp_v550 |5|))
               true)))
(let ((a!3 (=> (not (> (sel var__temp_h549 res) 3)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************141
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i199 Value = Ty_heap{ (sel)( , var_h_i199, res ) ==(sel)( , var_h198, res ) } 
 } 
 
                                                RET :  Base {var_v524:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i199 --->  Ty_heap  
 var_h198 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h553 --->  Ty_heap  
 var__temp_v554 --->  Ty_int  
 var__temp_h'555 --->  Ty_heap  
 var__temp_v_err556 --->  error  
 var_h198 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h198, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h553, res ) ==(sel)( , var_h198, res ) => 
 	 Rel (sel)( , var__temp_h553, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h553, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'555, res ) ==((sel)( , var__temp_h553, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i199 T2227)
(declare-const var_h198 T2227)
(declare-const v Int)
(declare-const var_h_i131 T2227)
(declare-const var_h130 T2227)
(declare-const v Int)
(declare-const var_h_i59 T2227)
(declare-const var_h58 T2227)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h553 T2227)
(declare-const var__temp_v554 Int)
(declare-const |var__temp_h'555| T2227)
(declare-const var__temp_v_err556 T2228)
(declare-const var_h198 T2227)
(declare-const var_h130 T2227)
(declare-const var_h58 T2227)
(declare-const err T2241)

solver 
 (declare-sort T2227)
(declare-fun sel (T2227 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2227)
(declare-fun var_h198 () T2227)
(declare-fun var_h58 () T2227)
(declare-fun var__temp_h553 () T2227)
(declare-fun |var__temp_h'555| () T2227)
(assert (= (sel var_h198 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'555| res) (+ (sel var__temp_h553 res) 2))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h553 res) (sel var_h198 res))
                    (= (sel var__temp_h553 res) 5))
                (=> (= (sel var__temp_h553 res) 5) a!1))))
  (not a!2))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************142
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo'
PARTIAL PATH
SUB 	 --c3'	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v557:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
c2
foo'
baz
foo
bar
 *********************Enumeration Iteration*****************143
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v557:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h558 --->  Ty_heap  
 var__temp_v559 --->  Ty_int  
 var__temp_h'560 --->  Ty_heap  
 var__temp_v_err561 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h558, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h558, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h558, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'560, res ) ==((sel)( , var__temp_h558, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i131 T2244)
(declare-const var_h130 T2244)
(declare-const v Int)
(declare-const var_h_i59 T2244)
(declare-const var_h58 T2244)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h558 T2244)
(declare-const var__temp_v559 Int)
(declare-const |var__temp_h'560| T2244)
(declare-const var__temp_v_err561 T2245)
(declare-const var_h130 T2244)
(declare-const var_h58 T2244)
(declare-const err T2258)

solver 
 (declare-sort T2244)
(declare-fun sel (T2244 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T2244)
(declare-fun var_h130 () T2244)
(declare-fun var__temp_h558 () T2244)
(declare-fun |var__temp_h'560| () T2244)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h558 res) (+ (sel var_h130 res) 6))
               (= (sel var__temp_h558 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'560| res) (+ (sel var__temp_h558 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h558 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************144
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v557:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h562 --->  Ty_heap  
 var__temp_v563 --->  Ty_int  
 var__temp_h'564 --->  Ty_heap  
 var__temp_v_err565 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h562, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h562, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h562, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'564, res ) ==((sel)( , var__temp_h562, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i131 T2261)
(declare-const var_h130 T2261)
(declare-const v Int)
(declare-const var_h_i59 T2261)
(declare-const var_h58 T2261)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h562 T2261)
(declare-const var__temp_v563 Int)
(declare-const |var__temp_h'564| T2261)
(declare-const var__temp_v_err565 T2262)
(declare-const var_h130 T2261)
(declare-const var_h58 T2261)
(declare-const err T2275)

solver 
 (declare-sort T2261)
(declare-fun sel (T2261 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T2261)
(declare-fun var_h130 () T2261)
(declare-fun var__temp_h562 () T2261)
(declare-fun |var__temp_h'564| () T2261)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h562 res) (+ (sel var_h130 res) 6))
               (= (sel var__temp_h562 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'564| res) (+ (sel var__temp_h562 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h562 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************145
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v557:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h566 --->  Ty_heap  
 var__temp_v567 --->  Ty_int  
 var__temp_h'568 --->  Ty_heap  
 var__temp_v_err569 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h566, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h566, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h566, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'568, res ) ==((sel)( , var__temp_h566, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i131 T2278)
(declare-const var_h130 T2278)
(declare-const v Int)
(declare-const var_h_i59 T2278)
(declare-const var_h58 T2278)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h566 T2278)
(declare-const var__temp_v567 Int)
(declare-const |var__temp_h'568| T2278)
(declare-const var__temp_v_err569 T2279)
(declare-const var_h130 T2278)
(declare-const var_h58 T2278)
(declare-const err T2292)

solver 
 (declare-sort T2278)
(declare-fun sel (T2278 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T2278)
(declare-fun var_h130 () T2278)
(declare-fun var__temp_h566 () T2278)
(declare-fun |var__temp_h'568| () T2278)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h566 res) (+ (sel var_h130 res) 6))
               (= (sel var__temp_h566 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'568| res) (+ (sel var__temp_h566 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h566 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************146
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v557:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h570 --->  Ty_heap  
 var__temp_v571 --->  Ty_int  
 var__temp_h'572 --->  Ty_heap  
 var__temp_v_err573 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h570, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h570, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h570, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'572, res ) ==((sel)( , var__temp_h570, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i131 T2295)
(declare-const var_h130 T2295)
(declare-const v Int)
(declare-const var_h_i59 T2295)
(declare-const var_h58 T2295)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h570 T2295)
(declare-const var__temp_v571 Int)
(declare-const |var__temp_h'572| T2295)
(declare-const var__temp_v_err573 T2296)
(declare-const var_h130 T2295)
(declare-const var_h58 T2295)
(declare-const err T2309)

solver 
 (declare-sort T2295)
(declare-fun sel (T2295 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T2295)
(declare-fun var_h130 () T2295)
(declare-fun var__temp_h570 () T2295)
(declare-fun |var__temp_h'572| () T2295)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h570 res) (+ (sel var_h130 res) 6))
               (= (sel var__temp_h570 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'572| res) (+ (sel var__temp_h570 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h570 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************147
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v557:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h574 --->  Ty_heap  
 var__temp_v575 --->  Ty_int  
 var__temp_h'576 --->  Ty_heap  
 var__temp_v_err577 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h574, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h574, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h574, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'576, res ) ==((sel)( , var__temp_h574, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i131 T2312)
(declare-const var_h130 T2312)
(declare-const v Int)
(declare-const var_h_i59 T2312)
(declare-const var_h58 T2312)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h574 T2312)
(declare-const var__temp_v575 Int)
(declare-const |var__temp_h'576| T2312)
(declare-const var__temp_v_err577 T2313)
(declare-const var_h130 T2312)
(declare-const var_h58 T2312)
(declare-const err T2326)

solver 
 (declare-sort T2312)
(declare-fun sel (T2312 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T2312)
(declare-fun var_h130 () T2312)
(declare-fun var__temp_h574 () T2312)
(declare-fun |var__temp_h'576| () T2312)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h574 res) (+ (sel var_h130 res) 6))
               (= (sel var__temp_h574 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'576| res) (+ (sel var__temp_h574 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h574 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************148
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v557:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h578 --->  Ty_heap  
 var__temp_v579 --->  Ty_int  
 var__temp_h'580 --->  Ty_heap  
 var__temp_v_err581 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h578, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h578, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h578, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'580, res ) ==((sel)( , var__temp_h578, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i131 T2329)
(declare-const var_h130 T2329)
(declare-const v Int)
(declare-const var_h_i59 T2329)
(declare-const var_h58 T2329)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h578 T2329)
(declare-const var__temp_v579 Int)
(declare-const |var__temp_h'580| T2329)
(declare-const var__temp_v_err581 T2330)
(declare-const var_h130 T2329)
(declare-const var_h58 T2329)
(declare-const err T2343)

solver 
 (declare-sort T2329)
(declare-fun sel (T2329 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T2329)
(declare-fun var_h130 () T2329)
(declare-fun var__temp_h578 () T2329)
(declare-fun |var__temp_h'580| () T2329)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h578 res) (+ (sel var_h130 res) 6))
               (> (sel var__temp_h578 res) 4)))
      (a!2 (=> (= (sel |var__temp_h'580| res) (+ (sel var__temp_h578 res) 10))
               true)))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h578 res) 4) a!2))))
  (not a!3))))

***************Selection Successful************c2
PARTIAL PATH NEW
NEW 	 --c3'	 --c4	 --c2
post_substituted Forall 
 	 
 Key =var_h_i583 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i583 Value = Ty_heap{ (sel)( , var_h_i583, res ) ==((sel)( , var_h582, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v584:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i583 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
foo'
baz
foo
bar
 *********************Enumeration Iteration*****************149
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i583 Value = Ty_heap{ (sel)( , var_h_i583, res ) ==((sel)( , var_h582, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v584:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i583 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h585 --->  Ty_heap  
 var__temp_v586 --->  Ty_int  
 var__temp_h'587 --->  Ty_heap  
 var__temp_v_err588 --->  error  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h585, res ) ==((sel)( , var_h582, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h585, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h585, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'587, res ) ==((sel)( , var__temp_h585, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'587, res ) ==(10)
 
VC_END(declare-const var_h_i583 T2346)
(declare-const var_h582 T2346)
(declare-const v Int)
(declare-const var_h_i131 T2346)
(declare-const var_h130 T2346)
(declare-const v Int)
(declare-const var_h_i59 T2346)
(declare-const var_h58 T2346)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h585 T2346)
(declare-const var__temp_v586 Int)
(declare-const |var__temp_h'587| T2346)
(declare-const var__temp_v_err588 T2347)
(declare-const var_h582 T2346)
(declare-const var_h130 T2346)
(declare-const var_h58 T2346)
(declare-const err T2360)

solver 
 (declare-sort T2346)
(declare-fun sel (T2346 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2346)
(declare-fun var_h582 () T2346)
(declare-fun var_h58 () T2346)
(declare-fun |var__temp_h'587| () T2346)
(declare-fun var__temp_h585 () T2346)
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h585 res) (+ (sel var_h582 res) 10))
               (= (sel var__temp_h585 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'587| res) (+ (sel var__temp_h585 res) 4))
               (= (sel |var__temp_h'587| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h585 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************150
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i583 Value = Ty_heap{ (sel)( , var_h_i583, res ) ==((sel)( , var_h582, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v584:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i583 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h589 --->  Ty_heap  
 var__temp_v590 --->  Ty_int  
 var__temp_h'591 --->  Ty_heap  
 var__temp_v_err592 --->  error  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h589, res ) ==((sel)( , var_h582, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h589, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h589, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'591, res ) ==((sel)( , var__temp_h589, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'591, res ) ==(10)
 
VC_END(declare-const var_h_i583 T2363)
(declare-const var_h582 T2363)
(declare-const v Int)
(declare-const var_h_i131 T2363)
(declare-const var_h130 T2363)
(declare-const v Int)
(declare-const var_h_i59 T2363)
(declare-const var_h58 T2363)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h589 T2363)
(declare-const var__temp_v590 Int)
(declare-const |var__temp_h'591| T2363)
(declare-const var__temp_v_err592 T2364)
(declare-const var_h582 T2363)
(declare-const var_h130 T2363)
(declare-const var_h58 T2363)
(declare-const err T2377)

solver 
 (declare-sort T2363)
(declare-fun sel (T2363 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2363)
(declare-fun var_h582 () T2363)
(declare-fun var_h58 () T2363)
(declare-fun |var__temp_h'591| () T2363)
(declare-fun var__temp_h589 () T2363)
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h589 res) (+ (sel var_h582 res) 10))
               (= (sel var__temp_h589 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'591| res) (+ (sel var__temp_h589 res) 4))
               (= (sel |var__temp_h'591| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h589 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************151
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i583 Value = Ty_heap{ (sel)( , var_h_i583, res ) ==((sel)( , var_h582, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v584:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i583 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h593 --->  Ty_heap  
 var__temp_v594 --->  Ty_int  
 var__temp_h'595 --->  Ty_heap  
 var__temp_v_err596 --->  error  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h593, res ) ==((sel)( , var_h582, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h593, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h593, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'595, res ) ==((sel)( , var__temp_h593, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'595, res ) ==(10)
 
VC_END(declare-const var_h_i583 T2380)
(declare-const var_h582 T2380)
(declare-const v Int)
(declare-const var_h_i131 T2380)
(declare-const var_h130 T2380)
(declare-const v Int)
(declare-const var_h_i59 T2380)
(declare-const var_h58 T2380)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h593 T2380)
(declare-const var__temp_v594 Int)
(declare-const |var__temp_h'595| T2380)
(declare-const var__temp_v_err596 T2381)
(declare-const var_h582 T2380)
(declare-const var_h130 T2380)
(declare-const var_h58 T2380)
(declare-const err T2394)

solver 
 (declare-sort T2380)
(declare-fun sel (T2380 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2380)
(declare-fun var_h582 () T2380)
(declare-fun var_h58 () T2380)
(declare-fun |var__temp_h'595| () T2380)
(declare-fun var__temp_h593 () T2380)
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h593 res) (+ (sel var_h582 res) 10))
               (= (sel var__temp_h593 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'595| res) (+ (sel var__temp_h593 res) 4))
               (= (sel |var__temp_h'595| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h593 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************152
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i583 Value = Ty_heap{ (sel)( , var_h_i583, res ) ==((sel)( , var_h582, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v584:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i583 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h597 --->  Ty_heap  
 var__temp_v598 --->  Ty_int  
 var__temp_h'599 --->  Ty_heap  
 var__temp_v_err600 --->  error  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h597, res ) ==((sel)( , var_h582, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h597, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h597, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'599, res ) ==((sel)( , var__temp_h597, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'599, res ) ==(10)
 
VC_END(declare-const var_h_i583 T2397)
(declare-const var_h582 T2397)
(declare-const v Int)
(declare-const var_h_i131 T2397)
(declare-const var_h130 T2397)
(declare-const v Int)
(declare-const var_h_i59 T2397)
(declare-const var_h58 T2397)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h597 T2397)
(declare-const var__temp_v598 Int)
(declare-const |var__temp_h'599| T2397)
(declare-const var__temp_v_err600 T2398)
(declare-const var_h582 T2397)
(declare-const var_h130 T2397)
(declare-const var_h58 T2397)
(declare-const err T2411)

solver 
 (declare-sort T2397)
(declare-fun sel (T2397 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2397)
(declare-fun var_h582 () T2397)
(declare-fun var_h58 () T2397)
(declare-fun |var__temp_h'599| () T2397)
(declare-fun var__temp_h597 () T2397)
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h597 res) (+ (sel var_h582 res) 10))
               (= (sel var__temp_h597 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'599| res) (+ (sel var__temp_h597 res) 5))
               (= (sel |var__temp_h'599| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h597 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************153
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i583 Value = Ty_heap{ (sel)( , var_h_i583, res ) ==((sel)( , var_h582, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v584:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i583 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h601 --->  Ty_heap  
 var__temp_v602 --->  Ty_int  
 var__temp_h'603 --->  Ty_heap  
 var__temp_v_err604 --->  error  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h601, res ) ==((sel)( , var_h582, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h601, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h601, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'603, res ) ==((sel)( , var__temp_h601, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'603, res ) ==(10)
 
VC_END(declare-const var_h_i583 T2414)
(declare-const var_h582 T2414)
(declare-const v Int)
(declare-const var_h_i131 T2414)
(declare-const var_h130 T2414)
(declare-const v Int)
(declare-const var_h_i59 T2414)
(declare-const var_h58 T2414)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h601 T2414)
(declare-const var__temp_v602 Int)
(declare-const |var__temp_h'603| T2414)
(declare-const var__temp_v_err604 T2415)
(declare-const var_h582 T2414)
(declare-const var_h130 T2414)
(declare-const var_h58 T2414)
(declare-const err T2428)

solver 
 (declare-sort T2414)
(declare-fun sel (T2414 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2414)
(declare-fun var_h582 () T2414)
(declare-fun var_h58 () T2414)
(declare-fun |var__temp_h'603| () T2414)
(declare-fun var__temp_h601 () T2414)
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h601 res) (+ (sel var_h582 res) 10))
               (= (sel var__temp_h601 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'603| res) (+ (sel var__temp_h601 res) 5))
               (= (sel |var__temp_h'603| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h601 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************154
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 20} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i583 Value = Ty_heap{ (sel)( , var_h_i583, res ) ==((sel)( , var_h582, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v584:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i583 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h605 --->  Ty_heap  
 var__temp_v606 --->  Ty_int  
 var__temp_h'607 --->  Ty_heap  
 var__temp_v_err608 --->  error  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h605, res ) ==((sel)( , var_h582, res ) + (10)) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'607, res ) ==(var__temp_v606) AND 
 	 Base var__temp_v606 = 20 => 
 	 Rel (sel)( , var__temp_h'607, res ) ==(10)
 
VC_END(declare-const var_h_i583 T2431)
(declare-const var_h582 T2431)
(declare-const v Int)
(declare-const var_h_i131 T2431)
(declare-const var_h130 T2431)
(declare-const v Int)
(declare-const var_h_i59 T2431)
(declare-const var_h58 T2431)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h605 T2431)
(declare-const var__temp_v606 Int)
(declare-const |var__temp_h'607| T2431)
(declare-const var__temp_v_err608 T2432)
(declare-const var_h582 T2431)
(declare-const var_h130 T2431)
(declare-const var_h58 T2431)
(declare-const err T2445)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2431)
(declare-fun sel (T2431 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2431)
(declare-fun var_h582 () T2431)
(declare-fun var_h58 () T2431)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'607| () T2431)
(declare-fun var__temp_v606 () Int)
(declare-fun var__temp_h605 () T2431)
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (= (sel var__temp_h605 res) (+ (sel var_h582 res) 10)) true))
      (a!2 (=> (and (= (sel |var__temp_h'607| res) var__temp_v606)
                    (= var__temp_v606 |20|))
               (= (sel |var__temp_h'607| res) 10))))
  (not (and a!1 (=> true a!2)))))

***************Selection Failed************foo'
 *********************Enumeration Iteration*****************155
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i583 Value = Ty_heap{ (sel)( , var_h_i583, res ) ==((sel)( , var_h582, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v584:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i583 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h609 --->  Ty_heap  
 var__temp_v610 --->  Ty_int  
 var__temp_h'611 --->  Ty_heap  
 var__temp_v_err612 --->  error  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h609, res ) ==((sel)( , var_h582, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h609, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h609, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'611, res ) ==((sel)( , var__temp_h609, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'611, res ) ==(10)
 
VC_END(declare-const var_h_i583 T2448)
(declare-const var_h582 T2448)
(declare-const v Int)
(declare-const var_h_i131 T2448)
(declare-const var_h130 T2448)
(declare-const v Int)
(declare-const var_h_i59 T2448)
(declare-const var_h58 T2448)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h609 T2448)
(declare-const var__temp_v610 Int)
(declare-const |var__temp_h'611| T2448)
(declare-const var__temp_v_err612 T2449)
(declare-const var_h582 T2448)
(declare-const var_h130 T2448)
(declare-const var_h58 T2448)
(declare-const err T2462)

solver 
 (declare-sort T2448)
(declare-fun sel (T2448 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2448)
(declare-fun var_h582 () T2448)
(declare-fun var_h58 () T2448)
(declare-fun |var__temp_h'611| () T2448)
(declare-fun var__temp_h609 () T2448)
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h609 res) (+ (sel var_h582 res) 10))
               (= (sel var__temp_h609 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'611| res) (+ (sel var__temp_h609 res) 3))
               (= (sel |var__temp_h'611| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h609 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************156
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (3) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i583 Value = Ty_heap{ (sel)( , var_h_i583, res ) ==((sel)( , var_h582, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v584:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i583 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h613 --->  Ty_heap  
 var__temp_v614 --->  Ty_int  
 var__temp_h'615 --->  Ty_heap  
 var__temp_v_err616 --->  error  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h613, res ) ==((sel)( , var_h582, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h613, res ) > (3) AND 
 	 Rel (sel)( , var__temp_h613, res ) > (3) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'615, res ) ==(var__temp_v614) AND 
 	 Base var__temp_v614 = 5 => 
 	 Rel (sel)( , var__temp_h'615, res ) ==(10)
 
VC_END(declare-const var_h_i583 T2465)
(declare-const var_h582 T2465)
(declare-const v Int)
(declare-const var_h_i131 T2465)
(declare-const var_h130 T2465)
(declare-const v Int)
(declare-const var_h_i59 T2465)
(declare-const var_h58 T2465)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h613 T2465)
(declare-const var__temp_v614 Int)
(declare-const |var__temp_h'615| T2465)
(declare-const var__temp_v_err616 T2466)
(declare-const var_h582 T2465)
(declare-const var_h130 T2465)
(declare-const var_h58 T2465)
(declare-const err T2479)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2465)
(declare-fun sel (T2465 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2465)
(declare-fun var_h582 () T2465)
(declare-fun var_h58 () T2465)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'615| () T2465)
(declare-fun var__temp_v614 () Int)
(declare-fun var__temp_h613 () T2465)
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h613 res) (+ (sel var_h582 res) 10))
               (not (> (sel var__temp_h613 res) 3))))
      (a!2 (=> (and (= (sel |var__temp_h'615| res) var__temp_v614)
                    (= var__temp_v614 |5|))
               (= (sel |var__temp_h'615| res) 10))))
(let ((a!3 (=> (not (> (sel var__temp_h613 res) 3)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************157
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i583 Value = Ty_heap{ (sel)( , var_h_i583, res ) ==((sel)( , var_h582, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v584:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i583 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h617 --->  Ty_heap  
 var__temp_v618 --->  Ty_int  
 var__temp_h'619 --->  Ty_heap  
 var__temp_v_err620 --->  error  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h617, res ) ==((sel)( , var_h582, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h617, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h617, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'619, res ) ==((sel)( , var__temp_h617, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'619, res ) ==(10)
 
VC_END(declare-const var_h_i583 T2482)
(declare-const var_h582 T2482)
(declare-const v Int)
(declare-const var_h_i131 T2482)
(declare-const var_h130 T2482)
(declare-const v Int)
(declare-const var_h_i59 T2482)
(declare-const var_h58 T2482)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h617 T2482)
(declare-const var__temp_v618 Int)
(declare-const |var__temp_h'619| T2482)
(declare-const var__temp_v_err620 T2483)
(declare-const var_h582 T2482)
(declare-const var_h130 T2482)
(declare-const var_h58 T2482)
(declare-const err T2496)

solver 
 (declare-sort T2482)
(declare-fun sel (T2482 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2482)
(declare-fun var_h582 () T2482)
(declare-fun var_h58 () T2482)
(declare-fun |var__temp_h'619| () T2482)
(declare-fun var__temp_h617 () T2482)
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h617 res) (+ (sel var_h582 res) 10))
               (= (sel var__temp_h617 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'619| res) (+ (sel var__temp_h617 res) 2))
               (= (sel |var__temp_h'619| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h617 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************158
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v584:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v584:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --c4	 --c2
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i583 Value = Ty_heap{ (sel)( , var_h_i583, res ) ==((sel)( , var_h582, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v621:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
foo'
baz
foo
bar
 *********************Enumeration Iteration*****************159
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i583 Value = Ty_heap{ (sel)( , var_h_i583, res ) ==((sel)( , var_h582, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v621:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h622 --->  Ty_heap  
 var__temp_v623 --->  Ty_int  
 var__temp_h'624 --->  Ty_heap  
 var__temp_v_err625 --->  error  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h622, res ) ==((sel)( , var_h582, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h622, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h622, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'624, res ) ==((sel)( , var__temp_h622, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i583 T2499)
(declare-const var_h582 T2499)
(declare-const v Int)
(declare-const var_h_i131 T2499)
(declare-const var_h130 T2499)
(declare-const v Int)
(declare-const var_h_i59 T2499)
(declare-const var_h58 T2499)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h622 T2499)
(declare-const var__temp_v623 Int)
(declare-const |var__temp_h'624| T2499)
(declare-const var__temp_v_err625 T2500)
(declare-const var_h582 T2499)
(declare-const var_h130 T2499)
(declare-const var_h58 T2499)
(declare-const err T2513)

solver 
 (declare-sort T2499)
(declare-fun sel (T2499 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2499)
(declare-fun var_h582 () T2499)
(declare-fun var_h58 () T2499)
(declare-fun var__temp_h622 () T2499)
(declare-fun |var__temp_h'624| () T2499)
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h622 res) (+ (sel var_h582 res) 10))
               (= (sel var__temp_h622 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'624| res) (+ (sel var__temp_h622 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h622 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************160
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i583 Value = Ty_heap{ (sel)( , var_h_i583, res ) ==((sel)( , var_h582, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v621:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h626 --->  Ty_heap  
 var__temp_v627 --->  Ty_int  
 var__temp_h'628 --->  Ty_heap  
 var__temp_v_err629 --->  error  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h626, res ) ==((sel)( , var_h582, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h626, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h626, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'628, res ) ==((sel)( , var__temp_h626, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i583 T2516)
(declare-const var_h582 T2516)
(declare-const v Int)
(declare-const var_h_i131 T2516)
(declare-const var_h130 T2516)
(declare-const v Int)
(declare-const var_h_i59 T2516)
(declare-const var_h58 T2516)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h626 T2516)
(declare-const var__temp_v627 Int)
(declare-const |var__temp_h'628| T2516)
(declare-const var__temp_v_err629 T2517)
(declare-const var_h582 T2516)
(declare-const var_h130 T2516)
(declare-const var_h58 T2516)
(declare-const err T2530)

solver 
 (declare-sort T2516)
(declare-fun sel (T2516 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2516)
(declare-fun var_h582 () T2516)
(declare-fun var_h58 () T2516)
(declare-fun var__temp_h626 () T2516)
(declare-fun |var__temp_h'628| () T2516)
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h626 res) (+ (sel var_h582 res) 10))
               (= (sel var__temp_h626 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'628| res) (+ (sel var__temp_h626 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h626 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************161
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i583 Value = Ty_heap{ (sel)( , var_h_i583, res ) ==((sel)( , var_h582, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v621:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h630 --->  Ty_heap  
 var__temp_v631 --->  Ty_int  
 var__temp_h'632 --->  Ty_heap  
 var__temp_v_err633 --->  error  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h630, res ) ==((sel)( , var_h582, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h630, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h630, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'632, res ) ==((sel)( , var__temp_h630, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i583 T2533)
(declare-const var_h582 T2533)
(declare-const v Int)
(declare-const var_h_i131 T2533)
(declare-const var_h130 T2533)
(declare-const v Int)
(declare-const var_h_i59 T2533)
(declare-const var_h58 T2533)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h630 T2533)
(declare-const var__temp_v631 Int)
(declare-const |var__temp_h'632| T2533)
(declare-const var__temp_v_err633 T2534)
(declare-const var_h582 T2533)
(declare-const var_h130 T2533)
(declare-const var_h58 T2533)
(declare-const err T2547)

solver 
 (declare-sort T2533)
(declare-fun sel (T2533 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2533)
(declare-fun var_h582 () T2533)
(declare-fun var_h58 () T2533)
(declare-fun var__temp_h630 () T2533)
(declare-fun |var__temp_h'632| () T2533)
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h630 res) (+ (sel var_h582 res) 10))
               (= (sel var__temp_h630 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'632| res) (+ (sel var__temp_h630 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h630 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************162
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i583 Value = Ty_heap{ (sel)( , var_h_i583, res ) ==((sel)( , var_h582, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v621:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h634 --->  Ty_heap  
 var__temp_v635 --->  Ty_int  
 var__temp_h'636 --->  Ty_heap  
 var__temp_v_err637 --->  error  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h634, res ) ==((sel)( , var_h582, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h634, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h634, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'636, res ) ==((sel)( , var__temp_h634, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i583 T2550)
(declare-const var_h582 T2550)
(declare-const v Int)
(declare-const var_h_i131 T2550)
(declare-const var_h130 T2550)
(declare-const v Int)
(declare-const var_h_i59 T2550)
(declare-const var_h58 T2550)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h634 T2550)
(declare-const var__temp_v635 Int)
(declare-const |var__temp_h'636| T2550)
(declare-const var__temp_v_err637 T2551)
(declare-const var_h582 T2550)
(declare-const var_h130 T2550)
(declare-const var_h58 T2550)
(declare-const err T2564)

solver 
 (declare-sort T2550)
(declare-fun sel (T2550 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2550)
(declare-fun var_h582 () T2550)
(declare-fun var_h58 () T2550)
(declare-fun var__temp_h634 () T2550)
(declare-fun |var__temp_h'636| () T2550)
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h634 res) (+ (sel var_h582 res) 10))
               (= (sel var__temp_h634 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'636| res) (+ (sel var__temp_h634 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h634 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************163
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i583 Value = Ty_heap{ (sel)( , var_h_i583, res ) ==((sel)( , var_h582, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v621:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h638 --->  Ty_heap  
 var__temp_v639 --->  Ty_int  
 var__temp_h'640 --->  Ty_heap  
 var__temp_v_err641 --->  error  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h638, res ) ==((sel)( , var_h582, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h638, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h638, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'640, res ) ==((sel)( , var__temp_h638, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i583 T2567)
(declare-const var_h582 T2567)
(declare-const v Int)
(declare-const var_h_i131 T2567)
(declare-const var_h130 T2567)
(declare-const v Int)
(declare-const var_h_i59 T2567)
(declare-const var_h58 T2567)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h638 T2567)
(declare-const var__temp_v639 Int)
(declare-const |var__temp_h'640| T2567)
(declare-const var__temp_v_err641 T2568)
(declare-const var_h582 T2567)
(declare-const var_h130 T2567)
(declare-const var_h58 T2567)
(declare-const err T2581)

solver 
 (declare-sort T2567)
(declare-fun sel (T2567 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2567)
(declare-fun var_h582 () T2567)
(declare-fun var_h58 () T2567)
(declare-fun var__temp_h638 () T2567)
(declare-fun |var__temp_h'640| () T2567)
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h638 res) (+ (sel var_h582 res) 10))
               (= (sel var__temp_h638 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'640| res) (+ (sel var__temp_h638 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h638 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************164
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 20} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i583 Value = Ty_heap{ (sel)( , var_h_i583, res ) ==((sel)( , var_h582, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v621:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h642 --->  Ty_heap  
 var__temp_v643 --->  Ty_int  
 var__temp_h'644 --->  Ty_heap  
 var__temp_v_err645 --->  error  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h642, res ) ==((sel)( , var_h582, res ) + (10)) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'644, res ) ==(var__temp_v643) AND 
 	 Base var__temp_v643 = 20 => 
 	 True
 
VC_END(declare-const var_h_i583 T2584)
(declare-const var_h582 T2584)
(declare-const v Int)
(declare-const var_h_i131 T2584)
(declare-const var_h130 T2584)
(declare-const v Int)
(declare-const var_h_i59 T2584)
(declare-const var_h58 T2584)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h642 T2584)
(declare-const var__temp_v643 Int)
(declare-const |var__temp_h'644| T2584)
(declare-const var__temp_v_err645 T2585)
(declare-const var_h582 T2584)
(declare-const var_h130 T2584)
(declare-const var_h58 T2584)
(declare-const err T2598)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2584)
(declare-fun sel (T2584 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2584)
(declare-fun var_h582 () T2584)
(declare-fun var_h58 () T2584)
(declare-fun |20| () Int)
(declare-fun var__temp_v643 () Int)
(declare-fun |var__temp_h'644| () T2584)
(declare-fun var__temp_h642 () T2584)
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (= (sel var__temp_h642 res) (+ (sel var_h582 res) 10)) true))
      (a!2 (=> (and (= (sel |var__temp_h'644| res) var__temp_v643)
                    (= var__temp_v643 |20|))
               true)))
  (not (and a!1 (=> true a!2)))))

***************Selection Successful************foo'
PARTIAL PATH NEW
NEW 	 --c3'	 --c4	 --c2	 --foo'
post_substituted Forall 
 	 
 Key =var_h_i647 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i647 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i647, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v648:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i647 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
baz
foo
bar
 *********************Enumeration Iteration*****************165
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i647 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i647, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v648:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i647 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i647 --->  Ty_heap  
 var_h646 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h649 --->  Ty_heap  
 var__temp_v650 --->  Ty_int  
 var__temp_h'651 --->  Ty_heap  
 var__temp_v_err652 --->  error  
 var_h646 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h646, res ) ==((sel)( , var_h582, res ) + (10)) AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h649, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h649, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h649, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'651, res ) ==((sel)( , var__temp_h649, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'651, res ) ==(10)
 
VC_END(declare-const var_h_i647 T2601)
(declare-const var_h646 T2601)
(declare-const v Int)
(declare-const var_h_i583 T2601)
(declare-const var_h582 T2601)
(declare-const v Int)
(declare-const var_h_i131 T2601)
(declare-const var_h130 T2601)
(declare-const v Int)
(declare-const var_h_i59 T2601)
(declare-const var_h58 T2601)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h649 T2601)
(declare-const var__temp_v650 Int)
(declare-const |var__temp_h'651| T2601)
(declare-const var__temp_v_err652 T2602)
(declare-const var_h646 T2601)
(declare-const var_h582 T2601)
(declare-const var_h130 T2601)
(declare-const var_h58 T2601)
(declare-const err T2615)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2601)
(declare-fun sel (T2601 Int) Int)
(declare-fun res () Int)
(declare-fun var_h582 () T2601)
(declare-fun var_h646 () T2601)
(declare-fun var_h130 () T2601)
(declare-fun var_h58 () T2601)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'651| () T2601)
(declare-fun var__temp_h649 () T2601)
(declare-fun v () Int)
(assert (= (sel var_h646 res) (+ (sel var_h582 res) 10)))
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h649 res) v) (= v |20|))
               (= (sel var__temp_h649 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'651| res) (+ (sel var__temp_h649 res) 4))
               (= (sel |var__temp_h'651| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h649 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************166
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i647 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i647, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v648:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i647 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i647 --->  Ty_heap  
 var_h646 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h653 --->  Ty_heap  
 var__temp_v654 --->  Ty_int  
 var__temp_h'655 --->  Ty_heap  
 var__temp_v_err656 --->  error  
 var_h646 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h646, res ) ==((sel)( , var_h582, res ) + (10)) AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h653, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h653, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h653, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'655, res ) ==((sel)( , var__temp_h653, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'655, res ) ==(10)
 
VC_END(declare-const var_h_i647 T2618)
(declare-const var_h646 T2618)
(declare-const v Int)
(declare-const var_h_i583 T2618)
(declare-const var_h582 T2618)
(declare-const v Int)
(declare-const var_h_i131 T2618)
(declare-const var_h130 T2618)
(declare-const v Int)
(declare-const var_h_i59 T2618)
(declare-const var_h58 T2618)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h653 T2618)
(declare-const var__temp_v654 Int)
(declare-const |var__temp_h'655| T2618)
(declare-const var__temp_v_err656 T2619)
(declare-const var_h646 T2618)
(declare-const var_h582 T2618)
(declare-const var_h130 T2618)
(declare-const var_h58 T2618)
(declare-const err T2632)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2618)
(declare-fun sel (T2618 Int) Int)
(declare-fun res () Int)
(declare-fun var_h582 () T2618)
(declare-fun var_h646 () T2618)
(declare-fun var_h130 () T2618)
(declare-fun var_h58 () T2618)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'655| () T2618)
(declare-fun var__temp_h653 () T2618)
(declare-fun v () Int)
(assert (= (sel var_h646 res) (+ (sel var_h582 res) 10)))
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h653 res) v) (= v |20|))
               (= (sel var__temp_h653 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'655| res) (+ (sel var__temp_h653 res) 4))
               (= (sel |var__temp_h'655| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h653 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************167
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i647 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i647, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v648:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i647 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i647 --->  Ty_heap  
 var_h646 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h657 --->  Ty_heap  
 var__temp_v658 --->  Ty_int  
 var__temp_h'659 --->  Ty_heap  
 var__temp_v_err660 --->  error  
 var_h646 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h646, res ) ==((sel)( , var_h582, res ) + (10)) AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h657, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h657, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h657, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'659, res ) ==((sel)( , var__temp_h657, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'659, res ) ==(10)
 
VC_END(declare-const var_h_i647 T2635)
(declare-const var_h646 T2635)
(declare-const v Int)
(declare-const var_h_i583 T2635)
(declare-const var_h582 T2635)
(declare-const v Int)
(declare-const var_h_i131 T2635)
(declare-const var_h130 T2635)
(declare-const v Int)
(declare-const var_h_i59 T2635)
(declare-const var_h58 T2635)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h657 T2635)
(declare-const var__temp_v658 Int)
(declare-const |var__temp_h'659| T2635)
(declare-const var__temp_v_err660 T2636)
(declare-const var_h646 T2635)
(declare-const var_h582 T2635)
(declare-const var_h130 T2635)
(declare-const var_h58 T2635)
(declare-const err T2649)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2635)
(declare-fun sel (T2635 Int) Int)
(declare-fun res () Int)
(declare-fun var_h582 () T2635)
(declare-fun var_h646 () T2635)
(declare-fun var_h130 () T2635)
(declare-fun var_h58 () T2635)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'659| () T2635)
(declare-fun var__temp_h657 () T2635)
(declare-fun v () Int)
(assert (= (sel var_h646 res) (+ (sel var_h582 res) 10)))
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h657 res) v) (= v |20|))
               (= (sel var__temp_h657 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'659| res) (+ (sel var__temp_h657 res) 4))
               (= (sel |var__temp_h'659| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h657 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************168
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i647 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i647, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v648:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i647 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i647 --->  Ty_heap  
 var_h646 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h661 --->  Ty_heap  
 var__temp_v662 --->  Ty_int  
 var__temp_h'663 --->  Ty_heap  
 var__temp_v_err664 --->  error  
 var_h646 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h646, res ) ==((sel)( , var_h582, res ) + (10)) AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h661, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h661, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h661, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'663, res ) ==((sel)( , var__temp_h661, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'663, res ) ==(10)
 
VC_END(declare-const var_h_i647 T2652)
(declare-const var_h646 T2652)
(declare-const v Int)
(declare-const var_h_i583 T2652)
(declare-const var_h582 T2652)
(declare-const v Int)
(declare-const var_h_i131 T2652)
(declare-const var_h130 T2652)
(declare-const v Int)
(declare-const var_h_i59 T2652)
(declare-const var_h58 T2652)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h661 T2652)
(declare-const var__temp_v662 Int)
(declare-const |var__temp_h'663| T2652)
(declare-const var__temp_v_err664 T2653)
(declare-const var_h646 T2652)
(declare-const var_h582 T2652)
(declare-const var_h130 T2652)
(declare-const var_h58 T2652)
(declare-const err T2666)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2652)
(declare-fun sel (T2652 Int) Int)
(declare-fun res () Int)
(declare-fun var_h582 () T2652)
(declare-fun var_h646 () T2652)
(declare-fun var_h130 () T2652)
(declare-fun var_h58 () T2652)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'663| () T2652)
(declare-fun var__temp_h661 () T2652)
(declare-fun v () Int)
(assert (= (sel var_h646 res) (+ (sel var_h582 res) 10)))
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h661 res) v) (= v |20|))
               (= (sel var__temp_h661 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'663| res) (+ (sel var__temp_h661 res) 5))
               (= (sel |var__temp_h'663| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h661 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************169
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i647 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i647, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v648:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i647 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i647 --->  Ty_heap  
 var_h646 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h665 --->  Ty_heap  
 var__temp_v666 --->  Ty_int  
 var__temp_h'667 --->  Ty_heap  
 var__temp_v_err668 --->  error  
 var_h646 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h646, res ) ==((sel)( , var_h582, res ) + (10)) AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h665, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h665, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h665, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'667, res ) ==((sel)( , var__temp_h665, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'667, res ) ==(10)
 
VC_END(declare-const var_h_i647 T2669)
(declare-const var_h646 T2669)
(declare-const v Int)
(declare-const var_h_i583 T2669)
(declare-const var_h582 T2669)
(declare-const v Int)
(declare-const var_h_i131 T2669)
(declare-const var_h130 T2669)
(declare-const v Int)
(declare-const var_h_i59 T2669)
(declare-const var_h58 T2669)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h665 T2669)
(declare-const var__temp_v666 Int)
(declare-const |var__temp_h'667| T2669)
(declare-const var__temp_v_err668 T2670)
(declare-const var_h646 T2669)
(declare-const var_h582 T2669)
(declare-const var_h130 T2669)
(declare-const var_h58 T2669)
(declare-const err T2683)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2669)
(declare-fun sel (T2669 Int) Int)
(declare-fun res () Int)
(declare-fun var_h582 () T2669)
(declare-fun var_h646 () T2669)
(declare-fun var_h130 () T2669)
(declare-fun var_h58 () T2669)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'667| () T2669)
(declare-fun var__temp_h665 () T2669)
(declare-fun v () Int)
(assert (= (sel var_h646 res) (+ (sel var_h582 res) 10)))
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h665 res) v) (= v |20|))
               (= (sel var__temp_h665 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'667| res) (+ (sel var__temp_h665 res) 5))
               (= (sel |var__temp_h'667| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h665 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************170
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i647 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i647, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v648:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i647 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i647 --->  Ty_heap  
 var_h646 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h669 --->  Ty_heap  
 var__temp_v670 --->  Ty_int  
 var__temp_h'671 --->  Ty_heap  
 var__temp_v_err672 --->  error  
 var_h646 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h646, res ) ==((sel)( , var_h582, res ) + (10)) AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h669, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h669, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h669, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'671, res ) ==((sel)( , var__temp_h669, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'671, res ) ==(10)
 
VC_END(declare-const var_h_i647 T2686)
(declare-const var_h646 T2686)
(declare-const v Int)
(declare-const var_h_i583 T2686)
(declare-const var_h582 T2686)
(declare-const v Int)
(declare-const var_h_i131 T2686)
(declare-const var_h130 T2686)
(declare-const v Int)
(declare-const var_h_i59 T2686)
(declare-const var_h58 T2686)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h669 T2686)
(declare-const var__temp_v670 Int)
(declare-const |var__temp_h'671| T2686)
(declare-const var__temp_v_err672 T2687)
(declare-const var_h646 T2686)
(declare-const var_h582 T2686)
(declare-const var_h130 T2686)
(declare-const var_h58 T2686)
(declare-const err T2700)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2686)
(declare-fun sel (T2686 Int) Int)
(declare-fun res () Int)
(declare-fun var_h582 () T2686)
(declare-fun var_h646 () T2686)
(declare-fun var_h130 () T2686)
(declare-fun var_h58 () T2686)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'671| () T2686)
(declare-fun var__temp_h669 () T2686)
(declare-fun v () Int)
(assert (= (sel var_h646 res) (+ (sel var_h582 res) 10)))
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h669 res) v) (= v |20|))
               (= (sel var__temp_h669 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'671| res) (+ (sel var__temp_h669 res) 3))
               (= (sel |var__temp_h'671| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h669 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************171
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (3) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i647 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i647, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v648:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i647 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i647 --->  Ty_heap  
 var_h646 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h673 --->  Ty_heap  
 var__temp_v674 --->  Ty_int  
 var__temp_h'675 --->  Ty_heap  
 var__temp_v_err676 --->  error  
 var_h646 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h646, res ) ==((sel)( , var_h582, res ) + (10)) AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h673, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h673, res ) > (3) AND 
 	 Rel (sel)( , var__temp_h673, res ) > (3) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'675, res ) ==(var__temp_v674) AND 
 	 Base var__temp_v674 = 5 => 
 	 Rel (sel)( , var__temp_h'675, res ) ==(10)
 
VC_END(declare-const var_h_i647 T2703)
(declare-const var_h646 T2703)
(declare-const v Int)
(declare-const var_h_i583 T2703)
(declare-const var_h582 T2703)
(declare-const v Int)
(declare-const var_h_i131 T2703)
(declare-const var_h130 T2703)
(declare-const v Int)
(declare-const var_h_i59 T2703)
(declare-const var_h58 T2703)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h673 T2703)
(declare-const var__temp_v674 Int)
(declare-const |var__temp_h'675| T2703)
(declare-const var__temp_v_err676 T2704)
(declare-const var_h646 T2703)
(declare-const var_h582 T2703)
(declare-const var_h130 T2703)
(declare-const var_h58 T2703)
(declare-const err T2717)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T2703)
(declare-fun sel (T2703 Int) Int)
(declare-fun res () Int)
(declare-fun var_h582 () T2703)
(declare-fun var_h646 () T2703)
(declare-fun var_h130 () T2703)
(declare-fun var_h58 () T2703)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'675| () T2703)
(declare-fun var__temp_v674 () Int)
(declare-fun var__temp_h673 () T2703)
(declare-fun v () Int)
(assert (= (sel var_h646 res) (+ (sel var_h582 res) 10)))
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h673 res) v) (= v |20|))
               (not (> (sel var__temp_h673 res) 3))))
      (a!2 (=> (and (= (sel |var__temp_h'675| res) var__temp_v674)
                    (= var__temp_v674 |5|))
               (= (sel |var__temp_h'675| res) 10))))
(let ((a!3 (=> (not (> (sel var__temp_h673 res) 3)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************172
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i647 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i647, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v648:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i647 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i647 --->  Ty_heap  
 var_h646 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h677 --->  Ty_heap  
 var__temp_v678 --->  Ty_int  
 var__temp_h'679 --->  Ty_heap  
 var__temp_v_err680 --->  error  
 var_h646 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h646, res ) ==((sel)( , var_h582, res ) + (10)) AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h677, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h677, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h677, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'679, res ) ==((sel)( , var__temp_h677, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'679, res ) ==(10)
 
VC_END(declare-const var_h_i647 T2720)
(declare-const var_h646 T2720)
(declare-const v Int)
(declare-const var_h_i583 T2720)
(declare-const var_h582 T2720)
(declare-const v Int)
(declare-const var_h_i131 T2720)
(declare-const var_h130 T2720)
(declare-const v Int)
(declare-const var_h_i59 T2720)
(declare-const var_h58 T2720)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h677 T2720)
(declare-const var__temp_v678 Int)
(declare-const |var__temp_h'679| T2720)
(declare-const var__temp_v_err680 T2721)
(declare-const var_h646 T2720)
(declare-const var_h582 T2720)
(declare-const var_h130 T2720)
(declare-const var_h58 T2720)
(declare-const err T2734)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2720)
(declare-fun sel (T2720 Int) Int)
(declare-fun res () Int)
(declare-fun var_h582 () T2720)
(declare-fun var_h646 () T2720)
(declare-fun var_h130 () T2720)
(declare-fun var_h58 () T2720)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'679| () T2720)
(declare-fun var__temp_h677 () T2720)
(declare-fun v () Int)
(assert (= (sel var_h646 res) (+ (sel var_h582 res) 10)))
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h677 res) v) (= v |20|))
               (= (sel var__temp_h677 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'679| res) (+ (sel var__temp_h677 res) 2))
               (= (sel |var__temp_h'679| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h677 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************173
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v648:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v648:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfoo'c2c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --c4	 --c2	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i647 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i647, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v681:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
baz
foo
bar
 *********************Enumeration Iteration*****************174
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i647 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i647, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v681:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i647 --->  Ty_heap  
 var_h646 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h682 --->  Ty_heap  
 var__temp_v683 --->  Ty_int  
 var__temp_h'684 --->  Ty_heap  
 var__temp_v_err685 --->  error  
 var_h646 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h646, res ) ==((sel)( , var_h582, res ) + (10)) AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h682, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h682, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h682, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'684, res ) ==((sel)( , var__temp_h682, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i647 T2737)
(declare-const var_h646 T2737)
(declare-const v Int)
(declare-const var_h_i583 T2737)
(declare-const var_h582 T2737)
(declare-const v Int)
(declare-const var_h_i131 T2737)
(declare-const var_h130 T2737)
(declare-const v Int)
(declare-const var_h_i59 T2737)
(declare-const var_h58 T2737)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h682 T2737)
(declare-const var__temp_v683 Int)
(declare-const |var__temp_h'684| T2737)
(declare-const var__temp_v_err685 T2738)
(declare-const var_h646 T2737)
(declare-const var_h582 T2737)
(declare-const var_h130 T2737)
(declare-const var_h58 T2737)
(declare-const err T2751)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2737)
(declare-fun sel (T2737 Int) Int)
(declare-fun res () Int)
(declare-fun var_h582 () T2737)
(declare-fun var_h646 () T2737)
(declare-fun var_h130 () T2737)
(declare-fun var_h58 () T2737)
(declare-fun |20| () Int)
(declare-fun var__temp_h682 () T2737)
(declare-fun |var__temp_h'684| () T2737)
(declare-fun v () Int)
(assert (= (sel var_h646 res) (+ (sel var_h582 res) 10)))
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h682 res) v) (= v |20|))
               (= (sel var__temp_h682 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'684| res) (+ (sel var__temp_h682 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h682 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************175
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i647 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i647, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v681:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i647 --->  Ty_heap  
 var_h646 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h686 --->  Ty_heap  
 var__temp_v687 --->  Ty_int  
 var__temp_h'688 --->  Ty_heap  
 var__temp_v_err689 --->  error  
 var_h646 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h646, res ) ==((sel)( , var_h582, res ) + (10)) AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h686, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h686, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h686, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'688, res ) ==((sel)( , var__temp_h686, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i647 T2754)
(declare-const var_h646 T2754)
(declare-const v Int)
(declare-const var_h_i583 T2754)
(declare-const var_h582 T2754)
(declare-const v Int)
(declare-const var_h_i131 T2754)
(declare-const var_h130 T2754)
(declare-const v Int)
(declare-const var_h_i59 T2754)
(declare-const var_h58 T2754)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h686 T2754)
(declare-const var__temp_v687 Int)
(declare-const |var__temp_h'688| T2754)
(declare-const var__temp_v_err689 T2755)
(declare-const var_h646 T2754)
(declare-const var_h582 T2754)
(declare-const var_h130 T2754)
(declare-const var_h58 T2754)
(declare-const err T2768)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2754)
(declare-fun sel (T2754 Int) Int)
(declare-fun res () Int)
(declare-fun var_h582 () T2754)
(declare-fun var_h646 () T2754)
(declare-fun var_h130 () T2754)
(declare-fun var_h58 () T2754)
(declare-fun |20| () Int)
(declare-fun var__temp_h686 () T2754)
(declare-fun |var__temp_h'688| () T2754)
(declare-fun v () Int)
(assert (= (sel var_h646 res) (+ (sel var_h582 res) 10)))
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h686 res) v) (= v |20|))
               (= (sel var__temp_h686 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'688| res) (+ (sel var__temp_h686 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h686 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************176
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i647 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i647, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v681:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i647 --->  Ty_heap  
 var_h646 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h690 --->  Ty_heap  
 var__temp_v691 --->  Ty_int  
 var__temp_h'692 --->  Ty_heap  
 var__temp_v_err693 --->  error  
 var_h646 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h646, res ) ==((sel)( , var_h582, res ) + (10)) AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h690, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h690, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h690, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'692, res ) ==((sel)( , var__temp_h690, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i647 T2771)
(declare-const var_h646 T2771)
(declare-const v Int)
(declare-const var_h_i583 T2771)
(declare-const var_h582 T2771)
(declare-const v Int)
(declare-const var_h_i131 T2771)
(declare-const var_h130 T2771)
(declare-const v Int)
(declare-const var_h_i59 T2771)
(declare-const var_h58 T2771)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h690 T2771)
(declare-const var__temp_v691 Int)
(declare-const |var__temp_h'692| T2771)
(declare-const var__temp_v_err693 T2772)
(declare-const var_h646 T2771)
(declare-const var_h582 T2771)
(declare-const var_h130 T2771)
(declare-const var_h58 T2771)
(declare-const err T2785)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2771)
(declare-fun sel (T2771 Int) Int)
(declare-fun res () Int)
(declare-fun var_h582 () T2771)
(declare-fun var_h646 () T2771)
(declare-fun var_h130 () T2771)
(declare-fun var_h58 () T2771)
(declare-fun |20| () Int)
(declare-fun var__temp_h690 () T2771)
(declare-fun |var__temp_h'692| () T2771)
(declare-fun v () Int)
(assert (= (sel var_h646 res) (+ (sel var_h582 res) 10)))
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h690 res) v) (= v |20|))
               (= (sel var__temp_h690 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'692| res) (+ (sel var__temp_h690 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h690 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************177
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i647 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i647, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v681:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i647 --->  Ty_heap  
 var_h646 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h694 --->  Ty_heap  
 var__temp_v695 --->  Ty_int  
 var__temp_h'696 --->  Ty_heap  
 var__temp_v_err697 --->  error  
 var_h646 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h646, res ) ==((sel)( , var_h582, res ) + (10)) AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h694, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h694, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h694, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'696, res ) ==((sel)( , var__temp_h694, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i647 T2788)
(declare-const var_h646 T2788)
(declare-const v Int)
(declare-const var_h_i583 T2788)
(declare-const var_h582 T2788)
(declare-const v Int)
(declare-const var_h_i131 T2788)
(declare-const var_h130 T2788)
(declare-const v Int)
(declare-const var_h_i59 T2788)
(declare-const var_h58 T2788)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h694 T2788)
(declare-const var__temp_v695 Int)
(declare-const |var__temp_h'696| T2788)
(declare-const var__temp_v_err697 T2789)
(declare-const var_h646 T2788)
(declare-const var_h582 T2788)
(declare-const var_h130 T2788)
(declare-const var_h58 T2788)
(declare-const err T2802)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2788)
(declare-fun sel (T2788 Int) Int)
(declare-fun res () Int)
(declare-fun var_h582 () T2788)
(declare-fun var_h646 () T2788)
(declare-fun var_h130 () T2788)
(declare-fun var_h58 () T2788)
(declare-fun |20| () Int)
(declare-fun var__temp_h694 () T2788)
(declare-fun |var__temp_h'696| () T2788)
(declare-fun v () Int)
(assert (= (sel var_h646 res) (+ (sel var_h582 res) 10)))
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h694 res) v) (= v |20|))
               (= (sel var__temp_h694 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'696| res) (+ (sel var__temp_h694 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h694 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************178
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i647 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i647, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v681:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i647 --->  Ty_heap  
 var_h646 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h698 --->  Ty_heap  
 var__temp_v699 --->  Ty_int  
 var__temp_h'700 --->  Ty_heap  
 var__temp_v_err701 --->  error  
 var_h646 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h646, res ) ==((sel)( , var_h582, res ) + (10)) AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h698, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h698, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h698, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'700, res ) ==((sel)( , var__temp_h698, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i647 T2805)
(declare-const var_h646 T2805)
(declare-const v Int)
(declare-const var_h_i583 T2805)
(declare-const var_h582 T2805)
(declare-const v Int)
(declare-const var_h_i131 T2805)
(declare-const var_h130 T2805)
(declare-const v Int)
(declare-const var_h_i59 T2805)
(declare-const var_h58 T2805)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h698 T2805)
(declare-const var__temp_v699 Int)
(declare-const |var__temp_h'700| T2805)
(declare-const var__temp_v_err701 T2806)
(declare-const var_h646 T2805)
(declare-const var_h582 T2805)
(declare-const var_h130 T2805)
(declare-const var_h58 T2805)
(declare-const err T2819)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2805)
(declare-fun sel (T2805 Int) Int)
(declare-fun res () Int)
(declare-fun var_h582 () T2805)
(declare-fun var_h646 () T2805)
(declare-fun var_h130 () T2805)
(declare-fun var_h58 () T2805)
(declare-fun |20| () Int)
(declare-fun var__temp_h698 () T2805)
(declare-fun |var__temp_h'700| () T2805)
(declare-fun v () Int)
(assert (= (sel var_h646 res) (+ (sel var_h582 res) 10)))
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h698 res) v) (= v |20|))
               (= (sel var__temp_h698 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'700| res) (+ (sel var__temp_h698 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h698 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************179
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i647 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i647, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v681:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i647 --->  Ty_heap  
 var_h646 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h702 --->  Ty_heap  
 var__temp_v703 --->  Ty_int  
 var__temp_h'704 --->  Ty_heap  
 var__temp_v_err705 --->  error  
 var_h646 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h646, res ) ==((sel)( , var_h582, res ) + (10)) AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h702, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h702, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h702, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'704, res ) ==((sel)( , var__temp_h702, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i647 T2822)
(declare-const var_h646 T2822)
(declare-const v Int)
(declare-const var_h_i583 T2822)
(declare-const var_h582 T2822)
(declare-const v Int)
(declare-const var_h_i131 T2822)
(declare-const var_h130 T2822)
(declare-const v Int)
(declare-const var_h_i59 T2822)
(declare-const var_h58 T2822)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h702 T2822)
(declare-const var__temp_v703 Int)
(declare-const |var__temp_h'704| T2822)
(declare-const var__temp_v_err705 T2823)
(declare-const var_h646 T2822)
(declare-const var_h582 T2822)
(declare-const var_h130 T2822)
(declare-const var_h58 T2822)
(declare-const err T2836)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2822)
(declare-fun sel (T2822 Int) Int)
(declare-fun res () Int)
(declare-fun var_h582 () T2822)
(declare-fun var_h646 () T2822)
(declare-fun var_h130 () T2822)
(declare-fun var_h58 () T2822)
(declare-fun |20| () Int)
(declare-fun var__temp_h702 () T2822)
(declare-fun |var__temp_h'704| () T2822)
(declare-fun v () Int)
(assert (= (sel var_h646 res) (+ (sel var_h582 res) 10)))
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h702 res) v) (= v |20|))
               (= (sel var__temp_h702 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'704| res) (+ (sel var__temp_h702 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h702 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************180
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (3) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i647 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i647, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v681:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i647 --->  Ty_heap  
 var_h646 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h706 --->  Ty_heap  
 var__temp_v707 --->  Ty_int  
 var__temp_h'708 --->  Ty_heap  
 var__temp_v_err709 --->  error  
 var_h646 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h646, res ) ==((sel)( , var_h582, res ) + (10)) AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h706, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h706, res ) > (3) AND 
 	 Rel (sel)( , var__temp_h706, res ) > (3) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'708, res ) ==(var__temp_v707) AND 
 	 Base var__temp_v707 = 5 => 
 	 True
 
VC_END(declare-const var_h_i647 T2839)
(declare-const var_h646 T2839)
(declare-const v Int)
(declare-const var_h_i583 T2839)
(declare-const var_h582 T2839)
(declare-const v Int)
(declare-const var_h_i131 T2839)
(declare-const var_h130 T2839)
(declare-const v Int)
(declare-const var_h_i59 T2839)
(declare-const var_h58 T2839)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h706 T2839)
(declare-const var__temp_v707 Int)
(declare-const |var__temp_h'708| T2839)
(declare-const var__temp_v_err709 T2840)
(declare-const var_h646 T2839)
(declare-const var_h582 T2839)
(declare-const var_h130 T2839)
(declare-const var_h58 T2839)
(declare-const err T2853)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T2839)
(declare-fun sel (T2839 Int) Int)
(declare-fun res () Int)
(declare-fun var_h582 () T2839)
(declare-fun var_h646 () T2839)
(declare-fun var_h130 () T2839)
(declare-fun var_h58 () T2839)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_v707 () Int)
(declare-fun |var__temp_h'708| () T2839)
(declare-fun var__temp_h706 () T2839)
(declare-fun v () Int)
(assert (= (sel var_h646 res) (+ (sel var_h582 res) 10)))
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h706 res) v) (= v |20|))
               (not (> (sel var__temp_h706 res) 3))))
      (a!2 (=> (and (= (sel |var__temp_h'708| res) var__temp_v707)
                    (= var__temp_v707 |5|))
               true)))
(let ((a!3 (=> (not (> (sel var__temp_h706 res) 3)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************181
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i647 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i647, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v681:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i647 --->  Ty_heap  
 var_h646 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h710 --->  Ty_heap  
 var__temp_v711 --->  Ty_int  
 var__temp_h'712 --->  Ty_heap  
 var__temp_v_err713 --->  error  
 var_h646 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h646, res ) ==((sel)( , var_h582, res ) + (10)) AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h710, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h710, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h710, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'712, res ) ==((sel)( , var__temp_h710, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i647 T2856)
(declare-const var_h646 T2856)
(declare-const v Int)
(declare-const var_h_i583 T2856)
(declare-const var_h582 T2856)
(declare-const v Int)
(declare-const var_h_i131 T2856)
(declare-const var_h130 T2856)
(declare-const v Int)
(declare-const var_h_i59 T2856)
(declare-const var_h58 T2856)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h710 T2856)
(declare-const var__temp_v711 Int)
(declare-const |var__temp_h'712| T2856)
(declare-const var__temp_v_err713 T2857)
(declare-const var_h646 T2856)
(declare-const var_h582 T2856)
(declare-const var_h130 T2856)
(declare-const var_h58 T2856)
(declare-const err T2870)
    (declare-const |20| Int)
  
solver 
 (declare-sort T2856)
(declare-fun sel (T2856 Int) Int)
(declare-fun res () Int)
(declare-fun var_h582 () T2856)
(declare-fun var_h646 () T2856)
(declare-fun var_h130 () T2856)
(declare-fun var_h58 () T2856)
(declare-fun |20| () Int)
(declare-fun var__temp_h710 () T2856)
(declare-fun |var__temp_h'712| () T2856)
(declare-fun v () Int)
(assert (= (sel var_h646 res) (+ (sel var_h582 res) 10)))
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h710 res) v) (= v |20|))
               (= (sel var__temp_h710 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'712| res) (+ (sel var__temp_h710 res) 2))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h710 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************182
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo'
PARTIAL PATH
SUB 	 --c3'	 --c4	 --c2
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i583 Value = Ty_heap{ (sel)( , var_h_i583, res ) ==((sel)( , var_h582, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v714:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
baz
foo
bar
 *********************Enumeration Iteration*****************183
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i583 Value = Ty_heap{ (sel)( , var_h_i583, res ) ==((sel)( , var_h582, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v714:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h715 --->  Ty_heap  
 var__temp_v716 --->  Ty_int  
 var__temp_h'717 --->  Ty_heap  
 var__temp_v_err718 --->  error  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h715, res ) ==((sel)( , var_h582, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h715, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h715, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'717, res ) ==((sel)( , var__temp_h715, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i583 T2873)
(declare-const var_h582 T2873)
(declare-const v Int)
(declare-const var_h_i131 T2873)
(declare-const var_h130 T2873)
(declare-const v Int)
(declare-const var_h_i59 T2873)
(declare-const var_h58 T2873)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h715 T2873)
(declare-const var__temp_v716 Int)
(declare-const |var__temp_h'717| T2873)
(declare-const var__temp_v_err718 T2874)
(declare-const var_h582 T2873)
(declare-const var_h130 T2873)
(declare-const var_h58 T2873)
(declare-const err T2887)

solver 
 (declare-sort T2873)
(declare-fun sel (T2873 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2873)
(declare-fun var_h582 () T2873)
(declare-fun var_h58 () T2873)
(declare-fun var__temp_h715 () T2873)
(declare-fun |var__temp_h'717| () T2873)
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h715 res) (+ (sel var_h582 res) 10))
               (= (sel var__temp_h715 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'717| res) (+ (sel var__temp_h715 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h715 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************184
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i583 Value = Ty_heap{ (sel)( , var_h_i583, res ) ==((sel)( , var_h582, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v714:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h719 --->  Ty_heap  
 var__temp_v720 --->  Ty_int  
 var__temp_h'721 --->  Ty_heap  
 var__temp_v_err722 --->  error  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h719, res ) ==((sel)( , var_h582, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h719, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h719, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'721, res ) ==((sel)( , var__temp_h719, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i583 T2890)
(declare-const var_h582 T2890)
(declare-const v Int)
(declare-const var_h_i131 T2890)
(declare-const var_h130 T2890)
(declare-const v Int)
(declare-const var_h_i59 T2890)
(declare-const var_h58 T2890)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h719 T2890)
(declare-const var__temp_v720 Int)
(declare-const |var__temp_h'721| T2890)
(declare-const var__temp_v_err722 T2891)
(declare-const var_h582 T2890)
(declare-const var_h130 T2890)
(declare-const var_h58 T2890)
(declare-const err T2904)

solver 
 (declare-sort T2890)
(declare-fun sel (T2890 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2890)
(declare-fun var_h582 () T2890)
(declare-fun var_h58 () T2890)
(declare-fun var__temp_h719 () T2890)
(declare-fun |var__temp_h'721| () T2890)
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h719 res) (+ (sel var_h582 res) 10))
               (= (sel var__temp_h719 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'721| res) (+ (sel var__temp_h719 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h719 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************185
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i583 Value = Ty_heap{ (sel)( , var_h_i583, res ) ==((sel)( , var_h582, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v714:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h723 --->  Ty_heap  
 var__temp_v724 --->  Ty_int  
 var__temp_h'725 --->  Ty_heap  
 var__temp_v_err726 --->  error  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h723, res ) ==((sel)( , var_h582, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h723, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h723, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'725, res ) ==((sel)( , var__temp_h723, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i583 T2907)
(declare-const var_h582 T2907)
(declare-const v Int)
(declare-const var_h_i131 T2907)
(declare-const var_h130 T2907)
(declare-const v Int)
(declare-const var_h_i59 T2907)
(declare-const var_h58 T2907)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h723 T2907)
(declare-const var__temp_v724 Int)
(declare-const |var__temp_h'725| T2907)
(declare-const var__temp_v_err726 T2908)
(declare-const var_h582 T2907)
(declare-const var_h130 T2907)
(declare-const var_h58 T2907)
(declare-const err T2921)

solver 
 (declare-sort T2907)
(declare-fun sel (T2907 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2907)
(declare-fun var_h582 () T2907)
(declare-fun var_h58 () T2907)
(declare-fun var__temp_h723 () T2907)
(declare-fun |var__temp_h'725| () T2907)
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h723 res) (+ (sel var_h582 res) 10))
               (= (sel var__temp_h723 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'725| res) (+ (sel var__temp_h723 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h723 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************186
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i583 Value = Ty_heap{ (sel)( , var_h_i583, res ) ==((sel)( , var_h582, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v714:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h727 --->  Ty_heap  
 var__temp_v728 --->  Ty_int  
 var__temp_h'729 --->  Ty_heap  
 var__temp_v_err730 --->  error  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h727, res ) ==((sel)( , var_h582, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h727, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h727, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'729, res ) ==((sel)( , var__temp_h727, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i583 T2924)
(declare-const var_h582 T2924)
(declare-const v Int)
(declare-const var_h_i131 T2924)
(declare-const var_h130 T2924)
(declare-const v Int)
(declare-const var_h_i59 T2924)
(declare-const var_h58 T2924)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h727 T2924)
(declare-const var__temp_v728 Int)
(declare-const |var__temp_h'729| T2924)
(declare-const var__temp_v_err730 T2925)
(declare-const var_h582 T2924)
(declare-const var_h130 T2924)
(declare-const var_h58 T2924)
(declare-const err T2938)

solver 
 (declare-sort T2924)
(declare-fun sel (T2924 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2924)
(declare-fun var_h582 () T2924)
(declare-fun var_h58 () T2924)
(declare-fun var__temp_h727 () T2924)
(declare-fun |var__temp_h'729| () T2924)
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h727 res) (+ (sel var_h582 res) 10))
               (= (sel var__temp_h727 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'729| res) (+ (sel var__temp_h727 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h727 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************187
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i583 Value = Ty_heap{ (sel)( , var_h_i583, res ) ==((sel)( , var_h582, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v714:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h731 --->  Ty_heap  
 var__temp_v732 --->  Ty_int  
 var__temp_h'733 --->  Ty_heap  
 var__temp_v_err734 --->  error  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h731, res ) ==((sel)( , var_h582, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h731, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h731, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'733, res ) ==((sel)( , var__temp_h731, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i583 T2941)
(declare-const var_h582 T2941)
(declare-const v Int)
(declare-const var_h_i131 T2941)
(declare-const var_h130 T2941)
(declare-const v Int)
(declare-const var_h_i59 T2941)
(declare-const var_h58 T2941)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h731 T2941)
(declare-const var__temp_v732 Int)
(declare-const |var__temp_h'733| T2941)
(declare-const var__temp_v_err734 T2942)
(declare-const var_h582 T2941)
(declare-const var_h130 T2941)
(declare-const var_h58 T2941)
(declare-const err T2955)

solver 
 (declare-sort T2941)
(declare-fun sel (T2941 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2941)
(declare-fun var_h582 () T2941)
(declare-fun var_h58 () T2941)
(declare-fun var__temp_h731 () T2941)
(declare-fun |var__temp_h'733| () T2941)
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h731 res) (+ (sel var_h582 res) 10))
               (= (sel var__temp_h731 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'733| res) (+ (sel var__temp_h731 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h731 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************188
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i583 Value = Ty_heap{ (sel)( , var_h_i583, res ) ==((sel)( , var_h582, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v714:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h735 --->  Ty_heap  
 var__temp_v736 --->  Ty_int  
 var__temp_h'737 --->  Ty_heap  
 var__temp_v_err738 --->  error  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h735, res ) ==((sel)( , var_h582, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h735, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h735, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'737, res ) ==((sel)( , var__temp_h735, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i583 T2958)
(declare-const var_h582 T2958)
(declare-const v Int)
(declare-const var_h_i131 T2958)
(declare-const var_h130 T2958)
(declare-const v Int)
(declare-const var_h_i59 T2958)
(declare-const var_h58 T2958)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h735 T2958)
(declare-const var__temp_v736 Int)
(declare-const |var__temp_h'737| T2958)
(declare-const var__temp_v_err738 T2959)
(declare-const var_h582 T2958)
(declare-const var_h130 T2958)
(declare-const var_h58 T2958)
(declare-const err T2972)

solver 
 (declare-sort T2958)
(declare-fun sel (T2958 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2958)
(declare-fun var_h582 () T2958)
(declare-fun var_h58 () T2958)
(declare-fun var__temp_h735 () T2958)
(declare-fun |var__temp_h'737| () T2958)
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h735 res) (+ (sel var_h582 res) 10))
               (= (sel var__temp_h735 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'737| res) (+ (sel var__temp_h735 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h735 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************189
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (3) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i583 Value = Ty_heap{ (sel)( , var_h_i583, res ) ==((sel)( , var_h582, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v714:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h739 --->  Ty_heap  
 var__temp_v740 --->  Ty_int  
 var__temp_h'741 --->  Ty_heap  
 var__temp_v_err742 --->  error  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h739, res ) ==((sel)( , var_h582, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h739, res ) > (3) AND 
 	 Rel (sel)( , var__temp_h739, res ) > (3) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'741, res ) ==(var__temp_v740) AND 
 	 Base var__temp_v740 = 5 => 
 	 True
 
VC_END(declare-const var_h_i583 T2975)
(declare-const var_h582 T2975)
(declare-const v Int)
(declare-const var_h_i131 T2975)
(declare-const var_h130 T2975)
(declare-const v Int)
(declare-const var_h_i59 T2975)
(declare-const var_h58 T2975)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h739 T2975)
(declare-const var__temp_v740 Int)
(declare-const |var__temp_h'741| T2975)
(declare-const var__temp_v_err742 T2976)
(declare-const var_h582 T2975)
(declare-const var_h130 T2975)
(declare-const var_h58 T2975)
(declare-const err T2989)
    (declare-const |5| Int)
  
solver 
 (declare-sort T2975)
(declare-fun sel (T2975 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2975)
(declare-fun var_h582 () T2975)
(declare-fun var_h58 () T2975)
(declare-fun |5| () Int)
(declare-fun var__temp_v740 () Int)
(declare-fun |var__temp_h'741| () T2975)
(declare-fun var__temp_h739 () T2975)
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h739 res) (+ (sel var_h582 res) 10))
               (not (> (sel var__temp_h739 res) 3))))
      (a!2 (=> (and (= (sel |var__temp_h'741| res) var__temp_v740)
                    (= var__temp_v740 |5|))
               true)))
(let ((a!3 (=> (not (> (sel var__temp_h739 res) 3)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************190
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i583 Value = Ty_heap{ (sel)( , var_h_i583, res ) ==((sel)( , var_h582, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v714:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i583 --->  Ty_heap  
 var_h582 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h743 --->  Ty_heap  
 var__temp_v744 --->  Ty_int  
 var__temp_h'745 --->  Ty_heap  
 var__temp_v_err746 --->  error  
 var_h582 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h582, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h743, res ) ==((sel)( , var_h582, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h743, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h743, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'745, res ) ==((sel)( , var__temp_h743, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i583 T2992)
(declare-const var_h582 T2992)
(declare-const v Int)
(declare-const var_h_i131 T2992)
(declare-const var_h130 T2992)
(declare-const v Int)
(declare-const var_h_i59 T2992)
(declare-const var_h58 T2992)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h743 T2992)
(declare-const var__temp_v744 Int)
(declare-const |var__temp_h'745| T2992)
(declare-const var__temp_v_err746 T2993)
(declare-const var_h582 T2992)
(declare-const var_h130 T2992)
(declare-const var_h58 T2992)
(declare-const err T3006)

solver 
 (declare-sort T2992)
(declare-fun sel (T2992 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T2992)
(declare-fun var_h582 () T2992)
(declare-fun var_h58 () T2992)
(declare-fun var__temp_h743 () T2992)
(declare-fun |var__temp_h'745| () T2992)
(assert (= (sel var_h582 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h743 res) (+ (sel var_h582 res) 10))
               (= (sel var__temp_h743 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'745| res) (+ (sel var__temp_h743 res) 2))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h743 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************191
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo'
PARTIAL PATH
SUB 	 --c3'	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v747:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
foo'
baz
foo
bar
 *********************Enumeration Iteration*****************192
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v747:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h748 --->  Ty_heap  
 var__temp_v749 --->  Ty_int  
 var__temp_h'750 --->  Ty_heap  
 var__temp_v_err751 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h748, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h748, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h748, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'750, res ) ==((sel)( , var__temp_h748, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i131 T3009)
(declare-const var_h130 T3009)
(declare-const v Int)
(declare-const var_h_i59 T3009)
(declare-const var_h58 T3009)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h748 T3009)
(declare-const var__temp_v749 Int)
(declare-const |var__temp_h'750| T3009)
(declare-const var__temp_v_err751 T3010)
(declare-const var_h130 T3009)
(declare-const var_h58 T3009)
(declare-const err T3023)

solver 
 (declare-sort T3009)
(declare-fun sel (T3009 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3009)
(declare-fun var_h130 () T3009)
(declare-fun var__temp_h748 () T3009)
(declare-fun |var__temp_h'750| () T3009)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h748 res) (+ (sel var_h130 res) 6))
               (= (sel var__temp_h748 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'750| res) (+ (sel var__temp_h748 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h748 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************193
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v747:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h752 --->  Ty_heap  
 var__temp_v753 --->  Ty_int  
 var__temp_h'754 --->  Ty_heap  
 var__temp_v_err755 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h752, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h752, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h752, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'754, res ) ==((sel)( , var__temp_h752, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i131 T3026)
(declare-const var_h130 T3026)
(declare-const v Int)
(declare-const var_h_i59 T3026)
(declare-const var_h58 T3026)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h752 T3026)
(declare-const var__temp_v753 Int)
(declare-const |var__temp_h'754| T3026)
(declare-const var__temp_v_err755 T3027)
(declare-const var_h130 T3026)
(declare-const var_h58 T3026)
(declare-const err T3040)

solver 
 (declare-sort T3026)
(declare-fun sel (T3026 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3026)
(declare-fun var_h130 () T3026)
(declare-fun var__temp_h752 () T3026)
(declare-fun |var__temp_h'754| () T3026)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h752 res) (+ (sel var_h130 res) 6))
               (= (sel var__temp_h752 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'754| res) (+ (sel var__temp_h752 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h752 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************194
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v747:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h756 --->  Ty_heap  
 var__temp_v757 --->  Ty_int  
 var__temp_h'758 --->  Ty_heap  
 var__temp_v_err759 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h756, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h756, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h756, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'758, res ) ==((sel)( , var__temp_h756, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i131 T3043)
(declare-const var_h130 T3043)
(declare-const v Int)
(declare-const var_h_i59 T3043)
(declare-const var_h58 T3043)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h756 T3043)
(declare-const var__temp_v757 Int)
(declare-const |var__temp_h'758| T3043)
(declare-const var__temp_v_err759 T3044)
(declare-const var_h130 T3043)
(declare-const var_h58 T3043)
(declare-const err T3057)

solver 
 (declare-sort T3043)
(declare-fun sel (T3043 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3043)
(declare-fun var_h130 () T3043)
(declare-fun var__temp_h756 () T3043)
(declare-fun |var__temp_h'758| () T3043)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h756 res) (+ (sel var_h130 res) 6))
               (= (sel var__temp_h756 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'758| res) (+ (sel var__temp_h756 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h756 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************195
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v747:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h760 --->  Ty_heap  
 var__temp_v761 --->  Ty_int  
 var__temp_h'762 --->  Ty_heap  
 var__temp_v_err763 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h760, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h760, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h760, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'762, res ) ==((sel)( , var__temp_h760, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i131 T3060)
(declare-const var_h130 T3060)
(declare-const v Int)
(declare-const var_h_i59 T3060)
(declare-const var_h58 T3060)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h760 T3060)
(declare-const var__temp_v761 Int)
(declare-const |var__temp_h'762| T3060)
(declare-const var__temp_v_err763 T3061)
(declare-const var_h130 T3060)
(declare-const var_h58 T3060)
(declare-const err T3074)

solver 
 (declare-sort T3060)
(declare-fun sel (T3060 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3060)
(declare-fun var_h130 () T3060)
(declare-fun var__temp_h760 () T3060)
(declare-fun |var__temp_h'762| () T3060)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h760 res) (+ (sel var_h130 res) 6))
               (= (sel var__temp_h760 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'762| res) (+ (sel var__temp_h760 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h760 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************196
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v747:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h764 --->  Ty_heap  
 var__temp_v765 --->  Ty_int  
 var__temp_h'766 --->  Ty_heap  
 var__temp_v_err767 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h764, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h764, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h764, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'766, res ) ==((sel)( , var__temp_h764, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i131 T3077)
(declare-const var_h130 T3077)
(declare-const v Int)
(declare-const var_h_i59 T3077)
(declare-const var_h58 T3077)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h764 T3077)
(declare-const var__temp_v765 Int)
(declare-const |var__temp_h'766| T3077)
(declare-const var__temp_v_err767 T3078)
(declare-const var_h130 T3077)
(declare-const var_h58 T3077)
(declare-const err T3091)

solver 
 (declare-sort T3077)
(declare-fun sel (T3077 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3077)
(declare-fun var_h130 () T3077)
(declare-fun var__temp_h764 () T3077)
(declare-fun |var__temp_h'766| () T3077)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h764 res) (+ (sel var_h130 res) 6))
               (= (sel var__temp_h764 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'766| res) (+ (sel var__temp_h764 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h764 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************197
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 20} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v747:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h768 --->  Ty_heap  
 var__temp_v769 --->  Ty_int  
 var__temp_h'770 --->  Ty_heap  
 var__temp_v_err771 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h768, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'770, res ) ==(var__temp_v769) AND 
 	 Base var__temp_v769 = 20 => 
 	 True
 
VC_END(declare-const var_h_i131 T3094)
(declare-const var_h130 T3094)
(declare-const v Int)
(declare-const var_h_i59 T3094)
(declare-const var_h58 T3094)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h768 T3094)
(declare-const var__temp_v769 Int)
(declare-const |var__temp_h'770| T3094)
(declare-const var__temp_v_err771 T3095)
(declare-const var_h130 T3094)
(declare-const var_h58 T3094)
(declare-const err T3108)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3094)
(declare-fun sel (T3094 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3094)
(declare-fun var_h130 () T3094)
(declare-fun |20| () Int)
(declare-fun var__temp_v769 () Int)
(declare-fun |var__temp_h'770| () T3094)
(declare-fun var__temp_h768 () T3094)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (= (sel var__temp_h768 res) (+ (sel var_h130 res) 6)) true))
      (a!2 (=> (and (= (sel |var__temp_h'770| res) var__temp_v769)
                    (= var__temp_v769 |20|))
               true)))
  (not (and a!1 (=> true a!2)))))

***************Selection Successful************foo'
PARTIAL PATH NEW
NEW 	 --c3'	 --c4	 --foo'
post_substituted Forall 
 	 
 Key =var_h_i773 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i773 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i773, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v774:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i773 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
baz
foo
bar
 *********************Enumeration Iteration*****************198
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i773 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i773, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v774:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i773 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i773 --->  Ty_heap  
 var_h772 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h775 --->  Ty_heap  
 var__temp_v776 --->  Ty_int  
 var__temp_h'777 --->  Ty_heap  
 var__temp_v_err778 --->  error  
 var_h772 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h772, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h775, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h775, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h775, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'777, res ) ==((sel)( , var__temp_h775, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'777, res ) ==(10)
 
VC_END(declare-const var_h_i773 T3111)
(declare-const var_h772 T3111)
(declare-const v Int)
(declare-const var_h_i131 T3111)
(declare-const var_h130 T3111)
(declare-const v Int)
(declare-const var_h_i59 T3111)
(declare-const var_h58 T3111)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h775 T3111)
(declare-const var__temp_v776 Int)
(declare-const |var__temp_h'777| T3111)
(declare-const var__temp_v_err778 T3112)
(declare-const var_h772 T3111)
(declare-const var_h130 T3111)
(declare-const var_h58 T3111)
(declare-const err T3125)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3111)
(declare-fun sel (T3111 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T3111)
(declare-fun var_h772 () T3111)
(declare-fun var_h58 () T3111)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'777| () T3111)
(declare-fun var__temp_h775 () T3111)
(declare-fun v () Int)
(assert (= (sel var_h772 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h775 res) v) (= v |20|))
               (= (sel var__temp_h775 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'777| res) (+ (sel var__temp_h775 res) 4))
               (= (sel |var__temp_h'777| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h775 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************199
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i773 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i773, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v774:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i773 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i773 --->  Ty_heap  
 var_h772 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h779 --->  Ty_heap  
 var__temp_v780 --->  Ty_int  
 var__temp_h'781 --->  Ty_heap  
 var__temp_v_err782 --->  error  
 var_h772 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h772, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h779, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h779, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h779, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'781, res ) ==((sel)( , var__temp_h779, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'781, res ) ==(10)
 
VC_END(declare-const var_h_i773 T3128)
(declare-const var_h772 T3128)
(declare-const v Int)
(declare-const var_h_i131 T3128)
(declare-const var_h130 T3128)
(declare-const v Int)
(declare-const var_h_i59 T3128)
(declare-const var_h58 T3128)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h779 T3128)
(declare-const var__temp_v780 Int)
(declare-const |var__temp_h'781| T3128)
(declare-const var__temp_v_err782 T3129)
(declare-const var_h772 T3128)
(declare-const var_h130 T3128)
(declare-const var_h58 T3128)
(declare-const err T3142)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3128)
(declare-fun sel (T3128 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T3128)
(declare-fun var_h772 () T3128)
(declare-fun var_h58 () T3128)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'781| () T3128)
(declare-fun var__temp_h779 () T3128)
(declare-fun v () Int)
(assert (= (sel var_h772 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h779 res) v) (= v |20|))
               (= (sel var__temp_h779 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'781| res) (+ (sel var__temp_h779 res) 4))
               (= (sel |var__temp_h'781| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h779 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************200
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i773 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i773, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v774:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i773 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i773 --->  Ty_heap  
 var_h772 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h783 --->  Ty_heap  
 var__temp_v784 --->  Ty_int  
 var__temp_h'785 --->  Ty_heap  
 var__temp_v_err786 --->  error  
 var_h772 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h772, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h783, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h783, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h783, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'785, res ) ==((sel)( , var__temp_h783, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'785, res ) ==(10)
 
VC_END(declare-const var_h_i773 T3145)
(declare-const var_h772 T3145)
(declare-const v Int)
(declare-const var_h_i131 T3145)
(declare-const var_h130 T3145)
(declare-const v Int)
(declare-const var_h_i59 T3145)
(declare-const var_h58 T3145)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h783 T3145)
(declare-const var__temp_v784 Int)
(declare-const |var__temp_h'785| T3145)
(declare-const var__temp_v_err786 T3146)
(declare-const var_h772 T3145)
(declare-const var_h130 T3145)
(declare-const var_h58 T3145)
(declare-const err T3159)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3145)
(declare-fun sel (T3145 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T3145)
(declare-fun var_h772 () T3145)
(declare-fun var_h58 () T3145)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'785| () T3145)
(declare-fun var__temp_h783 () T3145)
(declare-fun v () Int)
(assert (= (sel var_h772 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h783 res) v) (= v |20|))
               (= (sel var__temp_h783 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'785| res) (+ (sel var__temp_h783 res) 4))
               (= (sel |var__temp_h'785| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h783 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************201
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i773 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i773, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v774:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i773 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i773 --->  Ty_heap  
 var_h772 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h787 --->  Ty_heap  
 var__temp_v788 --->  Ty_int  
 var__temp_h'789 --->  Ty_heap  
 var__temp_v_err790 --->  error  
 var_h772 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h772, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h787, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h787, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h787, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'789, res ) ==((sel)( , var__temp_h787, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'789, res ) ==(10)
 
VC_END(declare-const var_h_i773 T3162)
(declare-const var_h772 T3162)
(declare-const v Int)
(declare-const var_h_i131 T3162)
(declare-const var_h130 T3162)
(declare-const v Int)
(declare-const var_h_i59 T3162)
(declare-const var_h58 T3162)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h787 T3162)
(declare-const var__temp_v788 Int)
(declare-const |var__temp_h'789| T3162)
(declare-const var__temp_v_err790 T3163)
(declare-const var_h772 T3162)
(declare-const var_h130 T3162)
(declare-const var_h58 T3162)
(declare-const err T3176)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3162)
(declare-fun sel (T3162 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T3162)
(declare-fun var_h772 () T3162)
(declare-fun var_h58 () T3162)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'789| () T3162)
(declare-fun var__temp_h787 () T3162)
(declare-fun v () Int)
(assert (= (sel var_h772 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h787 res) v) (= v |20|))
               (= (sel var__temp_h787 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'789| res) (+ (sel var__temp_h787 res) 5))
               (= (sel |var__temp_h'789| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h787 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************202
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i773 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i773, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v774:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i773 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i773 --->  Ty_heap  
 var_h772 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h791 --->  Ty_heap  
 var__temp_v792 --->  Ty_int  
 var__temp_h'793 --->  Ty_heap  
 var__temp_v_err794 --->  error  
 var_h772 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h772, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h791, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h791, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h791, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'793, res ) ==((sel)( , var__temp_h791, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'793, res ) ==(10)
 
VC_END(declare-const var_h_i773 T3179)
(declare-const var_h772 T3179)
(declare-const v Int)
(declare-const var_h_i131 T3179)
(declare-const var_h130 T3179)
(declare-const v Int)
(declare-const var_h_i59 T3179)
(declare-const var_h58 T3179)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h791 T3179)
(declare-const var__temp_v792 Int)
(declare-const |var__temp_h'793| T3179)
(declare-const var__temp_v_err794 T3180)
(declare-const var_h772 T3179)
(declare-const var_h130 T3179)
(declare-const var_h58 T3179)
(declare-const err T3193)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3179)
(declare-fun sel (T3179 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T3179)
(declare-fun var_h772 () T3179)
(declare-fun var_h58 () T3179)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'793| () T3179)
(declare-fun var__temp_h791 () T3179)
(declare-fun v () Int)
(assert (= (sel var_h772 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h791 res) v) (= v |20|))
               (= (sel var__temp_h791 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'793| res) (+ (sel var__temp_h791 res) 5))
               (= (sel |var__temp_h'793| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h791 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************203
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i773 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i773, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v774:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i773 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i773 --->  Ty_heap  
 var_h772 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h795 --->  Ty_heap  
 var__temp_v796 --->  Ty_int  
 var__temp_h'797 --->  Ty_heap  
 var__temp_v_err798 --->  error  
 var_h772 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h772, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h795, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h795, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h795, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'797, res ) ==((sel)( , var__temp_h795, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'797, res ) ==(10)
 
VC_END(declare-const var_h_i773 T3196)
(declare-const var_h772 T3196)
(declare-const v Int)
(declare-const var_h_i131 T3196)
(declare-const var_h130 T3196)
(declare-const v Int)
(declare-const var_h_i59 T3196)
(declare-const var_h58 T3196)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h795 T3196)
(declare-const var__temp_v796 Int)
(declare-const |var__temp_h'797| T3196)
(declare-const var__temp_v_err798 T3197)
(declare-const var_h772 T3196)
(declare-const var_h130 T3196)
(declare-const var_h58 T3196)
(declare-const err T3210)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3196)
(declare-fun sel (T3196 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T3196)
(declare-fun var_h772 () T3196)
(declare-fun var_h58 () T3196)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'797| () T3196)
(declare-fun var__temp_h795 () T3196)
(declare-fun v () Int)
(assert (= (sel var_h772 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h795 res) v) (= v |20|))
               (= (sel var__temp_h795 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'797| res) (+ (sel var__temp_h795 res) 3))
               (= (sel |var__temp_h'797| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h795 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************204
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (3) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i773 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i773, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v774:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i773 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i773 --->  Ty_heap  
 var_h772 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h799 --->  Ty_heap  
 var__temp_v800 --->  Ty_int  
 var__temp_h'801 --->  Ty_heap  
 var__temp_v_err802 --->  error  
 var_h772 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h772, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h799, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h799, res ) > (3) AND 
 	 Rel (sel)( , var__temp_h799, res ) > (3) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'801, res ) ==(var__temp_v800) AND 
 	 Base var__temp_v800 = 5 => 
 	 Rel (sel)( , var__temp_h'801, res ) ==(10)
 
VC_END(declare-const var_h_i773 T3213)
(declare-const var_h772 T3213)
(declare-const v Int)
(declare-const var_h_i131 T3213)
(declare-const var_h130 T3213)
(declare-const v Int)
(declare-const var_h_i59 T3213)
(declare-const var_h58 T3213)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h799 T3213)
(declare-const var__temp_v800 Int)
(declare-const |var__temp_h'801| T3213)
(declare-const var__temp_v_err802 T3214)
(declare-const var_h772 T3213)
(declare-const var_h130 T3213)
(declare-const var_h58 T3213)
(declare-const err T3227)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T3213)
(declare-fun sel (T3213 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T3213)
(declare-fun var_h772 () T3213)
(declare-fun var_h58 () T3213)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'801| () T3213)
(declare-fun var__temp_v800 () Int)
(declare-fun var__temp_h799 () T3213)
(declare-fun v () Int)
(assert (= (sel var_h772 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h799 res) v) (= v |20|))
               (not (> (sel var__temp_h799 res) 3))))
      (a!2 (=> (and (= (sel |var__temp_h'801| res) var__temp_v800)
                    (= var__temp_v800 |5|))
               (= (sel |var__temp_h'801| res) 10))))
(let ((a!3 (=> (not (> (sel var__temp_h799 res) 3)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************205
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i773 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i773, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v774:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i773 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i773 --->  Ty_heap  
 var_h772 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h803 --->  Ty_heap  
 var__temp_v804 --->  Ty_int  
 var__temp_h'805 --->  Ty_heap  
 var__temp_v_err806 --->  error  
 var_h772 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h772, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h803, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h803, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h803, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'805, res ) ==((sel)( , var__temp_h803, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'805, res ) ==(10)
 
VC_END(declare-const var_h_i773 T3230)
(declare-const var_h772 T3230)
(declare-const v Int)
(declare-const var_h_i131 T3230)
(declare-const var_h130 T3230)
(declare-const v Int)
(declare-const var_h_i59 T3230)
(declare-const var_h58 T3230)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h803 T3230)
(declare-const var__temp_v804 Int)
(declare-const |var__temp_h'805| T3230)
(declare-const var__temp_v_err806 T3231)
(declare-const var_h772 T3230)
(declare-const var_h130 T3230)
(declare-const var_h58 T3230)
(declare-const err T3244)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3230)
(declare-fun sel (T3230 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T3230)
(declare-fun var_h772 () T3230)
(declare-fun var_h58 () T3230)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'805| () T3230)
(declare-fun var__temp_h803 () T3230)
(declare-fun v () Int)
(assert (= (sel var_h772 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h803 res) v) (= v |20|))
               (= (sel var__temp_h803 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'805| res) (+ (sel var__temp_h803 res) 2))
               (= (sel |var__temp_h'805| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h803 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************206
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v774:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v774:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfoo'c2c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --c4	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i773 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i773, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v807:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
baz
foo
bar
 *********************Enumeration Iteration*****************207
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i773 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i773, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v807:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i773 --->  Ty_heap  
 var_h772 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h808 --->  Ty_heap  
 var__temp_v809 --->  Ty_int  
 var__temp_h'810 --->  Ty_heap  
 var__temp_v_err811 --->  error  
 var_h772 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h772, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h808, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h808, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h808, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'810, res ) ==((sel)( , var__temp_h808, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i773 T3247)
(declare-const var_h772 T3247)
(declare-const v Int)
(declare-const var_h_i131 T3247)
(declare-const var_h130 T3247)
(declare-const v Int)
(declare-const var_h_i59 T3247)
(declare-const var_h58 T3247)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h808 T3247)
(declare-const var__temp_v809 Int)
(declare-const |var__temp_h'810| T3247)
(declare-const var__temp_v_err811 T3248)
(declare-const var_h772 T3247)
(declare-const var_h130 T3247)
(declare-const var_h58 T3247)
(declare-const err T3261)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3247)
(declare-fun sel (T3247 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T3247)
(declare-fun var_h772 () T3247)
(declare-fun var_h58 () T3247)
(declare-fun |20| () Int)
(declare-fun var__temp_h808 () T3247)
(declare-fun |var__temp_h'810| () T3247)
(declare-fun v () Int)
(assert (= (sel var_h772 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h808 res) v) (= v |20|))
               (= (sel var__temp_h808 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'810| res) (+ (sel var__temp_h808 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h808 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************208
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i773 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i773, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v807:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i773 --->  Ty_heap  
 var_h772 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h812 --->  Ty_heap  
 var__temp_v813 --->  Ty_int  
 var__temp_h'814 --->  Ty_heap  
 var__temp_v_err815 --->  error  
 var_h772 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h772, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h812, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h812, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h812, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'814, res ) ==((sel)( , var__temp_h812, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i773 T3264)
(declare-const var_h772 T3264)
(declare-const v Int)
(declare-const var_h_i131 T3264)
(declare-const var_h130 T3264)
(declare-const v Int)
(declare-const var_h_i59 T3264)
(declare-const var_h58 T3264)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h812 T3264)
(declare-const var__temp_v813 Int)
(declare-const |var__temp_h'814| T3264)
(declare-const var__temp_v_err815 T3265)
(declare-const var_h772 T3264)
(declare-const var_h130 T3264)
(declare-const var_h58 T3264)
(declare-const err T3278)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3264)
(declare-fun sel (T3264 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T3264)
(declare-fun var_h772 () T3264)
(declare-fun var_h58 () T3264)
(declare-fun |20| () Int)
(declare-fun var__temp_h812 () T3264)
(declare-fun |var__temp_h'814| () T3264)
(declare-fun v () Int)
(assert (= (sel var_h772 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h812 res) v) (= v |20|))
               (= (sel var__temp_h812 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'814| res) (+ (sel var__temp_h812 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h812 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************209
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i773 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i773, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v807:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i773 --->  Ty_heap  
 var_h772 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h816 --->  Ty_heap  
 var__temp_v817 --->  Ty_int  
 var__temp_h'818 --->  Ty_heap  
 var__temp_v_err819 --->  error  
 var_h772 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h772, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h816, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h816, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h816, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'818, res ) ==((sel)( , var__temp_h816, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i773 T3281)
(declare-const var_h772 T3281)
(declare-const v Int)
(declare-const var_h_i131 T3281)
(declare-const var_h130 T3281)
(declare-const v Int)
(declare-const var_h_i59 T3281)
(declare-const var_h58 T3281)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h816 T3281)
(declare-const var__temp_v817 Int)
(declare-const |var__temp_h'818| T3281)
(declare-const var__temp_v_err819 T3282)
(declare-const var_h772 T3281)
(declare-const var_h130 T3281)
(declare-const var_h58 T3281)
(declare-const err T3295)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3281)
(declare-fun sel (T3281 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T3281)
(declare-fun var_h772 () T3281)
(declare-fun var_h58 () T3281)
(declare-fun |20| () Int)
(declare-fun var__temp_h816 () T3281)
(declare-fun |var__temp_h'818| () T3281)
(declare-fun v () Int)
(assert (= (sel var_h772 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h816 res) v) (= v |20|))
               (= (sel var__temp_h816 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'818| res) (+ (sel var__temp_h816 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h816 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************210
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i773 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i773, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v807:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i773 --->  Ty_heap  
 var_h772 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h820 --->  Ty_heap  
 var__temp_v821 --->  Ty_int  
 var__temp_h'822 --->  Ty_heap  
 var__temp_v_err823 --->  error  
 var_h772 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h772, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h820, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h820, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h820, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'822, res ) ==((sel)( , var__temp_h820, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i773 T3298)
(declare-const var_h772 T3298)
(declare-const v Int)
(declare-const var_h_i131 T3298)
(declare-const var_h130 T3298)
(declare-const v Int)
(declare-const var_h_i59 T3298)
(declare-const var_h58 T3298)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h820 T3298)
(declare-const var__temp_v821 Int)
(declare-const |var__temp_h'822| T3298)
(declare-const var__temp_v_err823 T3299)
(declare-const var_h772 T3298)
(declare-const var_h130 T3298)
(declare-const var_h58 T3298)
(declare-const err T3312)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3298)
(declare-fun sel (T3298 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T3298)
(declare-fun var_h772 () T3298)
(declare-fun var_h58 () T3298)
(declare-fun |20| () Int)
(declare-fun var__temp_h820 () T3298)
(declare-fun |var__temp_h'822| () T3298)
(declare-fun v () Int)
(assert (= (sel var_h772 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h820 res) v) (= v |20|))
               (= (sel var__temp_h820 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'822| res) (+ (sel var__temp_h820 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h820 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************211
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i773 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i773, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v807:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i773 --->  Ty_heap  
 var_h772 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h824 --->  Ty_heap  
 var__temp_v825 --->  Ty_int  
 var__temp_h'826 --->  Ty_heap  
 var__temp_v_err827 --->  error  
 var_h772 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h772, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h824, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h824, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h824, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'826, res ) ==((sel)( , var__temp_h824, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i773 T3315)
(declare-const var_h772 T3315)
(declare-const v Int)
(declare-const var_h_i131 T3315)
(declare-const var_h130 T3315)
(declare-const v Int)
(declare-const var_h_i59 T3315)
(declare-const var_h58 T3315)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h824 T3315)
(declare-const var__temp_v825 Int)
(declare-const |var__temp_h'826| T3315)
(declare-const var__temp_v_err827 T3316)
(declare-const var_h772 T3315)
(declare-const var_h130 T3315)
(declare-const var_h58 T3315)
(declare-const err T3329)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3315)
(declare-fun sel (T3315 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T3315)
(declare-fun var_h772 () T3315)
(declare-fun var_h58 () T3315)
(declare-fun |20| () Int)
(declare-fun var__temp_h824 () T3315)
(declare-fun |var__temp_h'826| () T3315)
(declare-fun v () Int)
(assert (= (sel var_h772 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h824 res) v) (= v |20|))
               (= (sel var__temp_h824 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'826| res) (+ (sel var__temp_h824 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h824 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************212
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i773 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i773, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v807:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i773 --->  Ty_heap  
 var_h772 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h828 --->  Ty_heap  
 var__temp_v829 --->  Ty_int  
 var__temp_h'830 --->  Ty_heap  
 var__temp_v_err831 --->  error  
 var_h772 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h772, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h828, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h828, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h828, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'830, res ) ==((sel)( , var__temp_h828, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i773 T3332)
(declare-const var_h772 T3332)
(declare-const v Int)
(declare-const var_h_i131 T3332)
(declare-const var_h130 T3332)
(declare-const v Int)
(declare-const var_h_i59 T3332)
(declare-const var_h58 T3332)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h828 T3332)
(declare-const var__temp_v829 Int)
(declare-const |var__temp_h'830| T3332)
(declare-const var__temp_v_err831 T3333)
(declare-const var_h772 T3332)
(declare-const var_h130 T3332)
(declare-const var_h58 T3332)
(declare-const err T3346)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3332)
(declare-fun sel (T3332 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T3332)
(declare-fun var_h772 () T3332)
(declare-fun var_h58 () T3332)
(declare-fun |20| () Int)
(declare-fun var__temp_h828 () T3332)
(declare-fun |var__temp_h'830| () T3332)
(declare-fun v () Int)
(assert (= (sel var_h772 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h828 res) v) (= v |20|))
               (= (sel var__temp_h828 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'830| res) (+ (sel var__temp_h828 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h828 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************213
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (3) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i773 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i773, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v807:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i773 --->  Ty_heap  
 var_h772 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h832 --->  Ty_heap  
 var__temp_v833 --->  Ty_int  
 var__temp_h'834 --->  Ty_heap  
 var__temp_v_err835 --->  error  
 var_h772 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h772, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h832, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h832, res ) > (3) AND 
 	 Rel (sel)( , var__temp_h832, res ) > (3) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'834, res ) ==(var__temp_v833) AND 
 	 Base var__temp_v833 = 5 => 
 	 True
 
VC_END(declare-const var_h_i773 T3349)
(declare-const var_h772 T3349)
(declare-const v Int)
(declare-const var_h_i131 T3349)
(declare-const var_h130 T3349)
(declare-const v Int)
(declare-const var_h_i59 T3349)
(declare-const var_h58 T3349)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h832 T3349)
(declare-const var__temp_v833 Int)
(declare-const |var__temp_h'834| T3349)
(declare-const var__temp_v_err835 T3350)
(declare-const var_h772 T3349)
(declare-const var_h130 T3349)
(declare-const var_h58 T3349)
(declare-const err T3363)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T3349)
(declare-fun sel (T3349 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T3349)
(declare-fun var_h772 () T3349)
(declare-fun var_h58 () T3349)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_v833 () Int)
(declare-fun |var__temp_h'834| () T3349)
(declare-fun var__temp_h832 () T3349)
(declare-fun v () Int)
(assert (= (sel var_h772 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h832 res) v) (= v |20|))
               (not (> (sel var__temp_h832 res) 3))))
      (a!2 (=> (and (= (sel |var__temp_h'834| res) var__temp_v833)
                    (= var__temp_v833 |5|))
               true)))
(let ((a!3 (=> (not (> (sel var__temp_h832 res) 3)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************214
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i773 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i773, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v807:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i773 --->  Ty_heap  
 var_h772 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h836 --->  Ty_heap  
 var__temp_v837 --->  Ty_int  
 var__temp_h'838 --->  Ty_heap  
 var__temp_v_err839 --->  error  
 var_h772 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h772, res ) ==((sel)( , var_h130, res ) + (6)) AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h836, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h836, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h836, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'838, res ) ==((sel)( , var__temp_h836, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i773 T3366)
(declare-const var_h772 T3366)
(declare-const v Int)
(declare-const var_h_i131 T3366)
(declare-const var_h130 T3366)
(declare-const v Int)
(declare-const var_h_i59 T3366)
(declare-const var_h58 T3366)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h836 T3366)
(declare-const var__temp_v837 Int)
(declare-const |var__temp_h'838| T3366)
(declare-const var__temp_v_err839 T3367)
(declare-const var_h772 T3366)
(declare-const var_h130 T3366)
(declare-const var_h58 T3366)
(declare-const err T3380)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3366)
(declare-fun sel (T3366 Int) Int)
(declare-fun res () Int)
(declare-fun var_h130 () T3366)
(declare-fun var_h772 () T3366)
(declare-fun var_h58 () T3366)
(declare-fun |20| () Int)
(declare-fun var__temp_h836 () T3366)
(declare-fun |var__temp_h'838| () T3366)
(declare-fun v () Int)
(assert (= (sel var_h772 res) (+ (sel var_h130 res) 6)))
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h836 res) v) (= v |20|))
               (= (sel var__temp_h836 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'838| res) (+ (sel var__temp_h836 res) 2))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h836 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************215
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo'
PARTIAL PATH
SUB 	 --c3'	 --c4
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v840:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
baz
foo
bar
 *********************Enumeration Iteration*****************216
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v840:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h841 --->  Ty_heap  
 var__temp_v842 --->  Ty_int  
 var__temp_h'843 --->  Ty_heap  
 var__temp_v_err844 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h841, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h841, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h841, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'843, res ) ==((sel)( , var__temp_h841, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i131 T3383)
(declare-const var_h130 T3383)
(declare-const v Int)
(declare-const var_h_i59 T3383)
(declare-const var_h58 T3383)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h841 T3383)
(declare-const var__temp_v842 Int)
(declare-const |var__temp_h'843| T3383)
(declare-const var__temp_v_err844 T3384)
(declare-const var_h130 T3383)
(declare-const var_h58 T3383)
(declare-const err T3397)

solver 
 (declare-sort T3383)
(declare-fun sel (T3383 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3383)
(declare-fun var_h130 () T3383)
(declare-fun var__temp_h841 () T3383)
(declare-fun |var__temp_h'843| () T3383)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h841 res) (+ (sel var_h130 res) 6))
               (= (sel var__temp_h841 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'843| res) (+ (sel var__temp_h841 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h841 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************217
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v840:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h845 --->  Ty_heap  
 var__temp_v846 --->  Ty_int  
 var__temp_h'847 --->  Ty_heap  
 var__temp_v_err848 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h845, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h845, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h845, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'847, res ) ==((sel)( , var__temp_h845, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i131 T3400)
(declare-const var_h130 T3400)
(declare-const v Int)
(declare-const var_h_i59 T3400)
(declare-const var_h58 T3400)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h845 T3400)
(declare-const var__temp_v846 Int)
(declare-const |var__temp_h'847| T3400)
(declare-const var__temp_v_err848 T3401)
(declare-const var_h130 T3400)
(declare-const var_h58 T3400)
(declare-const err T3414)

solver 
 (declare-sort T3400)
(declare-fun sel (T3400 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3400)
(declare-fun var_h130 () T3400)
(declare-fun var__temp_h845 () T3400)
(declare-fun |var__temp_h'847| () T3400)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h845 res) (+ (sel var_h130 res) 6))
               (= (sel var__temp_h845 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'847| res) (+ (sel var__temp_h845 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h845 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************218
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v840:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h849 --->  Ty_heap  
 var__temp_v850 --->  Ty_int  
 var__temp_h'851 --->  Ty_heap  
 var__temp_v_err852 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h849, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h849, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h849, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'851, res ) ==((sel)( , var__temp_h849, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i131 T3417)
(declare-const var_h130 T3417)
(declare-const v Int)
(declare-const var_h_i59 T3417)
(declare-const var_h58 T3417)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h849 T3417)
(declare-const var__temp_v850 Int)
(declare-const |var__temp_h'851| T3417)
(declare-const var__temp_v_err852 T3418)
(declare-const var_h130 T3417)
(declare-const var_h58 T3417)
(declare-const err T3431)

solver 
 (declare-sort T3417)
(declare-fun sel (T3417 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3417)
(declare-fun var_h130 () T3417)
(declare-fun var__temp_h849 () T3417)
(declare-fun |var__temp_h'851| () T3417)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h849 res) (+ (sel var_h130 res) 6))
               (= (sel var__temp_h849 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'851| res) (+ (sel var__temp_h849 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h849 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************219
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v840:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h853 --->  Ty_heap  
 var__temp_v854 --->  Ty_int  
 var__temp_h'855 --->  Ty_heap  
 var__temp_v_err856 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h853, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h853, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h853, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'855, res ) ==((sel)( , var__temp_h853, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i131 T3434)
(declare-const var_h130 T3434)
(declare-const v Int)
(declare-const var_h_i59 T3434)
(declare-const var_h58 T3434)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h853 T3434)
(declare-const var__temp_v854 Int)
(declare-const |var__temp_h'855| T3434)
(declare-const var__temp_v_err856 T3435)
(declare-const var_h130 T3434)
(declare-const var_h58 T3434)
(declare-const err T3448)

solver 
 (declare-sort T3434)
(declare-fun sel (T3434 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3434)
(declare-fun var_h130 () T3434)
(declare-fun var__temp_h853 () T3434)
(declare-fun |var__temp_h'855| () T3434)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h853 res) (+ (sel var_h130 res) 6))
               (= (sel var__temp_h853 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'855| res) (+ (sel var__temp_h853 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h853 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************220
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v840:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h857 --->  Ty_heap  
 var__temp_v858 --->  Ty_int  
 var__temp_h'859 --->  Ty_heap  
 var__temp_v_err860 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h857, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h857, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h857, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'859, res ) ==((sel)( , var__temp_h857, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i131 T3451)
(declare-const var_h130 T3451)
(declare-const v Int)
(declare-const var_h_i59 T3451)
(declare-const var_h58 T3451)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h857 T3451)
(declare-const var__temp_v858 Int)
(declare-const |var__temp_h'859| T3451)
(declare-const var__temp_v_err860 T3452)
(declare-const var_h130 T3451)
(declare-const var_h58 T3451)
(declare-const err T3465)

solver 
 (declare-sort T3451)
(declare-fun sel (T3451 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3451)
(declare-fun var_h130 () T3451)
(declare-fun var__temp_h857 () T3451)
(declare-fun |var__temp_h'859| () T3451)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h857 res) (+ (sel var_h130 res) 6))
               (= (sel var__temp_h857 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'859| res) (+ (sel var__temp_h857 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h857 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************221
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v840:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h861 --->  Ty_heap  
 var__temp_v862 --->  Ty_int  
 var__temp_h'863 --->  Ty_heap  
 var__temp_v_err864 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h861, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h861, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h861, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'863, res ) ==((sel)( , var__temp_h861, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i131 T3468)
(declare-const var_h130 T3468)
(declare-const v Int)
(declare-const var_h_i59 T3468)
(declare-const var_h58 T3468)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h861 T3468)
(declare-const var__temp_v862 Int)
(declare-const |var__temp_h'863| T3468)
(declare-const var__temp_v_err864 T3469)
(declare-const var_h130 T3468)
(declare-const var_h58 T3468)
(declare-const err T3482)

solver 
 (declare-sort T3468)
(declare-fun sel (T3468 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3468)
(declare-fun var_h130 () T3468)
(declare-fun var__temp_h861 () T3468)
(declare-fun |var__temp_h'863| () T3468)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h861 res) (+ (sel var_h130 res) 6))
               (= (sel var__temp_h861 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'863| res) (+ (sel var__temp_h861 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h861 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************222
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (3) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v840:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h865 --->  Ty_heap  
 var__temp_v866 --->  Ty_int  
 var__temp_h'867 --->  Ty_heap  
 var__temp_v_err868 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h865, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h865, res ) > (3) AND 
 	 Rel (sel)( , var__temp_h865, res ) > (3) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'867, res ) ==(var__temp_v866) AND 
 	 Base var__temp_v866 = 5 => 
 	 True
 
VC_END(declare-const var_h_i131 T3485)
(declare-const var_h130 T3485)
(declare-const v Int)
(declare-const var_h_i59 T3485)
(declare-const var_h58 T3485)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h865 T3485)
(declare-const var__temp_v866 Int)
(declare-const |var__temp_h'867| T3485)
(declare-const var__temp_v_err868 T3486)
(declare-const var_h130 T3485)
(declare-const var_h58 T3485)
(declare-const err T3499)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3485)
(declare-fun sel (T3485 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3485)
(declare-fun var_h130 () T3485)
(declare-fun |5| () Int)
(declare-fun var__temp_v866 () Int)
(declare-fun |var__temp_h'867| () T3485)
(declare-fun var__temp_h865 () T3485)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h865 res) (+ (sel var_h130 res) 6))
               (not (> (sel var__temp_h865 res) 3))))
      (a!2 (=> (and (= (sel |var__temp_h'867| res) var__temp_v866)
                    (= var__temp_v866 |5|))
               true)))
(let ((a!3 (=> (not (> (sel var__temp_h865 res) 3)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************223
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i131 Value = Ty_heap{ (sel)( , var_h_i131, res ) ==((sel)( , var_h130, res ) + (6)) } 
 } 
 
                                                RET :  Base {var_v840:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i131 --->  Ty_heap  
 var_h130 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h869 --->  Ty_heap  
 var__temp_v870 --->  Ty_int  
 var__temp_h'871 --->  Ty_heap  
 var__temp_v_err872 --->  error  
 var_h130 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h130, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h869, res ) ==((sel)( , var_h130, res ) + (6)) => 
 	 Rel (sel)( , var__temp_h869, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h869, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'871, res ) ==((sel)( , var__temp_h869, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i131 T3502)
(declare-const var_h130 T3502)
(declare-const v Int)
(declare-const var_h_i59 T3502)
(declare-const var_h58 T3502)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h869 T3502)
(declare-const var__temp_v870 Int)
(declare-const |var__temp_h'871| T3502)
(declare-const var__temp_v_err872 T3503)
(declare-const var_h130 T3502)
(declare-const var_h58 T3502)
(declare-const err T3516)

solver 
 (declare-sort T3502)
(declare-fun sel (T3502 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3502)
(declare-fun var_h130 () T3502)
(declare-fun var__temp_h869 () T3502)
(declare-fun |var__temp_h'871| () T3502)
(assert (= (sel var_h130 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h869 res) (+ (sel var_h130 res) 6))
               (= (sel var__temp_h869 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'871| res) (+ (sel var__temp_h869 res) 2))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h869 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************224
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT foo'
PARTIAL PATH
SUB 	 --c3'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i59 Value = Ty_heap{ (sel)( , var_h_i59, res ) ==((sel)( , var_h58, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v873:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
c2'
test
c2
foo'
baz
foo
bar
 *********************Enumeration Iteration*****************225
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i59 Value = Ty_heap{ (sel)( , var_h_i59, res ) ==((sel)( , var_h58, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v873:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h874 --->  Ty_heap  
 var__temp_v875 --->  Ty_int  
 var__temp_h'876 --->  Ty_heap  
 var__temp_v_err877 --->  error  
 var_h58 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h874, res ) ==((sel)( , var_h58, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h874, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h874, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'876, res ) ==((sel)( , var__temp_h874, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i59 T3519)
(declare-const var_h58 T3519)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h874 T3519)
(declare-const var__temp_v875 Int)
(declare-const |var__temp_h'876| T3519)
(declare-const var__temp_v_err877 T3520)
(declare-const var_h58 T3519)
(declare-const err T3533)

solver 
 (declare-sort T3519)
(declare-fun sel (T3519 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3519)
(declare-fun var__temp_h874 () T3519)
(declare-fun |var__temp_h'876| () T3519)
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h874 res) (+ (sel var_h58 res) 3))
               (= (sel var__temp_h874 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'876| res) (+ (sel var__temp_h874 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h874 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************226
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i59 Value = Ty_heap{ (sel)( , var_h_i59, res ) ==((sel)( , var_h58, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v873:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h878 --->  Ty_heap  
 var__temp_v879 --->  Ty_int  
 var__temp_h'880 --->  Ty_heap  
 var__temp_v_err881 --->  error  
 var_h58 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h878, res ) ==((sel)( , var_h58, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h878, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h878, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'880, res ) ==((sel)( , var__temp_h878, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i59 T3536)
(declare-const var_h58 T3536)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h878 T3536)
(declare-const var__temp_v879 Int)
(declare-const |var__temp_h'880| T3536)
(declare-const var__temp_v_err881 T3537)
(declare-const var_h58 T3536)
(declare-const err T3550)

solver 
 (declare-sort T3536)
(declare-fun sel (T3536 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3536)
(declare-fun var__temp_h878 () T3536)
(declare-fun |var__temp_h'880| () T3536)
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h878 res) (+ (sel var_h58 res) 3))
               (= (sel var__temp_h878 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'880| res) (+ (sel var__temp_h878 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h878 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************227
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i59 Value = Ty_heap{ (sel)( , var_h_i59, res ) ==((sel)( , var_h58, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v873:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h882 --->  Ty_heap  
 var__temp_v883 --->  Ty_int  
 var__temp_h'884 --->  Ty_heap  
 var__temp_v_err885 --->  error  
 var_h58 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h882, res ) ==((sel)( , var_h58, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h882, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h882, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'884, res ) ==((sel)( , var__temp_h882, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i59 T3553)
(declare-const var_h58 T3553)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h882 T3553)
(declare-const var__temp_v883 Int)
(declare-const |var__temp_h'884| T3553)
(declare-const var__temp_v_err885 T3554)
(declare-const var_h58 T3553)
(declare-const err T3567)

solver 
 (declare-sort T3553)
(declare-fun sel (T3553 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3553)
(declare-fun var__temp_h882 () T3553)
(declare-fun |var__temp_h'884| () T3553)
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h882 res) (+ (sel var_h58 res) 3))
               (= (sel var__temp_h882 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'884| res) (+ (sel var__temp_h882 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h882 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************228
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i59 Value = Ty_heap{ (sel)( , var_h_i59, res ) ==((sel)( , var_h58, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v873:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h886 --->  Ty_heap  
 var__temp_v887 --->  Ty_int  
 var__temp_h'888 --->  Ty_heap  
 var__temp_v_err889 --->  error  
 var_h58 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h886, res ) ==((sel)( , var_h58, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h886, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h886, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'888, res ) ==((sel)( , var__temp_h886, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i59 T3570)
(declare-const var_h58 T3570)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h886 T3570)
(declare-const var__temp_v887 Int)
(declare-const |var__temp_h'888| T3570)
(declare-const var__temp_v_err889 T3571)
(declare-const var_h58 T3570)
(declare-const err T3584)

solver 
 (declare-sort T3570)
(declare-fun sel (T3570 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3570)
(declare-fun var__temp_h886 () T3570)
(declare-fun |var__temp_h'888| () T3570)
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h886 res) (+ (sel var_h58 res) 3))
               (= (sel var__temp_h886 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'888| res) (+ (sel var__temp_h886 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h886 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************229
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (20) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i59 Value = Ty_heap{ (sel)( , var_h_i59, res ) ==((sel)( , var_h58, res ) + (3)) } 
 } 
 
                                                RET :  Base {var_v873:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(sel)( , h, res ) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h890 --->  Ty_heap  
 var__temp_v891 --->  Ty_int  
 var__temp_h'892 --->  Ty_heap  
 var__temp_v_err893 --->  error  
 var_h58 --->  Ty_heap 
 	 ANTE Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h890, res ) ==((sel)( , var_h58, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h890, res ) > (20) AND 
 	 Rel (sel)( , var__temp_h890, res ) > (20) => 
 	 Rel (sel)( , var__temp_h'892, res ) ==(sel)( , var__temp_h890, res ) => 
 	 True
 
VC_END(declare-const var_h_i59 T3587)
(declare-const var_h58 T3587)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h890 T3587)
(declare-const var__temp_v891 Int)
(declare-const |var__temp_h'892| T3587)
(declare-const var__temp_v_err893 T3588)
(declare-const var_h58 T3587)
(declare-const err T3601)

solver 
 (declare-sort T3587)
(declare-fun sel (T3587 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3587)
(declare-fun var__temp_h890 () T3587)
(declare-fun |var__temp_h'892| () T3587)
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h890 res) (+ (sel var_h58 res) 3))
               (not (> (sel var__temp_h890 res) 20))))
      (a!2 (=> (not (> (sel var__temp_h890 res) 20))
               (=> (= (sel |var__temp_h'892| res) (sel var__temp_h890 res))
                   true))))
  (not (and a!1 a!2))))

***************Selection Successful************c2'
PARTIAL PATH NEW
NEW 	 --c3'	 --c2'
post_substituted Forall 
 	 
 Key =var_h_i895 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i895 Value = Ty_heap{ (sel)( , var_h_i895, res ) ==(sel)( , var_h894, res ) } 
 } 
 
                                                RET :  Base {var_v896:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i895 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
c2
foo'
baz
foo
bar
 *********************Enumeration Iteration*****************230
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i895 Value = Ty_heap{ (sel)( , var_h_i895, res ) ==(sel)( , var_h894, res ) } 
 } 
 
                                                RET :  Base {var_v896:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i895 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h897 --->  Ty_heap  
 var__temp_v898 --->  Ty_int  
 var__temp_h'899 --->  Ty_heap  
 var__temp_v_err900 --->  error  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h897, res ) ==(sel)( , var_h894, res ) => 
 	 Rel (sel)( , var__temp_h897, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h897, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'899, res ) ==((sel)( , var__temp_h897, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'899, res ) ==(10)
 
VC_END(declare-const var_h_i895 T3604)
(declare-const var_h894 T3604)
(declare-const v Int)
(declare-const var_h_i59 T3604)
(declare-const var_h58 T3604)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h897 T3604)
(declare-const var__temp_v898 Int)
(declare-const |var__temp_h'899| T3604)
(declare-const var__temp_v_err900 T3605)
(declare-const var_h894 T3604)
(declare-const var_h58 T3604)
(declare-const err T3618)

solver 
 (declare-sort T3604)
(declare-fun sel (T3604 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3604)
(declare-fun var_h894 () T3604)
(declare-fun |var__temp_h'899| () T3604)
(declare-fun var__temp_h897 () T3604)
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'899| res) (+ (sel var__temp_h897 res) 4))
               (= (sel |var__temp_h'899| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h897 res) (sel var_h894 res))
                    (= (sel var__temp_h897 res) 7))
                (=> (= (sel var__temp_h897 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************231
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i895 Value = Ty_heap{ (sel)( , var_h_i895, res ) ==(sel)( , var_h894, res ) } 
 } 
 
                                                RET :  Base {var_v896:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i895 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h901 --->  Ty_heap  
 var__temp_v902 --->  Ty_int  
 var__temp_h'903 --->  Ty_heap  
 var__temp_v_err904 --->  error  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h901, res ) ==(sel)( , var_h894, res ) => 
 	 Rel (sel)( , var__temp_h901, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h901, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'903, res ) ==((sel)( , var__temp_h901, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'903, res ) ==(10)
 
VC_END(declare-const var_h_i895 T3621)
(declare-const var_h894 T3621)
(declare-const v Int)
(declare-const var_h_i59 T3621)
(declare-const var_h58 T3621)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h901 T3621)
(declare-const var__temp_v902 Int)
(declare-const |var__temp_h'903| T3621)
(declare-const var__temp_v_err904 T3622)
(declare-const var_h894 T3621)
(declare-const var_h58 T3621)
(declare-const err T3635)

solver 
 (declare-sort T3621)
(declare-fun sel (T3621 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3621)
(declare-fun var_h894 () T3621)
(declare-fun |var__temp_h'903| () T3621)
(declare-fun var__temp_h901 () T3621)
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'903| res) (+ (sel var__temp_h901 res) 4))
               (= (sel |var__temp_h'903| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h901 res) (sel var_h894 res))
                    (= (sel var__temp_h901 res) 7))
                (=> (= (sel var__temp_h901 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************232
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i895 Value = Ty_heap{ (sel)( , var_h_i895, res ) ==(sel)( , var_h894, res ) } 
 } 
 
                                                RET :  Base {var_v896:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i895 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h905 --->  Ty_heap  
 var__temp_v906 --->  Ty_int  
 var__temp_h'907 --->  Ty_heap  
 var__temp_v_err908 --->  error  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h905, res ) ==(sel)( , var_h894, res ) => 
 	 Rel (sel)( , var__temp_h905, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h905, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'907, res ) ==((sel)( , var__temp_h905, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'907, res ) ==(10)
 
VC_END(declare-const var_h_i895 T3638)
(declare-const var_h894 T3638)
(declare-const v Int)
(declare-const var_h_i59 T3638)
(declare-const var_h58 T3638)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h905 T3638)
(declare-const var__temp_v906 Int)
(declare-const |var__temp_h'907| T3638)
(declare-const var__temp_v_err908 T3639)
(declare-const var_h894 T3638)
(declare-const var_h58 T3638)
(declare-const err T3652)

solver 
 (declare-sort T3638)
(declare-fun sel (T3638 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3638)
(declare-fun var_h894 () T3638)
(declare-fun |var__temp_h'907| () T3638)
(declare-fun var__temp_h905 () T3638)
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'907| res) (+ (sel var__temp_h905 res) 4))
               (= (sel |var__temp_h'907| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h905 res) (sel var_h894 res))
                    (= (sel var__temp_h905 res) 7))
                (=> (= (sel var__temp_h905 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************233
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i895 Value = Ty_heap{ (sel)( , var_h_i895, res ) ==(sel)( , var_h894, res ) } 
 } 
 
                                                RET :  Base {var_v896:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i895 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h909 --->  Ty_heap  
 var__temp_v910 --->  Ty_int  
 var__temp_h'911 --->  Ty_heap  
 var__temp_v_err912 --->  error  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h909, res ) ==(sel)( , var_h894, res ) => 
 	 Rel (sel)( , var__temp_h909, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h909, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'911, res ) ==((sel)( , var__temp_h909, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'911, res ) ==(10)
 
VC_END(declare-const var_h_i895 T3655)
(declare-const var_h894 T3655)
(declare-const v Int)
(declare-const var_h_i59 T3655)
(declare-const var_h58 T3655)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h909 T3655)
(declare-const var__temp_v910 Int)
(declare-const |var__temp_h'911| T3655)
(declare-const var__temp_v_err912 T3656)
(declare-const var_h894 T3655)
(declare-const var_h58 T3655)
(declare-const err T3669)

solver 
 (declare-sort T3655)
(declare-fun sel (T3655 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3655)
(declare-fun var_h894 () T3655)
(declare-fun |var__temp_h'911| () T3655)
(declare-fun var__temp_h909 () T3655)
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'911| res) (+ (sel var__temp_h909 res) 5))
               (= (sel |var__temp_h'911| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h909 res) (sel var_h894 res))
                    (= (sel var__temp_h909 res) 7))
                (=> (= (sel var__temp_h909 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************234
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i895 Value = Ty_heap{ (sel)( , var_h_i895, res ) ==(sel)( , var_h894, res ) } 
 } 
 
                                                RET :  Base {var_v896:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i895 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h913 --->  Ty_heap  
 var__temp_v914 --->  Ty_int  
 var__temp_h'915 --->  Ty_heap  
 var__temp_v_err916 --->  error  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h913, res ) ==(sel)( , var_h894, res ) => 
 	 Rel (sel)( , var__temp_h913, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h913, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'915, res ) ==((sel)( , var__temp_h913, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'915, res ) ==(10)
 
VC_END(declare-const var_h_i895 T3672)
(declare-const var_h894 T3672)
(declare-const v Int)
(declare-const var_h_i59 T3672)
(declare-const var_h58 T3672)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h913 T3672)
(declare-const var__temp_v914 Int)
(declare-const |var__temp_h'915| T3672)
(declare-const var__temp_v_err916 T3673)
(declare-const var_h894 T3672)
(declare-const var_h58 T3672)
(declare-const err T3686)

solver 
 (declare-sort T3672)
(declare-fun sel (T3672 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3672)
(declare-fun var_h894 () T3672)
(declare-fun |var__temp_h'915| () T3672)
(declare-fun var__temp_h913 () T3672)
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'915| res) (+ (sel var__temp_h913 res) 5))
               (= (sel |var__temp_h'915| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h913 res) (sel var_h894 res))
                    (= (sel var__temp_h913 res) 6))
                (=> (= (sel var__temp_h913 res) 6) a!1))))
  (not a!2))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************235
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i895 Value = Ty_heap{ (sel)( , var_h_i895, res ) ==(sel)( , var_h894, res ) } 
 } 
 
                                                RET :  Base {var_v896:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i895 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h917 --->  Ty_heap  
 var__temp_v918 --->  Ty_int  
 var__temp_h'919 --->  Ty_heap  
 var__temp_v_err920 --->  error  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h917, res ) ==(sel)( , var_h894, res ) => 
 	 Rel (sel)( , var__temp_h917, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h917, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'919, res ) ==((sel)( , var__temp_h917, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h'919, res ) ==(10)
 
VC_END(declare-const var_h_i895 T3689)
(declare-const var_h894 T3689)
(declare-const v Int)
(declare-const var_h_i59 T3689)
(declare-const var_h58 T3689)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h917 T3689)
(declare-const var__temp_v918 Int)
(declare-const |var__temp_h'919| T3689)
(declare-const var__temp_v_err920 T3690)
(declare-const var_h894 T3689)
(declare-const var_h58 T3689)
(declare-const err T3703)

solver 
 (declare-sort T3689)
(declare-fun sel (T3689 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3689)
(declare-fun var_h894 () T3689)
(declare-fun |var__temp_h'919| () T3689)
(declare-fun var__temp_h917 () T3689)
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'919| res) (+ (sel var__temp_h917 res) 10))
               (= (sel |var__temp_h'919| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h917 res) (sel var_h894 res))
                    (> (sel var__temp_h917 res) 4))
                (=> (> (sel var__temp_h917 res) 4) a!1))))
  (not a!2))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************236
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 20} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i895 Value = Ty_heap{ (sel)( , var_h_i895, res ) ==(sel)( , var_h894, res ) } 
 } 
 
                                                RET :  Base {var_v896:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i895 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h921 --->  Ty_heap  
 var__temp_v922 --->  Ty_int  
 var__temp_h'923 --->  Ty_heap  
 var__temp_v_err924 --->  error  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h921, res ) ==(sel)( , var_h894, res ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'923, res ) ==(var__temp_v922) AND 
 	 Base var__temp_v922 = 20 => 
 	 Rel (sel)( , var__temp_h'923, res ) ==(10)
 
VC_END(declare-const var_h_i895 T3706)
(declare-const var_h894 T3706)
(declare-const v Int)
(declare-const var_h_i59 T3706)
(declare-const var_h58 T3706)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h921 T3706)
(declare-const var__temp_v922 Int)
(declare-const |var__temp_h'923| T3706)
(declare-const var__temp_v_err924 T3707)
(declare-const var_h894 T3706)
(declare-const var_h58 T3706)
(declare-const err T3720)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3706)
(declare-fun sel (T3706 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3706)
(declare-fun var_h894 () T3706)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'923| () T3706)
(declare-fun var__temp_v922 () Int)
(declare-fun var__temp_h921 () T3706)
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel |var__temp_h'923| res) var__temp_v922)
                    (= var__temp_v922 |20|))
               (= (sel |var__temp_h'923| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h921 res) (sel var_h894 res)) true)
                (=> true a!1))))
  (not a!2))))

***************Selection Failed************foo'
 *********************Enumeration Iteration*****************237
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i895 Value = Ty_heap{ (sel)( , var_h_i895, res ) ==(sel)( , var_h894, res ) } 
 } 
 
                                                RET :  Base {var_v896:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i895 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h925 --->  Ty_heap  
 var__temp_v926 --->  Ty_int  
 var__temp_h'927 --->  Ty_heap  
 var__temp_v_err928 --->  error  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h925, res ) ==(sel)( , var_h894, res ) => 
 	 Rel (sel)( , var__temp_h925, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h925, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'927, res ) ==((sel)( , var__temp_h925, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'927, res ) ==(10)
 
VC_END(declare-const var_h_i895 T3723)
(declare-const var_h894 T3723)
(declare-const v Int)
(declare-const var_h_i59 T3723)
(declare-const var_h58 T3723)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h925 T3723)
(declare-const var__temp_v926 Int)
(declare-const |var__temp_h'927| T3723)
(declare-const var__temp_v_err928 T3724)
(declare-const var_h894 T3723)
(declare-const var_h58 T3723)
(declare-const err T3737)

solver 
 (declare-sort T3723)
(declare-fun sel (T3723 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3723)
(declare-fun var_h894 () T3723)
(declare-fun |var__temp_h'927| () T3723)
(declare-fun var__temp_h925 () T3723)
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'927| res) (+ (sel var__temp_h925 res) 3))
               (= (sel |var__temp_h'927| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h925 res) (sel var_h894 res))
                    (= (sel var__temp_h925 res) 7))
                (=> (= (sel var__temp_h925 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************238
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (3) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i895 Value = Ty_heap{ (sel)( , var_h_i895, res ) ==(sel)( , var_h894, res ) } 
 } 
 
                                                RET :  Base {var_v896:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i895 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h929 --->  Ty_heap  
 var__temp_v930 --->  Ty_int  
 var__temp_h'931 --->  Ty_heap  
 var__temp_v_err932 --->  error  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h929, res ) ==(sel)( , var_h894, res ) => 
 	 Rel (sel)( , var__temp_h929, res ) > (3) AND 
 	 Rel (sel)( , var__temp_h929, res ) > (3) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'931, res ) ==(var__temp_v930) AND 
 	 Base var__temp_v930 = 5 => 
 	 Rel (sel)( , var__temp_h'931, res ) ==(10)
 
VC_END(declare-const var_h_i895 T3740)
(declare-const var_h894 T3740)
(declare-const v Int)
(declare-const var_h_i59 T3740)
(declare-const var_h58 T3740)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h929 T3740)
(declare-const var__temp_v930 Int)
(declare-const |var__temp_h'931| T3740)
(declare-const var__temp_v_err932 T3741)
(declare-const var_h894 T3740)
(declare-const var_h58 T3740)
(declare-const err T3754)
    (declare-const |5| Int)
  
solver 
 (declare-sort T3740)
(declare-fun sel (T3740 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3740)
(declare-fun var_h894 () T3740)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'931| () T3740)
(declare-fun var__temp_v930 () Int)
(declare-fun var__temp_h929 () T3740)
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h929 res) (sel var_h894 res))
               (not (> (sel var__temp_h929 res) 3))))
      (a!2 (=> (and (= (sel |var__temp_h'931| res) var__temp_v930)
                    (= var__temp_v930 |5|))
               (= (sel |var__temp_h'931| res) 10))))
(let ((a!3 (=> (not (> (sel var__temp_h929 res) 3)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************239
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i895 Value = Ty_heap{ (sel)( , var_h_i895, res ) ==(sel)( , var_h894, res ) } 
 } 
 
                                                RET :  Base {var_v896:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i895 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h933 --->  Ty_heap  
 var__temp_v934 --->  Ty_int  
 var__temp_h'935 --->  Ty_heap  
 var__temp_v_err936 --->  error  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h933, res ) ==(sel)( , var_h894, res ) => 
 	 Rel (sel)( , var__temp_h933, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h933, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'935, res ) ==((sel)( , var__temp_h933, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'935, res ) ==(10)
 
VC_END(declare-const var_h_i895 T3757)
(declare-const var_h894 T3757)
(declare-const v Int)
(declare-const var_h_i59 T3757)
(declare-const var_h58 T3757)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h933 T3757)
(declare-const var__temp_v934 Int)
(declare-const |var__temp_h'935| T3757)
(declare-const var__temp_v_err936 T3758)
(declare-const var_h894 T3757)
(declare-const var_h58 T3757)
(declare-const err T3771)

solver 
 (declare-sort T3757)
(declare-fun sel (T3757 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3757)
(declare-fun var_h894 () T3757)
(declare-fun |var__temp_h'935| () T3757)
(declare-fun var__temp_h933 () T3757)
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'935| res) (+ (sel var__temp_h933 res) 2))
               (= (sel |var__temp_h'935| res) 10))))
(let ((a!2 (and (=> (= (sel var__temp_h933 res) (sel var_h894 res))
                    (= (sel var__temp_h933 res) 5))
                (=> (= (sel var__temp_h933 res) 5) a!1))))
  (not a!2))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************240
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v896:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v896:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i895 Value = Ty_heap{ (sel)( , var_h_i895, res ) ==(sel)( , var_h894, res ) } 
 } 
 
                                                RET :  Base {var_v937:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
c2
foo'
baz
foo
bar
 *********************Enumeration Iteration*****************241
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i895 Value = Ty_heap{ (sel)( , var_h_i895, res ) ==(sel)( , var_h894, res ) } 
 } 
 
                                                RET :  Base {var_v937:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h938 --->  Ty_heap  
 var__temp_v939 --->  Ty_int  
 var__temp_h'940 --->  Ty_heap  
 var__temp_v_err941 --->  error  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h938, res ) ==(sel)( , var_h894, res ) => 
 	 Rel (sel)( , var__temp_h938, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h938, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'940, res ) ==((sel)( , var__temp_h938, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i895 T3774)
(declare-const var_h894 T3774)
(declare-const v Int)
(declare-const var_h_i59 T3774)
(declare-const var_h58 T3774)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h938 T3774)
(declare-const var__temp_v939 Int)
(declare-const |var__temp_h'940| T3774)
(declare-const var__temp_v_err941 T3775)
(declare-const var_h894 T3774)
(declare-const var_h58 T3774)
(declare-const err T3788)

solver 
 (declare-sort T3774)
(declare-fun sel (T3774 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3774)
(declare-fun var_h894 () T3774)
(declare-fun var__temp_h938 () T3774)
(declare-fun |var__temp_h'940| () T3774)
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'940| res) (+ (sel var__temp_h938 res) 4))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h938 res) (sel var_h894 res))
                    (= (sel var__temp_h938 res) 7))
                (=> (= (sel var__temp_h938 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************242
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i895 Value = Ty_heap{ (sel)( , var_h_i895, res ) ==(sel)( , var_h894, res ) } 
 } 
 
                                                RET :  Base {var_v937:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h942 --->  Ty_heap  
 var__temp_v943 --->  Ty_int  
 var__temp_h'944 --->  Ty_heap  
 var__temp_v_err945 --->  error  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h942, res ) ==(sel)( , var_h894, res ) => 
 	 Rel (sel)( , var__temp_h942, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h942, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'944, res ) ==((sel)( , var__temp_h942, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i895 T3791)
(declare-const var_h894 T3791)
(declare-const v Int)
(declare-const var_h_i59 T3791)
(declare-const var_h58 T3791)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h942 T3791)
(declare-const var__temp_v943 Int)
(declare-const |var__temp_h'944| T3791)
(declare-const var__temp_v_err945 T3792)
(declare-const var_h894 T3791)
(declare-const var_h58 T3791)
(declare-const err T3805)

solver 
 (declare-sort T3791)
(declare-fun sel (T3791 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3791)
(declare-fun var_h894 () T3791)
(declare-fun var__temp_h942 () T3791)
(declare-fun |var__temp_h'944| () T3791)
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'944| res) (+ (sel var__temp_h942 res) 4))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h942 res) (sel var_h894 res))
                    (= (sel var__temp_h942 res) 7))
                (=> (= (sel var__temp_h942 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************243
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i895 Value = Ty_heap{ (sel)( , var_h_i895, res ) ==(sel)( , var_h894, res ) } 
 } 
 
                                                RET :  Base {var_v937:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h946 --->  Ty_heap  
 var__temp_v947 --->  Ty_int  
 var__temp_h'948 --->  Ty_heap  
 var__temp_v_err949 --->  error  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h946, res ) ==(sel)( , var_h894, res ) => 
 	 Rel (sel)( , var__temp_h946, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h946, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'948, res ) ==((sel)( , var__temp_h946, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i895 T3808)
(declare-const var_h894 T3808)
(declare-const v Int)
(declare-const var_h_i59 T3808)
(declare-const var_h58 T3808)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h946 T3808)
(declare-const var__temp_v947 Int)
(declare-const |var__temp_h'948| T3808)
(declare-const var__temp_v_err949 T3809)
(declare-const var_h894 T3808)
(declare-const var_h58 T3808)
(declare-const err T3822)

solver 
 (declare-sort T3808)
(declare-fun sel (T3808 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3808)
(declare-fun var_h894 () T3808)
(declare-fun var__temp_h946 () T3808)
(declare-fun |var__temp_h'948| () T3808)
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'948| res) (+ (sel var__temp_h946 res) 4))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h946 res) (sel var_h894 res))
                    (= (sel var__temp_h946 res) 7))
                (=> (= (sel var__temp_h946 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************244
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i895 Value = Ty_heap{ (sel)( , var_h_i895, res ) ==(sel)( , var_h894, res ) } 
 } 
 
                                                RET :  Base {var_v937:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h950 --->  Ty_heap  
 var__temp_v951 --->  Ty_int  
 var__temp_h'952 --->  Ty_heap  
 var__temp_v_err953 --->  error  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h950, res ) ==(sel)( , var_h894, res ) => 
 	 Rel (sel)( , var__temp_h950, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h950, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'952, res ) ==((sel)( , var__temp_h950, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i895 T3825)
(declare-const var_h894 T3825)
(declare-const v Int)
(declare-const var_h_i59 T3825)
(declare-const var_h58 T3825)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h950 T3825)
(declare-const var__temp_v951 Int)
(declare-const |var__temp_h'952| T3825)
(declare-const var__temp_v_err953 T3826)
(declare-const var_h894 T3825)
(declare-const var_h58 T3825)
(declare-const err T3839)

solver 
 (declare-sort T3825)
(declare-fun sel (T3825 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3825)
(declare-fun var_h894 () T3825)
(declare-fun var__temp_h950 () T3825)
(declare-fun |var__temp_h'952| () T3825)
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'952| res) (+ (sel var__temp_h950 res) 5))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h950 res) (sel var_h894 res))
                    (= (sel var__temp_h950 res) 7))
                (=> (= (sel var__temp_h950 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************245
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i895 Value = Ty_heap{ (sel)( , var_h_i895, res ) ==(sel)( , var_h894, res ) } 
 } 
 
                                                RET :  Base {var_v937:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h954 --->  Ty_heap  
 var__temp_v955 --->  Ty_int  
 var__temp_h'956 --->  Ty_heap  
 var__temp_v_err957 --->  error  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h954, res ) ==(sel)( , var_h894, res ) => 
 	 Rel (sel)( , var__temp_h954, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h954, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'956, res ) ==((sel)( , var__temp_h954, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i895 T3842)
(declare-const var_h894 T3842)
(declare-const v Int)
(declare-const var_h_i59 T3842)
(declare-const var_h58 T3842)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h954 T3842)
(declare-const var__temp_v955 Int)
(declare-const |var__temp_h'956| T3842)
(declare-const var__temp_v_err957 T3843)
(declare-const var_h894 T3842)
(declare-const var_h58 T3842)
(declare-const err T3856)

solver 
 (declare-sort T3842)
(declare-fun sel (T3842 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3842)
(declare-fun var_h894 () T3842)
(declare-fun var__temp_h954 () T3842)
(declare-fun |var__temp_h'956| () T3842)
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'956| res) (+ (sel var__temp_h954 res) 5))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h954 res) (sel var_h894 res))
                    (= (sel var__temp_h954 res) 6))
                (=> (= (sel var__temp_h954 res) 6) a!1))))
  (not a!2))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************246
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i895 Value = Ty_heap{ (sel)( , var_h_i895, res ) ==(sel)( , var_h894, res ) } 
 } 
 
                                                RET :  Base {var_v937:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h958 --->  Ty_heap  
 var__temp_v959 --->  Ty_int  
 var__temp_h'960 --->  Ty_heap  
 var__temp_v_err961 --->  error  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h958, res ) ==(sel)( , var_h894, res ) => 
 	 Rel (sel)( , var__temp_h958, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h958, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'960, res ) ==((sel)( , var__temp_h958, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i895 T3859)
(declare-const var_h894 T3859)
(declare-const v Int)
(declare-const var_h_i59 T3859)
(declare-const var_h58 T3859)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h958 T3859)
(declare-const var__temp_v959 Int)
(declare-const |var__temp_h'960| T3859)
(declare-const var__temp_v_err961 T3860)
(declare-const var_h894 T3859)
(declare-const var_h58 T3859)
(declare-const err T3873)

solver 
 (declare-sort T3859)
(declare-fun sel (T3859 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3859)
(declare-fun var_h894 () T3859)
(declare-fun var__temp_h958 () T3859)
(declare-fun |var__temp_h'960| () T3859)
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'960| res) (+ (sel var__temp_h958 res) 10))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h958 res) (sel var_h894 res))
                    (> (sel var__temp_h958 res) 4))
                (=> (> (sel var__temp_h958 res) 4) a!1))))
  (not a!2))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************247
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ true } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 20} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i895 Value = Ty_heap{ (sel)( , var_h_i895, res ) ==(sel)( , var_h894, res ) } 
 } 
 
                                                RET :  Base {var_v937:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 20 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h962 --->  Ty_heap  
 var__temp_v963 --->  Ty_int  
 var__temp_h'964 --->  Ty_heap  
 var__temp_v_err965 --->  error  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h962, res ) ==(sel)( , var_h894, res ) => 
 	 True AND 
 	 True => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'964, res ) ==(var__temp_v963) AND 
 	 Base var__temp_v963 = 20 => 
 	 True
 
VC_END(declare-const var_h_i895 T3876)
(declare-const var_h894 T3876)
(declare-const v Int)
(declare-const var_h_i59 T3876)
(declare-const var_h58 T3876)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h962 T3876)
(declare-const var__temp_v963 Int)
(declare-const |var__temp_h'964| T3876)
(declare-const var__temp_v_err965 T3877)
(declare-const var_h894 T3876)
(declare-const var_h58 T3876)
(declare-const err T3890)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3876)
(declare-fun sel (T3876 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T3876)
(declare-fun var_h894 () T3876)
(declare-fun |20| () Int)
(declare-fun var__temp_v963 () Int)
(declare-fun |var__temp_h'964| () T3876)
(declare-fun var__temp_h962 () T3876)
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel |var__temp_h'964| res) var__temp_v963)
                    (= var__temp_v963 |20|))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h962 res) (sel var_h894 res)) true)
                (=> true a!1))))
  (not a!2))))

***************Selection Successful************foo'
PARTIAL PATH NEW
NEW 	 --c3'	 --c2'	 --foo'
post_substituted Forall 
 	 
 Key =var_h_i967 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i967 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i967, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v968:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i967 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
c2
baz
foo
bar
 *********************Enumeration Iteration*****************248
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i967 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i967, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v968:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i967 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h969 --->  Ty_heap  
 var__temp_v970 --->  Ty_int  
 var__temp_h'971 --->  Ty_heap  
 var__temp_v_err972 --->  error  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h969, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h969, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h969, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'971, res ) ==((sel)( , var__temp_h969, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'971, res ) ==(10)
 
VC_END(declare-const var_h_i967 T3893)
(declare-const var_h966 T3893)
(declare-const v Int)
(declare-const var_h_i895 T3893)
(declare-const var_h894 T3893)
(declare-const v Int)
(declare-const var_h_i59 T3893)
(declare-const var_h58 T3893)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h969 T3893)
(declare-const var__temp_v970 Int)
(declare-const |var__temp_h'971| T3893)
(declare-const var__temp_v_err972 T3894)
(declare-const var_h966 T3893)
(declare-const var_h894 T3893)
(declare-const var_h58 T3893)
(declare-const err T3907)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3893)
(declare-fun sel (T3893 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T3893)
(declare-fun var_h966 () T3893)
(declare-fun var_h58 () T3893)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'971| () T3893)
(declare-fun var__temp_h969 () T3893)
(declare-fun v () Int)
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h969 res) v) (= v |20|))
               (= (sel var__temp_h969 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'971| res) (+ (sel var__temp_h969 res) 4))
               (= (sel |var__temp_h'971| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h969 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************249
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i967 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i967, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v968:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i967 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h973 --->  Ty_heap  
 var__temp_v974 --->  Ty_int  
 var__temp_h'975 --->  Ty_heap  
 var__temp_v_err976 --->  error  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h973, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h973, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h973, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'975, res ) ==((sel)( , var__temp_h973, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'975, res ) ==(10)
 
VC_END(declare-const var_h_i967 T3910)
(declare-const var_h966 T3910)
(declare-const v Int)
(declare-const var_h_i895 T3910)
(declare-const var_h894 T3910)
(declare-const v Int)
(declare-const var_h_i59 T3910)
(declare-const var_h58 T3910)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h973 T3910)
(declare-const var__temp_v974 Int)
(declare-const |var__temp_h'975| T3910)
(declare-const var__temp_v_err976 T3911)
(declare-const var_h966 T3910)
(declare-const var_h894 T3910)
(declare-const var_h58 T3910)
(declare-const err T3924)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3910)
(declare-fun sel (T3910 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T3910)
(declare-fun var_h966 () T3910)
(declare-fun var_h58 () T3910)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'975| () T3910)
(declare-fun var__temp_h973 () T3910)
(declare-fun v () Int)
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h973 res) v) (= v |20|))
               (= (sel var__temp_h973 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'975| res) (+ (sel var__temp_h973 res) 4))
               (= (sel |var__temp_h'975| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h973 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************250
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i967 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i967, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v968:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i967 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h977 --->  Ty_heap  
 var__temp_v978 --->  Ty_int  
 var__temp_h'979 --->  Ty_heap  
 var__temp_v_err980 --->  error  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h977, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h977, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h977, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'979, res ) ==((sel)( , var__temp_h977, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'979, res ) ==(10)
 
VC_END(declare-const var_h_i967 T3927)
(declare-const var_h966 T3927)
(declare-const v Int)
(declare-const var_h_i895 T3927)
(declare-const var_h894 T3927)
(declare-const v Int)
(declare-const var_h_i59 T3927)
(declare-const var_h58 T3927)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h977 T3927)
(declare-const var__temp_v978 Int)
(declare-const |var__temp_h'979| T3927)
(declare-const var__temp_v_err980 T3928)
(declare-const var_h966 T3927)
(declare-const var_h894 T3927)
(declare-const var_h58 T3927)
(declare-const err T3941)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3927)
(declare-fun sel (T3927 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T3927)
(declare-fun var_h966 () T3927)
(declare-fun var_h58 () T3927)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'979| () T3927)
(declare-fun var__temp_h977 () T3927)
(declare-fun v () Int)
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h977 res) v) (= v |20|))
               (= (sel var__temp_h977 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'979| res) (+ (sel var__temp_h977 res) 4))
               (= (sel |var__temp_h'979| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h977 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************251
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i967 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i967, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v968:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i967 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h981 --->  Ty_heap  
 var__temp_v982 --->  Ty_int  
 var__temp_h'983 --->  Ty_heap  
 var__temp_v_err984 --->  error  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h981, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h981, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h981, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'983, res ) ==((sel)( , var__temp_h981, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'983, res ) ==(10)
 
VC_END(declare-const var_h_i967 T3944)
(declare-const var_h966 T3944)
(declare-const v Int)
(declare-const var_h_i895 T3944)
(declare-const var_h894 T3944)
(declare-const v Int)
(declare-const var_h_i59 T3944)
(declare-const var_h58 T3944)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h981 T3944)
(declare-const var__temp_v982 Int)
(declare-const |var__temp_h'983| T3944)
(declare-const var__temp_v_err984 T3945)
(declare-const var_h966 T3944)
(declare-const var_h894 T3944)
(declare-const var_h58 T3944)
(declare-const err T3958)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3944)
(declare-fun sel (T3944 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T3944)
(declare-fun var_h966 () T3944)
(declare-fun var_h58 () T3944)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'983| () T3944)
(declare-fun var__temp_h981 () T3944)
(declare-fun v () Int)
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h981 res) v) (= v |20|))
               (= (sel var__temp_h981 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'983| res) (+ (sel var__temp_h981 res) 5))
               (= (sel |var__temp_h'983| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h981 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************252
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i967 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i967, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v968:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i967 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h985 --->  Ty_heap  
 var__temp_v986 --->  Ty_int  
 var__temp_h'987 --->  Ty_heap  
 var__temp_v_err988 --->  error  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h985, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h985, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h985, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'987, res ) ==((sel)( , var__temp_h985, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'987, res ) ==(10)
 
VC_END(declare-const var_h_i967 T3961)
(declare-const var_h966 T3961)
(declare-const v Int)
(declare-const var_h_i895 T3961)
(declare-const var_h894 T3961)
(declare-const v Int)
(declare-const var_h_i59 T3961)
(declare-const var_h58 T3961)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h985 T3961)
(declare-const var__temp_v986 Int)
(declare-const |var__temp_h'987| T3961)
(declare-const var__temp_v_err988 T3962)
(declare-const var_h966 T3961)
(declare-const var_h894 T3961)
(declare-const var_h58 T3961)
(declare-const err T3975)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3961)
(declare-fun sel (T3961 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T3961)
(declare-fun var_h966 () T3961)
(declare-fun var_h58 () T3961)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'987| () T3961)
(declare-fun var__temp_h985 () T3961)
(declare-fun v () Int)
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h985 res) v) (= v |20|))
               (= (sel var__temp_h985 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'987| res) (+ (sel var__temp_h985 res) 5))
               (= (sel |var__temp_h'987| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h985 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************253
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i967 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i967, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v968:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i967 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h989 --->  Ty_heap  
 var__temp_v990 --->  Ty_int  
 var__temp_h'991 --->  Ty_heap  
 var__temp_v_err992 --->  error  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h989, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h989, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h989, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'991, res ) ==((sel)( , var__temp_h989, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h'991, res ) ==(10)
 
VC_END(declare-const var_h_i967 T3978)
(declare-const var_h966 T3978)
(declare-const v Int)
(declare-const var_h_i895 T3978)
(declare-const var_h894 T3978)
(declare-const v Int)
(declare-const var_h_i59 T3978)
(declare-const var_h58 T3978)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h989 T3978)
(declare-const var__temp_v990 Int)
(declare-const |var__temp_h'991| T3978)
(declare-const var__temp_v_err992 T3979)
(declare-const var_h966 T3978)
(declare-const var_h894 T3978)
(declare-const var_h58 T3978)
(declare-const err T3992)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3978)
(declare-fun sel (T3978 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T3978)
(declare-fun var_h966 () T3978)
(declare-fun var_h58 () T3978)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'991| () T3978)
(declare-fun var__temp_h989 () T3978)
(declare-fun v () Int)
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h989 res) v) (= v |20|))
               (> (sel var__temp_h989 res) 4)))
      (a!2 (=> (= (sel |var__temp_h'991| res) (+ (sel var__temp_h989 res) 10))
               (= (sel |var__temp_h'991| res) 10))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h989 res) 4) a!2))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************254
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i967 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i967, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v968:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i967 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h993 --->  Ty_heap  
 var__temp_v994 --->  Ty_int  
 var__temp_h'995 --->  Ty_heap  
 var__temp_v_err996 --->  error  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h993, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h993, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h993, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'995, res ) ==((sel)( , var__temp_h993, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'995, res ) ==(10)
 
VC_END(declare-const var_h_i967 T3995)
(declare-const var_h966 T3995)
(declare-const v Int)
(declare-const var_h_i895 T3995)
(declare-const var_h894 T3995)
(declare-const v Int)
(declare-const var_h_i59 T3995)
(declare-const var_h58 T3995)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h993 T3995)
(declare-const var__temp_v994 Int)
(declare-const |var__temp_h'995| T3995)
(declare-const var__temp_v_err996 T3996)
(declare-const var_h966 T3995)
(declare-const var_h894 T3995)
(declare-const var_h58 T3995)
(declare-const err T4009)
    (declare-const |20| Int)
  
solver 
 (declare-sort T3995)
(declare-fun sel (T3995 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T3995)
(declare-fun var_h966 () T3995)
(declare-fun var_h58 () T3995)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'995| () T3995)
(declare-fun var__temp_h993 () T3995)
(declare-fun v () Int)
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h993 res) v) (= v |20|))
               (= (sel var__temp_h993 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'995| res) (+ (sel var__temp_h993 res) 3))
               (= (sel |var__temp_h'995| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h993 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************255
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (3) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i967 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i967, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v968:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i967 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h997 --->  Ty_heap  
 var__temp_v998 --->  Ty_int  
 var__temp_h'999 --->  Ty_heap  
 var__temp_v_err1000 --->  error  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h997, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h997, res ) > (3) AND 
 	 Rel (sel)( , var__temp_h997, res ) > (3) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'999, res ) ==(var__temp_v998) AND 
 	 Base var__temp_v998 = 5 => 
 	 Rel (sel)( , var__temp_h'999, res ) ==(10)
 
VC_END(declare-const var_h_i967 T4012)
(declare-const var_h966 T4012)
(declare-const v Int)
(declare-const var_h_i895 T4012)
(declare-const var_h894 T4012)
(declare-const v Int)
(declare-const var_h_i59 T4012)
(declare-const var_h58 T4012)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h997 T4012)
(declare-const var__temp_v998 Int)
(declare-const |var__temp_h'999| T4012)
(declare-const var__temp_v_err1000 T4013)
(declare-const var_h966 T4012)
(declare-const var_h894 T4012)
(declare-const var_h58 T4012)
(declare-const err T4026)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T4012)
(declare-fun sel (T4012 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4012)
(declare-fun var_h966 () T4012)
(declare-fun var_h58 () T4012)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'999| () T4012)
(declare-fun var__temp_v998 () Int)
(declare-fun var__temp_h997 () T4012)
(declare-fun v () Int)
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h997 res) v) (= v |20|))
               (not (> (sel var__temp_h997 res) 3))))
      (a!2 (=> (and (= (sel |var__temp_h'999| res) var__temp_v998)
                    (= var__temp_v998 |5|))
               (= (sel |var__temp_h'999| res) 10))))
(let ((a!3 (=> (not (> (sel var__temp_h997 res) 3)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************256
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i967 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i967, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v968:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i967 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1001 --->  Ty_heap  
 var__temp_v1002 --->  Ty_int  
 var__temp_h'1003 --->  Ty_heap  
 var__temp_v_err1004 --->  error  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1001, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h1001, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1001, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'1003, res ) ==((sel)( , var__temp_h1001, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'1003, res ) ==(10)
 
VC_END(declare-const var_h_i967 T4029)
(declare-const var_h966 T4029)
(declare-const v Int)
(declare-const var_h_i895 T4029)
(declare-const var_h894 T4029)
(declare-const v Int)
(declare-const var_h_i59 T4029)
(declare-const var_h58 T4029)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1001 T4029)
(declare-const var__temp_v1002 Int)
(declare-const |var__temp_h'1003| T4029)
(declare-const var__temp_v_err1004 T4030)
(declare-const var_h966 T4029)
(declare-const var_h894 T4029)
(declare-const var_h58 T4029)
(declare-const err T4043)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4029)
(declare-fun sel (T4029 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4029)
(declare-fun var_h966 () T4029)
(declare-fun var_h58 () T4029)
(declare-fun |20| () Int)
(declare-fun |var__temp_h'1003| () T4029)
(declare-fun var__temp_h1001 () T4029)
(declare-fun v () Int)
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1001 res) v) (= v |20|))
               (= (sel var__temp_h1001 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'1003| res) (+ (sel var__temp_h1001 res) 2))
               (= (sel |var__temp_h'1003| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1001 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************257
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v968:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v968:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --c2'	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i967 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i967, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1005:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
c2
baz
foo
bar
 *********************Enumeration Iteration*****************258
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i967 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i967, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1005:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1006 --->  Ty_heap  
 var__temp_v1007 --->  Ty_int  
 var__temp_h'1008 --->  Ty_heap  
 var__temp_v_err1009 --->  error  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1006, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h1006, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1006, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1008, res ) ==((sel)( , var__temp_h1006, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i967 T4046)
(declare-const var_h966 T4046)
(declare-const v Int)
(declare-const var_h_i895 T4046)
(declare-const var_h894 T4046)
(declare-const v Int)
(declare-const var_h_i59 T4046)
(declare-const var_h58 T4046)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1006 T4046)
(declare-const var__temp_v1007 Int)
(declare-const |var__temp_h'1008| T4046)
(declare-const var__temp_v_err1009 T4047)
(declare-const var_h966 T4046)
(declare-const var_h894 T4046)
(declare-const var_h58 T4046)
(declare-const err T4060)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4046)
(declare-fun sel (T4046 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4046)
(declare-fun var_h966 () T4046)
(declare-fun var_h58 () T4046)
(declare-fun |20| () Int)
(declare-fun var__temp_h1006 () T4046)
(declare-fun |var__temp_h'1008| () T4046)
(declare-fun v () Int)
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1006 res) v) (= v |20|))
               (= (sel var__temp_h1006 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1008| res) (+ (sel var__temp_h1006 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1006 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************259
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i967 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i967, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1005:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1010 --->  Ty_heap  
 var__temp_v1011 --->  Ty_int  
 var__temp_h'1012 --->  Ty_heap  
 var__temp_v_err1013 --->  error  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1010, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h1010, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1010, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1012, res ) ==((sel)( , var__temp_h1010, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i967 T4063)
(declare-const var_h966 T4063)
(declare-const v Int)
(declare-const var_h_i895 T4063)
(declare-const var_h894 T4063)
(declare-const v Int)
(declare-const var_h_i59 T4063)
(declare-const var_h58 T4063)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1010 T4063)
(declare-const var__temp_v1011 Int)
(declare-const |var__temp_h'1012| T4063)
(declare-const var__temp_v_err1013 T4064)
(declare-const var_h966 T4063)
(declare-const var_h894 T4063)
(declare-const var_h58 T4063)
(declare-const err T4077)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4063)
(declare-fun sel (T4063 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4063)
(declare-fun var_h966 () T4063)
(declare-fun var_h58 () T4063)
(declare-fun |20| () Int)
(declare-fun var__temp_h1010 () T4063)
(declare-fun |var__temp_h'1012| () T4063)
(declare-fun v () Int)
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1010 res) v) (= v |20|))
               (= (sel var__temp_h1010 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1012| res) (+ (sel var__temp_h1010 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1010 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************260
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i967 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i967, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1005:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1014 --->  Ty_heap  
 var__temp_v1015 --->  Ty_int  
 var__temp_h'1016 --->  Ty_heap  
 var__temp_v_err1017 --->  error  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1014, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h1014, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1014, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1016, res ) ==((sel)( , var__temp_h1014, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i967 T4080)
(declare-const var_h966 T4080)
(declare-const v Int)
(declare-const var_h_i895 T4080)
(declare-const var_h894 T4080)
(declare-const v Int)
(declare-const var_h_i59 T4080)
(declare-const var_h58 T4080)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1014 T4080)
(declare-const var__temp_v1015 Int)
(declare-const |var__temp_h'1016| T4080)
(declare-const var__temp_v_err1017 T4081)
(declare-const var_h966 T4080)
(declare-const var_h894 T4080)
(declare-const var_h58 T4080)
(declare-const err T4094)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4080)
(declare-fun sel (T4080 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4080)
(declare-fun var_h966 () T4080)
(declare-fun var_h58 () T4080)
(declare-fun |20| () Int)
(declare-fun var__temp_h1014 () T4080)
(declare-fun |var__temp_h'1016| () T4080)
(declare-fun v () Int)
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1014 res) v) (= v |20|))
               (= (sel var__temp_h1014 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1016| res) (+ (sel var__temp_h1014 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1014 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************261
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i967 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i967, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1005:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1018 --->  Ty_heap  
 var__temp_v1019 --->  Ty_int  
 var__temp_h'1020 --->  Ty_heap  
 var__temp_v_err1021 --->  error  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1018, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h1018, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1018, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1020, res ) ==((sel)( , var__temp_h1018, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i967 T4097)
(declare-const var_h966 T4097)
(declare-const v Int)
(declare-const var_h_i895 T4097)
(declare-const var_h894 T4097)
(declare-const v Int)
(declare-const var_h_i59 T4097)
(declare-const var_h58 T4097)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1018 T4097)
(declare-const var__temp_v1019 Int)
(declare-const |var__temp_h'1020| T4097)
(declare-const var__temp_v_err1021 T4098)
(declare-const var_h966 T4097)
(declare-const var_h894 T4097)
(declare-const var_h58 T4097)
(declare-const err T4111)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4097)
(declare-fun sel (T4097 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4097)
(declare-fun var_h966 () T4097)
(declare-fun var_h58 () T4097)
(declare-fun |20| () Int)
(declare-fun var__temp_h1018 () T4097)
(declare-fun |var__temp_h'1020| () T4097)
(declare-fun v () Int)
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1018 res) v) (= v |20|))
               (= (sel var__temp_h1018 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1020| res) (+ (sel var__temp_h1018 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1018 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************262
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i967 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i967, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1005:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1022 --->  Ty_heap  
 var__temp_v1023 --->  Ty_int  
 var__temp_h'1024 --->  Ty_heap  
 var__temp_v_err1025 --->  error  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1022, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h1022, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h1022, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'1024, res ) ==((sel)( , var__temp_h1022, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i967 T4114)
(declare-const var_h966 T4114)
(declare-const v Int)
(declare-const var_h_i895 T4114)
(declare-const var_h894 T4114)
(declare-const v Int)
(declare-const var_h_i59 T4114)
(declare-const var_h58 T4114)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1022 T4114)
(declare-const var__temp_v1023 Int)
(declare-const |var__temp_h'1024| T4114)
(declare-const var__temp_v_err1025 T4115)
(declare-const var_h966 T4114)
(declare-const var_h894 T4114)
(declare-const var_h58 T4114)
(declare-const err T4128)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4114)
(declare-fun sel (T4114 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4114)
(declare-fun var_h966 () T4114)
(declare-fun var_h58 () T4114)
(declare-fun |20| () Int)
(declare-fun var__temp_h1022 () T4114)
(declare-fun |var__temp_h'1024| () T4114)
(declare-fun v () Int)
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1022 res) v) (= v |20|))
               (= (sel var__temp_h1022 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'1024| res) (+ (sel var__temp_h1022 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1022 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************263
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i967 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i967, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1005:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1026 --->  Ty_heap  
 var__temp_v1027 --->  Ty_int  
 var__temp_h'1028 --->  Ty_heap  
 var__temp_v_err1029 --->  error  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1026, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h1026, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1026, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'1028, res ) ==((sel)( , var__temp_h1026, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i967 T4131)
(declare-const var_h966 T4131)
(declare-const v Int)
(declare-const var_h_i895 T4131)
(declare-const var_h894 T4131)
(declare-const v Int)
(declare-const var_h_i59 T4131)
(declare-const var_h58 T4131)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1026 T4131)
(declare-const var__temp_v1027 Int)
(declare-const |var__temp_h'1028| T4131)
(declare-const var__temp_v_err1029 T4132)
(declare-const var_h966 T4131)
(declare-const var_h894 T4131)
(declare-const var_h58 T4131)
(declare-const err T4145)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4131)
(declare-fun sel (T4131 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4131)
(declare-fun var_h966 () T4131)
(declare-fun var_h58 () T4131)
(declare-fun |20| () Int)
(declare-fun var__temp_h1026 () T4131)
(declare-fun |var__temp_h'1028| () T4131)
(declare-fun v () Int)
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1026 res) v) (= v |20|))
               (> (sel var__temp_h1026 res) 4)))
      (a!2 (=> (= (sel |var__temp_h'1028| res) (+ (sel var__temp_h1026 res) 10))
               true)))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h1026 res) 4) a!2))))
  (not a!3))))

***************Selection Successful************c2
PARTIAL PATH NEW
NEW 	 --c3'	 --c2'	 --foo'	 --c2
post_substituted Forall 
 	 
 Key =var_h_i1031 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1031 Value = Ty_heap{ (sel)( , var_h_i1031, res ) ==((sel)( , var_h1030, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1032:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1031 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
baz
foo
bar
 *********************Enumeration Iteration*****************264
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1031 Value = Ty_heap{ (sel)( , var_h_i1031, res ) ==((sel)( , var_h1030, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1032:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1031 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1031 --->  Ty_heap  
 var_h1030 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1033 --->  Ty_heap  
 var__temp_v1034 --->  Ty_int  
 var__temp_h'1035 --->  Ty_heap  
 var__temp_v_err1036 --->  error  
 var_h1030 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1030, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1033, res ) ==((sel)( , var_h1030, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1033, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1033, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1035, res ) ==((sel)( , var__temp_h1033, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'1035, res ) ==(10)
 
VC_END(declare-const var_h_i1031 T4148)
(declare-const var_h1030 T4148)
(declare-const v Int)
(declare-const var_h_i967 T4148)
(declare-const var_h966 T4148)
(declare-const v Int)
(declare-const var_h_i895 T4148)
(declare-const var_h894 T4148)
(declare-const v Int)
(declare-const var_h_i59 T4148)
(declare-const var_h58 T4148)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1033 T4148)
(declare-const var__temp_v1034 Int)
(declare-const |var__temp_h'1035| T4148)
(declare-const var__temp_v_err1036 T4149)
(declare-const var_h1030 T4148)
(declare-const var_h966 T4148)
(declare-const var_h894 T4148)
(declare-const var_h58 T4148)
(declare-const err T4162)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4148)
(declare-fun v () Int)
(declare-fun sel (T4148 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1030 () T4148)
(declare-fun |20| () Int)
(declare-fun var_h894 () T4148)
(declare-fun var_h966 () T4148)
(declare-fun var_h58 () T4148)
(declare-fun |var__temp_h'1035| () T4148)
(declare-fun var__temp_h1033 () T4148)
(assert (= (sel var_h1030 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1033 res) (+ (sel var_h1030 res) 10))
               (= (sel var__temp_h1033 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1035| res) (+ (sel var__temp_h1033 res) 4))
               (= (sel |var__temp_h'1035| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1033 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************265
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1031 Value = Ty_heap{ (sel)( , var_h_i1031, res ) ==((sel)( , var_h1030, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1032:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1031 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1031 --->  Ty_heap  
 var_h1030 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1037 --->  Ty_heap  
 var__temp_v1038 --->  Ty_int  
 var__temp_h'1039 --->  Ty_heap  
 var__temp_v_err1040 --->  error  
 var_h1030 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1030, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1037, res ) ==((sel)( , var_h1030, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1037, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1037, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1039, res ) ==((sel)( , var__temp_h1037, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'1039, res ) ==(10)
 
VC_END(declare-const var_h_i1031 T4165)
(declare-const var_h1030 T4165)
(declare-const v Int)
(declare-const var_h_i967 T4165)
(declare-const var_h966 T4165)
(declare-const v Int)
(declare-const var_h_i895 T4165)
(declare-const var_h894 T4165)
(declare-const v Int)
(declare-const var_h_i59 T4165)
(declare-const var_h58 T4165)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1037 T4165)
(declare-const var__temp_v1038 Int)
(declare-const |var__temp_h'1039| T4165)
(declare-const var__temp_v_err1040 T4166)
(declare-const var_h1030 T4165)
(declare-const var_h966 T4165)
(declare-const var_h894 T4165)
(declare-const var_h58 T4165)
(declare-const err T4179)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4165)
(declare-fun v () Int)
(declare-fun sel (T4165 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1030 () T4165)
(declare-fun |20| () Int)
(declare-fun var_h894 () T4165)
(declare-fun var_h966 () T4165)
(declare-fun var_h58 () T4165)
(declare-fun |var__temp_h'1039| () T4165)
(declare-fun var__temp_h1037 () T4165)
(assert (= (sel var_h1030 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1037 res) (+ (sel var_h1030 res) 10))
               (= (sel var__temp_h1037 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1039| res) (+ (sel var__temp_h1037 res) 4))
               (= (sel |var__temp_h'1039| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1037 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************266
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1031 Value = Ty_heap{ (sel)( , var_h_i1031, res ) ==((sel)( , var_h1030, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1032:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1031 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1031 --->  Ty_heap  
 var_h1030 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1041 --->  Ty_heap  
 var__temp_v1042 --->  Ty_int  
 var__temp_h'1043 --->  Ty_heap  
 var__temp_v_err1044 --->  error  
 var_h1030 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1030, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1041, res ) ==((sel)( , var_h1030, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1041, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1041, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1043, res ) ==((sel)( , var__temp_h1041, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'1043, res ) ==(10)
 
VC_END(declare-const var_h_i1031 T4182)
(declare-const var_h1030 T4182)
(declare-const v Int)
(declare-const var_h_i967 T4182)
(declare-const var_h966 T4182)
(declare-const v Int)
(declare-const var_h_i895 T4182)
(declare-const var_h894 T4182)
(declare-const v Int)
(declare-const var_h_i59 T4182)
(declare-const var_h58 T4182)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1041 T4182)
(declare-const var__temp_v1042 Int)
(declare-const |var__temp_h'1043| T4182)
(declare-const var__temp_v_err1044 T4183)
(declare-const var_h1030 T4182)
(declare-const var_h966 T4182)
(declare-const var_h894 T4182)
(declare-const var_h58 T4182)
(declare-const err T4196)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4182)
(declare-fun v () Int)
(declare-fun sel (T4182 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1030 () T4182)
(declare-fun |20| () Int)
(declare-fun var_h894 () T4182)
(declare-fun var_h966 () T4182)
(declare-fun var_h58 () T4182)
(declare-fun |var__temp_h'1043| () T4182)
(declare-fun var__temp_h1041 () T4182)
(assert (= (sel var_h1030 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1041 res) (+ (sel var_h1030 res) 10))
               (= (sel var__temp_h1041 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1043| res) (+ (sel var__temp_h1041 res) 4))
               (= (sel |var__temp_h'1043| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1041 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************267
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1031 Value = Ty_heap{ (sel)( , var_h_i1031, res ) ==((sel)( , var_h1030, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1032:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1031 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1031 --->  Ty_heap  
 var_h1030 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1045 --->  Ty_heap  
 var__temp_v1046 --->  Ty_int  
 var__temp_h'1047 --->  Ty_heap  
 var__temp_v_err1048 --->  error  
 var_h1030 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1030, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1045, res ) ==((sel)( , var_h1030, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1045, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1045, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1047, res ) ==((sel)( , var__temp_h1045, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'1047, res ) ==(10)
 
VC_END(declare-const var_h_i1031 T4199)
(declare-const var_h1030 T4199)
(declare-const v Int)
(declare-const var_h_i967 T4199)
(declare-const var_h966 T4199)
(declare-const v Int)
(declare-const var_h_i895 T4199)
(declare-const var_h894 T4199)
(declare-const v Int)
(declare-const var_h_i59 T4199)
(declare-const var_h58 T4199)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1045 T4199)
(declare-const var__temp_v1046 Int)
(declare-const |var__temp_h'1047| T4199)
(declare-const var__temp_v_err1048 T4200)
(declare-const var_h1030 T4199)
(declare-const var_h966 T4199)
(declare-const var_h894 T4199)
(declare-const var_h58 T4199)
(declare-const err T4213)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4199)
(declare-fun v () Int)
(declare-fun sel (T4199 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1030 () T4199)
(declare-fun |20| () Int)
(declare-fun var_h894 () T4199)
(declare-fun var_h966 () T4199)
(declare-fun var_h58 () T4199)
(declare-fun |var__temp_h'1047| () T4199)
(declare-fun var__temp_h1045 () T4199)
(assert (= (sel var_h1030 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1045 res) (+ (sel var_h1030 res) 10))
               (= (sel var__temp_h1045 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1047| res) (+ (sel var__temp_h1045 res) 5))
               (= (sel |var__temp_h'1047| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1045 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************268
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1031 Value = Ty_heap{ (sel)( , var_h_i1031, res ) ==((sel)( , var_h1030, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1032:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1031 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1031 --->  Ty_heap  
 var_h1030 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1049 --->  Ty_heap  
 var__temp_v1050 --->  Ty_int  
 var__temp_h'1051 --->  Ty_heap  
 var__temp_v_err1052 --->  error  
 var_h1030 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1030, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1049, res ) ==((sel)( , var_h1030, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1049, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h1049, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'1051, res ) ==((sel)( , var__temp_h1049, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'1051, res ) ==(10)
 
VC_END(declare-const var_h_i1031 T4216)
(declare-const var_h1030 T4216)
(declare-const v Int)
(declare-const var_h_i967 T4216)
(declare-const var_h966 T4216)
(declare-const v Int)
(declare-const var_h_i895 T4216)
(declare-const var_h894 T4216)
(declare-const v Int)
(declare-const var_h_i59 T4216)
(declare-const var_h58 T4216)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1049 T4216)
(declare-const var__temp_v1050 Int)
(declare-const |var__temp_h'1051| T4216)
(declare-const var__temp_v_err1052 T4217)
(declare-const var_h1030 T4216)
(declare-const var_h966 T4216)
(declare-const var_h894 T4216)
(declare-const var_h58 T4216)
(declare-const err T4230)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4216)
(declare-fun v () Int)
(declare-fun sel (T4216 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1030 () T4216)
(declare-fun |20| () Int)
(declare-fun var_h894 () T4216)
(declare-fun var_h966 () T4216)
(declare-fun var_h58 () T4216)
(declare-fun |var__temp_h'1051| () T4216)
(declare-fun var__temp_h1049 () T4216)
(assert (= (sel var_h1030 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1049 res) (+ (sel var_h1030 res) 10))
               (= (sel var__temp_h1049 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'1051| res) (+ (sel var__temp_h1049 res) 5))
               (= (sel |var__temp_h'1051| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1049 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************269
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1031 Value = Ty_heap{ (sel)( , var_h_i1031, res ) ==((sel)( , var_h1030, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1032:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1031 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1031 --->  Ty_heap  
 var_h1030 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1053 --->  Ty_heap  
 var__temp_v1054 --->  Ty_int  
 var__temp_h'1055 --->  Ty_heap  
 var__temp_v_err1056 --->  error  
 var_h1030 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1030, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1053, res ) ==((sel)( , var_h1030, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1053, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1053, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1055, res ) ==((sel)( , var__temp_h1053, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'1055, res ) ==(10)
 
VC_END(declare-const var_h_i1031 T4233)
(declare-const var_h1030 T4233)
(declare-const v Int)
(declare-const var_h_i967 T4233)
(declare-const var_h966 T4233)
(declare-const v Int)
(declare-const var_h_i895 T4233)
(declare-const var_h894 T4233)
(declare-const v Int)
(declare-const var_h_i59 T4233)
(declare-const var_h58 T4233)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1053 T4233)
(declare-const var__temp_v1054 Int)
(declare-const |var__temp_h'1055| T4233)
(declare-const var__temp_v_err1056 T4234)
(declare-const var_h1030 T4233)
(declare-const var_h966 T4233)
(declare-const var_h894 T4233)
(declare-const var_h58 T4233)
(declare-const err T4247)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4233)
(declare-fun v () Int)
(declare-fun sel (T4233 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1030 () T4233)
(declare-fun |20| () Int)
(declare-fun var_h894 () T4233)
(declare-fun var_h966 () T4233)
(declare-fun var_h58 () T4233)
(declare-fun |var__temp_h'1055| () T4233)
(declare-fun var__temp_h1053 () T4233)
(assert (= (sel var_h1030 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1053 res) (+ (sel var_h1030 res) 10))
               (= (sel var__temp_h1053 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1055| res) (+ (sel var__temp_h1053 res) 3))
               (= (sel |var__temp_h'1055| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1053 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************270
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (3) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1031 Value = Ty_heap{ (sel)( , var_h_i1031, res ) ==((sel)( , var_h1030, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1032:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1031 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1031 --->  Ty_heap  
 var_h1030 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1057 --->  Ty_heap  
 var__temp_v1058 --->  Ty_int  
 var__temp_h'1059 --->  Ty_heap  
 var__temp_v_err1060 --->  error  
 var_h1030 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1030, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1057, res ) ==((sel)( , var_h1030, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1057, res ) > (3) AND 
 	 Rel (sel)( , var__temp_h1057, res ) > (3) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1059, res ) ==(var__temp_v1058) AND 
 	 Base var__temp_v1058 = 5 => 
 	 Rel (sel)( , var__temp_h'1059, res ) ==(10)
 
VC_END(declare-const var_h_i1031 T4250)
(declare-const var_h1030 T4250)
(declare-const v Int)
(declare-const var_h_i967 T4250)
(declare-const var_h966 T4250)
(declare-const v Int)
(declare-const var_h_i895 T4250)
(declare-const var_h894 T4250)
(declare-const v Int)
(declare-const var_h_i59 T4250)
(declare-const var_h58 T4250)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1057 T4250)
(declare-const var__temp_v1058 Int)
(declare-const |var__temp_h'1059| T4250)
(declare-const var__temp_v_err1060 T4251)
(declare-const var_h1030 T4250)
(declare-const var_h966 T4250)
(declare-const var_h894 T4250)
(declare-const var_h58 T4250)
(declare-const err T4264)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T4250)
(declare-fun v () Int)
(declare-fun sel (T4250 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1030 () T4250)
(declare-fun |20| () Int)
(declare-fun var_h894 () T4250)
(declare-fun var_h966 () T4250)
(declare-fun var_h58 () T4250)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1059| () T4250)
(declare-fun var__temp_v1058 () Int)
(declare-fun var__temp_h1057 () T4250)
(assert (= (sel var_h1030 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h1057 res) (+ (sel var_h1030 res) 10))
               (not (> (sel var__temp_h1057 res) 3))))
      (a!2 (=> (and (= (sel |var__temp_h'1059| res) var__temp_v1058)
                    (= var__temp_v1058 |5|))
               (= (sel |var__temp_h'1059| res) 10))))
(let ((a!3 (=> (not (> (sel var__temp_h1057 res) 3)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************271
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1031 Value = Ty_heap{ (sel)( , var_h_i1031, res ) ==((sel)( , var_h1030, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1032:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1031 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1031 --->  Ty_heap  
 var_h1030 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1061 --->  Ty_heap  
 var__temp_v1062 --->  Ty_int  
 var__temp_h'1063 --->  Ty_heap  
 var__temp_v_err1064 --->  error  
 var_h1030 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1030, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1061, res ) ==((sel)( , var_h1030, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1061, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1061, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'1063, res ) ==((sel)( , var__temp_h1061, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'1063, res ) ==(10)
 
VC_END(declare-const var_h_i1031 T4267)
(declare-const var_h1030 T4267)
(declare-const v Int)
(declare-const var_h_i967 T4267)
(declare-const var_h966 T4267)
(declare-const v Int)
(declare-const var_h_i895 T4267)
(declare-const var_h894 T4267)
(declare-const v Int)
(declare-const var_h_i59 T4267)
(declare-const var_h58 T4267)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1061 T4267)
(declare-const var__temp_v1062 Int)
(declare-const |var__temp_h'1063| T4267)
(declare-const var__temp_v_err1064 T4268)
(declare-const var_h1030 T4267)
(declare-const var_h966 T4267)
(declare-const var_h894 T4267)
(declare-const var_h58 T4267)
(declare-const err T4281)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4267)
(declare-fun v () Int)
(declare-fun sel (T4267 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1030 () T4267)
(declare-fun |20| () Int)
(declare-fun var_h894 () T4267)
(declare-fun var_h966 () T4267)
(declare-fun var_h58 () T4267)
(declare-fun |var__temp_h'1063| () T4267)
(declare-fun var__temp_h1061 () T4267)
(assert (= (sel var_h1030 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1061 res) (+ (sel var_h1030 res) 10))
               (= (sel var__temp_h1061 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'1063| res) (+ (sel var__temp_h1061 res) 2))
               (= (sel |var__temp_h'1063| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1061 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************272
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1032:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1032:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2foo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --c2'	 --foo'	 --c2
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1031 Value = Ty_heap{ (sel)( , var_h_i1031, res ) ==((sel)( , var_h1030, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1065:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
baz
foo
bar
 *********************Enumeration Iteration*****************273
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1031 Value = Ty_heap{ (sel)( , var_h_i1031, res ) ==((sel)( , var_h1030, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1065:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1031 --->  Ty_heap  
 var_h1030 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1066 --->  Ty_heap  
 var__temp_v1067 --->  Ty_int  
 var__temp_h'1068 --->  Ty_heap  
 var__temp_v_err1069 --->  error  
 var_h1030 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1030, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1066, res ) ==((sel)( , var_h1030, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1066, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1066, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1068, res ) ==((sel)( , var__temp_h1066, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i1031 T4284)
(declare-const var_h1030 T4284)
(declare-const v Int)
(declare-const var_h_i967 T4284)
(declare-const var_h966 T4284)
(declare-const v Int)
(declare-const var_h_i895 T4284)
(declare-const var_h894 T4284)
(declare-const v Int)
(declare-const var_h_i59 T4284)
(declare-const var_h58 T4284)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1066 T4284)
(declare-const var__temp_v1067 Int)
(declare-const |var__temp_h'1068| T4284)
(declare-const var__temp_v_err1069 T4285)
(declare-const var_h1030 T4284)
(declare-const var_h966 T4284)
(declare-const var_h894 T4284)
(declare-const var_h58 T4284)
(declare-const err T4298)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4284)
(declare-fun v () Int)
(declare-fun sel (T4284 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1030 () T4284)
(declare-fun |20| () Int)
(declare-fun var_h894 () T4284)
(declare-fun var_h966 () T4284)
(declare-fun var_h58 () T4284)
(declare-fun var__temp_h1066 () T4284)
(declare-fun |var__temp_h'1068| () T4284)
(assert (= (sel var_h1030 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1066 res) (+ (sel var_h1030 res) 10))
               (= (sel var__temp_h1066 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1068| res) (+ (sel var__temp_h1066 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1066 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************274
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1031 Value = Ty_heap{ (sel)( , var_h_i1031, res ) ==((sel)( , var_h1030, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1065:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1031 --->  Ty_heap  
 var_h1030 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1070 --->  Ty_heap  
 var__temp_v1071 --->  Ty_int  
 var__temp_h'1072 --->  Ty_heap  
 var__temp_v_err1073 --->  error  
 var_h1030 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1030, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1070, res ) ==((sel)( , var_h1030, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1070, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1070, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1072, res ) ==((sel)( , var__temp_h1070, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i1031 T4301)
(declare-const var_h1030 T4301)
(declare-const v Int)
(declare-const var_h_i967 T4301)
(declare-const var_h966 T4301)
(declare-const v Int)
(declare-const var_h_i895 T4301)
(declare-const var_h894 T4301)
(declare-const v Int)
(declare-const var_h_i59 T4301)
(declare-const var_h58 T4301)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1070 T4301)
(declare-const var__temp_v1071 Int)
(declare-const |var__temp_h'1072| T4301)
(declare-const var__temp_v_err1073 T4302)
(declare-const var_h1030 T4301)
(declare-const var_h966 T4301)
(declare-const var_h894 T4301)
(declare-const var_h58 T4301)
(declare-const err T4315)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4301)
(declare-fun v () Int)
(declare-fun sel (T4301 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1030 () T4301)
(declare-fun |20| () Int)
(declare-fun var_h894 () T4301)
(declare-fun var_h966 () T4301)
(declare-fun var_h58 () T4301)
(declare-fun var__temp_h1070 () T4301)
(declare-fun |var__temp_h'1072| () T4301)
(assert (= (sel var_h1030 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1070 res) (+ (sel var_h1030 res) 10))
               (= (sel var__temp_h1070 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1072| res) (+ (sel var__temp_h1070 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1070 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************275
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1031 Value = Ty_heap{ (sel)( , var_h_i1031, res ) ==((sel)( , var_h1030, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1065:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1031 --->  Ty_heap  
 var_h1030 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1074 --->  Ty_heap  
 var__temp_v1075 --->  Ty_int  
 var__temp_h'1076 --->  Ty_heap  
 var__temp_v_err1077 --->  error  
 var_h1030 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1030, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1074, res ) ==((sel)( , var_h1030, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1074, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1074, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1076, res ) ==((sel)( , var__temp_h1074, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i1031 T4318)
(declare-const var_h1030 T4318)
(declare-const v Int)
(declare-const var_h_i967 T4318)
(declare-const var_h966 T4318)
(declare-const v Int)
(declare-const var_h_i895 T4318)
(declare-const var_h894 T4318)
(declare-const v Int)
(declare-const var_h_i59 T4318)
(declare-const var_h58 T4318)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1074 T4318)
(declare-const var__temp_v1075 Int)
(declare-const |var__temp_h'1076| T4318)
(declare-const var__temp_v_err1077 T4319)
(declare-const var_h1030 T4318)
(declare-const var_h966 T4318)
(declare-const var_h894 T4318)
(declare-const var_h58 T4318)
(declare-const err T4332)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4318)
(declare-fun v () Int)
(declare-fun sel (T4318 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1030 () T4318)
(declare-fun |20| () Int)
(declare-fun var_h894 () T4318)
(declare-fun var_h966 () T4318)
(declare-fun var_h58 () T4318)
(declare-fun var__temp_h1074 () T4318)
(declare-fun |var__temp_h'1076| () T4318)
(assert (= (sel var_h1030 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1074 res) (+ (sel var_h1030 res) 10))
               (= (sel var__temp_h1074 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1076| res) (+ (sel var__temp_h1074 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1074 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************276
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1031 Value = Ty_heap{ (sel)( , var_h_i1031, res ) ==((sel)( , var_h1030, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1065:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1031 --->  Ty_heap  
 var_h1030 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1078 --->  Ty_heap  
 var__temp_v1079 --->  Ty_int  
 var__temp_h'1080 --->  Ty_heap  
 var__temp_v_err1081 --->  error  
 var_h1030 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1030, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1078, res ) ==((sel)( , var_h1030, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1078, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1078, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1080, res ) ==((sel)( , var__temp_h1078, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i1031 T4335)
(declare-const var_h1030 T4335)
(declare-const v Int)
(declare-const var_h_i967 T4335)
(declare-const var_h966 T4335)
(declare-const v Int)
(declare-const var_h_i895 T4335)
(declare-const var_h894 T4335)
(declare-const v Int)
(declare-const var_h_i59 T4335)
(declare-const var_h58 T4335)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1078 T4335)
(declare-const var__temp_v1079 Int)
(declare-const |var__temp_h'1080| T4335)
(declare-const var__temp_v_err1081 T4336)
(declare-const var_h1030 T4335)
(declare-const var_h966 T4335)
(declare-const var_h894 T4335)
(declare-const var_h58 T4335)
(declare-const err T4349)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4335)
(declare-fun v () Int)
(declare-fun sel (T4335 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1030 () T4335)
(declare-fun |20| () Int)
(declare-fun var_h894 () T4335)
(declare-fun var_h966 () T4335)
(declare-fun var_h58 () T4335)
(declare-fun var__temp_h1078 () T4335)
(declare-fun |var__temp_h'1080| () T4335)
(assert (= (sel var_h1030 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1078 res) (+ (sel var_h1030 res) 10))
               (= (sel var__temp_h1078 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1080| res) (+ (sel var__temp_h1078 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1078 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************277
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1031 Value = Ty_heap{ (sel)( , var_h_i1031, res ) ==((sel)( , var_h1030, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1065:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1031 --->  Ty_heap  
 var_h1030 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1082 --->  Ty_heap  
 var__temp_v1083 --->  Ty_int  
 var__temp_h'1084 --->  Ty_heap  
 var__temp_v_err1085 --->  error  
 var_h1030 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1030, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1082, res ) ==((sel)( , var_h1030, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1082, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h1082, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'1084, res ) ==((sel)( , var__temp_h1082, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i1031 T4352)
(declare-const var_h1030 T4352)
(declare-const v Int)
(declare-const var_h_i967 T4352)
(declare-const var_h966 T4352)
(declare-const v Int)
(declare-const var_h_i895 T4352)
(declare-const var_h894 T4352)
(declare-const v Int)
(declare-const var_h_i59 T4352)
(declare-const var_h58 T4352)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1082 T4352)
(declare-const var__temp_v1083 Int)
(declare-const |var__temp_h'1084| T4352)
(declare-const var__temp_v_err1085 T4353)
(declare-const var_h1030 T4352)
(declare-const var_h966 T4352)
(declare-const var_h894 T4352)
(declare-const var_h58 T4352)
(declare-const err T4366)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4352)
(declare-fun v () Int)
(declare-fun sel (T4352 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1030 () T4352)
(declare-fun |20| () Int)
(declare-fun var_h894 () T4352)
(declare-fun var_h966 () T4352)
(declare-fun var_h58 () T4352)
(declare-fun var__temp_h1082 () T4352)
(declare-fun |var__temp_h'1084| () T4352)
(assert (= (sel var_h1030 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1082 res) (+ (sel var_h1030 res) 10))
               (= (sel var__temp_h1082 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'1084| res) (+ (sel var__temp_h1082 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1082 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************278
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1031 Value = Ty_heap{ (sel)( , var_h_i1031, res ) ==((sel)( , var_h1030, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1065:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1031 --->  Ty_heap  
 var_h1030 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1086 --->  Ty_heap  
 var__temp_v1087 --->  Ty_int  
 var__temp_h'1088 --->  Ty_heap  
 var__temp_v_err1089 --->  error  
 var_h1030 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1030, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1086, res ) ==((sel)( , var_h1030, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1086, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1086, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1088, res ) ==((sel)( , var__temp_h1086, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i1031 T4369)
(declare-const var_h1030 T4369)
(declare-const v Int)
(declare-const var_h_i967 T4369)
(declare-const var_h966 T4369)
(declare-const v Int)
(declare-const var_h_i895 T4369)
(declare-const var_h894 T4369)
(declare-const v Int)
(declare-const var_h_i59 T4369)
(declare-const var_h58 T4369)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1086 T4369)
(declare-const var__temp_v1087 Int)
(declare-const |var__temp_h'1088| T4369)
(declare-const var__temp_v_err1089 T4370)
(declare-const var_h1030 T4369)
(declare-const var_h966 T4369)
(declare-const var_h894 T4369)
(declare-const var_h58 T4369)
(declare-const err T4383)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4369)
(declare-fun v () Int)
(declare-fun sel (T4369 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1030 () T4369)
(declare-fun |20| () Int)
(declare-fun var_h894 () T4369)
(declare-fun var_h966 () T4369)
(declare-fun var_h58 () T4369)
(declare-fun var__temp_h1086 () T4369)
(declare-fun |var__temp_h'1088| () T4369)
(assert (= (sel var_h1030 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1086 res) (+ (sel var_h1030 res) 10))
               (= (sel var__temp_h1086 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1088| res) (+ (sel var__temp_h1086 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1086 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************279
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (3) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1031 Value = Ty_heap{ (sel)( , var_h_i1031, res ) ==((sel)( , var_h1030, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1065:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1031 --->  Ty_heap  
 var_h1030 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1090 --->  Ty_heap  
 var__temp_v1091 --->  Ty_int  
 var__temp_h'1092 --->  Ty_heap  
 var__temp_v_err1093 --->  error  
 var_h1030 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1030, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1090, res ) ==((sel)( , var_h1030, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1090, res ) > (3) AND 
 	 Rel (sel)( , var__temp_h1090, res ) > (3) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1092, res ) ==(var__temp_v1091) AND 
 	 Base var__temp_v1091 = 5 => 
 	 True
 
VC_END(declare-const var_h_i1031 T4386)
(declare-const var_h1030 T4386)
(declare-const v Int)
(declare-const var_h_i967 T4386)
(declare-const var_h966 T4386)
(declare-const v Int)
(declare-const var_h_i895 T4386)
(declare-const var_h894 T4386)
(declare-const v Int)
(declare-const var_h_i59 T4386)
(declare-const var_h58 T4386)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1090 T4386)
(declare-const var__temp_v1091 Int)
(declare-const |var__temp_h'1092| T4386)
(declare-const var__temp_v_err1093 T4387)
(declare-const var_h1030 T4386)
(declare-const var_h966 T4386)
(declare-const var_h894 T4386)
(declare-const var_h58 T4386)
(declare-const err T4400)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T4386)
(declare-fun v () Int)
(declare-fun sel (T4386 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1030 () T4386)
(declare-fun |20| () Int)
(declare-fun var_h894 () T4386)
(declare-fun var_h966 () T4386)
(declare-fun var_h58 () T4386)
(declare-fun |5| () Int)
(declare-fun var__temp_v1091 () Int)
(declare-fun |var__temp_h'1092| () T4386)
(declare-fun var__temp_h1090 () T4386)
(assert (= (sel var_h1030 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h1090 res) (+ (sel var_h1030 res) 10))
               (not (> (sel var__temp_h1090 res) 3))))
      (a!2 (=> (and (= (sel |var__temp_h'1092| res) var__temp_v1091)
                    (= var__temp_v1091 |5|))
               true)))
(let ((a!3 (=> (not (> (sel var__temp_h1090 res) 3)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************280
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1031 Value = Ty_heap{ (sel)( , var_h_i1031, res ) ==((sel)( , var_h1030, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1065:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1031 --->  Ty_heap  
 var_h1030 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1094 --->  Ty_heap  
 var__temp_v1095 --->  Ty_int  
 var__temp_h'1096 --->  Ty_heap  
 var__temp_v_err1097 --->  error  
 var_h1030 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1030, res ) ==(v) AND 
 	 Base v = 20 AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1094, res ) ==((sel)( , var_h1030, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1094, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1094, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'1096, res ) ==((sel)( , var__temp_h1094, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i1031 T4403)
(declare-const var_h1030 T4403)
(declare-const v Int)
(declare-const var_h_i967 T4403)
(declare-const var_h966 T4403)
(declare-const v Int)
(declare-const var_h_i895 T4403)
(declare-const var_h894 T4403)
(declare-const v Int)
(declare-const var_h_i59 T4403)
(declare-const var_h58 T4403)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1094 T4403)
(declare-const var__temp_v1095 Int)
(declare-const |var__temp_h'1096| T4403)
(declare-const var__temp_v_err1097 T4404)
(declare-const var_h1030 T4403)
(declare-const var_h966 T4403)
(declare-const var_h894 T4403)
(declare-const var_h58 T4403)
(declare-const err T4417)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4403)
(declare-fun v () Int)
(declare-fun sel (T4403 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1030 () T4403)
(declare-fun |20| () Int)
(declare-fun var_h894 () T4403)
(declare-fun var_h966 () T4403)
(declare-fun var_h58 () T4403)
(declare-fun var__temp_h1094 () T4403)
(declare-fun |var__temp_h'1096| () T4403)
(assert (= (sel var_h1030 res) v))
(assert (= |20| 20))
(assert (= v |20|))
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1094 res) (+ (sel var_h1030 res) 10))
               (= (sel var__temp_h1094 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'1096| res) (+ (sel var__temp_h1094 res) 2))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1094 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************281
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 	 --c3'	 --c2'	 --foo'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i967 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i967, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1098:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
baz
foo
bar
 *********************Enumeration Iteration*****************282
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i967 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i967, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1098:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1099 --->  Ty_heap  
 var__temp_v1100 --->  Ty_int  
 var__temp_h'1101 --->  Ty_heap  
 var__temp_v_err1102 --->  error  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1099, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h1099, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1099, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1101, res ) ==((sel)( , var__temp_h1099, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i967 T4420)
(declare-const var_h966 T4420)
(declare-const v Int)
(declare-const var_h_i895 T4420)
(declare-const var_h894 T4420)
(declare-const v Int)
(declare-const var_h_i59 T4420)
(declare-const var_h58 T4420)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1099 T4420)
(declare-const var__temp_v1100 Int)
(declare-const |var__temp_h'1101| T4420)
(declare-const var__temp_v_err1102 T4421)
(declare-const var_h966 T4420)
(declare-const var_h894 T4420)
(declare-const var_h58 T4420)
(declare-const err T4434)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4420)
(declare-fun sel (T4420 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4420)
(declare-fun var_h966 () T4420)
(declare-fun var_h58 () T4420)
(declare-fun |20| () Int)
(declare-fun var__temp_h1099 () T4420)
(declare-fun |var__temp_h'1101| () T4420)
(declare-fun v () Int)
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1099 res) v) (= v |20|))
               (= (sel var__temp_h1099 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1101| res) (+ (sel var__temp_h1099 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1099 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************283
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i967 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i967, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1098:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1103 --->  Ty_heap  
 var__temp_v1104 --->  Ty_int  
 var__temp_h'1105 --->  Ty_heap  
 var__temp_v_err1106 --->  error  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1103, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h1103, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1103, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1105, res ) ==((sel)( , var__temp_h1103, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i967 T4437)
(declare-const var_h966 T4437)
(declare-const v Int)
(declare-const var_h_i895 T4437)
(declare-const var_h894 T4437)
(declare-const v Int)
(declare-const var_h_i59 T4437)
(declare-const var_h58 T4437)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1103 T4437)
(declare-const var__temp_v1104 Int)
(declare-const |var__temp_h'1105| T4437)
(declare-const var__temp_v_err1106 T4438)
(declare-const var_h966 T4437)
(declare-const var_h894 T4437)
(declare-const var_h58 T4437)
(declare-const err T4451)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4437)
(declare-fun sel (T4437 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4437)
(declare-fun var_h966 () T4437)
(declare-fun var_h58 () T4437)
(declare-fun |20| () Int)
(declare-fun var__temp_h1103 () T4437)
(declare-fun |var__temp_h'1105| () T4437)
(declare-fun v () Int)
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1103 res) v) (= v |20|))
               (= (sel var__temp_h1103 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1105| res) (+ (sel var__temp_h1103 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1103 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************284
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i967 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i967, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1098:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1107 --->  Ty_heap  
 var__temp_v1108 --->  Ty_int  
 var__temp_h'1109 --->  Ty_heap  
 var__temp_v_err1110 --->  error  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1107, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h1107, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1107, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1109, res ) ==((sel)( , var__temp_h1107, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i967 T4454)
(declare-const var_h966 T4454)
(declare-const v Int)
(declare-const var_h_i895 T4454)
(declare-const var_h894 T4454)
(declare-const v Int)
(declare-const var_h_i59 T4454)
(declare-const var_h58 T4454)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1107 T4454)
(declare-const var__temp_v1108 Int)
(declare-const |var__temp_h'1109| T4454)
(declare-const var__temp_v_err1110 T4455)
(declare-const var_h966 T4454)
(declare-const var_h894 T4454)
(declare-const var_h58 T4454)
(declare-const err T4468)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4454)
(declare-fun sel (T4454 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4454)
(declare-fun var_h966 () T4454)
(declare-fun var_h58 () T4454)
(declare-fun |20| () Int)
(declare-fun var__temp_h1107 () T4454)
(declare-fun |var__temp_h'1109| () T4454)
(declare-fun v () Int)
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1107 res) v) (= v |20|))
               (= (sel var__temp_h1107 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1109| res) (+ (sel var__temp_h1107 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1107 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************285
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i967 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i967, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1098:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1111 --->  Ty_heap  
 var__temp_v1112 --->  Ty_int  
 var__temp_h'1113 --->  Ty_heap  
 var__temp_v_err1114 --->  error  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1111, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h1111, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1111, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1113, res ) ==((sel)( , var__temp_h1111, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i967 T4471)
(declare-const var_h966 T4471)
(declare-const v Int)
(declare-const var_h_i895 T4471)
(declare-const var_h894 T4471)
(declare-const v Int)
(declare-const var_h_i59 T4471)
(declare-const var_h58 T4471)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1111 T4471)
(declare-const var__temp_v1112 Int)
(declare-const |var__temp_h'1113| T4471)
(declare-const var__temp_v_err1114 T4472)
(declare-const var_h966 T4471)
(declare-const var_h894 T4471)
(declare-const var_h58 T4471)
(declare-const err T4485)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4471)
(declare-fun sel (T4471 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4471)
(declare-fun var_h966 () T4471)
(declare-fun var_h58 () T4471)
(declare-fun |20| () Int)
(declare-fun var__temp_h1111 () T4471)
(declare-fun |var__temp_h'1113| () T4471)
(declare-fun v () Int)
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1111 res) v) (= v |20|))
               (= (sel var__temp_h1111 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1113| res) (+ (sel var__temp_h1111 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1111 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************286
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i967 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i967, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1098:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1115 --->  Ty_heap  
 var__temp_v1116 --->  Ty_int  
 var__temp_h'1117 --->  Ty_heap  
 var__temp_v_err1118 --->  error  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1115, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h1115, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h1115, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'1117, res ) ==((sel)( , var__temp_h1115, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i967 T4488)
(declare-const var_h966 T4488)
(declare-const v Int)
(declare-const var_h_i895 T4488)
(declare-const var_h894 T4488)
(declare-const v Int)
(declare-const var_h_i59 T4488)
(declare-const var_h58 T4488)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1115 T4488)
(declare-const var__temp_v1116 Int)
(declare-const |var__temp_h'1117| T4488)
(declare-const var__temp_v_err1118 T4489)
(declare-const var_h966 T4488)
(declare-const var_h894 T4488)
(declare-const var_h58 T4488)
(declare-const err T4502)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4488)
(declare-fun sel (T4488 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4488)
(declare-fun var_h966 () T4488)
(declare-fun var_h58 () T4488)
(declare-fun |20| () Int)
(declare-fun var__temp_h1115 () T4488)
(declare-fun |var__temp_h'1117| () T4488)
(declare-fun v () Int)
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1115 res) v) (= v |20|))
               (= (sel var__temp_h1115 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'1117| res) (+ (sel var__temp_h1115 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1115 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************287
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i967 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i967, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1098:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1119 --->  Ty_heap  
 var__temp_v1120 --->  Ty_int  
 var__temp_h'1121 --->  Ty_heap  
 var__temp_v_err1122 --->  error  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1119, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h1119, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1119, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1121, res ) ==((sel)( , var__temp_h1119, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i967 T4505)
(declare-const var_h966 T4505)
(declare-const v Int)
(declare-const var_h_i895 T4505)
(declare-const var_h894 T4505)
(declare-const v Int)
(declare-const var_h_i59 T4505)
(declare-const var_h58 T4505)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1119 T4505)
(declare-const var__temp_v1120 Int)
(declare-const |var__temp_h'1121| T4505)
(declare-const var__temp_v_err1122 T4506)
(declare-const var_h966 T4505)
(declare-const var_h894 T4505)
(declare-const var_h58 T4505)
(declare-const err T4519)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4505)
(declare-fun sel (T4505 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4505)
(declare-fun var_h966 () T4505)
(declare-fun var_h58 () T4505)
(declare-fun |20| () Int)
(declare-fun var__temp_h1119 () T4505)
(declare-fun |var__temp_h'1121| () T4505)
(declare-fun v () Int)
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1119 res) v) (= v |20|))
               (= (sel var__temp_h1119 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1121| res) (+ (sel var__temp_h1119 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1119 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************288
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (3) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i967 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i967, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1098:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1123 --->  Ty_heap  
 var__temp_v1124 --->  Ty_int  
 var__temp_h'1125 --->  Ty_heap  
 var__temp_v_err1126 --->  error  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1123, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h1123, res ) > (3) AND 
 	 Rel (sel)( , var__temp_h1123, res ) > (3) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1125, res ) ==(var__temp_v1124) AND 
 	 Base var__temp_v1124 = 5 => 
 	 True
 
VC_END(declare-const var_h_i967 T4522)
(declare-const var_h966 T4522)
(declare-const v Int)
(declare-const var_h_i895 T4522)
(declare-const var_h894 T4522)
(declare-const v Int)
(declare-const var_h_i59 T4522)
(declare-const var_h58 T4522)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1123 T4522)
(declare-const var__temp_v1124 Int)
(declare-const |var__temp_h'1125| T4522)
(declare-const var__temp_v_err1126 T4523)
(declare-const var_h966 T4522)
(declare-const var_h894 T4522)
(declare-const var_h58 T4522)
(declare-const err T4536)
    (declare-const |20| Int)
      (declare-const |5| Int)
  
solver 
 (declare-sort T4522)
(declare-fun sel (T4522 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4522)
(declare-fun var_h966 () T4522)
(declare-fun var_h58 () T4522)
(declare-fun |20| () Int)
(declare-fun |5| () Int)
(declare-fun var__temp_v1124 () Int)
(declare-fun |var__temp_h'1125| () T4522)
(declare-fun var__temp_h1123 () T4522)
(declare-fun v () Int)
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1123 res) v) (= v |20|))
               (not (> (sel var__temp_h1123 res) 3))))
      (a!2 (=> (and (= (sel |var__temp_h'1125| res) var__temp_v1124)
                    (= var__temp_v1124 |5|))
               true)))
(let ((a!3 (=> (not (> (sel var__temp_h1123 res) 3)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Failed************foo
 *********************Enumeration Iteration*****************289
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i967 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i967, res ) ==(v)
 	 , v = 20 >c  } 
 } 
 
                                                RET :  Base {var_v1098:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i967 --->  Ty_heap  
 var_h966 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1127 --->  Ty_heap  
 var__temp_v1128 --->  Ty_int  
 var__temp_h'1129 --->  Ty_heap  
 var__temp_v_err1130 --->  error  
 var_h966 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h966, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1127, res ) ==(v) AND 
 	 Base v = 20 => 
 	 Rel (sel)( , var__temp_h1127, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1127, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'1129, res ) ==((sel)( , var__temp_h1127, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i967 T4539)
(declare-const var_h966 T4539)
(declare-const v Int)
(declare-const var_h_i895 T4539)
(declare-const var_h894 T4539)
(declare-const v Int)
(declare-const var_h_i59 T4539)
(declare-const var_h58 T4539)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1127 T4539)
(declare-const var__temp_v1128 Int)
(declare-const |var__temp_h'1129| T4539)
(declare-const var__temp_v_err1130 T4540)
(declare-const var_h966 T4539)
(declare-const var_h894 T4539)
(declare-const var_h58 T4539)
(declare-const err T4553)
    (declare-const |20| Int)
  
solver 
 (declare-sort T4539)
(declare-fun sel (T4539 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4539)
(declare-fun var_h966 () T4539)
(declare-fun var_h58 () T4539)
(declare-fun |20| () Int)
(declare-fun var__temp_h1127 () T4539)
(declare-fun |var__temp_h'1129| () T4539)
(declare-fun v () Int)
(assert (= (sel var_h966 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |20| 20))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1127 res) v) (= v |20|))
               (= (sel var__temp_h1127 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'1129| res) (+ (sel var__temp_h1127 res) 2))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1127 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************290
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 	 --c3'	 --c2'
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i895 Value = Ty_heap{ (sel)( , var_h_i895, res ) ==(sel)( , var_h894, res ) } 
 } 
 
                                                RET :  Base {var_v1131:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
c2
baz
foo
bar
 *********************Enumeration Iteration*****************291
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i895 Value = Ty_heap{ (sel)( , var_h_i895, res ) ==(sel)( , var_h894, res ) } 
 } 
 
                                                RET :  Base {var_v1131:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1132 --->  Ty_heap  
 var__temp_v1133 --->  Ty_int  
 var__temp_h'1134 --->  Ty_heap  
 var__temp_v_err1135 --->  error  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1132, res ) ==(sel)( , var_h894, res ) => 
 	 Rel (sel)( , var__temp_h1132, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1132, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1134, res ) ==((sel)( , var__temp_h1132, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i895 T4556)
(declare-const var_h894 T4556)
(declare-const v Int)
(declare-const var_h_i59 T4556)
(declare-const var_h58 T4556)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1132 T4556)
(declare-const var__temp_v1133 Int)
(declare-const |var__temp_h'1134| T4556)
(declare-const var__temp_v_err1135 T4557)
(declare-const var_h894 T4556)
(declare-const var_h58 T4556)
(declare-const err T4570)

solver 
 (declare-sort T4556)
(declare-fun sel (T4556 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T4556)
(declare-fun var_h894 () T4556)
(declare-fun var__temp_h1132 () T4556)
(declare-fun |var__temp_h'1134| () T4556)
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'1134| res) (+ (sel var__temp_h1132 res) 4))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h1132 res) (sel var_h894 res))
                    (= (sel var__temp_h1132 res) 7))
                (=> (= (sel var__temp_h1132 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************292
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i895 Value = Ty_heap{ (sel)( , var_h_i895, res ) ==(sel)( , var_h894, res ) } 
 } 
 
                                                RET :  Base {var_v1131:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1136 --->  Ty_heap  
 var__temp_v1137 --->  Ty_int  
 var__temp_h'1138 --->  Ty_heap  
 var__temp_v_err1139 --->  error  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1136, res ) ==(sel)( , var_h894, res ) => 
 	 Rel (sel)( , var__temp_h1136, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1136, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1138, res ) ==((sel)( , var__temp_h1136, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i895 T4573)
(declare-const var_h894 T4573)
(declare-const v Int)
(declare-const var_h_i59 T4573)
(declare-const var_h58 T4573)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1136 T4573)
(declare-const var__temp_v1137 Int)
(declare-const |var__temp_h'1138| T4573)
(declare-const var__temp_v_err1139 T4574)
(declare-const var_h894 T4573)
(declare-const var_h58 T4573)
(declare-const err T4587)

solver 
 (declare-sort T4573)
(declare-fun sel (T4573 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T4573)
(declare-fun var_h894 () T4573)
(declare-fun var__temp_h1136 () T4573)
(declare-fun |var__temp_h'1138| () T4573)
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'1138| res) (+ (sel var__temp_h1136 res) 4))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h1136 res) (sel var_h894 res))
                    (= (sel var__temp_h1136 res) 7))
                (=> (= (sel var__temp_h1136 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************293
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i895 Value = Ty_heap{ (sel)( , var_h_i895, res ) ==(sel)( , var_h894, res ) } 
 } 
 
                                                RET :  Base {var_v1131:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1140 --->  Ty_heap  
 var__temp_v1141 --->  Ty_int  
 var__temp_h'1142 --->  Ty_heap  
 var__temp_v_err1143 --->  error  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1140, res ) ==(sel)( , var_h894, res ) => 
 	 Rel (sel)( , var__temp_h1140, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1140, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1142, res ) ==((sel)( , var__temp_h1140, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i895 T4590)
(declare-const var_h894 T4590)
(declare-const v Int)
(declare-const var_h_i59 T4590)
(declare-const var_h58 T4590)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1140 T4590)
(declare-const var__temp_v1141 Int)
(declare-const |var__temp_h'1142| T4590)
(declare-const var__temp_v_err1143 T4591)
(declare-const var_h894 T4590)
(declare-const var_h58 T4590)
(declare-const err T4604)

solver 
 (declare-sort T4590)
(declare-fun sel (T4590 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T4590)
(declare-fun var_h894 () T4590)
(declare-fun var__temp_h1140 () T4590)
(declare-fun |var__temp_h'1142| () T4590)
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'1142| res) (+ (sel var__temp_h1140 res) 4))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h1140 res) (sel var_h894 res))
                    (= (sel var__temp_h1140 res) 7))
                (=> (= (sel var__temp_h1140 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************294
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i895 Value = Ty_heap{ (sel)( , var_h_i895, res ) ==(sel)( , var_h894, res ) } 
 } 
 
                                                RET :  Base {var_v1131:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1144 --->  Ty_heap  
 var__temp_v1145 --->  Ty_int  
 var__temp_h'1146 --->  Ty_heap  
 var__temp_v_err1147 --->  error  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1144, res ) ==(sel)( , var_h894, res ) => 
 	 Rel (sel)( , var__temp_h1144, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1144, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1146, res ) ==((sel)( , var__temp_h1144, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i895 T4607)
(declare-const var_h894 T4607)
(declare-const v Int)
(declare-const var_h_i59 T4607)
(declare-const var_h58 T4607)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1144 T4607)
(declare-const var__temp_v1145 Int)
(declare-const |var__temp_h'1146| T4607)
(declare-const var__temp_v_err1147 T4608)
(declare-const var_h894 T4607)
(declare-const var_h58 T4607)
(declare-const err T4621)

solver 
 (declare-sort T4607)
(declare-fun sel (T4607 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T4607)
(declare-fun var_h894 () T4607)
(declare-fun var__temp_h1144 () T4607)
(declare-fun |var__temp_h'1146| () T4607)
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'1146| res) (+ (sel var__temp_h1144 res) 5))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h1144 res) (sel var_h894 res))
                    (= (sel var__temp_h1144 res) 7))
                (=> (= (sel var__temp_h1144 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************295
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i895 Value = Ty_heap{ (sel)( , var_h_i895, res ) ==(sel)( , var_h894, res ) } 
 } 
 
                                                RET :  Base {var_v1131:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1148 --->  Ty_heap  
 var__temp_v1149 --->  Ty_int  
 var__temp_h'1150 --->  Ty_heap  
 var__temp_v_err1151 --->  error  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1148, res ) ==(sel)( , var_h894, res ) => 
 	 Rel (sel)( , var__temp_h1148, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h1148, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'1150, res ) ==((sel)( , var__temp_h1148, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i895 T4624)
(declare-const var_h894 T4624)
(declare-const v Int)
(declare-const var_h_i59 T4624)
(declare-const var_h58 T4624)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1148 T4624)
(declare-const var__temp_v1149 Int)
(declare-const |var__temp_h'1150| T4624)
(declare-const var__temp_v_err1151 T4625)
(declare-const var_h894 T4624)
(declare-const var_h58 T4624)
(declare-const err T4638)

solver 
 (declare-sort T4624)
(declare-fun sel (T4624 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T4624)
(declare-fun var_h894 () T4624)
(declare-fun var__temp_h1148 () T4624)
(declare-fun |var__temp_h'1150| () T4624)
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'1150| res) (+ (sel var__temp_h1148 res) 5))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h1148 res) (sel var_h894 res))
                    (= (sel var__temp_h1148 res) 6))
                (=> (= (sel var__temp_h1148 res) 6) a!1))))
  (not a!2))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************296
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i895 Value = Ty_heap{ (sel)( , var_h_i895, res ) ==(sel)( , var_h894, res ) } 
 } 
 
                                                RET :  Base {var_v1131:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1152 --->  Ty_heap  
 var__temp_v1153 --->  Ty_int  
 var__temp_h'1154 --->  Ty_heap  
 var__temp_v_err1155 --->  error  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1152, res ) ==(sel)( , var_h894, res ) => 
 	 Rel (sel)( , var__temp_h1152, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1152, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'1154, res ) ==((sel)( , var__temp_h1152, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i895 T4641)
(declare-const var_h894 T4641)
(declare-const v Int)
(declare-const var_h_i59 T4641)
(declare-const var_h58 T4641)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1152 T4641)
(declare-const var__temp_v1153 Int)
(declare-const |var__temp_h'1154| T4641)
(declare-const var__temp_v_err1155 T4642)
(declare-const var_h894 T4641)
(declare-const var_h58 T4641)
(declare-const err T4655)

solver 
 (declare-sort T4641)
(declare-fun sel (T4641 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T4641)
(declare-fun var_h894 () T4641)
(declare-fun var__temp_h1152 () T4641)
(declare-fun |var__temp_h'1154| () T4641)
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'1154| res) (+ (sel var__temp_h1152 res) 10))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h1152 res) (sel var_h894 res))
                    (> (sel var__temp_h1152 res) 4))
                (=> (> (sel var__temp_h1152 res) 4) a!1))))
  (not a!2))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************297
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i895 Value = Ty_heap{ (sel)( , var_h_i895, res ) ==(sel)( , var_h894, res ) } 
 } 
 
                                                RET :  Base {var_v1131:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1156 --->  Ty_heap  
 var__temp_v1157 --->  Ty_int  
 var__temp_h'1158 --->  Ty_heap  
 var__temp_v_err1159 --->  error  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1156, res ) ==(sel)( , var_h894, res ) => 
 	 Rel (sel)( , var__temp_h1156, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1156, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1158, res ) ==((sel)( , var__temp_h1156, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i895 T4658)
(declare-const var_h894 T4658)
(declare-const v Int)
(declare-const var_h_i59 T4658)
(declare-const var_h58 T4658)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1156 T4658)
(declare-const var__temp_v1157 Int)
(declare-const |var__temp_h'1158| T4658)
(declare-const var__temp_v_err1159 T4659)
(declare-const var_h894 T4658)
(declare-const var_h58 T4658)
(declare-const err T4672)

solver 
 (declare-sort T4658)
(declare-fun sel (T4658 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T4658)
(declare-fun var_h894 () T4658)
(declare-fun var__temp_h1156 () T4658)
(declare-fun |var__temp_h'1158| () T4658)
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel |var__temp_h'1158| res) (+ (sel var__temp_h1156 res) 3))
               true)))
(let ((a!2 (and (=> (= (sel var__temp_h1156 res) (sel var_h894 res))
                    (= (sel var__temp_h1156 res) 7))
                (=> (= (sel var__temp_h1156 res) 7) a!1))))
  (not a!2))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************298
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ Not (sel)( , h, res ) > (3) } 
 } 
 
                                                RET :  Base {v:Ty_int | v = 5} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i895 Value = Ty_heap{ (sel)( , var_h_i895, res ) ==(sel)( , var_h894, res ) } 
 } 
 
                                                RET :  Base {var_v1131:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ 
 Conj <c (sel)( , h', res ) ==(v)
 	 , v = 5 >c  }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1160 --->  Ty_heap  
 var__temp_v1161 --->  Ty_int  
 var__temp_h'1162 --->  Ty_heap  
 var__temp_v_err1163 --->  error  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1160, res ) ==(sel)( , var_h894, res ) => 
 	 Rel (sel)( , var__temp_h1160, res ) > (3) AND 
 	 Rel (sel)( , var__temp_h1160, res ) > (3) => 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h'1162, res ) ==(var__temp_v1161) AND 
 	 Base var__temp_v1161 = 5 => 
 	 True
 
VC_END(declare-const var_h_i895 T4675)
(declare-const var_h894 T4675)
(declare-const v Int)
(declare-const var_h_i59 T4675)
(declare-const var_h58 T4675)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1160 T4675)
(declare-const var__temp_v1161 Int)
(declare-const |var__temp_h'1162| T4675)
(declare-const var__temp_v_err1163 T4676)
(declare-const var_h894 T4675)
(declare-const var_h58 T4675)
(declare-const err T4689)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4675)
(declare-fun sel (T4675 Int) Int)
(declare-fun res () Int)
(declare-fun var_h58 () T4675)
(declare-fun var_h894 () T4675)
(declare-fun |5| () Int)
(declare-fun var__temp_v1161 () Int)
(declare-fun |var__temp_h'1162| () T4675)
(declare-fun var__temp_h1160 () T4675)
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (= (sel var__temp_h1160 res) (sel var_h894 res))
               (not (> (sel var__temp_h1160 res) 3))))
      (a!2 (=> (and (= (sel |var__temp_h'1162| res) var__temp_v1161)
                    (= var__temp_v1161 |5|))
               true)))
(let ((a!3 (=> (not (> (sel var__temp_h1160 res) 3)) a!2)))
  (not (and a!1 a!3)))))

***************Selection Successful************foo
PARTIAL PATH NEW
NEW 	 --c3'	 --c2'	 --foo
post_substituted Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1165, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1166:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
c2
baz
bar
 *********************Enumeration Iteration*****************299
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1165, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1166:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1167 --->  Ty_heap  
 var__temp_v1168 --->  Ty_int  
 var__temp_h'1169 --->  Ty_heap  
 var__temp_v_err1170 --->  error  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1167, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1167, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1167, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1169, res ) ==((sel)( , var__temp_h1167, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'1169, res ) ==(10)
 
VC_END(declare-const var_h_i1165 T4692)
(declare-const var_h1164 T4692)
(declare-const v Int)
(declare-const var_h_i895 T4692)
(declare-const var_h894 T4692)
(declare-const v Int)
(declare-const var_h_i59 T4692)
(declare-const var_h58 T4692)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1167 T4692)
(declare-const var__temp_v1168 Int)
(declare-const |var__temp_h'1169| T4692)
(declare-const var__temp_v_err1170 T4693)
(declare-const var_h1164 T4692)
(declare-const var_h894 T4692)
(declare-const var_h58 T4692)
(declare-const err T4706)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4692)
(declare-fun sel (T4692 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4692)
(declare-fun var_h1164 () T4692)
(declare-fun var_h58 () T4692)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1169| () T4692)
(declare-fun var__temp_h1167 () T4692)
(declare-fun v () Int)
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1167 res) v) (= v |5|))
               (= (sel var__temp_h1167 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1169| res) (+ (sel var__temp_h1167 res) 4))
               (= (sel |var__temp_h'1169| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1167 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************300
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1165, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1166:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1171 --->  Ty_heap  
 var__temp_v1172 --->  Ty_int  
 var__temp_h'1173 --->  Ty_heap  
 var__temp_v_err1174 --->  error  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1171, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1171, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1171, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1173, res ) ==((sel)( , var__temp_h1171, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'1173, res ) ==(10)
 
VC_END(declare-const var_h_i1165 T4709)
(declare-const var_h1164 T4709)
(declare-const v Int)
(declare-const var_h_i895 T4709)
(declare-const var_h894 T4709)
(declare-const v Int)
(declare-const var_h_i59 T4709)
(declare-const var_h58 T4709)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1171 T4709)
(declare-const var__temp_v1172 Int)
(declare-const |var__temp_h'1173| T4709)
(declare-const var__temp_v_err1174 T4710)
(declare-const var_h1164 T4709)
(declare-const var_h894 T4709)
(declare-const var_h58 T4709)
(declare-const err T4723)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4709)
(declare-fun sel (T4709 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4709)
(declare-fun var_h1164 () T4709)
(declare-fun var_h58 () T4709)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1173| () T4709)
(declare-fun var__temp_h1171 () T4709)
(declare-fun v () Int)
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1171 res) v) (= v |5|))
               (= (sel var__temp_h1171 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1173| res) (+ (sel var__temp_h1171 res) 4))
               (= (sel |var__temp_h'1173| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1171 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************301
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1165, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1166:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1175 --->  Ty_heap  
 var__temp_v1176 --->  Ty_int  
 var__temp_h'1177 --->  Ty_heap  
 var__temp_v_err1178 --->  error  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1175, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1175, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1175, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1177, res ) ==((sel)( , var__temp_h1175, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'1177, res ) ==(10)
 
VC_END(declare-const var_h_i1165 T4726)
(declare-const var_h1164 T4726)
(declare-const v Int)
(declare-const var_h_i895 T4726)
(declare-const var_h894 T4726)
(declare-const v Int)
(declare-const var_h_i59 T4726)
(declare-const var_h58 T4726)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1175 T4726)
(declare-const var__temp_v1176 Int)
(declare-const |var__temp_h'1177| T4726)
(declare-const var__temp_v_err1178 T4727)
(declare-const var_h1164 T4726)
(declare-const var_h894 T4726)
(declare-const var_h58 T4726)
(declare-const err T4740)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4726)
(declare-fun sel (T4726 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4726)
(declare-fun var_h1164 () T4726)
(declare-fun var_h58 () T4726)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1177| () T4726)
(declare-fun var__temp_h1175 () T4726)
(declare-fun v () Int)
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1175 res) v) (= v |5|))
               (= (sel var__temp_h1175 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1177| res) (+ (sel var__temp_h1175 res) 4))
               (= (sel |var__temp_h'1177| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1175 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************302
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1165, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1166:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1179 --->  Ty_heap  
 var__temp_v1180 --->  Ty_int  
 var__temp_h'1181 --->  Ty_heap  
 var__temp_v_err1182 --->  error  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1179, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1179, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1179, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1181, res ) ==((sel)( , var__temp_h1179, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'1181, res ) ==(10)
 
VC_END(declare-const var_h_i1165 T4743)
(declare-const var_h1164 T4743)
(declare-const v Int)
(declare-const var_h_i895 T4743)
(declare-const var_h894 T4743)
(declare-const v Int)
(declare-const var_h_i59 T4743)
(declare-const var_h58 T4743)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1179 T4743)
(declare-const var__temp_v1180 Int)
(declare-const |var__temp_h'1181| T4743)
(declare-const var__temp_v_err1182 T4744)
(declare-const var_h1164 T4743)
(declare-const var_h894 T4743)
(declare-const var_h58 T4743)
(declare-const err T4757)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4743)
(declare-fun sel (T4743 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4743)
(declare-fun var_h1164 () T4743)
(declare-fun var_h58 () T4743)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1181| () T4743)
(declare-fun var__temp_h1179 () T4743)
(declare-fun v () Int)
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1179 res) v) (= v |5|))
               (= (sel var__temp_h1179 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1181| res) (+ (sel var__temp_h1179 res) 5))
               (= (sel |var__temp_h'1181| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1179 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************303
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1165, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1166:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1183 --->  Ty_heap  
 var__temp_v1184 --->  Ty_int  
 var__temp_h'1185 --->  Ty_heap  
 var__temp_v_err1186 --->  error  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1183, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1183, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h1183, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'1185, res ) ==((sel)( , var__temp_h1183, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'1185, res ) ==(10)
 
VC_END(declare-const var_h_i1165 T4760)
(declare-const var_h1164 T4760)
(declare-const v Int)
(declare-const var_h_i895 T4760)
(declare-const var_h894 T4760)
(declare-const v Int)
(declare-const var_h_i59 T4760)
(declare-const var_h58 T4760)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1183 T4760)
(declare-const var__temp_v1184 Int)
(declare-const |var__temp_h'1185| T4760)
(declare-const var__temp_v_err1186 T4761)
(declare-const var_h1164 T4760)
(declare-const var_h894 T4760)
(declare-const var_h58 T4760)
(declare-const err T4774)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4760)
(declare-fun sel (T4760 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4760)
(declare-fun var_h1164 () T4760)
(declare-fun var_h58 () T4760)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1185| () T4760)
(declare-fun var__temp_h1183 () T4760)
(declare-fun v () Int)
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1183 res) v) (= v |5|))
               (= (sel var__temp_h1183 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'1185| res) (+ (sel var__temp_h1183 res) 5))
               (= (sel |var__temp_h'1185| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1183 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************304
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1165, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1166:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1187 --->  Ty_heap  
 var__temp_v1188 --->  Ty_int  
 var__temp_h'1189 --->  Ty_heap  
 var__temp_v_err1190 --->  error  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1187, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1187, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1187, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'1189, res ) ==((sel)( , var__temp_h1187, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h'1189, res ) ==(10)
 
VC_END(declare-const var_h_i1165 T4777)
(declare-const var_h1164 T4777)
(declare-const v Int)
(declare-const var_h_i895 T4777)
(declare-const var_h894 T4777)
(declare-const v Int)
(declare-const var_h_i59 T4777)
(declare-const var_h58 T4777)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1187 T4777)
(declare-const var__temp_v1188 Int)
(declare-const |var__temp_h'1189| T4777)
(declare-const var__temp_v_err1190 T4778)
(declare-const var_h1164 T4777)
(declare-const var_h894 T4777)
(declare-const var_h58 T4777)
(declare-const err T4791)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4777)
(declare-fun sel (T4777 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4777)
(declare-fun var_h1164 () T4777)
(declare-fun var_h58 () T4777)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1189| () T4777)
(declare-fun var__temp_h1187 () T4777)
(declare-fun v () Int)
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1187 res) v) (= v |5|))
               (> (sel var__temp_h1187 res) 4)))
      (a!2 (=> (= (sel |var__temp_h'1189| res) (+ (sel var__temp_h1187 res) 10))
               (= (sel |var__temp_h'1189| res) 10))))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h1187 res) 4) a!2))))
  (not a!3))))

***************Selection Failed************c2
 *********************Enumeration Iteration*****************305
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1165, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1166:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1191 --->  Ty_heap  
 var__temp_v1192 --->  Ty_int  
 var__temp_h'1193 --->  Ty_heap  
 var__temp_v_err1194 --->  error  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1191, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1191, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1191, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1193, res ) ==((sel)( , var__temp_h1191, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'1193, res ) ==(10)
 
VC_END(declare-const var_h_i1165 T4794)
(declare-const var_h1164 T4794)
(declare-const v Int)
(declare-const var_h_i895 T4794)
(declare-const var_h894 T4794)
(declare-const v Int)
(declare-const var_h_i59 T4794)
(declare-const var_h58 T4794)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1191 T4794)
(declare-const var__temp_v1192 Int)
(declare-const |var__temp_h'1193| T4794)
(declare-const var__temp_v_err1194 T4795)
(declare-const var_h1164 T4794)
(declare-const var_h894 T4794)
(declare-const var_h58 T4794)
(declare-const err T4808)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4794)
(declare-fun sel (T4794 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4794)
(declare-fun var_h1164 () T4794)
(declare-fun var_h58 () T4794)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1193| () T4794)
(declare-fun var__temp_h1191 () T4794)
(declare-fun v () Int)
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1191 res) v) (= v |5|))
               (= (sel var__temp_h1191 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1193| res) (+ (sel var__temp_h1191 res) 3))
               (= (sel |var__temp_h'1193| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1191 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************306
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1165, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1166:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1195 --->  Ty_heap  
 var__temp_v1196 --->  Ty_int  
 var__temp_h'1197 --->  Ty_heap  
 var__temp_v_err1198 --->  error  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1195, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1195, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1195, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'1197, res ) ==((sel)( , var__temp_h1195, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'1197, res ) ==(10)
 
VC_END(declare-const var_h_i1165 T4811)
(declare-const var_h1164 T4811)
(declare-const v Int)
(declare-const var_h_i895 T4811)
(declare-const var_h894 T4811)
(declare-const v Int)
(declare-const var_h_i59 T4811)
(declare-const var_h58 T4811)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1195 T4811)
(declare-const var__temp_v1196 Int)
(declare-const |var__temp_h'1197| T4811)
(declare-const var__temp_v_err1198 T4812)
(declare-const var_h1164 T4811)
(declare-const var_h894 T4811)
(declare-const var_h58 T4811)
(declare-const err T4825)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4811)
(declare-fun sel (T4811 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4811)
(declare-fun var_h1164 () T4811)
(declare-fun var_h58 () T4811)
(declare-fun |5| () Int)
(declare-fun |var__temp_h'1197| () T4811)
(declare-fun var__temp_h1195 () T4811)
(declare-fun v () Int)
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1195 res) v) (= v |5|))
               (= (sel var__temp_h1195 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'1197| res) (+ (sel var__temp_h1195 res) 2))
               (= (sel |var__temp_h'1197| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1195 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************307
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1166:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1166:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsfoofoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --c2'	 --foo
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1165, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1199:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
c2
baz
bar
 *********************Enumeration Iteration*****************308
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1165, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1199:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1200 --->  Ty_heap  
 var__temp_v1201 --->  Ty_int  
 var__temp_h'1202 --->  Ty_heap  
 var__temp_v_err1203 --->  error  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1200, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1200, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1200, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1202, res ) ==((sel)( , var__temp_h1200, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i1165 T4828)
(declare-const var_h1164 T4828)
(declare-const v Int)
(declare-const var_h_i895 T4828)
(declare-const var_h894 T4828)
(declare-const v Int)
(declare-const var_h_i59 T4828)
(declare-const var_h58 T4828)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1200 T4828)
(declare-const var__temp_v1201 Int)
(declare-const |var__temp_h'1202| T4828)
(declare-const var__temp_v_err1203 T4829)
(declare-const var_h1164 T4828)
(declare-const var_h894 T4828)
(declare-const var_h58 T4828)
(declare-const err T4842)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4828)
(declare-fun sel (T4828 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4828)
(declare-fun var_h1164 () T4828)
(declare-fun var_h58 () T4828)
(declare-fun |5| () Int)
(declare-fun var__temp_h1200 () T4828)
(declare-fun |var__temp_h'1202| () T4828)
(declare-fun v () Int)
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1200 res) v) (= v |5|))
               (= (sel var__temp_h1200 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1202| res) (+ (sel var__temp_h1200 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1200 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************309
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1165, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1199:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1204 --->  Ty_heap  
 var__temp_v1205 --->  Ty_int  
 var__temp_h'1206 --->  Ty_heap  
 var__temp_v_err1207 --->  error  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1204, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1204, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1204, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1206, res ) ==((sel)( , var__temp_h1204, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i1165 T4845)
(declare-const var_h1164 T4845)
(declare-const v Int)
(declare-const var_h_i895 T4845)
(declare-const var_h894 T4845)
(declare-const v Int)
(declare-const var_h_i59 T4845)
(declare-const var_h58 T4845)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1204 T4845)
(declare-const var__temp_v1205 Int)
(declare-const |var__temp_h'1206| T4845)
(declare-const var__temp_v_err1207 T4846)
(declare-const var_h1164 T4845)
(declare-const var_h894 T4845)
(declare-const var_h58 T4845)
(declare-const err T4859)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4845)
(declare-fun sel (T4845 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4845)
(declare-fun var_h1164 () T4845)
(declare-fun var_h58 () T4845)
(declare-fun |5| () Int)
(declare-fun var__temp_h1204 () T4845)
(declare-fun |var__temp_h'1206| () T4845)
(declare-fun v () Int)
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1204 res) v) (= v |5|))
               (= (sel var__temp_h1204 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1206| res) (+ (sel var__temp_h1204 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1204 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************310
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1165, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1199:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1208 --->  Ty_heap  
 var__temp_v1209 --->  Ty_int  
 var__temp_h'1210 --->  Ty_heap  
 var__temp_v_err1211 --->  error  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1208, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1208, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1208, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1210, res ) ==((sel)( , var__temp_h1208, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i1165 T4862)
(declare-const var_h1164 T4862)
(declare-const v Int)
(declare-const var_h_i895 T4862)
(declare-const var_h894 T4862)
(declare-const v Int)
(declare-const var_h_i59 T4862)
(declare-const var_h58 T4862)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1208 T4862)
(declare-const var__temp_v1209 Int)
(declare-const |var__temp_h'1210| T4862)
(declare-const var__temp_v_err1211 T4863)
(declare-const var_h1164 T4862)
(declare-const var_h894 T4862)
(declare-const var_h58 T4862)
(declare-const err T4876)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4862)
(declare-fun sel (T4862 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4862)
(declare-fun var_h1164 () T4862)
(declare-fun var_h58 () T4862)
(declare-fun |5| () Int)
(declare-fun var__temp_h1208 () T4862)
(declare-fun |var__temp_h'1210| () T4862)
(declare-fun v () Int)
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1208 res) v) (= v |5|))
               (= (sel var__temp_h1208 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1210| res) (+ (sel var__temp_h1208 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1208 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************311
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1165, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1199:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1212 --->  Ty_heap  
 var__temp_v1213 --->  Ty_int  
 var__temp_h'1214 --->  Ty_heap  
 var__temp_v_err1215 --->  error  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1212, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1212, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1212, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1214, res ) ==((sel)( , var__temp_h1212, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i1165 T4879)
(declare-const var_h1164 T4879)
(declare-const v Int)
(declare-const var_h_i895 T4879)
(declare-const var_h894 T4879)
(declare-const v Int)
(declare-const var_h_i59 T4879)
(declare-const var_h58 T4879)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1212 T4879)
(declare-const var__temp_v1213 Int)
(declare-const |var__temp_h'1214| T4879)
(declare-const var__temp_v_err1215 T4880)
(declare-const var_h1164 T4879)
(declare-const var_h894 T4879)
(declare-const var_h58 T4879)
(declare-const err T4893)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4879)
(declare-fun sel (T4879 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4879)
(declare-fun var_h1164 () T4879)
(declare-fun var_h58 () T4879)
(declare-fun |5| () Int)
(declare-fun var__temp_h1212 () T4879)
(declare-fun |var__temp_h'1214| () T4879)
(declare-fun v () Int)
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1212 res) v) (= v |5|))
               (= (sel var__temp_h1212 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1214| res) (+ (sel var__temp_h1212 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1212 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************312
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1165, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1199:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1216 --->  Ty_heap  
 var__temp_v1217 --->  Ty_int  
 var__temp_h'1218 --->  Ty_heap  
 var__temp_v_err1219 --->  error  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1216, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1216, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h1216, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'1218, res ) ==((sel)( , var__temp_h1216, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i1165 T4896)
(declare-const var_h1164 T4896)
(declare-const v Int)
(declare-const var_h_i895 T4896)
(declare-const var_h894 T4896)
(declare-const v Int)
(declare-const var_h_i59 T4896)
(declare-const var_h58 T4896)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1216 T4896)
(declare-const var__temp_v1217 Int)
(declare-const |var__temp_h'1218| T4896)
(declare-const var__temp_v_err1219 T4897)
(declare-const var_h1164 T4896)
(declare-const var_h894 T4896)
(declare-const var_h58 T4896)
(declare-const err T4910)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4896)
(declare-fun sel (T4896 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4896)
(declare-fun var_h1164 () T4896)
(declare-fun var_h58 () T4896)
(declare-fun |5| () Int)
(declare-fun var__temp_h1216 () T4896)
(declare-fun |var__temp_h'1218| () T4896)
(declare-fun v () Int)
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1216 res) v) (= v |5|))
               (= (sel var__temp_h1216 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'1218| res) (+ (sel var__temp_h1216 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1216 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************313
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) > (4) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1165, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1199:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (10)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1220 --->  Ty_heap  
 var__temp_v1221 --->  Ty_int  
 var__temp_h'1222 --->  Ty_heap  
 var__temp_v_err1223 --->  error  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1220, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1220, res ) > (4) AND 
 	 Rel (sel)( , var__temp_h1220, res ) > (4) => 
 	 Rel (sel)( , var__temp_h'1222, res ) ==((sel)( , var__temp_h1220, res ) + (10)) => 
 	 True
 
VC_END(declare-const var_h_i1165 T4913)
(declare-const var_h1164 T4913)
(declare-const v Int)
(declare-const var_h_i895 T4913)
(declare-const var_h894 T4913)
(declare-const v Int)
(declare-const var_h_i59 T4913)
(declare-const var_h58 T4913)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1220 T4913)
(declare-const var__temp_v1221 Int)
(declare-const |var__temp_h'1222| T4913)
(declare-const var__temp_v_err1223 T4914)
(declare-const var_h1164 T4913)
(declare-const var_h894 T4913)
(declare-const var_h58 T4913)
(declare-const err T4927)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4913)
(declare-fun sel (T4913 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T4913)
(declare-fun var_h1164 () T4913)
(declare-fun var_h58 () T4913)
(declare-fun |5| () Int)
(declare-fun var__temp_h1220 () T4913)
(declare-fun |var__temp_h'1222| () T4913)
(declare-fun v () Int)
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1220 res) v) (= v |5|))
               (> (sel var__temp_h1220 res) 4)))
      (a!2 (=> (= (sel |var__temp_h'1222| res) (+ (sel var__temp_h1220 res) 10))
               true)))
(let ((a!3 (and a!1 (=> (> (sel var__temp_h1220 res) 4) a!2))))
  (not a!3))))

***************Selection Successful************c2
PARTIAL PATH NEW
NEW 	 --c3'	 --c2'	 --foo	 --c2
post_substituted Forall 
 	 
 Key =var_h_i1225 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1225 Value = Ty_heap{ (sel)( , var_h_i1225, res ) ==((sel)( , var_h1224, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1226:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1225 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
baz
bar
 *********************Enumeration Iteration*****************314
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1225 Value = Ty_heap{ (sel)( , var_h_i1225, res ) ==((sel)( , var_h1224, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1226:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1225 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1225 --->  Ty_heap  
 var_h1224 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1227 --->  Ty_heap  
 var__temp_v1228 --->  Ty_int  
 var__temp_h'1229 --->  Ty_heap  
 var__temp_v_err1230 --->  error  
 var_h1224 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1224, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1227, res ) ==((sel)( , var_h1224, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1227, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1227, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1229, res ) ==((sel)( , var__temp_h1227, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'1229, res ) ==(10)
 
VC_END(declare-const var_h_i1225 T4930)
(declare-const var_h1224 T4930)
(declare-const v Int)
(declare-const var_h_i1165 T4930)
(declare-const var_h1164 T4930)
(declare-const v Int)
(declare-const var_h_i895 T4930)
(declare-const var_h894 T4930)
(declare-const v Int)
(declare-const var_h_i59 T4930)
(declare-const var_h58 T4930)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1227 T4930)
(declare-const var__temp_v1228 Int)
(declare-const |var__temp_h'1229| T4930)
(declare-const var__temp_v_err1230 T4931)
(declare-const var_h1224 T4930)
(declare-const var_h1164 T4930)
(declare-const var_h894 T4930)
(declare-const var_h58 T4930)
(declare-const err T4944)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4930)
(declare-fun v () Int)
(declare-fun sel (T4930 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1224 () T4930)
(declare-fun |5| () Int)
(declare-fun var_h894 () T4930)
(declare-fun var_h1164 () T4930)
(declare-fun var_h58 () T4930)
(declare-fun |var__temp_h'1229| () T4930)
(declare-fun var__temp_h1227 () T4930)
(assert (= (sel var_h1224 res) v))
(assert (= |5| 5))
(assert (= v |5|))
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1227 res) (+ (sel var_h1224 res) 10))
               (= (sel var__temp_h1227 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1229| res) (+ (sel var__temp_h1227 res) 4))
               (= (sel |var__temp_h'1229| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1227 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************315
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1225 Value = Ty_heap{ (sel)( , var_h_i1225, res ) ==((sel)( , var_h1224, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1226:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1225 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1225 --->  Ty_heap  
 var_h1224 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1231 --->  Ty_heap  
 var__temp_v1232 --->  Ty_int  
 var__temp_h'1233 --->  Ty_heap  
 var__temp_v_err1234 --->  error  
 var_h1224 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1224, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1231, res ) ==((sel)( , var_h1224, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1231, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1231, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1233, res ) ==((sel)( , var__temp_h1231, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'1233, res ) ==(10)
 
VC_END(declare-const var_h_i1225 T4947)
(declare-const var_h1224 T4947)
(declare-const v Int)
(declare-const var_h_i1165 T4947)
(declare-const var_h1164 T4947)
(declare-const v Int)
(declare-const var_h_i895 T4947)
(declare-const var_h894 T4947)
(declare-const v Int)
(declare-const var_h_i59 T4947)
(declare-const var_h58 T4947)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1231 T4947)
(declare-const var__temp_v1232 Int)
(declare-const |var__temp_h'1233| T4947)
(declare-const var__temp_v_err1234 T4948)
(declare-const var_h1224 T4947)
(declare-const var_h1164 T4947)
(declare-const var_h894 T4947)
(declare-const var_h58 T4947)
(declare-const err T4961)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4947)
(declare-fun v () Int)
(declare-fun sel (T4947 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1224 () T4947)
(declare-fun |5| () Int)
(declare-fun var_h894 () T4947)
(declare-fun var_h1164 () T4947)
(declare-fun var_h58 () T4947)
(declare-fun |var__temp_h'1233| () T4947)
(declare-fun var__temp_h1231 () T4947)
(assert (= (sel var_h1224 res) v))
(assert (= |5| 5))
(assert (= v |5|))
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1231 res) (+ (sel var_h1224 res) 10))
               (= (sel var__temp_h1231 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1233| res) (+ (sel var__temp_h1231 res) 4))
               (= (sel |var__temp_h'1233| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1231 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************316
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1225 Value = Ty_heap{ (sel)( , var_h_i1225, res ) ==((sel)( , var_h1224, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1226:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1225 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1225 --->  Ty_heap  
 var_h1224 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1235 --->  Ty_heap  
 var__temp_v1236 --->  Ty_int  
 var__temp_h'1237 --->  Ty_heap  
 var__temp_v_err1238 --->  error  
 var_h1224 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1224, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1235, res ) ==((sel)( , var_h1224, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1235, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1235, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1237, res ) ==((sel)( , var__temp_h1235, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'1237, res ) ==(10)
 
VC_END(declare-const var_h_i1225 T4964)
(declare-const var_h1224 T4964)
(declare-const v Int)
(declare-const var_h_i1165 T4964)
(declare-const var_h1164 T4964)
(declare-const v Int)
(declare-const var_h_i895 T4964)
(declare-const var_h894 T4964)
(declare-const v Int)
(declare-const var_h_i59 T4964)
(declare-const var_h58 T4964)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1235 T4964)
(declare-const var__temp_v1236 Int)
(declare-const |var__temp_h'1237| T4964)
(declare-const var__temp_v_err1238 T4965)
(declare-const var_h1224 T4964)
(declare-const var_h1164 T4964)
(declare-const var_h894 T4964)
(declare-const var_h58 T4964)
(declare-const err T4978)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4964)
(declare-fun v () Int)
(declare-fun sel (T4964 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1224 () T4964)
(declare-fun |5| () Int)
(declare-fun var_h894 () T4964)
(declare-fun var_h1164 () T4964)
(declare-fun var_h58 () T4964)
(declare-fun |var__temp_h'1237| () T4964)
(declare-fun var__temp_h1235 () T4964)
(assert (= (sel var_h1224 res) v))
(assert (= |5| 5))
(assert (= v |5|))
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1235 res) (+ (sel var_h1224 res) 10))
               (= (sel var__temp_h1235 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1237| res) (+ (sel var__temp_h1235 res) 4))
               (= (sel |var__temp_h'1237| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1235 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************317
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1225 Value = Ty_heap{ (sel)( , var_h_i1225, res ) ==((sel)( , var_h1224, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1226:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1225 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1225 --->  Ty_heap  
 var_h1224 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1239 --->  Ty_heap  
 var__temp_v1240 --->  Ty_int  
 var__temp_h'1241 --->  Ty_heap  
 var__temp_v_err1242 --->  error  
 var_h1224 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1224, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1239, res ) ==((sel)( , var_h1224, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1239, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1239, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1241, res ) ==((sel)( , var__temp_h1239, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'1241, res ) ==(10)
 
VC_END(declare-const var_h_i1225 T4981)
(declare-const var_h1224 T4981)
(declare-const v Int)
(declare-const var_h_i1165 T4981)
(declare-const var_h1164 T4981)
(declare-const v Int)
(declare-const var_h_i895 T4981)
(declare-const var_h894 T4981)
(declare-const v Int)
(declare-const var_h_i59 T4981)
(declare-const var_h58 T4981)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1239 T4981)
(declare-const var__temp_v1240 Int)
(declare-const |var__temp_h'1241| T4981)
(declare-const var__temp_v_err1242 T4982)
(declare-const var_h1224 T4981)
(declare-const var_h1164 T4981)
(declare-const var_h894 T4981)
(declare-const var_h58 T4981)
(declare-const err T4995)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4981)
(declare-fun v () Int)
(declare-fun sel (T4981 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1224 () T4981)
(declare-fun |5| () Int)
(declare-fun var_h894 () T4981)
(declare-fun var_h1164 () T4981)
(declare-fun var_h58 () T4981)
(declare-fun |var__temp_h'1241| () T4981)
(declare-fun var__temp_h1239 () T4981)
(assert (= (sel var_h1224 res) v))
(assert (= |5| 5))
(assert (= v |5|))
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1239 res) (+ (sel var_h1224 res) 10))
               (= (sel var__temp_h1239 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1241| res) (+ (sel var__temp_h1239 res) 5))
               (= (sel |var__temp_h'1241| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1239 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************318
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1225 Value = Ty_heap{ (sel)( , var_h_i1225, res ) ==((sel)( , var_h1224, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1226:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1225 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1225 --->  Ty_heap  
 var_h1224 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1243 --->  Ty_heap  
 var__temp_v1244 --->  Ty_int  
 var__temp_h'1245 --->  Ty_heap  
 var__temp_v_err1246 --->  error  
 var_h1224 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1224, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1243, res ) ==((sel)( , var_h1224, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1243, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h1243, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'1245, res ) ==((sel)( , var__temp_h1243, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'1245, res ) ==(10)
 
VC_END(declare-const var_h_i1225 T4998)
(declare-const var_h1224 T4998)
(declare-const v Int)
(declare-const var_h_i1165 T4998)
(declare-const var_h1164 T4998)
(declare-const v Int)
(declare-const var_h_i895 T4998)
(declare-const var_h894 T4998)
(declare-const v Int)
(declare-const var_h_i59 T4998)
(declare-const var_h58 T4998)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1243 T4998)
(declare-const var__temp_v1244 Int)
(declare-const |var__temp_h'1245| T4998)
(declare-const var__temp_v_err1246 T4999)
(declare-const var_h1224 T4998)
(declare-const var_h1164 T4998)
(declare-const var_h894 T4998)
(declare-const var_h58 T4998)
(declare-const err T5012)
    (declare-const |5| Int)
  
solver 
 (declare-sort T4998)
(declare-fun v () Int)
(declare-fun sel (T4998 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1224 () T4998)
(declare-fun |5| () Int)
(declare-fun var_h894 () T4998)
(declare-fun var_h1164 () T4998)
(declare-fun var_h58 () T4998)
(declare-fun |var__temp_h'1245| () T4998)
(declare-fun var__temp_h1243 () T4998)
(assert (= (sel var_h1224 res) v))
(assert (= |5| 5))
(assert (= v |5|))
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1243 res) (+ (sel var_h1224 res) 10))
               (= (sel var__temp_h1243 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'1245| res) (+ (sel var__temp_h1243 res) 5))
               (= (sel |var__temp_h'1245| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1243 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************319
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1225 Value = Ty_heap{ (sel)( , var_h_i1225, res ) ==((sel)( , var_h1224, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1226:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1225 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1225 --->  Ty_heap  
 var_h1224 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1247 --->  Ty_heap  
 var__temp_v1248 --->  Ty_int  
 var__temp_h'1249 --->  Ty_heap  
 var__temp_v_err1250 --->  error  
 var_h1224 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1224, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1247, res ) ==((sel)( , var_h1224, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1247, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1247, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1249, res ) ==((sel)( , var__temp_h1247, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'1249, res ) ==(10)
 
VC_END(declare-const var_h_i1225 T5015)
(declare-const var_h1224 T5015)
(declare-const v Int)
(declare-const var_h_i1165 T5015)
(declare-const var_h1164 T5015)
(declare-const v Int)
(declare-const var_h_i895 T5015)
(declare-const var_h894 T5015)
(declare-const v Int)
(declare-const var_h_i59 T5015)
(declare-const var_h58 T5015)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1247 T5015)
(declare-const var__temp_v1248 Int)
(declare-const |var__temp_h'1249| T5015)
(declare-const var__temp_v_err1250 T5016)
(declare-const var_h1224 T5015)
(declare-const var_h1164 T5015)
(declare-const var_h894 T5015)
(declare-const var_h58 T5015)
(declare-const err T5029)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5015)
(declare-fun v () Int)
(declare-fun sel (T5015 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1224 () T5015)
(declare-fun |5| () Int)
(declare-fun var_h894 () T5015)
(declare-fun var_h1164 () T5015)
(declare-fun var_h58 () T5015)
(declare-fun |var__temp_h'1249| () T5015)
(declare-fun var__temp_h1247 () T5015)
(assert (= (sel var_h1224 res) v))
(assert (= |5| 5))
(assert (= v |5|))
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1247 res) (+ (sel var_h1224 res) 10))
               (= (sel var__temp_h1247 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1249| res) (+ (sel var__temp_h1247 res) 3))
               (= (sel |var__temp_h'1249| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1247 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************320
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1225 Value = Ty_heap{ (sel)( , var_h_i1225, res ) ==((sel)( , var_h1224, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1226:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1225 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1225 --->  Ty_heap  
 var_h1224 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1251 --->  Ty_heap  
 var__temp_v1252 --->  Ty_int  
 var__temp_h'1253 --->  Ty_heap  
 var__temp_v_err1254 --->  error  
 var_h1224 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1224, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1251, res ) ==((sel)( , var_h1224, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1251, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1251, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'1253, res ) ==((sel)( , var__temp_h1251, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h'1253, res ) ==(10)
 
VC_END(declare-const var_h_i1225 T5032)
(declare-const var_h1224 T5032)
(declare-const v Int)
(declare-const var_h_i1165 T5032)
(declare-const var_h1164 T5032)
(declare-const v Int)
(declare-const var_h_i895 T5032)
(declare-const var_h894 T5032)
(declare-const v Int)
(declare-const var_h_i59 T5032)
(declare-const var_h58 T5032)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1251 T5032)
(declare-const var__temp_v1252 Int)
(declare-const |var__temp_h'1253| T5032)
(declare-const var__temp_v_err1254 T5033)
(declare-const var_h1224 T5032)
(declare-const var_h1164 T5032)
(declare-const var_h894 T5032)
(declare-const var_h58 T5032)
(declare-const err T5046)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5032)
(declare-fun v () Int)
(declare-fun sel (T5032 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1224 () T5032)
(declare-fun |5| () Int)
(declare-fun var_h894 () T5032)
(declare-fun var_h1164 () T5032)
(declare-fun var_h58 () T5032)
(declare-fun |var__temp_h'1253| () T5032)
(declare-fun var__temp_h1251 () T5032)
(assert (= (sel var_h1224 res) v))
(assert (= |5| 5))
(assert (= v |5|))
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1251 res) (+ (sel var_h1224 res) 10))
               (= (sel var__temp_h1251 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'1253| res) (+ (sel var__temp_h1251 res) 2))
               (= (sel |var__temp_h'1253| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1251 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************321
 Single Component Enumeration Failed, trying the eRet Case
 eRet Failed, the effect is not Pure, Attempting esynthesizeBindSpecial
EsynthesizeBindSpecial Return TypeBase {var_v1226:Ty_unknown | true}
isynthesizeConstApp
Spec Base {var_v1226:Ty_unknown | true}
Found Cons
Non constructors found,  try another approachNo Holes from the return type
bindSpecial failed, Attempting Simple Bind Enumeration
EXPLORED1 Termsc2foofoo'c2'c4c3'
esynthesizeBind
PARTIAL PATH
SUB 	 --c3'	 --c2'	 --foo	 --c2
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1225 Value = Ty_heap{ (sel)( , var_h_i1225, res ) ==((sel)( , var_h1224, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1255:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
baz
bar
 *********************Enumeration Iteration*****************322
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1225 Value = Ty_heap{ (sel)( , var_h_i1225, res ) ==((sel)( , var_h1224, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1255:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1225 --->  Ty_heap  
 var_h1224 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1256 --->  Ty_heap  
 var__temp_v1257 --->  Ty_int  
 var__temp_h'1258 --->  Ty_heap  
 var__temp_v_err1259 --->  error  
 var_h1224 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1224, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1256, res ) ==((sel)( , var_h1224, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1256, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1256, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1258, res ) ==((sel)( , var__temp_h1256, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i1225 T5049)
(declare-const var_h1224 T5049)
(declare-const v Int)
(declare-const var_h_i1165 T5049)
(declare-const var_h1164 T5049)
(declare-const v Int)
(declare-const var_h_i895 T5049)
(declare-const var_h894 T5049)
(declare-const v Int)
(declare-const var_h_i59 T5049)
(declare-const var_h58 T5049)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1256 T5049)
(declare-const var__temp_v1257 Int)
(declare-const |var__temp_h'1258| T5049)
(declare-const var__temp_v_err1259 T5050)
(declare-const var_h1224 T5049)
(declare-const var_h1164 T5049)
(declare-const var_h894 T5049)
(declare-const var_h58 T5049)
(declare-const err T5063)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5049)
(declare-fun v () Int)
(declare-fun sel (T5049 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1224 () T5049)
(declare-fun |5| () Int)
(declare-fun var_h894 () T5049)
(declare-fun var_h1164 () T5049)
(declare-fun var_h58 () T5049)
(declare-fun var__temp_h1256 () T5049)
(declare-fun |var__temp_h'1258| () T5049)
(assert (= (sel var_h1224 res) v))
(assert (= |5| 5))
(assert (= v |5|))
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1256 res) (+ (sel var_h1224 res) 10))
               (= (sel var__temp_h1256 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1258| res) (+ (sel var__temp_h1256 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1256 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************323
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1225 Value = Ty_heap{ (sel)( , var_h_i1225, res ) ==((sel)( , var_h1224, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1255:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1225 --->  Ty_heap  
 var_h1224 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1260 --->  Ty_heap  
 var__temp_v1261 --->  Ty_int  
 var__temp_h'1262 --->  Ty_heap  
 var__temp_v_err1263 --->  error  
 var_h1224 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1224, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1260, res ) ==((sel)( , var_h1224, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1260, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1260, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1262, res ) ==((sel)( , var__temp_h1260, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i1225 T5066)
(declare-const var_h1224 T5066)
(declare-const v Int)
(declare-const var_h_i1165 T5066)
(declare-const var_h1164 T5066)
(declare-const v Int)
(declare-const var_h_i895 T5066)
(declare-const var_h894 T5066)
(declare-const v Int)
(declare-const var_h_i59 T5066)
(declare-const var_h58 T5066)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1260 T5066)
(declare-const var__temp_v1261 Int)
(declare-const |var__temp_h'1262| T5066)
(declare-const var__temp_v_err1263 T5067)
(declare-const var_h1224 T5066)
(declare-const var_h1164 T5066)
(declare-const var_h894 T5066)
(declare-const var_h58 T5066)
(declare-const err T5080)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5066)
(declare-fun v () Int)
(declare-fun sel (T5066 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1224 () T5066)
(declare-fun |5| () Int)
(declare-fun var_h894 () T5066)
(declare-fun var_h1164 () T5066)
(declare-fun var_h58 () T5066)
(declare-fun var__temp_h1260 () T5066)
(declare-fun |var__temp_h'1262| () T5066)
(assert (= (sel var_h1224 res) v))
(assert (= |5| 5))
(assert (= v |5|))
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1260 res) (+ (sel var_h1224 res) 10))
               (= (sel var__temp_h1260 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1262| res) (+ (sel var__temp_h1260 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1260 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************324
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1225 Value = Ty_heap{ (sel)( , var_h_i1225, res ) ==((sel)( , var_h1224, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1255:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1225 --->  Ty_heap  
 var_h1224 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1264 --->  Ty_heap  
 var__temp_v1265 --->  Ty_int  
 var__temp_h'1266 --->  Ty_heap  
 var__temp_v_err1267 --->  error  
 var_h1224 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1224, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1264, res ) ==((sel)( , var_h1224, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1264, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1264, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1266, res ) ==((sel)( , var__temp_h1264, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i1225 T5083)
(declare-const var_h1224 T5083)
(declare-const v Int)
(declare-const var_h_i1165 T5083)
(declare-const var_h1164 T5083)
(declare-const v Int)
(declare-const var_h_i895 T5083)
(declare-const var_h894 T5083)
(declare-const v Int)
(declare-const var_h_i59 T5083)
(declare-const var_h58 T5083)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1264 T5083)
(declare-const var__temp_v1265 Int)
(declare-const |var__temp_h'1266| T5083)
(declare-const var__temp_v_err1267 T5084)
(declare-const var_h1224 T5083)
(declare-const var_h1164 T5083)
(declare-const var_h894 T5083)
(declare-const var_h58 T5083)
(declare-const err T5097)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5083)
(declare-fun v () Int)
(declare-fun sel (T5083 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1224 () T5083)
(declare-fun |5| () Int)
(declare-fun var_h894 () T5083)
(declare-fun var_h1164 () T5083)
(declare-fun var_h58 () T5083)
(declare-fun var__temp_h1264 () T5083)
(declare-fun |var__temp_h'1266| () T5083)
(assert (= (sel var_h1224 res) v))
(assert (= |5| 5))
(assert (= v |5|))
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1264 res) (+ (sel var_h1224 res) 10))
               (= (sel var__temp_h1264 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1266| res) (+ (sel var__temp_h1264 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1264 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************325
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1225 Value = Ty_heap{ (sel)( , var_h_i1225, res ) ==((sel)( , var_h1224, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1255:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1225 --->  Ty_heap  
 var_h1224 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1268 --->  Ty_heap  
 var__temp_v1269 --->  Ty_int  
 var__temp_h'1270 --->  Ty_heap  
 var__temp_v_err1271 --->  error  
 var_h1224 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1224, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1268, res ) ==((sel)( , var_h1224, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1268, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1268, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1270, res ) ==((sel)( , var__temp_h1268, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i1225 T5100)
(declare-const var_h1224 T5100)
(declare-const v Int)
(declare-const var_h_i1165 T5100)
(declare-const var_h1164 T5100)
(declare-const v Int)
(declare-const var_h_i895 T5100)
(declare-const var_h894 T5100)
(declare-const v Int)
(declare-const var_h_i59 T5100)
(declare-const var_h58 T5100)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1268 T5100)
(declare-const var__temp_v1269 Int)
(declare-const |var__temp_h'1270| T5100)
(declare-const var__temp_v_err1271 T5101)
(declare-const var_h1224 T5100)
(declare-const var_h1164 T5100)
(declare-const var_h894 T5100)
(declare-const var_h58 T5100)
(declare-const err T5114)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5100)
(declare-fun v () Int)
(declare-fun sel (T5100 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1224 () T5100)
(declare-fun |5| () Int)
(declare-fun var_h894 () T5100)
(declare-fun var_h1164 () T5100)
(declare-fun var_h58 () T5100)
(declare-fun var__temp_h1268 () T5100)
(declare-fun |var__temp_h'1270| () T5100)
(assert (= (sel var_h1224 res) v))
(assert (= |5| 5))
(assert (= v |5|))
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1268 res) (+ (sel var_h1224 res) 10))
               (= (sel var__temp_h1268 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1270| res) (+ (sel var__temp_h1268 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1268 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************326
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1225 Value = Ty_heap{ (sel)( , var_h_i1225, res ) ==((sel)( , var_h1224, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1255:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1225 --->  Ty_heap  
 var_h1224 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1272 --->  Ty_heap  
 var__temp_v1273 --->  Ty_int  
 var__temp_h'1274 --->  Ty_heap  
 var__temp_v_err1275 --->  error  
 var_h1224 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1224, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1272, res ) ==((sel)( , var_h1224, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1272, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h1272, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'1274, res ) ==((sel)( , var__temp_h1272, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i1225 T5117)
(declare-const var_h1224 T5117)
(declare-const v Int)
(declare-const var_h_i1165 T5117)
(declare-const var_h1164 T5117)
(declare-const v Int)
(declare-const var_h_i895 T5117)
(declare-const var_h894 T5117)
(declare-const v Int)
(declare-const var_h_i59 T5117)
(declare-const var_h58 T5117)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1272 T5117)
(declare-const var__temp_v1273 Int)
(declare-const |var__temp_h'1274| T5117)
(declare-const var__temp_v_err1275 T5118)
(declare-const var_h1224 T5117)
(declare-const var_h1164 T5117)
(declare-const var_h894 T5117)
(declare-const var_h58 T5117)
(declare-const err T5131)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5117)
(declare-fun v () Int)
(declare-fun sel (T5117 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1224 () T5117)
(declare-fun |5| () Int)
(declare-fun var_h894 () T5117)
(declare-fun var_h1164 () T5117)
(declare-fun var_h58 () T5117)
(declare-fun var__temp_h1272 () T5117)
(declare-fun |var__temp_h'1274| () T5117)
(assert (= (sel var_h1224 res) v))
(assert (= |5| 5))
(assert (= v |5|))
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1272 res) (+ (sel var_h1224 res) 10))
               (= (sel var__temp_h1272 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'1274| res) (+ (sel var__temp_h1272 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1272 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************327
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1225 Value = Ty_heap{ (sel)( , var_h_i1225, res ) ==((sel)( , var_h1224, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1255:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1225 --->  Ty_heap  
 var_h1224 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1276 --->  Ty_heap  
 var__temp_v1277 --->  Ty_int  
 var__temp_h'1278 --->  Ty_heap  
 var__temp_v_err1279 --->  error  
 var_h1224 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1224, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1276, res ) ==((sel)( , var_h1224, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1276, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1276, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1278, res ) ==((sel)( , var__temp_h1276, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i1225 T5134)
(declare-const var_h1224 T5134)
(declare-const v Int)
(declare-const var_h_i1165 T5134)
(declare-const var_h1164 T5134)
(declare-const v Int)
(declare-const var_h_i895 T5134)
(declare-const var_h894 T5134)
(declare-const v Int)
(declare-const var_h_i59 T5134)
(declare-const var_h58 T5134)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1276 T5134)
(declare-const var__temp_v1277 Int)
(declare-const |var__temp_h'1278| T5134)
(declare-const var__temp_v_err1279 T5135)
(declare-const var_h1224 T5134)
(declare-const var_h1164 T5134)
(declare-const var_h894 T5134)
(declare-const var_h58 T5134)
(declare-const err T5148)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5134)
(declare-fun v () Int)
(declare-fun sel (T5134 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1224 () T5134)
(declare-fun |5| () Int)
(declare-fun var_h894 () T5134)
(declare-fun var_h1164 () T5134)
(declare-fun var_h58 () T5134)
(declare-fun var__temp_h1276 () T5134)
(declare-fun |var__temp_h'1278| () T5134)
(assert (= (sel var_h1224 res) v))
(assert (= |5| 5))
(assert (= v |5|))
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1276 res) (+ (sel var_h1224 res) 10))
               (= (sel var__temp_h1276 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1278| res) (+ (sel var__temp_h1276 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1276 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************328
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1225 Value = Ty_heap{ (sel)( , var_h_i1225, res ) ==((sel)( , var_h1224, res ) + (10)) } 
 } 
 
                                                RET :  Base {var_v1255:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1225 --->  Ty_heap  
 var_h1224 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1280 --->  Ty_heap  
 var__temp_v1281 --->  Ty_int  
 var__temp_h'1282 --->  Ty_heap  
 var__temp_v_err1283 --->  error  
 var_h1224 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1224, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1280, res ) ==((sel)( , var_h1224, res ) + (10)) => 
 	 Rel (sel)( , var__temp_h1280, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1280, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'1282, res ) ==((sel)( , var__temp_h1280, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i1225 T5151)
(declare-const var_h1224 T5151)
(declare-const v Int)
(declare-const var_h_i1165 T5151)
(declare-const var_h1164 T5151)
(declare-const v Int)
(declare-const var_h_i895 T5151)
(declare-const var_h894 T5151)
(declare-const v Int)
(declare-const var_h_i59 T5151)
(declare-const var_h58 T5151)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1280 T5151)
(declare-const var__temp_v1281 Int)
(declare-const |var__temp_h'1282| T5151)
(declare-const var__temp_v_err1283 T5152)
(declare-const var_h1224 T5151)
(declare-const var_h1164 T5151)
(declare-const var_h894 T5151)
(declare-const var_h58 T5151)
(declare-const err T5165)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5151)
(declare-fun v () Int)
(declare-fun sel (T5151 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1224 () T5151)
(declare-fun |5| () Int)
(declare-fun var_h894 () T5151)
(declare-fun var_h1164 () T5151)
(declare-fun var_h58 () T5151)
(declare-fun var__temp_h1280 () T5151)
(declare-fun |var__temp_h'1282| () T5151)
(assert (= (sel var_h1224 res) v))
(assert (= |5| 5))
(assert (= v |5|))
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1280 res) (+ (sel var_h1224 res) 10))
               (= (sel var__temp_h1280 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'1282| res) (+ (sel var__temp_h1280 res) 2))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1280 res) 5) a!2))))
  (not a!3))))

***************Selection Failed************bar
 *********************Enumeration Iteration*****************329
THE PATH ENDED WITHOUT RESULT
THE LAST COMPONENT c2
PARTIAL PATH
SUB 	 --c3'	 --c2'	 --foo
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1165, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1284:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
baz
bar
 *********************Enumeration Iteration*****************330
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1165, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1284:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1285 --->  Ty_heap  
 var__temp_v1286 --->  Ty_int  
 var__temp_h'1287 --->  Ty_heap  
 var__temp_v_err1288 --->  error  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1285, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1285, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1285, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1287, res ) ==((sel)( , var__temp_h1285, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i1165 T5168)
(declare-const var_h1164 T5168)
(declare-const v Int)
(declare-const var_h_i895 T5168)
(declare-const var_h894 T5168)
(declare-const v Int)
(declare-const var_h_i59 T5168)
(declare-const var_h58 T5168)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1285 T5168)
(declare-const var__temp_v1286 Int)
(declare-const |var__temp_h'1287| T5168)
(declare-const var__temp_v_err1288 T5169)
(declare-const var_h1164 T5168)
(declare-const var_h894 T5168)
(declare-const var_h58 T5168)
(declare-const err T5182)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5168)
(declare-fun sel (T5168 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T5168)
(declare-fun var_h1164 () T5168)
(declare-fun var_h58 () T5168)
(declare-fun |5| () Int)
(declare-fun var__temp_h1285 () T5168)
(declare-fun |var__temp_h'1287| () T5168)
(declare-fun v () Int)
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1285 res) v) (= v |5|))
               (= (sel var__temp_h1285 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1287| res) (+ (sel var__temp_h1285 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1285 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************331
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1165, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1284:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1289 --->  Ty_heap  
 var__temp_v1290 --->  Ty_int  
 var__temp_h'1291 --->  Ty_heap  
 var__temp_v_err1292 --->  error  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1289, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1289, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1289, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1291, res ) ==((sel)( , var__temp_h1289, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i1165 T5185)
(declare-const var_h1164 T5185)
(declare-const v Int)
(declare-const var_h_i895 T5185)
(declare-const var_h894 T5185)
(declare-const v Int)
(declare-const var_h_i59 T5185)
(declare-const var_h58 T5185)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1289 T5185)
(declare-const var__temp_v1290 Int)
(declare-const |var__temp_h'1291| T5185)
(declare-const var__temp_v_err1292 T5186)
(declare-const var_h1164 T5185)
(declare-const var_h894 T5185)
(declare-const var_h58 T5185)
(declare-const err T5199)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5185)
(declare-fun sel (T5185 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T5185)
(declare-fun var_h1164 () T5185)
(declare-fun var_h58 () T5185)
(declare-fun |5| () Int)
(declare-fun var__temp_h1289 () T5185)
(declare-fun |var__temp_h'1291| () T5185)
(declare-fun v () Int)
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1289 res) v) (= v |5|))
               (= (sel var__temp_h1289 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1291| res) (+ (sel var__temp_h1289 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1289 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************332
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1165, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1284:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1293 --->  Ty_heap  
 var__temp_v1294 --->  Ty_int  
 var__temp_h'1295 --->  Ty_heap  
 var__temp_v_err1296 --->  error  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1293, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1293, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1293, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1295, res ) ==((sel)( , var__temp_h1293, res ) + (4)) => 
 	 True
 
VC_END(declare-const var_h_i1165 T5202)
(declare-const var_h1164 T5202)
(declare-const v Int)
(declare-const var_h_i895 T5202)
(declare-const var_h894 T5202)
(declare-const v Int)
(declare-const var_h_i59 T5202)
(declare-const var_h58 T5202)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1293 T5202)
(declare-const var__temp_v1294 Int)
(declare-const |var__temp_h'1295| T5202)
(declare-const var__temp_v_err1296 T5203)
(declare-const var_h1164 T5202)
(declare-const var_h894 T5202)
(declare-const var_h58 T5202)
(declare-const err T5216)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5202)
(declare-fun sel (T5202 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T5202)
(declare-fun var_h1164 () T5202)
(declare-fun var_h58 () T5202)
(declare-fun |5| () Int)
(declare-fun var__temp_h1293 () T5202)
(declare-fun |var__temp_h'1295| () T5202)
(declare-fun v () Int)
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1293 res) v) (= v |5|))
               (= (sel var__temp_h1293 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1295| res) (+ (sel var__temp_h1293 res) 4))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1293 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************333
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1165, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1284:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1297 --->  Ty_heap  
 var__temp_v1298 --->  Ty_int  
 var__temp_h'1299 --->  Ty_heap  
 var__temp_v_err1300 --->  error  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1297, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1297, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1297, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1299, res ) ==((sel)( , var__temp_h1297, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i1165 T5219)
(declare-const var_h1164 T5219)
(declare-const v Int)
(declare-const var_h_i895 T5219)
(declare-const var_h894 T5219)
(declare-const v Int)
(declare-const var_h_i59 T5219)
(declare-const var_h58 T5219)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1297 T5219)
(declare-const var__temp_v1298 Int)
(declare-const |var__temp_h'1299| T5219)
(declare-const var__temp_v_err1300 T5220)
(declare-const var_h1164 T5219)
(declare-const var_h894 T5219)
(declare-const var_h58 T5219)
(declare-const err T5233)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5219)
(declare-fun sel (T5219 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T5219)
(declare-fun var_h1164 () T5219)
(declare-fun var_h58 () T5219)
(declare-fun |5| () Int)
(declare-fun var__temp_h1297 () T5219)
(declare-fun |var__temp_h'1299| () T5219)
(declare-fun v () Int)
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1297 res) v) (= v |5|))
               (= (sel var__temp_h1297 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1299| res) (+ (sel var__temp_h1297 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1297 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************334
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1165, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1284:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1301 --->  Ty_heap  
 var__temp_v1302 --->  Ty_int  
 var__temp_h'1303 --->  Ty_heap  
 var__temp_v_err1304 --->  error  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1301, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1301, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h1301, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'1303, res ) ==((sel)( , var__temp_h1301, res ) + (5)) => 
 	 True
 
VC_END(declare-const var_h_i1165 T5236)
(declare-const var_h1164 T5236)
(declare-const v Int)
(declare-const var_h_i895 T5236)
(declare-const var_h894 T5236)
(declare-const v Int)
(declare-const var_h_i59 T5236)
(declare-const var_h58 T5236)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1301 T5236)
(declare-const var__temp_v1302 Int)
(declare-const |var__temp_h'1303| T5236)
(declare-const var__temp_v_err1304 T5237)
(declare-const var_h1164 T5236)
(declare-const var_h894 T5236)
(declare-const var_h58 T5236)
(declare-const err T5250)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5236)
(declare-fun sel (T5236 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T5236)
(declare-fun var_h1164 () T5236)
(declare-fun var_h58 () T5236)
(declare-fun |5| () Int)
(declare-fun var__temp_h1301 () T5236)
(declare-fun |var__temp_h'1303| () T5236)
(declare-fun v () Int)
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1301 res) v) (= v |5|))
               (= (sel var__temp_h1301 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'1303| res) (+ (sel var__temp_h1301 res) 5))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1301 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************335
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1165, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1284:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1305 --->  Ty_heap  
 var__temp_v1306 --->  Ty_int  
 var__temp_h'1307 --->  Ty_heap  
 var__temp_v_err1308 --->  error  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1305, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1305, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1305, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1307, res ) ==((sel)( , var__temp_h1305, res ) + (3)) => 
 	 True
 
VC_END(declare-const var_h_i1165 T5253)
(declare-const var_h1164 T5253)
(declare-const v Int)
(declare-const var_h_i895 T5253)
(declare-const var_h894 T5253)
(declare-const v Int)
(declare-const var_h_i59 T5253)
(declare-const var_h58 T5253)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1305 T5253)
(declare-const var__temp_v1306 Int)
(declare-const |var__temp_h'1307| T5253)
(declare-const var__temp_v_err1308 T5254)
(declare-const var_h1164 T5253)
(declare-const var_h894 T5253)
(declare-const var_h58 T5253)
(declare-const err T5267)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5253)
(declare-fun sel (T5253 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T5253)
(declare-fun var_h1164 () T5253)
(declare-fun var_h58 () T5253)
(declare-fun |5| () Int)
(declare-fun var__temp_h1305 () T5253)
(declare-fun |var__temp_h'1307| () T5253)
(declare-fun v () Int)
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1305 res) v) (= v |5|))
               (= (sel var__temp_h1305 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1307| res) (+ (sel var__temp_h1305 res) 3))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1305 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz
 *********************Enumeration Iteration*****************336
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(5) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1165 Value = Ty_heap{ 
 Conj <c (sel)( , var_h_i1165, res ) ==(v)
 	 , v = 5 >c  } 
 } 
 
                                                RET :  Base {var_v1284:Ty_unknown | true} 
 { 
                                                POST true 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (2)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1309 --->  Ty_heap  
 var__temp_v1310 --->  Ty_int  
 var__temp_h'1311 --->  Ty_heap  
 var__temp_v_err1312 --->  error  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Conj  AND 
 	 Rel (sel)( , var__temp_h1309, res ) ==(v) AND 
 	 Base v = 5 => 
 	 Rel (sel)( , var__temp_h1309, res ) ==(5) AND 
 	 Rel (sel)( , var__temp_h1309, res ) ==(5) => 
 	 Rel (sel)( , var__temp_h'1311, res ) ==((sel)( , var__temp_h1309, res ) + (2)) => 
 	 True
 
VC_END(declare-const var_h_i1165 T5270)
(declare-const var_h1164 T5270)
(declare-const v Int)
(declare-const var_h_i895 T5270)
(declare-const var_h894 T5270)
(declare-const v Int)
(declare-const var_h_i59 T5270)
(declare-const var_h58 T5270)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1309 T5270)
(declare-const var__temp_v1310 Int)
(declare-const |var__temp_h'1311| T5270)
(declare-const var__temp_v_err1312 T5271)
(declare-const var_h1164 T5270)
(declare-const var_h894 T5270)
(declare-const var_h58 T5270)
(declare-const err T5284)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5270)
(declare-fun sel (T5270 Int) Int)
(declare-fun res () Int)
(declare-fun var_h894 () T5270)
(declare-fun var_h1164 () T5270)
(declare-fun var_h58 () T5270)
(declare-fun |5| () Int)
(declare-fun var__temp_h1309 () T5270)
(declare-fun |var__temp_h'1311| () T5270)
(declare-fun v () Int)
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (= |5| 5))
(assert (let ((a!1 (=> (and (= (sel var__temp_h1309 res) v) (= v |5|))
               (= (sel var__temp_h1309 res) 5)))
      (a!2 (=> (= (sel |var__temp_h'1311| res) (+ (sel var__temp_h1309 res) 2))
               true)))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1309 res) 5) a!2))))
  (not a!3))))

***************Selection Successful************bar
PARTIAL PATH NEW
NEW 	 --c3'	 --c2'	 --foo	 --bar
post_substituted Forall 
 	 
 Key =var_h_i1314 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) }
Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1314 Value = Ty_heap{ (sel)( , var_h_i1314, res ) ==((sel)( , var_h1313, res ) + (2)) } 
 } 
 
                                                RET :  Base {var_v1315:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1314 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
FOUND COMPONENTS 
baz'
baz'''
baz''
c5
test
baz
 *********************Enumeration Iteration*****************337
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1314 Value = Ty_heap{ (sel)( , var_h_i1314, res ) ==((sel)( , var_h1313, res ) + (2)) } 
 } 
 
                                                RET :  Base {var_v1315:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1314 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1314 --->  Ty_heap  
 var_h1313 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1316 --->  Ty_heap  
 var__temp_v1317 --->  Ty_int  
 var__temp_h'1318 --->  Ty_heap  
 var__temp_v_err1319 --->  error  
 var_h1313 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1313, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1316, res ) ==((sel)( , var_h1313, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h1316, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1316, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1318, res ) ==((sel)( , var__temp_h1316, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'1318, res ) ==(10)
 
VC_END(declare-const var_h_i1314 T5287)
(declare-const var_h1313 T5287)
(declare-const v Int)
(declare-const var_h_i1165 T5287)
(declare-const var_h1164 T5287)
(declare-const v Int)
(declare-const var_h_i895 T5287)
(declare-const var_h894 T5287)
(declare-const v Int)
(declare-const var_h_i59 T5287)
(declare-const var_h58 T5287)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1316 T5287)
(declare-const var__temp_v1317 Int)
(declare-const |var__temp_h'1318| T5287)
(declare-const var__temp_v_err1319 T5288)
(declare-const var_h1313 T5287)
(declare-const var_h1164 T5287)
(declare-const var_h894 T5287)
(declare-const var_h58 T5287)
(declare-const err T5301)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5287)
(declare-fun v () Int)
(declare-fun sel (T5287 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1313 () T5287)
(declare-fun |5| () Int)
(declare-fun var_h894 () T5287)
(declare-fun var_h1164 () T5287)
(declare-fun var_h58 () T5287)
(declare-fun |var__temp_h'1318| () T5287)
(declare-fun var__temp_h1316 () T5287)
(assert (= (sel var_h1313 res) v))
(assert (= |5| 5))
(assert (= v |5|))
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1316 res) (+ (sel var_h1313 res) 2))
               (= (sel var__temp_h1316 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1318| res) (+ (sel var__temp_h1316 res) 4))
               (= (sel |var__temp_h'1318| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1316 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'
 *********************Enumeration Iteration*****************338
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1314 Value = Ty_heap{ (sel)( , var_h_i1314, res ) ==((sel)( , var_h1313, res ) + (2)) } 
 } 
 
                                                RET :  Base {var_v1315:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1314 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1314 --->  Ty_heap  
 var_h1313 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1320 --->  Ty_heap  
 var__temp_v1321 --->  Ty_int  
 var__temp_h'1322 --->  Ty_heap  
 var__temp_v_err1323 --->  error  
 var_h1313 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1313, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1320, res ) ==((sel)( , var_h1313, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h1320, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1320, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1322, res ) ==((sel)( , var__temp_h1320, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'1322, res ) ==(10)
 
VC_END(declare-const var_h_i1314 T5304)
(declare-const var_h1313 T5304)
(declare-const v Int)
(declare-const var_h_i1165 T5304)
(declare-const var_h1164 T5304)
(declare-const v Int)
(declare-const var_h_i895 T5304)
(declare-const var_h894 T5304)
(declare-const v Int)
(declare-const var_h_i59 T5304)
(declare-const var_h58 T5304)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1320 T5304)
(declare-const var__temp_v1321 Int)
(declare-const |var__temp_h'1322| T5304)
(declare-const var__temp_v_err1323 T5305)
(declare-const var_h1313 T5304)
(declare-const var_h1164 T5304)
(declare-const var_h894 T5304)
(declare-const var_h58 T5304)
(declare-const err T5318)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5304)
(declare-fun v () Int)
(declare-fun sel (T5304 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1313 () T5304)
(declare-fun |5| () Int)
(declare-fun var_h894 () T5304)
(declare-fun var_h1164 () T5304)
(declare-fun var_h58 () T5304)
(declare-fun |var__temp_h'1322| () T5304)
(declare-fun var__temp_h1320 () T5304)
(assert (= (sel var_h1313 res) v))
(assert (= |5| 5))
(assert (= v |5|))
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1320 res) (+ (sel var_h1313 res) 2))
               (= (sel var__temp_h1320 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1322| res) (+ (sel var__temp_h1320 res) 4))
               (= (sel |var__temp_h'1322| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1320 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz'''
 *********************Enumeration Iteration*****************339
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1314 Value = Ty_heap{ (sel)( , var_h_i1314, res ) ==((sel)( , var_h1313, res ) + (2)) } 
 } 
 
                                                RET :  Base {var_v1315:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1314 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (4)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1314 --->  Ty_heap  
 var_h1313 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1324 --->  Ty_heap  
 var__temp_v1325 --->  Ty_int  
 var__temp_h'1326 --->  Ty_heap  
 var__temp_v_err1327 --->  error  
 var_h1313 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1313, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1324, res ) ==((sel)( , var_h1313, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h1324, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1324, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1326, res ) ==((sel)( , var__temp_h1324, res ) + (4)) => 
 	 Rel (sel)( , var__temp_h'1326, res ) ==(10)
 
VC_END(declare-const var_h_i1314 T5321)
(declare-const var_h1313 T5321)
(declare-const v Int)
(declare-const var_h_i1165 T5321)
(declare-const var_h1164 T5321)
(declare-const v Int)
(declare-const var_h_i895 T5321)
(declare-const var_h894 T5321)
(declare-const v Int)
(declare-const var_h_i59 T5321)
(declare-const var_h58 T5321)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1324 T5321)
(declare-const var__temp_v1325 Int)
(declare-const |var__temp_h'1326| T5321)
(declare-const var__temp_v_err1327 T5322)
(declare-const var_h1313 T5321)
(declare-const var_h1164 T5321)
(declare-const var_h894 T5321)
(declare-const var_h58 T5321)
(declare-const err T5335)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5321)
(declare-fun v () Int)
(declare-fun sel (T5321 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1313 () T5321)
(declare-fun |5| () Int)
(declare-fun var_h894 () T5321)
(declare-fun var_h1164 () T5321)
(declare-fun var_h58 () T5321)
(declare-fun |var__temp_h'1326| () T5321)
(declare-fun var__temp_h1324 () T5321)
(assert (= (sel var_h1313 res) v))
(assert (= |5| 5))
(assert (= v |5|))
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1324 res) (+ (sel var_h1313 res) 2))
               (= (sel var__temp_h1324 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1326| res) (+ (sel var__temp_h1324 res) 4))
               (= (sel |var__temp_h'1326| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1324 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************baz''
 *********************Enumeration Iteration*****************340
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1314 Value = Ty_heap{ (sel)( , var_h_i1314, res ) ==((sel)( , var_h1313, res ) + (2)) } 
 } 
 
                                                RET :  Base {var_v1315:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1314 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1314 --->  Ty_heap  
 var_h1313 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1328 --->  Ty_heap  
 var__temp_v1329 --->  Ty_int  
 var__temp_h'1330 --->  Ty_heap  
 var__temp_v_err1331 --->  error  
 var_h1313 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1313, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1328, res ) ==((sel)( , var_h1313, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h1328, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1328, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1330, res ) ==((sel)( , var__temp_h1328, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'1330, res ) ==(10)
 
VC_END(declare-const var_h_i1314 T5338)
(declare-const var_h1313 T5338)
(declare-const v Int)
(declare-const var_h_i1165 T5338)
(declare-const var_h1164 T5338)
(declare-const v Int)
(declare-const var_h_i895 T5338)
(declare-const var_h894 T5338)
(declare-const v Int)
(declare-const var_h_i59 T5338)
(declare-const var_h58 T5338)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1328 T5338)
(declare-const var__temp_v1329 Int)
(declare-const |var__temp_h'1330| T5338)
(declare-const var__temp_v_err1331 T5339)
(declare-const var_h1313 T5338)
(declare-const var_h1164 T5338)
(declare-const var_h894 T5338)
(declare-const var_h58 T5338)
(declare-const err T5352)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5338)
(declare-fun v () Int)
(declare-fun sel (T5338 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1313 () T5338)
(declare-fun |5| () Int)
(declare-fun var_h894 () T5338)
(declare-fun var_h1164 () T5338)
(declare-fun var_h58 () T5338)
(declare-fun |var__temp_h'1330| () T5338)
(declare-fun var__temp_h1328 () T5338)
(assert (= (sel var_h1313 res) v))
(assert (= |5| 5))
(assert (= v |5|))
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1328 res) (+ (sel var_h1313 res) 2))
               (= (sel var__temp_h1328 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1330| res) (+ (sel var__temp_h1328 res) 5))
               (= (sel |var__temp_h'1330| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1328 res) 7) a!2))))
  (not a!3))))

***************Selection Failed************c5
 *********************Enumeration Iteration*****************341
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(6) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1314 Value = Ty_heap{ (sel)( , var_h_i1314, res ) ==((sel)( , var_h1313, res ) + (2)) } 
 } 
 
                                                RET :  Base {var_v1315:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1314 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (5)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1314 --->  Ty_heap  
 var_h1313 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1332 --->  Ty_heap  
 var__temp_v1333 --->  Ty_int  
 var__temp_h'1334 --->  Ty_heap  
 var__temp_v_err1335 --->  error  
 var_h1313 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1313, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1332, res ) ==((sel)( , var_h1313, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h1332, res ) ==(6) AND 
 	 Rel (sel)( , var__temp_h1332, res ) ==(6) => 
 	 Rel (sel)( , var__temp_h'1334, res ) ==((sel)( , var__temp_h1332, res ) + (5)) => 
 	 Rel (sel)( , var__temp_h'1334, res ) ==(10)
 
VC_END(declare-const var_h_i1314 T5355)
(declare-const var_h1313 T5355)
(declare-const v Int)
(declare-const var_h_i1165 T5355)
(declare-const var_h1164 T5355)
(declare-const v Int)
(declare-const var_h_i895 T5355)
(declare-const var_h894 T5355)
(declare-const v Int)
(declare-const var_h_i59 T5355)
(declare-const var_h58 T5355)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1332 T5355)
(declare-const var__temp_v1333 Int)
(declare-const |var__temp_h'1334| T5355)
(declare-const var__temp_v_err1335 T5356)
(declare-const var_h1313 T5355)
(declare-const var_h1164 T5355)
(declare-const var_h894 T5355)
(declare-const var_h58 T5355)
(declare-const err T5369)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5355)
(declare-fun v () Int)
(declare-fun sel (T5355 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1313 () T5355)
(declare-fun |5| () Int)
(declare-fun var_h894 () T5355)
(declare-fun var_h1164 () T5355)
(declare-fun var_h58 () T5355)
(declare-fun |var__temp_h'1334| () T5355)
(declare-fun var__temp_h1332 () T5355)
(assert (= (sel var_h1313 res) v))
(assert (= |5| 5))
(assert (= v |5|))
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1332 res) (+ (sel var_h1313 res) 2))
               (= (sel var__temp_h1332 res) 6)))
      (a!2 (=> (= (sel |var__temp_h'1334| res) (+ (sel var__temp_h1332 res) 5))
               (= (sel |var__temp_h'1334| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1332 res) 6) a!2))))
  (not a!3))))

***************Selection Failed************test
 *********************Enumeration Iteration*****************342
Found after Enumeration MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =h Value = Ty_heap{ (sel)( , h, res ) ==(7) } 
 } 
 
                                                RET :  Base {v:Ty_int | true} 
 { 
                                                POST Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) } 
 } 
 )
Compared Against Spec MArrrow ( State 
 
                                                PRE { 
 Forall 
 	 
 Key =var_h_i1314 Value = Ty_heap{ (sel)( , var_h_i1314, res ) ==((sel)( , var_h1313, res ) + (2)) } 
 } 
 
                                                RET :  Base {var_v1315:Ty_unknown | true} 
 { 
                                                POST Forall 
 	 
 Key =var_h_i1314 Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==(10) } 
 } 
 )
 Case Non-Exceptional: Original Inferred post Forall 
 	 
 Key =h Value = Ty_heap
 Key =v Value = Ty_int
 Key =h' Value = Ty_heap{ (sel)( , h', res ) ==((sel)( , h, res ) + (3)) }
 Standardizing verification conditions 
STANDARD VC_BEGIN TyDBINDS  
 
 var_h_i1314 --->  Ty_heap  
 var_h1313 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i1165 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i895 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 v --->  Ty_int  
 var_h_i59 --->  Ty_heap  
 var_h58 --->  Ty_heap  
 v --->  Ty_int  
 c3' --->  Ty_int  
 baz' --->  Ty_int  
 baz''' --->  Ty_int  
 baz'' --->  Ty_int  
 c5 --->  Ty_int  
 c4 --->  Ty_int  
 c2' --->  Ty_int  
 test --->  Ty_int  
 c2 --->  Ty_int  
 foo' --->  Ty_int  
 baz --->  Ty_int  
 foo --->  Ty_int  
 bar --->  Ty_int  
 res --->  Ty_int  
 var__temp_h1336 --->  Ty_heap  
 var__temp_v1337 --->  Ty_int  
 var__temp_h'1338 --->  Ty_heap  
 var__temp_v_err1339 --->  error  
 var_h1313 --->  Ty_heap  
 var_h1164 --->  Ty_heap  
 var_h894 --->  Ty_heap  
 var_h58 --->  Ty_heap 
 	 ANTE Conj  AND 
 	 Rel (sel)( , var_h1313, res ) ==(v) AND 
 	 Base v = 5 AND 
 	 Rel (sel)( , var_h1164, res ) ==(sel)( , var_h894, res ) AND 
 	 Rel (sel)( , var_h894, res ) ==((sel)( , var_h58, res ) + (3)) AND 
 	 Rel (sel)( , var_h58, res ) ==(0) 
 	 ------------------------

	 CONS Conj  AND 
 	 Rel (sel)( , var__temp_h1336, res ) ==((sel)( , var_h1313, res ) + (2)) => 
 	 Rel (sel)( , var__temp_h1336, res ) ==(7) AND 
 	 Rel (sel)( , var__temp_h1336, res ) ==(7) => 
 	 Rel (sel)( , var__temp_h'1338, res ) ==((sel)( , var__temp_h1336, res ) + (3)) => 
 	 Rel (sel)( , var__temp_h'1338, res ) ==(10)
 
VC_END(declare-const var_h_i1314 T5372)
(declare-const var_h1313 T5372)
(declare-const v Int)
(declare-const var_h_i1165 T5372)
(declare-const var_h1164 T5372)
(declare-const v Int)
(declare-const var_h_i895 T5372)
(declare-const var_h894 T5372)
(declare-const v Int)
(declare-const var_h_i59 T5372)
(declare-const var_h58 T5372)
(declare-const v Int)
(declare-const |c3'| Int)
(declare-const |baz'| Int)
(declare-const |baz'''| Int)
(declare-const |baz''| Int)
(declare-const c5 Int)
(declare-const c4 Int)
(declare-const |c2'| Int)
(declare-const test Int)
(declare-const c2 Int)
(declare-const |foo'| Int)
(declare-const baz Int)
(declare-const foo Int)
(declare-const bar Int)
(declare-const res Int)
(declare-const var__temp_h1336 T5372)
(declare-const var__temp_v1337 Int)
(declare-const |var__temp_h'1338| T5372)
(declare-const var__temp_v_err1339 T5373)
(declare-const var_h1313 T5372)
(declare-const var_h1164 T5372)
(declare-const var_h894 T5372)
(declare-const var_h58 T5372)
(declare-const err T5386)
    (declare-const |5| Int)
  
solver 
 (declare-sort T5372)
(declare-fun v () Int)
(declare-fun sel (T5372 Int) Int)
(declare-fun res () Int)
(declare-fun var_h1313 () T5372)
(declare-fun |5| () Int)
(declare-fun var_h894 () T5372)
(declare-fun var_h1164 () T5372)
(declare-fun var_h58 () T5372)
(declare-fun |var__temp_h'1338| () T5372)
(declare-fun var__temp_h1336 () T5372)
(assert (= (sel var_h1313 res) v))
(assert (= |5| 5))
(assert (= v |5|))
(assert (= (sel var_h1164 res) (sel var_h894 res)))
(assert (= (sel var_h894 res) (+ (sel var_h58 res) 3)))
(assert (= (sel var_h58 res) 0))
(assert (let ((a!1 (=> (= (sel var__temp_h1336 res) (+ (sel var_h1313 res) 2))
               (= (sel var__temp_h1336 res) 7)))
      (a!2 (=> (= (sel |var__temp_h'1338| res) (+ (sel var__temp_h1336 res) 3))
               (= (sel |var__temp_h'1338| res) 10))))
(let ((a!3 (and a!1 (=> (= (sel var__temp_h1336 res) 7) a!2))))
  (not a!3))))

***************Selection Successful************bazSingle Component Enumeration Succeeded
PARTIAL PATH NEW
SUB 	 --c3'	 --c2'	 --foo	 --bar	 --baz
Found e2 in (x <- e1 in e2)
{ 
Eret { 
Evar baz 
 } 
 }
Found e2 in (x <- e1 in e2)
{ 
Ebind Evar v <- { 
Eret { 
Evar bar 
 } 
 } in { 
Eret { 
Evar baz 
 } 
 } 
 }
Found e2 in (x <- e1 in e2)
{ 
Ebind Evar v <- { 
Eret { 
Evar foo 
 } 
 } in { 
Ebind Evar v <- { 
Eret { 
Evar bar 
 } 
 } in { 
Eret { 
Evar baz 
 } 
 } 
 } 
 }
Found e2 in (x <- e1 in e2)
{ 
Ebind Evar v <- { 
Eret { 
Evar c2' 
 } 
 } in { 
Ebind Evar v <- { 
Eret { 
Evar foo 
 } 
 } in { 
Ebind Evar v <- { 
Eret { 
Evar bar 
 } 
 } in { 
Eret { 
Evar baz 
 } 
 } 
 } 
 } 
 }
ENUM ::baz::test::c5::baz''::baz'''::baz'::bar::baz::test::c5::baz''::baz'''::baz'::bar::baz::test::c5::baz''::baz'''::baz'::bar::baz::test::c5::baz''::baz'''::baz'::c2::test::c5::baz''::baz'''::baz'::bar::baz::c2::test::c5::baz''::baz'''::baz'::foo::baz::c2::test::c5::baz''::baz'''::baz'::bar::foo::baz::test::c5::baz''::baz'''::baz'::bar::foo::baz::test::c5::baz''::baz'''::baz'::bar::foo::baz::test::c5::baz''::baz'''::baz'::c2::test::c5::baz''::baz'''::baz'::bar::foo::baz::c2::test::c5::baz''::baz'''::baz'::foo'::c2::test::c5::baz''::baz'''::baz'::bar::foo::baz::foo'::c2::test::c5::baz''::baz'''::baz'::c2'::c5::baz''::baz'''::baz'::bar::foo::baz::test::c5::baz''::baz'''::baz'::bar::foo::baz::test::c5::baz''::baz'''::baz'::bar::foo::baz::test::c5::baz''::baz'''::baz'::foo'::test::c5::baz''::baz'''::baz'::bar::foo::baz::test::c5::baz''::baz'''::baz'::bar::foo::baz::test::c5::baz''::baz'''::baz'::bar::foo::baz::test::c5::baz''::baz'''::baz'::foo'::test::c5::baz''::baz'''::baz'::bar::foo::baz::foo'::test::c5::baz''::baz'''::baz'::c2::test::c5::baz''::baz'''::baz'::bar::foo::baz::test::c5::baz''::baz'''::baz'::bar::foo::baz::test::c5::baz''::baz'''::baz'::bar::foo::baz::test::c5::baz''::baz'''::baz'::foo'::test::c5::baz''::baz'''::baz'::bar::foo::baz::test::c5::baz''::baz'''::baz'::bar::foo::baz::test::c5::baz''::baz'''::baz'::bar::foo::baz::test::c5::baz''::baz'''::baz'::foo'::test::c5::baz''::baz'''::baz'::bar::foo::baz::foo'::test::c5::baz''::baz'''::baz'::c2::test::c5::baz''::baz'''::baz'::bar::foo::baz::foo'::c2::test::c5::baz''::baz'''::baz'::c2'::c5::baz''::baz'''::baz'::bar::foo::baz::foo'::c2::test::c2'::c5::baz''::baz'''::baz'::c4::c5::baz''::baz'''::baz'::bar::foo::baz::foo'::c2::test::c2'::c4::c5::baz''::baz'''::baz'::c3'::bar::foo::baz::foo'::c2::test::c2'::c4::c5::baz''::baz'''::baz'::c3'
SUB 
 	 --c3'
 	 --c2'
 	 --foo
 	 --bar
 	 --baz
 	 --bar
 	 --foo
 	 --c2'
 	 --c3'Success : { 
Ebind Evar v <- { 
Eret { 
Evar c3' 
 } 
 } in { 
Ebind Evar v <- { 
Eret { 
Evar c2' 
 } 
 } in { 
Ebind Evar v <- { 
Eret { 
Evar foo 
 } 
 } in { 
Ebind Evar v <- { 
Eret { 
Evar bar 
 } 
 } in { 
Eret { 
Evar baz 
 } 
 } 
 } 
 } 
 } 
 }